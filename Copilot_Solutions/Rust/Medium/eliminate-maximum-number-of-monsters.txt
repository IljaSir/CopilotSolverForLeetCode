Synthesizing 10/10 solutions

=======

        let mut time = Vec::new();
        for i in 0..dist.len() {
            time.push(dist[i] as f64 / speed[i] as f64);
        }
        time.sort_by(|a, b| a.partial_cmp(b).unwrap());
        let mut cur = 0.0;
        for i in 0..time.len() {
            cur += 1.0;
            if time[i] < cur {
                return i as i32;
            }
        }
        time.len() as i32
    }
}

=======

        let n = dist.len();
        let mut times = Vec::new();
        for i in 0..n {
            times.push((dist[i] + speed[i] - 1) / speed[i]);
        }
        times.sort();
        let mut t = 0;
        for i in 0..n {
            if times[i] <= t {
                return i as i32;
            }
            t += 1;
        }
        n as i32

=======

        let mut time: Vec<f64> = dist.iter().zip(speed.iter()).map(|(d, s)| *d as f64 / *s as f64).collect();
        time.sort_by(|a, b| a.partial_cmp(b).unwrap());
        let mut i = 0;
        while i < time.len() && time[i] > i as f64 {
            i += 1;
        }
        i as i32
    }
}

=======

        let mut t = vec![];
        for i in 0..dist.len() {
            t.push((dist[i] as f64 / speed[i] as f64).ceil() as i32);
        }
        t.sort_unstable();
        let mut i = 0;
        while i < t.len() && t[i] > i as i32 {
            i += 1;
        }
        i as i32
    }
}

=======

        let mut t = dist
            .into_iter()
            .zip(speed)
            .map(|(d, s)| (d as f64 / s as f64).ceil() as i32)
            .collect::<Vec<_>>();
        t.sort();
        let mut i = 0;
        while i < t.len() && i as i32 < t[i] {
            i += 1;
        }
        i as i32
    }
}

=======

        let mut time = Vec::new();
        for i in 0..dist.len() {
            time.push((dist[i] + speed[i] - 1) / speed[i]);
        }
        time.sort();
        let mut t = 0;
        let mut i = 0;
        while i < time.len() && time[i] > t {
            i += 1;
            t += 1;
        }
        i as i32

=======

        let mut t = dist
            .iter()
            .zip(speed.iter())
            .map(|(d, s)| d / s + if d % s > 0 { 1 } else { 0 })
            .collect::<Vec<i32>>();
        t.sort_unstable();
        let mut i = 0;
        while i < t.len() && t[i] > i as i32 {
            i += 1;
        }
        i as i32
    }
}

=======

        let mut v = dist.iter().zip(speed.iter()).map(|(d, s)| (d + s - 1) / s).collect::<Vec<i32>>();
        v.sort();
        let mut t = 0;
        for (i, d) in v.iter().enumerate() {
            if i as i32 >= *d {
                return i as i32;
            }
        }
        v.len() as i32
    }
}

=======

        let mut t = dist.iter().zip(speed.iter()).map(|(d, s)| (d - 1) / s).collect::<Vec<_>>();
        t.sort();
        let mut i = 0;
        while i < t.len() && t[i] >= i as i32 {
            i += 1;
        }
        i as i32

=======

        let mut dist = dist;
        let mut speed = speed;
        let mut time = 0;
        let mut count = 0;
        while !dist.is_empty() {
            time += 1;
            for i in 0..dist.len() {
                dist[i] -= speed[i];
            }
            let mut idx = 0;
            while idx < dist.len() && dist[idx] <= 0 {
                idx += 1;
            }
            if idx > 0 {
                dist.drain(0..idx);
                speed.drain(0..idx);
                count += 1;
            }
            if count >= time {
                return time;
            }
        }
        count
    }
}
