Synthesizing 10/10 solutions

=======
Suggestion 1

        let mut one = 0;
        let mut two = 0;
        for i in nums {
            one = (one ^ i) & !two;
            two = (two ^ i) & !one;
        }
        one

=======
Suggestion 2

        let mut result = 0;
        for i in 0..32 {
            let mut sum = 0;
            for j in 0..nums.len() {
                sum += (nums[j] >> i) & 1;
            }
            result |= (sum % 3) << i;
        }
        result

=======
Suggestion 3

        let mut ones = 0;
        let mut twos = 0;
        for &n in nums.iter() {
            ones = (ones ^ n) & !twos;
            twos = (twos ^ n) & !ones;
        }
        ones

=======
Suggestion 4

        let mut ans = 0;
        for i in 0..32 {
            let mut cnt = 0;
            for j in 0..nums.len() {
                if (nums[j] >> i) & 1 == 1 {
                    cnt += 1;
                }
            }
            if cnt % 3 == 1 {
                ans |= 1 << i;
            }
        }
        ans

=======
Suggestion 5

        let mut result = 0;
        for i in 0..32 {
            let mut sum = 0;
            for num in &nums {
                sum += (num >> i) & 1;
            }
            result |= (sum % 3) << i;
        }
        result

=======
Suggestion 6

        let mut ans = 0;
        for i in 0..32 {
            let mut cnt = 0;
            for j in 0..nums.len() {
                if nums[j] & (1 << i) != 0 {
                    cnt += 1;
                }
            }
            if cnt % 3 != 0 {
                ans |= 1 << i;
            }
        }
        ans

=======
Suggestion 7

        let mut res = 0;
        for i in 0..32 {
            let mut cnt = 0;
            for &num in nums.iter() {
                if (num >> i) & 1 == 1 {
                    cnt += 1;
                }
            }
            if cnt % 3 != 0 {
                res |= 1 << i;
            }
        }
        res

=======
Suggestion 8

        let mut set = std::collections::HashSet::new();
        let mut sum = 0;
        for n in nums {
            if !set.contains(&n) {
                set.insert(n);
                sum += n;
            }
        }
        sum * 3 - nums.iter().sum::<i32>()

=======
Suggestion 9

        let mut s = 0;
        let mut t = 0;
        for n in nums {
            s = !t & (s ^ n);
            t = !s & (t ^ n);
        }
        s

=======
Suggestion 10

        let mut map = std::collections::HashMap::new();
        for num in nums {
            map.entry(num).and_modify(|x| *x += 1).or_insert(1);
        }
        for (key, value) in map {
            if value == 1 {
                return key;
            }
        }
        -1
    }
}
