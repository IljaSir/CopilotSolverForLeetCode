Synthesizing 10/10 solutions

=======

        let mut q = Vec::new();
        let mut w = Vec::new();
        for s in queries {
            q.push(Self::f(&s));
        }
        for s in words {
            w.push(Self::f(&s));
        }
        w.sort();
        let mut res = Vec::new();
        for i in q {
            let mut cnt = 0;
            for j in &w {
                if i < *j {
                    cnt += 1;
                }
            }
            res.push(cnt as i32);
        }
        res
    }
    fn f(s: &str) -> i32 {
        let mut min = 'z' as i32 + 1;
        let mut cnt = 0;
        for c in s.chars() {
            if c as i32 < min {
                min = c as i32;
                cnt = 1;
            } else if c as i32 == min {
                cnt += 1;
            }
        }
        cnt

=======

        let queries: Vec<i32> = queries.iter().map(|q| Self::f(q)).collect();
        let words: Vec<i32> = words.iter().map(|w| Self::f(w)).collect();
        let mut res = vec![];
        for q in queries {
            let mut count = 0;
            for w in &words {
                if q < *w {
                    count += 1;
                }
            }
            res.push(count);
        }
        res
    }
    fn f(s: &str) -> i32 {
        let mut count = 0;
        let mut min = 'z';
        for c in s.chars() {
            if c < min {
                min = c;
                count = 1;
            } else if c == min {
                count += 1;
            }
        }
        count

=======

        let mut q = Vec::new();
        let mut w = Vec::new();
        for i in queries {
            q.push(frequency(i));
        }
        for i in words {
            w.push(frequency(i));
        }
        let mut result = Vec::new();
        for i in q {
            let mut count = 0;
            for j in &w {
                if i < *j {
                    count += 1;
                }
            }
            result.push(count);
        }
        result
    }
}

=======

        let mut q = queries.into_iter().map(|s| Self::f(s)).collect::<Vec<i32>>();
        let mut w = words.into_iter().map(|s| Self::f(s)).collect::<Vec<i32>>();
        q.iter_mut().map(|i| {
            *i = w.iter().filter(|j| **j > *i).count() as i32;
            *i
        }).collect::<Vec<i32>>()
    }
    fn f(s: String) -> i32 {
        let mut c = [0; 26];
        for b in s.as_bytes() {
            c[(b - b'a') as usize] += 1;
        }
        c.iter().filter(|i| **i > 0).next().unwrap()
    }
}

=======

        let mut words: Vec<i32> = words.iter().map(|s| Self::f(&s)).collect();
        words.sort();
        queries.iter().map(|s| {
            let f = Self::f(&s);
            words.iter().filter(|&&w| w > f).count() as i32
        }).collect()

=======

        let mut freq = vec![0; 11];
        for word in words {
            let f = Self::f(word);
            freq[f] += 1;
        }
        for i in (1..11).rev() {
            freq[i-1] += freq[i];
        }
        queries
            .iter()
            .map(|q| freq[Self::f(q.clone()) + 1])
            .collect()

=======

        let mut res = vec![];
        let mut q = vec![];
        let mut w = vec![];
        for i in 0..queries.len() {
            q.push(Self::f(&queries[i]));
        }
        for i in 0..words.len() {
            w.push(Self::f(&words[i]));
        }
        for i in 0..q.len() {
            let mut count = 0;
            for j in 0..w.len() {
                if q[i] < w[j] {
                    count += 1;
                }
            }
            res.push(count);
        }
        res
    }
    fn f(s: &str) -> i32 {
        let mut count = 1;
        let mut min = s.chars().nth(0).unwrap();
        for i in 1..s.len() {
            let c = s.chars().nth(i).unwrap();
            if c == min {
                count += 1;
            } else if c < min {
                min = c;
                count = 1;
            }
        }
        count

=======

        let mut word_count = vec![0; 11];
        for word in words {
            word_count[Self::f(word)] += 1;
        }
        for i in (1..word_count.len()).rev() {
            word_count[i-1] += word_count[i];
        }
        let mut result = Vec::new();
        for query in queries {
            result.push(word_count[Self::f(query)+1]);
        }
        result
    }
    fn f(s: String) -> usize {
        let mut count = vec![0; 26];
        for c in s.chars() {
            count[c as usize - 'a' as usize] += 1;
        }
        for i in 0..count.len() {
            if count[i] > 0 {
                return count[i];
            }
        }
        0

=======

        let mut words_frequency: Vec<i32> = Vec::new();
        for word in words {
            let mut word = word.chars().collect::<Vec<char>>();
            word.sort();
            let mut count = 1;
            for i in 1..word.len() {
                if word[i] == word[i-1] {
                    count += 1;
                } else {
                    break;
                }
            }
            words_frequency.push(count);
        }
        let mut queries_frequency: Vec<i32> = Vec::new();
        for query in queries {
            let mut query = query.chars().collect::<Vec<char>>();
            query.sort();
            let mut count = 1;
            for i in 1..query.len() {
                if query[i] == query[i-1] {
                    count += 1;
                } else {
                    break;
                }
            }
            queries_frequency.push(count);
        }
        let mut ans: Vec<i32> = Vec::new();
        for query in queries_frequency {
            let mut count = 0;
            for word in &words_frequency {
                if query < *word {
                    count += 1;
                }
            }
            ans.push(count);
        }
        ans

=======

        let mut words = words.iter().map(|x| x.chars().fold(vec![0;26], |mut acc, c| { acc[c as usize - 97] += 1; acc })).collect::<Vec<Vec<i32>>>();
        let mut queries = queries.iter().map(|x| x.chars().fold(vec![0;26], |mut acc, c| { acc[c as usize - 97] += 1; acc })).collect::<Vec<Vec<i32>>>();
        for i in 0..words.len() {
            for j in 1..26 {
                words[i][j] += words[i][j-1];
            }
        }
        for i in 0..queries.len() {
            for j in 1..26 {
                queries[i][j] += queries[i][j-1];
            }
        }
        queries.iter().map(|x| words.iter().filter(|y| x[0] < y[0]).count() as i32).collect()
    }
}
