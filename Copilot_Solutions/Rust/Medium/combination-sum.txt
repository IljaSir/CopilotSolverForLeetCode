Synthesizing 10/10 solutions

=======
Suggestion 1

        let mut res = Vec::new();
        let mut cur = Vec::new();
        Solution::dfs(&candidates, target, 0, &mut cur, &mut res);
        res
    }
    fn dfs(candidates: &Vec<i32>, target: i32, idx: usize, cur: &mut Vec<i32>, res: &mut Vec<Vec<i32>>) {
        if target == 0 {
            res.push(cur.clone());
            return;
        }
        for i in idx..candidates.len() {
            let v = candidates[i];
            if target - v < 0 {
                continue;
            }
            cur.push(v);
            Solution::dfs(candidates, target - v, i, cur, res);
            cur.pop();
        }

=======
Suggestion 2

        let mut ans = Vec::new();
        let mut path = Vec::new();
        Self::backtrack(&candidates, target, 0, &mut path, &mut ans);
        ans
    }

    fn backtrack(candidates: &Vec<i32>, target: i32, start: usize, path: &mut Vec<i32>, ans: &mut Vec<Vec<i32>>) {
        if target == 0 {
            ans.push(path.clone());
            return;
        }
        for i in start..candidates.len() {
            let cand = candidates[i];
            if target - cand < 0 {
                continue;
            }
            path.push(cand);
            Self::backtrack(candidates, target - cand, i, path, ans);
            path.pop();
        }

=======
Suggestion 3

        let mut result: Vec<Vec<i32>> = vec![];
        Self::dfs(&candidates, target, 0, &mut vec![], &mut result);
        result
    }
    fn dfs(candidates: &Vec<i32>, target: i32, index: usize, path: &mut Vec<i32>, result: &mut Vec<Vec<i32>>) {
        if target < 0 {
            return;
        }
        if target == 0 {
            result.push(path.clone());
            return;
        }
        for i in index..candidates.len() {
            path.push(candidates[i]);
            Self::dfs(candidates, target - candidates[i], i, path, result);
            path.pop();
        }
    }
}

=======
Suggestion 4

        let mut res = Vec::new();
        let mut path = Vec::new();
        Solution::backtrack(&mut res, &mut path, &candidates, target, 0);
        res
    }

    fn backtrack(res: &mut Vec<Vec<i32>>, path: &mut Vec<i32>, candidates: &Vec<i32>, target: i32, start: usize) {
        if target < 0 {
            return;
        }
        if target == 0 {
            res.push(path.clone());
            return;
        }
        for i in start..candidates.len() {
            path.push(candidates[i]);
            Solution::backtrack(res, path, candidates, target - candidates[i], i);
            path.pop();
        }
    }
}

=======
Suggestion 5

        let mut result = vec![];
        let mut path = vec![];
        let mut candidates = candidates;
        candidates.sort();
        Self::dfs(&candidates, target, 0, &mut path, &mut result);
        result
    }
    fn dfs(candidates: &Vec<i32>, target: i32, start: usize, path: &mut Vec<i32>, result: &mut Vec<Vec<i32>>) {
        if target == 0 {
            result.push(path.to_vec());
            return;
        }
        for i in start..candidates.len() {
            let candidate = candidates[i];
            if candidate > target {
                break;
            }
            path.push(candidate);
            Self::dfs(candidates, target - candidate, i, path, result);
            path.pop();
        }
    }
}

=======
Suggestion 6

        let mut res = vec![];
        let mut path = vec![];
        let mut candidates = candidates;
        candidates.sort();
        Self::backtrack(&mut res, &mut path, &candidates, target, 0);
        res
    }
    fn backtrack(res: &mut Vec<Vec<i32>>, path: &mut Vec<i32>, candidates: &Vec<i32>, target: i32, start: usize) {
        if target == 0 {
            res.push(path.clone());
            return;
        }
        for i in start..candidates.len() {
            if target - candidates[i] < 0 {
                break;
            }
            path.push(candidates[i]);
            Self::backtrack(res, path, candidates, target - candidates[i], i);
            path.pop();
        }
    }
}

=======
Suggestion 7

        let mut ans = vec![];
        let mut cur = vec![];
        Self::backtrack(&candidates, target, 0, &mut cur, &mut ans);
        ans
    }

    fn backtrack(candidates: &Vec<i32>, target: i32, start: usize, cur: &mut Vec<i32>, ans: &mut Vec<Vec<i32>>) {
        if target == 0 {
            ans.push(cur.clone());
            return;
        }
        if target < 0 {
            return;
        }
        for i in start..candidates.len() {
            cur.push(candidates[i]);
            Self::backtrack(candidates, target - candidates[i], i, cur, ans);
            cur.pop();
        }

=======
Suggestion 8

        let mut result = vec![];
        let mut tmp = vec![];
        let mut candidates = candidates;
        candidates.sort();
        Self::dfs(&candidates, target, 0, &mut tmp, &mut result);
        result
    }

    fn dfs(candidates: &Vec<i32>, target: i32, start: usize, tmp: &mut Vec<i32>, result: &mut Vec<Vec<i32>>) {
        if target < 0 {
            return;
        }
        if target == 0 {
            result.push(tmp.clone());
            return;
        }
        for i in start..candidates.len() {
            if candidates[i] > target {
                break;
            }
            tmp.push(candidates[i]);
            Self::dfs(candidates, target - candidates[i], i, tmp, result);
            tmp.pop();
        }
    }
}

=======
Suggestion 9

        let mut result = Vec::new();
        let mut current = Vec::new();
        let mut candidates = candidates;
        candidates.sort();
        Self::backtrack(&candidates, 0, target, &mut current, &mut result);
        result
    }

    fn backtrack(candidates: &Vec<i32>, start: usize, target: i32, current: &mut Vec<i32>, result: &mut Vec<Vec<i32>>) {
        if target == 0 {
            result.push(current.clone());
            return;
        }

        for i in start..candidates.len() {
            if target - candidates[i] < 0 {
                break;
            }
            current.push(candidates[i]);
            Self::backtrack(candidates, i, target - candidates[i], current, result);
            current.pop();
        }
    }
}

=======
Suggestion 10

        let mut result = Vec::new();
        let mut candidates = candidates;
        candidates.sort();
        let mut path = Vec::new();
        Self::backtrack(&candidates, target, &mut path, &mut result);
        result
    }
    fn backtrack(candidates: &[i32], target: i32, path: &mut Vec<i32>, result: &mut Vec<Vec<i32>>) {
        if target == 0 {
            result.push(path.to_vec());
            return;
        }
        for (i, &candidate) in candidates.iter().enumerate() {
            if target - candidate < 0 {
                break;
            }
            path.push(candidate);
            Self::backtrack(&candidates[i..], target - candidate, path, result);
            path.pop();
        }
