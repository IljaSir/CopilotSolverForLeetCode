Synthesizing 10/10 solutions

=======

        let mut events = events;
        events.sort_by(|a, b| a[1].cmp(&b[1]));
        let mut seen = vec![false; 100001];
        let mut ans = 0;
        for e in events {
            for i in e[0]..=e[1] {
                if !seen[i as usize] {
                    seen[i as usize] = true;
                    ans += 1;
                    break;
                }
            }
        }
        ans

=======

        let mut events = events;
        events.sort_by(|a, b| a[1].cmp(&b[1]));
        let mut used = vec![false; 100001];
        let mut res = 0;
        for e in events {
            for i in e[0]..=e[1] {
                if !used[i as usize] {
                    res += 1;
                    used[i as usize] = true;
                    break;
                }
            }
        }
        res

=======

        let mut events = events;
        events.sort_by(|a, b| a[1].cmp(&b[1]));
        let mut seen = vec![false; 100001];
        let mut count = 0;
        for event in events {
            let mut i = event[0];
            while i <= event[1] {
                if !seen[i as usize] {
                    seen[i as usize] = true;
                    count += 1;
                    break;
                }
                i += 1;
            }
        }
        count

=======

        let mut events = events;
        events.sort_unstable_by(|a, b| a[1].cmp(&b[1]));
        let mut set = std::collections::HashSet::new();
        for event in events {
            for i in event[0]..event[1] + 1 {
                if !set.contains(&i) {
                    set.insert(i);
                    break;
                }
            }
        }
        set.len() as i32

=======

        let mut events = events;
        events.sort_by(|a, b| a[1].cmp(&b[1]));
        let mut day = 0;
        let mut count = 0;
        let mut i = 0;
        let mut visited = vec![false; 100001];
        while i < events.len() {
            day = day.max(events[i][0]);
            while day <= events[i][1] && visited[day as usize] {
                day += 1;
            }
            if day <= events[i][1] {
                visited[day as usize] = true;
                count += 1;
            }
            i += 1;
        }
        count

=======

        let mut events: Vec<Vec<i32>> = events;
        events.sort_by(|a, b| a[1].cmp(&b[1]));
        let mut day = 1;
        let mut count = 0;
        let mut i = 0;
        let mut visited = vec![false; 100001];
        while i < events.len() && day <= events[events.len() - 1][1] {
            let mut j = i;
            while j < events.len() && events[j][1] == day {
                j += 1;
            }
            let mut k = j - 1;
            while k >= i {
                if !visited[events[k][0] as usize] {
                    visited[events[k][0] as usize] = true;
                    count += 1;
                    break;
                }
                k -= 1;
            }
            day += 1;
            i = j;
        }
        count
    }
}

=======

        let mut events = events;
        events.sort_by_key(|e| e[0]);
        let mut pq = std::collections::BinaryHeap::new();
        let mut i = 0;
        let mut res = 0;
        for d in 1..100001 {
            while i < events.len() && events[i][0] == d {
                pq.push(std::cmp::Reverse(events[i][1]));
                i += 1;
            }
            while !pq.is_empty() && pq.peek().unwrap().0 < d {
                pq.pop();
            }
            if !pq.is_empty() {
                res += 1;
                pq.pop();
            }
        }
        res

=======

        let mut events = events;
        events.sort_unstable_by_key(|x| x[1]);
        let mut ans = 0;
        let mut used = vec![false; 100001];
        for e in events {
            for i in e[0]..=e[1] {
                if !used[i as usize] {
                    used[i as usize] = true;
                    ans += 1;
                    break;
                }
            }
        }
        ans

=======

        let mut events = events;
        events.sort_by_key(|e| e[1]);
        let mut set = std::collections::HashSet::new();
        let mut i = 0;
        for e in events {
            let mut j = e[0];
            while j <= e[1] && i < e[1] {
                if !set.contains(&j) {
                    set.insert(j);
                    i += 1;
                    break;
                }
                j += 1;
            }
        }
        i
    }
}

=======

        let mut events = events;
        events.sort_by_key(|a| a[1]);
        let mut day = 0;
        let mut ans = 0;
        let mut i = 0;
        let mut pq = std::collections::BinaryHeap::new();
        while !pq.is_empty() || i < events.len() {
            if pq.is_empty() {
                day = events[i][0];
            }
            while i < events.len() && events[i][0] <= day {
                pq.push(std::cmp::Reverse(events[i][1]));
                i += 1;
            }
            pq.pop();
            ans += 1;
            day += 1;
            while !pq.is_empty() && pq.peek().unwrap().0 < day {
                pq.pop();
            }
        }
        ans
