Synthesizing 10/10 solutions

=======

        let mut m = std::collections::HashMap::new();
        for &d in &deliciousness {
            *m.entry(d).or_insert(0) += 1;
        }
        let mut keys: Vec<_> = m.keys().collect();
        keys.sort();
        let mut res = 0;
        for i in 0..keys.len() {
            for j in i..keys.len() {
                let sum = keys[i] + keys[j];
                if sum & (sum - 1) == 0 {
                    let cnt = m.get(keys[i]).unwrap() * m.get(keys[j]).unwrap();
                    res += if i == j { cnt - 1 } else { cnt };
                }
            }
        }
        (res / 2) as i32 % 1000000007
    }
}

=======

        let mut map = std::collections::HashMap::new();
        let mut count = 0;
        for d in deliciousness {
            for i in 0..22 {
                let target = 1 << i;
                if let Some(v) = map.get(&(target - d)) {
                    count += v;
                    count %= 1000000007;
                }
            }
            *map.entry(d).or_insert(0) += 1;
        }
        count

=======

        let mut m = std::collections::HashMap::new();
        let mut ans = 0;
        let mut i = 0;
        while i < deliciousness.len() {
            let mut j = 0;
            while j <= 21 {
                let t = 1 << j;
                if let Some(v) = m.get(&(t - deliciousness[i])) {
                    ans += v;
                    ans %= 1000000007;
                }
                j += 1;
            }
            *m.entry(deliciousness[i]).or_insert(0) += 1;
            i += 1;
        }
        ans as i32

=======

        let mut map = std::collections::HashMap::new();
        let mut res = 0;
        for d in deliciousness {
            for i in 0..=21 {
                let diff = 1 << i - d;
                if let Some(count) = map.get(&diff) {
                    res = (res + count) % 1000000007;
                }
            }
            *map.entry(d).or_insert(0) += 1;
        }
        res

=======

        let mut res = 0;
        let mut map = std::collections::HashMap::new();
        for d in deliciousness {
            for i in 0..=21 {
                let target = 2_i64.pow(i) - d as i64;
                if let Some(count) = map.get(&target) {
                    res += count;
                }
            }
            *map.entry(d as i64).or_insert(0) += 1;
        }
        res as i32 % 1000000007
    }
}

=======

        let mut ans = 0;
        let mut map = std::collections::HashMap::new();
        for &x in deliciousness.iter() {
            for i in 0..21 {
                ans += map.get(&(1 << i) - x).unwrap_or(&0);
            }
            *map.entry(x).or_insert(0) += 1;
        }
        (ans % 1000000007) as i32
    }
}

=======

        let mut cnt = std::collections::HashMap::new();
        let mut ans = 0i64;
        for &x in deliciousness.iter() {
            for k in 0..22 {
                if let Some(&y) = cnt.get(&(1 << k - x)) {
                    ans += y;
                }
            }
            *cnt.entry(x).or_insert(0) += 1;
        }
        (ans % 1000000007) as i32
    }
}

=======

        let mut count = 0;
        let mut map = std::collections::HashMap::new();
        for i in deliciousness {
            let mut j = 1;
            while j <= i << 10 {
                if let Some(c) = map.get(&(j - i)) {
                    count += c;
                    count %= 1000000007;
                }
                j <<= 1;
            }
            *map.entry(i).or_default() += 1;
        }
        count as i32

=======

        let mut count = 0;
        let mut map = std::collections::HashMap::new();
        for &i in deliciousness.iter() {
            for j in 0..22 {
                let k = 2_i32.pow(j) - i;
                if let Some(&v) = map.get(&k) {
                    count += v;
                    count %= 1_000_000_007;
                }
            }
            *map.entry(i).or_default() += 1;
        }
        count as i32

=======

        let mut map = std::collections::HashMap::new();
        let mut ans = 0;
        let mod_num = 1_000_000_007;
        for i in 0..=21 {
            let k = 1 << i;
            for &delicious in &deliciousness {
                if let Some(&v) = map.get(&(k - delicious)) {
                    ans += v;
                    ans %= mod_num;
                }
                *map.entry(delicious).or_default() += 1;
            }
        }
        ans
