Synthesizing 10/10 solutions

=======

        let mut stack: Vec<i32> = vec![];
        let mut j = 0;
        for i in 0..pushed.len() {
            stack.push(pushed[i]);
            while !stack.is_empty() && stack[stack.len()-1] == popped[j] {
                stack.pop();
                j += 1;
            }
        }
        stack.is_empty()

=======

        let mut stack: Vec<i32> = vec![];
        let mut j = 0;
        for i in 0..pushed.len() {
            stack.push(pushed[i]);
            while !stack.is_empty() && stack[stack.len()-1] == popped[j] {
                stack.pop();
                j += 1;
            }
        }
        stack.is_empty()
    }
}

=======

        let mut stack = Vec::new();
        let mut i = 0;
        for x in pushed {
            stack.push(x);
            while !stack.is_empty() && stack[stack.len() - 1] == popped[i] {
                stack.pop();
                i += 1;
            }
        }
        stack.is_empty()

=======

        let mut stack = vec![];
        let mut i = 0;
        for x in pushed {
            stack.push(x);
            while !stack.is_empty() && stack[stack.len() - 1] == popped[i] {
                stack.pop();
                i += 1;
            }
        }
        stack.is_empty()
    }
}

=======

        let mut stack: Vec<i32> = Vec::new();
        let mut i = 0;
        for n in pushed {
            stack.push(n);
            while !stack.is_empty() && stack[stack.len()-1] == popped[i] {
                stack.pop();
                i += 1;
            }
        }
        stack.is_empty()

=======

        let mut stack = Vec::new();
        let mut pushed = pushed;
        let mut popped = popped;
        while !pushed.is_empty() {
            stack.push(pushed.remove(0));
            while !stack.is_empty() && stack[stack.len() - 1] == popped[0] {
                stack.pop();
                popped.remove(0);
            }
        }
        while !stack.is_empty() && stack[stack.len() - 1] == popped[0] {
            stack.pop();
            popped.remove(0);
        }
        stack.is_empty()

=======

        let mut stack = vec![];
        let mut i = 0;
        for &num in &pushed {
            stack.push(num);
            while let Some(&top) = stack.last() {
                if top == popped[i] {
                    stack.pop();
                    i += 1;
                } else {
                    break;
                }
            }
        }
        stack.is_empty()

=======

        let mut stack = Vec::new();
        let mut i = 0;
        for a in pushed {
            stack.push(a);
            while let Some(&b) = stack.last() {
                if b == popped[i] {
                    i += 1;
                    stack.pop();
                } else {
                    break;
                }
            }
        }
        i == popped.len()
    }
}

=======

        let mut stack = Vec::new();
        let mut j = 0;
        for p in pushed {
            stack.push(p);
            while let Some(&top) = stack.last() {
                if top == popped[j] {
                    stack.pop();
                    j += 1;
                } else {
                    break;
                }
            }
        }
        stack.is_empty()

=======

        let mut stack = Vec::new();
        let mut pushed_idx = 0;
        for i in 0..popped.len() {
            if !stack.is_empty() && stack[stack.len() - 1] == popped[i] {
                stack.pop();
            } else {
                while pushed_idx < pushed.len() && pushed[pushed_idx] != popped[i] {
                    stack.push(pushed[pushed_idx]);
                    pushed_idx += 1;
                }
                if pushed_idx == pushed.len() {
                    return false;
                }
                pushed_idx += 1;
            }
        }
        true
