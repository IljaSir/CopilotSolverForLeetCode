Synthesizing 10/10 solutions

=======

        let mut sum = 0;
        let mut odd = 0;
        let mut even = 0;
        for stone in stones {
            sum += stone;
            if stone % 2 == 0 {
                even += 1;
            } else {
                odd += 1;
            }
        }
        if sum % 3 == 0 {
            even > 0 && odd > 0
        } else if sum % 3 == 1 {
            odd > 1
        } else {
            even > 1
        }

=======

        let mut sum = 0;
        let mut odd = 0;
        let mut even = 0;
        for stone in stones {
            sum += stone;
            if stone % 2 == 0 {
                even += 1;
            } else {
                odd += 1;
            }
        }
        if sum % 3 == 0 {
            if odd == 0 {
                return false;
            } else if even == 0 {
                return odd % 2 == 0;
            } else {
                return true;
            }
        } else if sum % 3 == 1 {
            return odd >= 1;
        } else {
            return even >= 1;
        }

=======

        let mut sum = 0;
        let mut odd = 0;
        let mut even = 0;
        for i in 0..stones.len() {
            sum += stones[i];
            if stones[i] % 2 == 1 {
                odd += 1;
            } else {
                even += 1;
            }
        }
        if sum % 3 == 0 {
            if odd % 2 == 0 {
                return true;
            } else {
                return false;
            }
        } else if sum % 3 == 1 {
            if odd > 0 {
                return true;
            } else {
                return false;
            }
        } else {
            if odd > 1 {
                return true;
            } else {
                return false;
            }
        }

=======

        let mut sum = 0;
        let mut odd = 0;
        let mut even = 0;
        for stone in stones {
            sum += stone;
            if stone % 2 == 1 {
                odd += 1;
            } else {
                even += 1;
            }
        }
        let sum = sum % 3;
        if sum == 0 {
            true
        } else if sum == 1 {
            odd >= 1 && even >= 2
        } else {
            odd >= 2 && even >= 1
        }
    }
}

=======

        let mut sum = 0;
        let mut odd = 0;
        let mut even = 0;
        for i in 0..stones.len() {
            if stones[i] % 2 == 0 {
                even += 1;
            } else {
                odd += 1;
            }
            sum += stones[i];
        }
        if odd % 2 == 0 {
            return sum % 3 != 1;
        } else {
            return sum % 3 != 2;
        }

=======

        let mut sum = 0;
        let mut count = vec![0; 3];
        for &s in &stones {
            sum += s;
            count[s as usize % 3] += 1;
        }
        if sum % 3 == 0 {
            count[0] > 0 && count[1] > 0
        } else {
            count[sum as usize % 3] > 0
        }

=======

        let mut sum = 0;
        let mut odd = 0;
        let mut even = 0;
        for i in 0..stones.len() {
            let v = stones[i];
            sum += v;
            if v % 2 == 0 {
                even += 1;
            } else {
                odd += 1;
            }
        }
        if sum % 3 == 0 {
            return odd % 2 == 1;
        } else if sum % 3 == 1 {
            return odd > 0;
        } else {
            return even > 0;
        }

=======

        let mut cnt = vec![0; 3];
        for &v in stones.iter() {
            cnt[v as usize % 3] += 1;
        }
        if cnt[0] % 2 == 0 {
            cnt[1] > cnt[2]
        } else {
            cnt[1] != cnt[2]
        }
    }
}

=======

        let n = stones.len();
        let mut dp = vec![vec![vec![0; 3]; 2]; n];
        dp[n-1][0][stones[n-1] % 3] = 1;
        dp[n-1][1][stones[n-1] % 3] = 1;
        for i in (0..n-1).rev() {
            for j in 0..3 {
                let a = (j + stones[i]) % 3;
                let b = (j + 2 * stones[i]) % 3;
                dp[i][0][j] = dp[i+1][1][a] | dp[i+1][1][b];
                dp[i][1][j] = dp[i+1][0][a] | dp[i+1][0][b];
            }
        }
        dp[0][0][0] == 1

=======

        let mut cnt = vec![0;3];
        for stone in stones {
            cnt[stone as usize % 3] += 1;
        }
        let mut turn = true;
        let mut a = 0;
        let mut b = 0;
        while cnt[1] > 0 || cnt[2] > 0 {
            if turn {
                if cnt[2] > 0 {
                    cnt[2] -= 1;
                    a += 2;
                } else {
                    cnt[1] -= 1;
                    a += 1;
                }
            } else {
                if cnt[1] > 0 {
                    cnt[1] -= 1;
                    b += 1;
                } else {
                    cnt[2] -= 1;
                    b += 2;
                }
            }
            turn = !turn;
        }
        if a % 3 == 0 {
            return false;
        }
        if b % 3 == 0 {
            return true;
        }
        if cnt[0] > 0 {
            return true;
        }
        false
