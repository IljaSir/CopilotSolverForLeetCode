Synthesizing 10/10 solutions

=======

        let m = grid.len();
        let n = grid[0].len();
        let mut visited = vec![vec![false; n]; m];
        let mut queue = std::collections::VecDeque::new();
        queue.push_back((0, 0));
        let mut found = false;
        while !queue.is_empty() {
            let (i, j) = queue.pop_front().unwrap();
            if visited[i][j] {
                continue;
            }
            visited[i][j] = true;
            if i == m - 1 && j == n - 1 {
                found = true;
                break;
            }
            let street = grid[i][j];
            if street == 1 {
                if j > 0 && grid[i][j - 1] == 1 {
                    queue.push_back((i, j - 1));
                }
                if j < n - 1 && grid[i][j + 1] == 1 {
                    queue.push_back((i, j + 1));
                }
            } else if street == 2 {
                if i > 0 && grid[i - 1][j] == 2 {
                    queue.push_back((i - 1, j));
                }
                if i < m - 1 && grid[i + 1][j] == 2 {
                    queue.push_back((i + 1, j));
                }
            } else if street == 3 {
                if j > 0 && grid[i][j - 1] == 1 {
                    queue.push_back((i, j - 1));
                }
                if i < m - 1 && grid[i + 1][j] == 2 {
                    queue.push_back((i + 1, j));
                }
            } else if street == 4 {
                if j < n - 1 && grid[i][j + 1] == 1 {
                    queue.push_back((i, j + 1));
                }
                if i < m - 1 && grid[i + 1][j] == 2 {
                    queue.push_back((i + 1, j));
                }
            } else if street == 5 {
                if j > 0 && grid[i][j - 1] == 1 {
                    queue.push_back((i, j - 1));
                }
                if i > 0 &&

=======

        let m = grid.len();
        let n = grid[0].len();
        let mut visited = vec![vec![false; n]; m];
        let mut queue = std::collections::VecDeque::new();
        queue.push_back((0, 0));
        while !queue.is_empty() {
            let (x, y) = queue.pop_front().unwrap();
            if visited[x][y] {
                continue;
            }
            visited[x][y] = true;
            if x == m - 1 && y == n - 1 {
                return true;
            }
            match grid[x][y] {
                1 => {
                    if y > 0 && grid[x][y - 1] == 1 {
                        queue.push_back((x, y - 1));
                    }
                    if y + 1 < n && grid[x][y + 1] == 1 {
                        queue.push_back((x, y + 1));
                    }
                }
                2 => {
                    if x > 0 && grid[x - 1][y] == 2 {
                        queue.push_back((x - 1, y));
                    }
                    if x + 1 < m && grid[x + 1][y] == 2 {
                        queue.push_back((x + 1, y));
                    }
                }
                3 => {
                    if y > 0 && grid[x][y - 1] == 1 {
                        queue.push_back((x, y - 1));
                    }
                    if x + 1 < m && grid[x + 1][y] == 2 {
                        queue.push_back((x + 1, y));
                    }
                }
                4 => {
                    if y + 1 < n && grid[x][y + 1] == 1 {
                        queue.push_back((x, y + 1));
                    }
                    if x + 1 < m && grid[x + 1][y] == 2 {
                        queue.push_back((x + 1, y));
                    }
                }
                5 => {
                    if y > 0 && grid[x][y - 1] == 1 {
                        queue.push_back((x, y - 1));
                    }
                    if x > 0 && grid[x - 1][y] == 2 {
                        queue.push_back((x - 1,

=======

        let m = grid.len();
        let n = grid[0].len();
        let mut visited = vec![vec![false; n]; m];
        let mut q = std::collections::VecDeque::new();
        q.push_back((0, 0));
        while let Some((i, j)) = q.pop_front() {
            if i == m - 1 && j == n - 1 {
                return true;
            }
            visited[i][j] = true;
            match grid[i][j] {
                1 => {
                    if j > 0 && !visited[i][j - 1] && (grid[i][j - 1] == 1 || grid[i][j - 1] == 4 || grid[i][j - 1] == 6) {
                        q.push_back((i, j - 1));
                    }
                    if j < n - 1 && !visited[i][j + 1] && (grid[i][j + 1] == 1 || grid[i][j + 1] == 3 || grid[i][j + 1] == 5) {
                        q.push_back((i, j + 1));
                    }
                },
                2 => {
                    if i > 0 && !visited[i - 1][j] && (grid[i - 1][j] == 2 || grid[i - 1][j] == 3 || grid[i - 1][j] == 4) {
                        q.push_back((i - 1, j));
                    }
                    if i < m - 1 && !visited[i + 1][j] && (grid[i + 1][j] == 2 || grid[i + 1][j] == 5 || grid[i + 1][j] == 6) {
                        q.push_back((i + 1, j));
                    }
                },
                3 => {
                    if j > 0 && !visited[i][j - 1] && (grid[i][j - 1] == 1 || grid[i][j - 1] == 4 || grid[i][j - 1] == 6) {
                        q.push_back((i, j - 1));
                    }
                    if i < m - 1 && !visited[i + 1][j] && (grid

=======

        let m = grid.len();
        let n = grid[0].len();
        let mut visited = vec![vec![false; n]; m];
        let mut queue = Vec::new();
        queue.push((0, 0));
        while !queue.is_empty() {
            let (x, y) = queue.remove(0);
            if x == m - 1 && y == n - 1 {
                return true;
            }
            visited[x][y] = true;
            let mut next = Vec::new();
            match grid[x][y] {
                1 => {
                    next.push((x, y - 1));
                    next.push((x, y + 1));
                },
                2 => {
                    next.push((x - 1, y));
                    next.push((x + 1, y));
                },
                3 => {
                    next.push((x, y - 1));
                    next.push((x + 1, y));
                },
                4 => {
                    next.push((x, y + 1));
                    next.push((x + 1, y));
                },
                5 => {
                    next.push((x, y - 1));
                    next.push((x - 1, y));
                },
                6 => {
                    next.push((x, y + 1));
                    next.push((x - 1, y));
                },
                _ => unreachable!(),
            }
            for (nx, ny) in next {
                if nx < 0 || nx >= m || ny < 0 || ny >= n || visited[nx][ny] {
                    continue;
                }
                let mut ok = false;
                match grid[nx][ny] {
                    1 => {
                        if ny == y - 1 {
                            ok = true;
                        }
                        if ny == y + 1 {
                            ok = true;
                        }
                    },
                    2 => {
                        if nx == x - 1 {
                            ok = true;
                        }
                        if nx == x + 1 {
                            ok = true;
                        }
                    },
                    3 => {
                        if ny == y - 1 {
                            ok = true;
                        }
                        if nx == x + 1 {
                            ok = true;
                        }
                    },
                    4 => {
                        if ny == y + 1 {
                            ok = true;
                        }
                        if

=======

        let m = grid.len();
        let n = grid[0].len();
        let mut visited = vec![vec![false; n]; m];
        let mut q = vec![(0, 0)];
        visited[0][0] = true;
        while !q.is_empty() {
            let (i, j) = q.remove(0);
            if i == m - 1 && j == n - 1 {
                return true;
            }
            let dir = grid[i][j];
            let dirs = match dir {
                1 => vec![(0, -1), (0, 1)],
                2 => vec![(-1, 0), (1, 0)],
                3 => vec![(0, -1), (1, 0)],
                4 => vec![(0, 1), (1, 0)],
                5 => vec![(0, -1), (-1, 0)],
                6 => vec![(0, 1), (-1, 0)],
                _ => vec![],
            };
            for (di, dj) in dirs {
                let ni = i as i32 + di;
                let nj = j as i32 + dj;
                if ni < 0 || ni >= m as i32 || nj < 0 || nj >= n as i32 {
                    continue;
                }
                let ni = ni as usize;
                let nj = nj as usize;
                if visited[ni][nj] {
                    continue;
                }
                let ndir = grid[ni][nj];
                let ndirs = match ndir {
                    1 => vec![(0, -1), (0, 1)],
                    2 => vec![(-1, 0), (1, 0)],
                    3 => vec![(0, -1), (-1, 0)],
                    4 => vec![(0, 1), (-1, 0)],
                    5 => vec![(0, -1), (1, 0)],
                    6 => vec![(0, 1), (1, 0)],
                    _ => vec![],
                };
                if !ndirs.contains(&(-di, -dj)) {
                    continue;
                }
                visited[ni][nj] = true;
                q.push((ni, nj));
            }

=======

        let m = grid.len();
        let n = grid[0].len();
        let mut visited = vec![vec![false; n]; m];
        let mut stack = vec![(0, 0)];
        while let Some((x, y)) = stack.pop() {
            if visited[x][y] {
                continue;
            }
            visited[x][y] = true;
            if x == m - 1 && y == n - 1 {
                return true;
            }
            let dir = grid[x][y];
            if dir == 1 {
                if y > 0 && grid[x][y - 1] % 2 == 1 {
                    stack.push((x, y - 1));
                }
                if y < n - 1 && grid[x][y + 1] % 2 == 1 {
                    stack.push((x, y + 1));
                }
            } else if dir == 2 {
                if x > 0 && grid[x - 1][y] > 2 {
                    stack.push((x - 1, y));
                }
                if x < m - 1 && grid[x + 1][y] > 2 {
                    stack.push((x + 1, y));
                }
            } else if dir == 3 {
                if y > 0 && grid[x][y - 1] % 2 == 1 {
                    stack.push((x, y - 1));
                }
                if x < m - 1 && grid[x + 1][y] > 2 {
                    stack.push((x + 1, y));
                }
            } else if dir == 4 {
                if y < n - 1 && grid[x][y + 1] % 2 == 1 {
                    stack.push((x, y + 1));
                }
                if x < m - 1 && grid[x + 1][y] > 2 {
                    stack.push((x + 1, y));
                }
            } else if dir == 5 {
                if y > 0 && grid[x][y - 1] % 2 == 1 {
                    stack.push((x, y - 1));
                }
                if x > 0 && grid[x - 1][y] > 2 {
                    stack.push((x - 1, y));

=======

        let mut visited = vec![vec![false; grid[0].len()]; grid.len()];
        let mut queue = std::collections::VecDeque::new();
        queue.push_back((0, 0));
        while !queue.is_empty() {
            let (x, y) = queue.pop_front().unwrap();
            if x == grid.len() - 1 && y == grid[0].len() - 1 {
                return true;
            }
            visited[x][y] = true;
            for (nx, ny) in Self::next(x, y, grid[x][y]) {
                if !visited[nx][ny] && Self::check(nx, ny, grid[nx][ny], x, y, grid[x][y]) {
                    queue.push_back((nx, ny));
                }
            }
        }
        false
    }
    fn next(x: usize, y: usize, dir: i32) -> Vec<(usize, usize)> {
        match dir {
            1 => vec![(x, y - 1), (x, y + 1)],
            2 => vec![(x - 1, y), (x + 1, y)],
            3 => vec![(x, y - 1), (x + 1, y)],
            4 => vec![(x, y + 1), (x + 1, y)],
            5 => vec![(x, y - 1), (x - 1, y)],
            6 => vec![(x, y + 1), (x - 1, y)],
            _ => vec![],
        }

=======

        let (m, n) = (grid.len(), grid[0].len());
        let mut visited = vec![vec![false; n]; m];
        fn dfs(grid: &Vec<Vec<i32>>, i: usize, j: usize, visited: &mut Vec<Vec<bool>>) -> bool {
            if i == grid.len() - 1 && j == grid[0].len() - 1 {
                return true;
            }
            visited[i][j] = true;
            let mut res = false;
            let (m, n) = (grid.len(), grid[0].len());
            let dirs = vec![vec![0, 1], vec![1, 0], vec![0, -1], vec![-1, 0]];
            for dir in dirs {
                let (x, y) = (i as i32 + dir[0], j as i32 + dir[1]);
                if x < 0 || x >= m as i32 || y < 0 || y >= n as i32 {
                    continue;
                }
                let (x, y) = (x as usize, y as usize);
                if visited[x][y] {
                    continue;
                }
                let (a, b) = (grid[i][j], grid[x][y]);
                if (a == 1 && b == 1) || (a == 2 && b == 2) {
                    res |= dfs(grid, x, y, visited);
                } else if (a == 1 && b == 4) || (a == 4 && b == 1) {
                    if dir[0] == 0 {
                        res |= dfs(grid, x, y, visited);
                    }
                } else if (a == 1 && b == 3) || (a == 3 && b == 1) {
                    if dir[0] == 0 {
                        res |= dfs(grid, x, y, visited);
                    }
                } else if (a == 2 && b == 5) || (a == 5 && b == 2) {
                    if dir[1] == 0 {
                        res |= dfs(grid, x, y, visited);
                    }
                } else if (a == 2 && b == 6) || (a == 6 && b == 2) {
                    if dir

=======

        let m = grid.len();
        let n = grid[0].len();
        let mut visited = vec![vec![false; n]; m];
        let mut queue = vec![(0, 0)];
        while queue.len() > 0 {
            let (i, j) = queue.pop().unwrap();
            if i == m - 1 && j == n - 1 {
                return true;
            }
            visited[i][j] = true;
            for (x, y) in Self::next(&grid, i, j) {
                if !visited[x][y] {
                    queue.push((x, y));
                }
            }
        }
        false
    }
    fn next(grid: &Vec<Vec<i32>>, i: usize, j: usize) -> Vec<(usize, usize)> {
        let mut result = vec![];
        let m = grid.len();
        let n = grid[0].len();
        let street = grid[i][j];
        if i > 0 {
            let street2 = grid[i - 1][j];
            if street == 1 && street2 == 1 {
                result.push((i - 1, j));
            } else if street == 4 && street2 == 3 {
                result.push((i - 1, j));
            } else if street == 6 && street2 == 3 {
                result.push((i - 1, j));
            }
        }
        if i < m - 1 {
            let street2 = grid[i + 1][j];
            if street == 1 && street2 == 1 {
                result.push((i + 1, j));
            } else if street == 3 && street2 == 4 {
                result.push((i + 1, j));
            } else if street == 5 && street2 == 4 {
                result.push((i + 1, j));
            }
        }
        if j > 0 {
            let street2 = grid[i][j - 1];
            if street == 2 && street2 == 2 {
                result.push((i, j - 1));
            } else if street == 3 && street2 == 6 {
                result.push((i, j - 1));
            } else if street == 4 && street2 == 5 {
                result.push((i,

=======

        
    }
}
