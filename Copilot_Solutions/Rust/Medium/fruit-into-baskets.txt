Synthesizing 9/10 solutions

=======

        let mut l = 0;
        let mut r = 0;
        let mut m = std::collections::HashMap::new();
        let mut res = 0;
        while r < fruits.len() {
            *m.entry(fruits[r]).or_insert(0) += 1;
            while m.len() > 2 {
                *m.entry(fruits[l]).or_insert(0) -= 1;
                if m[&fruits[l]] == 0 {
                    m.remove(&fruits[l]);
                }
                l += 1;
            }
            res = res.max(r - l + 1);
            r += 1;
        }
        res as i32

=======

        let mut map = std::collections::HashMap::new();
        let mut start = 0;
        let mut max = 0;
        for (i, &fruit) in fruits.iter().enumerate() {
            *map.entry(fruit).or_insert(0) += 1;
            while map.len() > 2 {
                if let Some(&mut count) = map.get_mut(&fruits[start]) {
                    if count == 1 {
                        map.remove(&fruits[start]);
                    } else {
                        count -= 1;
                    }
                }
                start += 1;
            }
            max = max.max(i - start + 1);
        }
        max as i32

=======

        let mut map = std::collections::HashMap::new();
        let mut max = 0;
        let mut start = 0;
        for i in 0..fruits.len() {
            let count = map.entry(fruits[i]).or_insert(0);
            *count += 1;
            while map.len() > 2 {
                let count = map.get_mut(&fruits[start]).unwrap();
                *count -= 1;
                if *count == 0 {
                    map.remove(&fruits[start]);
                }
                start += 1;
            }
            max = max.max(i - start + 1);
        }
        max as i32

=======

        let mut max = 0;
        let mut map = std::collections::HashMap::new();
        let mut start = 0;
        for (i, &fruit) in fruits.iter().enumerate() {
            *map.entry(fruit).or_insert(0) += 1;
            while map.len() > 2 {
                let start_fruit = fruits[start];
                if let Some(count) = map.get_mut(&start_fruit) {
                    *count -= 1;
                    if *count == 0 {
                        map.remove(&start_fruit);
                    }
                }
                start += 1;
            }
            max = max.max(i - start + 1);
        }
        max as i32

=======

        let mut max = 0;
        let mut left = 0;
        let mut right = 0;
        let mut count = 0;
        let mut map = std::collections::HashMap::new();
        while right < fruits.len() {
            *map.entry(fruits[right]).or_insert(0) += 1;
            if map.get(&fruits[right]).unwrap() == &1 {
                count += 1;
            }
            right += 1;
            while count > 2 {
                *map.get_mut(&fruits[left]).unwrap() -= 1;
                if map.get(&fruits[left]).unwrap() == &0 {
                    count -= 1;
                }
                left += 1;
            }
            max = max.max(right - left);
        }
        max as i32

=======

        let mut ans = 0;
        let mut i = 0;
        let mut j = 0;
        let mut basket = std::collections::HashMap::new();
        while j < fruits.len() {
            *basket.entry(fruits[j]).or_insert(0) += 1;
            while basket.len() > 2 {
                *basket.entry(fruits[i]).or_insert(0) -= 1;
                if basket[&fruits[i]] == 0 {
                    basket.remove(&fruits[i]);
                }
                i += 1;
            }
            ans = ans.max(j - i + 1);
            j += 1;
        }
        ans as i32

=======

        let mut baskets = vec![0; fruits.len()];
        let mut count = 0;
        let mut max = 0;
        for i in 0..fruits.len() {
            if baskets[fruits[i] as usize] == 0 {
                count += 1;
            }
            baskets[fruits[i] as usize] += 1;
            while count > 2 {
                baskets[fruits[i - max] as usize] -= 1;
                if baskets[fruits[i - max] as usize] == 0 {
                    count -= 1;
                }
                max -= 1;
            }
            max += 1;
        }
        max as i32

=======

        let mut count = vec![0; fruits.len()];
        let mut max = 0;
        let mut i = 0;
        let mut j = 0;
        let mut k = 0;
        while j < fruits.len() {
            if count[fruits[j] as usize] == 0 {
                k += 1;
            }
            count[fruits[j] as usize] += 1;
            while k > 2 {
                count[fruits[i] as usize] -= 1;
                if count[fruits[i] as usize] == 0 {
                    k -= 1;
                }
                i += 1;
            }
            max = max.max(j - i + 1);
            j += 1;
        }
        max as i32
    }
}

=======

        let mut left = 0;
        let mut right = 0;
        let mut max = 0;
        let mut count = 0;
        let mut last = 0;
        let mut last_num = 0;
        let mut map = std::collections::HashMap::new();
        while right < fruits.len() {
            let n = fruits[right];
            let c = map.entry(n).or_insert(0);
            *c += 1;
            if n != last {
                last = n;
                last_num = 1;
            } else {
                last_num += 1;
            }
            right += 1;
            while map.len() > 2 {
                let n = fruits[left];
                let c = map.entry(n).or_insert(0);
                *c -= 1;
                if *c == 0 {
                    map.remove(&n);
                }
                left += 1;
            }
            if map.len() == 2 {
                count = map[&last] + map[&fruits[left]];
            } else if map.len() == 1 {
                count = map[&last];
            } else {
                count = 0;
            }
            if count > max {
                max = count;
            }
        }
        max as i32
    }
}
