Synthesizing 6/10 solutions

=======
Suggestion 1

        let mut result = Vec::new();
        let mut current = 1;
        for _ in 0..n {
            result.push(current);
            if current * 10 <= n {
                current *= 10;
            } else if current % 10 != 9 && current + 1 <= n {
                current += 1;
            } else {
                while (current / 10) % 10 == 9 {
                    current /= 10;
                }
                current = current / 10 + 1;
            }
        }
        result

=======
Suggestion 2

        let mut result = Vec::new();
        let mut cur = 1;
        for _ in 0..n {
            result.push(cur);
            if cur * 10 <= n {
                cur *= 10;
            } else if cur % 10 != 9 && cur + 1 <= n {
                cur += 1;
            } else {
                cur /= 10;
                while cur % 10 == 9 {
                    cur /= 10;
                }
                cur += 1;
            }
        }
        result

=======
Suggestion 3

        let mut res = vec![];
        let mut i = 1;
        for _ in 0..n {
            res.push(i);
            if i * 10 <= n {
                i *= 10;
            } else if i % 10 != 9 && i + 1 <= n {
                i += 1;
            } else {
                while (i / 10) % 10 == 9 {
                    i /= 10;
                }
                i = i / 10 + 1;
            }
        }
        res

=======
Suggestion 4

        let mut res = Vec::new();
        let mut x = 1;
        for _ in 0..n {
            res.push(x);
            if x * 10 <= n {
                x *= 10;
            } else {
                if x == n {
                    x /= 10;
                }
                x += 1;
                while x % 10 == 0 {
                    x /= 10;
                }
            }
        }
        res
    }
}

=======
Suggestion 5

        let mut result: Vec<i32> = Vec::new();
        let mut i = 1;
        for _ in 0..n {
            result.push(i);
            if i * 10 <= n {
                i *= 10;
            } else if i % 10 != 9 && i + 1 <= n {
                i += 1;
            } else {
                while (i / 10) % 10 == 9 {
                    i /= 10;
                }
                i = i / 10 + 1;
            }
        }
        result

=======
Suggestion 6

        let mut res = Vec::new();
        for i in 1..10 {
            if i > n {
                break;
            }
            res.push(i);
            Self::dfs(i, n, &mut res);
        }
        res
    }
    fn dfs(i: i32, n: i32, res: &mut Vec<i32>) {
        for j in 0..10 {
            let k = i * 10 + j;
            if k > n {
                break;
            }
            res.push(k);
            Self::dfs(k, n, res);
        }
