Synthesizing 10/10 solutions

=======

        let mut visited = vec![false; arr.len()];
        let mut stack = vec![start as usize];
        while let Some(i) = stack.pop() {
            if arr[i] == 0 {
                return true;
            }
            visited[i] = true;
            if i as i32 + arr[i] < arr.len() as i32 && !visited[i + arr[i] as usize] {
                stack.push(i + arr[i] as usize);
            }
            if i as i32 - arr[i] >= 0 && !visited[i - arr[i] as usize] {
                stack.push(i - arr[i] as usize);
            }
        }
        false
    }
}

=======

        let mut visited = vec![false; arr.len()];
        let mut stack = vec![start as usize];
        while let Some(i) = stack.pop() {
            if arr[i] == 0 {
                return true;
            }
            if visited[i] {
                continue;
            }
            visited[i] = true;
            if i as i32 + arr[i] < arr.len() as i32 {
                stack.push((i as i32 + arr[i]) as usize);
            }
            if i as i32 >= arr[i] {
                stack.push((i as i32 - arr[i]) as usize);
            }
        }
        false

=======

        let mut visited = vec![false; arr.len()];
        let mut stack = vec![start as usize];
        while !stack.is_empty() {
            let i = stack.pop().unwrap();
            if arr[i] == 0 {
                return true;
            }
            visited[i] = true;
            if i as i32 + arr[i] < arr.len() as i32 && !visited[i + arr[i] as usize] {
                stack.push(i + arr[i] as usize);
            }
            if i as i32 - arr[i] >= 0 && !visited[i - arr[i] as usize] {
                stack.push(i - arr[i] as usize);
            }
        }
        false
    }
}

=======

        let n = arr.len();
        let mut visited = vec![false; n];
        let mut q = std::collections::VecDeque::new();
        q.push_back(start as usize);
        while let Some(i) = q.pop_front() {
            if arr[i] == 0 {
                return true;
            }
            if visited[i] {
                continue;
            }
            visited[i] = true;
            if i as i32 + arr[i] < n as i32 {
                q.push_back((i as i32 + arr[i]) as usize);
            }
            if i as i32 - arr[i] >= 0 {
                q.push_back((i as i32 - arr[i]) as usize);
            }
        }
        false
    }
}

=======

        let mut visited = vec![false; arr.len()];
        let mut stack = vec![start as usize];
        while let Some(idx) = stack.pop() {
            if arr[idx] == 0 {
                return true;
            }
            if visited[idx] {
                continue;
            }
            visited[idx] = true;
            let left = idx as i32 - arr[idx];
            let right = idx as i32 + arr[idx];
            if left >= 0 {
                stack.push(left as usize);
            }
            if right < arr.len() as i32 {
                stack.push(right as usize);
            }
        }
        false

=======

        let mut visited = vec![false; arr.len()];
        let mut queue = std::collections::VecDeque::new();
        queue.push_back(start as usize);
        while let Some(i) = queue.pop_front() {
            if arr[i] == 0 {
                return true;
            }
            visited[i] = true;
            if (i as i32) + arr[i] < arr.len() as i32 && !visited[((i as i32) + arr[i]) as usize] {
                queue.push_back(((i as i32) + arr[i]) as usize);
            }
            if (i as i32) - arr[i] >= 0 && !visited[((i as i32) - arr[i]) as usize] {
                queue.push_back(((i as i32) - arr[i]) as usize);
            }
        }
        false
    }
}

=======

        let mut visited = vec![false; arr.len()];
        let mut stack = vec![start as usize];
        while !stack.is_empty() {
            let i = stack.pop().unwrap();
            if visited[i] {
                continue;
            }
            visited[i] = true;
            if arr[i] == 0 {
                return true;
            }
            if i as i32 + arr[i] < arr.len() as i32 {
                stack.push((i as i32 + arr[i]) as usize);
            }
            if i as i32 - arr[i] >= 0 {
                stack.push((i as i32 - arr[i]) as usize);
            }
        }
        false

=======

        let mut visited = vec![false; arr.len()];
        let mut stack = Vec::new();
        stack.push(start as usize);
        while !stack.is_empty() {
            let index = stack.pop().unwrap();
            if arr[index] == 0 {
                return true;
            }
            visited[index] = true;
            let left = (index as i32 - arr[index]) as usize;
            if left < arr.len() && !visited[left] {
                stack.push(left);
            }
            let right = (index as i32 + arr[index]) as usize;
            if right < arr.len() && !visited[right] {
                stack.push(right);
            }
        }
        false
    }
}

=======

        let mut visited = vec![false; arr.len()];
        let mut queue = Vec::new();
        queue.push(start as usize);
        while !queue.is_empty() {
            let i = queue.pop().unwrap();
            if arr[i] == 0 {
                return true;
            }
            if visited[i] {
                continue;
            }
            visited[i] = true;
            if i as i32 + arr[i] < arr.len() as i32 {
                queue.push((i as i32 + arr[i]) as usize);
            }
            if i as i32 - arr[i] >= 0 {
                queue.push((i as i32 - arr[i]) as usize);
            }
        }
        false
    }
}

=======

        let mut visited = vec![false; arr.len()];
        let mut stack = vec![(start, arr[start as usize])];
        while let Some((idx, val)) = stack.pop() {
            if val == 0 {
                return true;
            }
            let idx = idx as usize;
            if visited[idx] {
                continue;
            }
            visited[idx] = true;
            if idx + val as usize < arr.len() {
                stack.push((idx as i32 + val, arr[idx + val as usize]));
            }
            if idx >= val as usize {
                stack.push((idx as i32 - val, arr[idx - val as usize]));
            }
        }
        false
