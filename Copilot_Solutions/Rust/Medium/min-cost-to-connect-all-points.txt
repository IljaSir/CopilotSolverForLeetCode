Synthesizing 5/10 solutions

=======

        let n = points.len();
        let mut parent = vec![0; n];
        for i in 0..n {
            parent[i] = i;
        }
        let mut edges = vec![];
        for i in 0..n {
            for j in i+1..n {
                let d = (points[i][0] - points[j][0]).abs() + (points[i][1] - points[j][1]).abs();
                edges.push((d, i, j));
            }
        }
        edges.sort();
        let mut ans = 0;
        let mut num = n;
        for (d, i, j) in edges {
            if Self::find(&mut parent, i) != Self::find(&mut parent, j) {
                ans += d;
                Self::union(&mut parent, i, j);
                num -= 1;
                if num == 1 {
                    break;
                }
            }
        }
        ans
    }
    fn find(parent: &mut Vec<usize>, i: usize) -> usize {
        if parent[i] != i {
            parent[i] = Self::find(parent, parent[i]);
        }
        parent[i]
    }
    fn union(parent: &mut Vec<usize>, i: usize, j: usize) {
        let pi = Self::find(parent, i);
        let pj = Self::find(parent, j);
        if pi != pj {
            parent[pi] = pj;
        }

=======

        let n = points.len();
        let mut dists = vec![vec![std::i32::MAX; n]; n];
        for i in 0..n {
            for j in i+1..n {
                let d = (points[i][0] - points[j][0]).abs() + (points[i][1] - points[j][1]).abs();
                dists[i][j] = d;
                dists[j][i] = d;
            }
        }
        let mut visited = vec![false; n];
        let mut dist = vec![std::i32::MAX; n];
        let mut res = 0;
        dist[0] = 0;
        for _ in 0..n {
            let mut min_dist = std::i32::MAX;
            let mut min_idx = 0;
            for i in 0..n {
                if !visited[i] && dist[i] < min_dist {
                    min_idx = i;
                    min_dist = dist[i];
                }
            }
            visited[min_idx] = true;
            res += min_dist;
            for i in 0..n {
                if !visited[i] && dists[min_idx][i] < dist[i] {
                    dist[i] = dists[min_idx][i];
                }
            }
        }
        res

=======

        let n = points.len();
        let mut uf = UnionFind::new(n);
        let mut edges = Vec::new();
        for i in 0..n {
            for j in i + 1..n {
                let cost = (points[i][0] - points[j][0]).abs() + (points[i][1] - points[j][1]).abs();
                edges.push((cost, i, j));
            }
        }
        edges.sort();
        let mut ret = 0;
        let mut num = 1;
        for (cost, x, y) in edges {
            if uf.union(x, y) {
                ret += cost;
                num += 1;
                if num == n {
                    break;
                }
            }
        }
        ret
    }
}

=======

        let mut edges = Vec::new();
        for i in 0..points.len() {
            for j in i+1..points.len() {
                let x = points[i][0] - points[j][0];
                let y = points[i][1] - points[j][1];
                edges.push((x.abs() + y.abs(), i, j));
            }
        }
        edges.sort();
        let mut uf = UnionFind::new(points.len());
        let mut ans = 0;
        for (w, x, y) in edges {
            if uf.union(x, y) {
                ans += w;
            }
        }
        ans
    }
}

=======

        let mut res = 0;
        let mut visited = vec![false; points.len()];
        let mut heap = BinaryHeap::new();
        heap.push(Reverse((0, 0)));
        while let Some(Reverse((cost, i))) = heap.pop() {
            if visited[i] {
                continue;
            }
            visited[i] = true;
            res += cost;
            for j in 0..points.len() {
                if !visited[j] {
                    let cost = (points[i][0] - points[j][0]).abs() + (points[i][1] - points[j][1]).abs();
                    heap.push(Reverse((cost, j)));
                }
            }
        }
        res
