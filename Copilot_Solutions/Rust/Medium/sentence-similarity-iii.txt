Synthesizing 10/10 solutions

=======

        if sentence1 == sentence2 {
            return true;
        }
        let words1: Vec<&str> = sentence1.split(' ').collect();
        let words2: Vec<&str> = sentence2.split(' ').collect();
        let (mut i, mut j) = (0, 0);
        while i < words1.len() && j < words2.len() {
            if words1[i] == words2[j] {
                i += 1;
                j += 1;
            } else {
                break;
            }
        }
        while i < words1.len() && j < words2.len() {
            if words1[words1.len() - 1 - i] == words2[words2.len() - 1 - j] {
                i += 1;
                j += 1;
            } else {
                break;
            }
        }
        i == words1.len() && j == words2.len()

=======

        let words1: Vec<&str> = sentence1.split(' ').collect();
        let words2: Vec<&str> = sentence2.split(' ').collect();
        if words1.len() < words2.len() {
            return Self::are_sentences_similar(sentence2, sentence1);
        }
        if words1.len() - words2.len() > 1 {
            return false;
        }
        let mut i = 0;
        while i < words2.len() && words1[i] == words2[i] {
            i += 1;
        }
        let mut j = 0;
        while j < words2.len() && words1[words1.len() - 1 - j] == words2[words2.len() - 1 - j] {
            j += 1;
        }
        i + j == words2.len()

=======

        let s1: Vec<&str> = sentence1.split(" ").collect();
        let s2: Vec<&str> = sentence2.split(" ").collect();
        if s1.len() > s2.len() {
            return Self::are_sentences_similar(sentence2, sentence1);
        }
        let mut i = 0;
        let mut j = s2.len() - 1;
        while i < s1.len() && s1[i] == s2[i] {
            i += 1;
        }
        while j >= i && s1[j - i] == s2[j] {
            j -= 1;
        }
        i >= s1.len() || j < i

=======

        let s1: Vec<&str> = sentence1.split(' ').collect();
        let s2: Vec<&str> = sentence2.split(' ').collect();
        let (s1, s2) = if s1.len() > s2.len() { (s1, s2) } else { (s2, s1) };
        let mut i = 0;
        while i < s2.len() && s1[i] == s2[i] {
            i += 1;
        }
        let mut j = 0;
        while j < s2.len() && s1[s1.len() - j - 1] == s2[s2.len() - j - 1] {
            j += 1;
        }
        i + j >= s2.len()
    }
}

=======

        let s1: Vec<&str> = sentence1.split(" ").collect();
        let s2: Vec<&str> = sentence2.split(" ").collect();
        let (s1, s2) = if s1.len() > s2.len() { (s1, s2) } else { (s2, s1) };
        let mut i = 0;
        while i < s2.len() && s1[i] == s2[i] {
            i += 1;
        }
        let mut j = 0;
        while j < s2.len() && s1[s1.len() - 1 - j] == s2[s2.len() - 1 - j] {
            j += 1;
        }
        i + j >= s2.len()
    }
}

=======

        if sentence1 == sentence2 {
            return true;
        }
        let words1: Vec<String> = sentence1.split(" ").map(|s| s.to_string()).collect();
        let words2: Vec<String> = sentence2.split(" ").map(|s| s.to_string()).collect();
        if words1.len() == words2.len() {
            return false;
        }
        let (mut shorter, mut longer) = (words1, words2);
        if longer.len() < shorter.len() {
            std::mem::swap(&mut shorter, &mut longer);
        }
        let mut i = 0;
        let mut j = 0;
        while i < shorter.len() && j < longer.len() {
            if shorter[i] == longer[j] {
                i += 1;
                j += 1;
            } else {
                j += 1;
            }
        }
        i == shorter.len()

=======

        let s1 = sentence1.split(" ").collect::<Vec<_>>();
        let s2 = sentence2.split(" ").collect::<Vec<_>>();
        let n1 = s1.len();
        let n2 = s2.len();
        if n1 > n2 {
            return Self::are_sentences_similar(sentence2, sentence1);
        }
        let mut i = 0;
        while i < n1 && s1[i] == s2[i] {
            i += 1;
        }
        if i == n1 {
            return true;
        }
        let mut j = 0;
        while j < n1 && s1[n1 - 1 - j] == s2[n2 - 1 - j] {
            j += 1;
        }
        i + j == n1

=======

        let s1 = sentence1.split(" ").collect::<Vec<&str>>();
        let s2 = sentence2.split(" ").collect::<Vec<&str>>();
        if s1.len() != s2.len() {
            if s1.len() < s2.len() {
                return Self::are_sentences_similar(sentence2, sentence1);
            }
            let mut i = 0;
            while i < s2.len() {
                if s1[i] != s2[i] {
                    break;
                }
                i += 1;
            }
            let mut j = 1;
            while j <= s2.len() {
                if s1[s1.len()-j] != s2[s2.len()-j] {
                    break;
                }
                j += 1;
            }
            return i + j - 1 == s1.len();
        }
        for i in 0..s1.len() {
            if s1[i] != s2[i] {
                return false;
            }
        }
        true

=======

        let s1 = sentence1.split(' ').collect::<Vec<&str>>();
        let s2 = sentence2.split(' ').collect::<Vec<&str>>();
        if s1.len() < s2.len() {
            Self::are_sentences_similar(sentence2, sentence1)
        } else {
            let mut i = 0;
            let mut j = 0;
            while i < s1.len() && j < s2.len() {
                if s1[i] == s2[j] {
                    i += 1;
                    j += 1;
                } else {
                    break;
                }
            }
            if j == s2.len() {
                true
            } else {
                i = s1.len() - 1;
                j = s2.len() - 1;
                while i >= 0 && j >= 0 {
                    if s1[i] == s2[j] {
                        i -= 1;
                        j -= 1;
                    } else {
                        break;
                    }
                }
                j < 0
            }
        }
    }
}

=======

        let mut s1 = sentence1.split(" ");
        let mut s2 = sentence2.split(" ");
        let mut s1_last = s1.next_back();
        let mut s2_last = s2.next_back();
        while s1_last.is_some() && s2_last.is_some() && s1_last == s2_last {
            s1_last = s1.next_back();
            s2_last = s2.next_back();
        }
        if s1_last.is_none() && s2_last.is_none() {
            return true;
        }
        let mut s1_first = s1.next();
        let mut s2_first = s2.next();
        while s1_first.is_some() && s2_first.is_some() && s1_first == s2_first {
            s1_first = s1.next();
            s2_first = s2.next();
        }
        s1_first.is_none() && s2_first.is_none()
