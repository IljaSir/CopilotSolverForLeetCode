Synthesizing 3/10 solutions

=======

        let (d1, d2) = (divisor1 as i64, divisor2 as i64);
        let (u1, u2) = (unique_cnt1 as i64, unique_cnt2 as i64);
        let (mut l, mut r) = (1, u1 + u2);
        while l < r {
            let m = (l + r) >> 1;
            if m - m / d1 - m / d2 + m / (d1 * d2) < u1 + u2 {
                l = m + 1;
            } else {
                r = m;
            }
        }
        l as i32

=======

        let mut div1 = divisor1;
        let mut div2 = divisor2;
        let mut cnt1 = unique_cnt1;
        let mut cnt2 = unique_cnt2;
        while div1 != div2 {
            if div1 < div2 {
                let tmp = div1;
                div1 = div2;
                div2 = tmp;
                let tmp = cnt1;
                cnt1 = cnt2;
                cnt2 = tmp;
            }
            let tmp = div1;
            div1 = div2;
            div2 = tmp % div2;
        }
        let mut res = cnt1 + cnt2;
        if cnt1 % div1 != 0 {
            res -= div1 - cnt1 % div1;
        }
        res

=======

        let (mut lo, mut hi) = (1, unique_cnt1 + unique_cnt2);
        while lo < hi {
            let mid = (lo + hi) / 2;
            if mid - mid / divisor1 - mid / divisor2 + mid / (divisor1 * divisor2) >= unique_cnt1.min(unique_cnt2) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        lo
