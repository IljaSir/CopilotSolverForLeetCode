Synthesizing 9/10 solutions

=======

        let mut c1 = [0; 26];
        let mut c2 = [0; 26];
        for c in word1.chars() {
            c1[c as usize - 'a' as usize] += 1;
        }
        for c in word2.chars() {
            c2[c as usize - 'a' as usize] += 1;
        }
        let mut diff = 0;
        for i in 0..26 {
            if c1[i] > 0 && c2[i] == 0 {
                diff += 1;
            }
            if c2[i] > 0 && c1[i] == 0 {
                diff -= 1;
            }
        }
        let mut sum = 0;
        for i in 0..26 {
            sum += (c1[i] - c2[i]).abs();
        }
        sum / 2 <= diff.abs()

=======

        let mut freq1 = vec![0; 26];
        let mut freq2 = vec![0; 26];
        for c in word1.chars() {
            freq1[c as usize - 'a' as usize] += 1;
        }
        for c in word2.chars() {
            freq2[c as usize - 'a' as usize] += 1;
        }
        let mut diff1 = 0;
        let mut diff2 = 0;
        for i in 0..26 {
            if freq1[i] > 0 && freq2[i] == 0 {
                diff1 += 1;
            }
            if freq1[i] == 0 && freq2[i] > 0 {
                diff2 += 1;
            }
        }
        if diff1 == 0 && diff2 == 0 {
            return false;
        }
        if diff1 + diff2 <= 2 {
            return true;
        }
        let mut sum1 = 0;
        let mut sum2 = 0;
        for i in 0..26 {
            sum1 += freq1[i];
            sum2 += freq2[i];
        }
        sum1 > sum2

=======

        let mut c1 = vec![0; 26];
        let mut c2 = vec![0; 26];
        for c in word1.chars() {
            c1[(c as u8 - 'a' as u8) as usize] += 1;
        }
        for c in word2.chars() {
            c2[(c as u8 - 'a' as u8) as usize] += 1;
        }
        let mut c3 = vec![0; 26];
        let mut c4 = vec![0; 26];
        for i in 0..26 {
            c3[c1[i] as usize] += 1;
            c4[c2[i] as usize] += 1;
        }
        for i in 0..26 {
            if c3[i] > 0 && c4[i] > 0 {
                c3[i] -= 1;
                c4[i] -= 1;
            }
        }
        let mut s1 = 0;
        let mut s2 = 0;
        for i in 0..26 {
            s1 += c3[i] * i;
            s2 += c4[i] * i;
        }
        if s1 > s2 {
            std::mem::swap(&mut s1, &mut s2);
        }
        s1 == 1 && s2 == 1
    }
}

=======

        if word1.len() != word2.len() {
            return false;
        }
        let mut count1 = [0; 26];
        let mut count2 = [0; 26];
        for (c1, c2) in word1.chars().zip(word2.chars()) {
            let i1 = (c1 as u8 - b'a') as usize;
            let i2 = (c2 as u8 - b'a') as usize;
            count1[i1] += 1;
            count2[i2] += 1;
        }
        let mut diff = 0;
        for i in 0..26 {
            if count1[i] != count2[i] {
                diff += 1;
            }
        }
        diff <= 2

=======

        let mut word1 = word1.into_bytes();
        let mut word2 = word2.into_bytes();
        let mut c1 = vec![0; 26];
        let mut c2 = vec![0; 26];
        for i in 0..word1.len() {
            c1[word1[i] as usize - 'a' as usize] += 1;
            c2[word2[i] as usize - 'a' as usize] += 1;
        }
        let mut diff = 0;
        for i in 0..26 {
            if c1[i] == c2[i] {
                continue;
            }
            if c1[i] > c2[i] {
                diff += c1[i] - c2[i];
            } else {
                diff += (c2[i] - c1[i]) / 2;
            }
        }
        diff <= 1
    }
}

=======

        let mut c1 = vec![0; 26];
        let mut c2 = vec![0; 26];
        let mut l1 = 0;
        let mut l2 = 0;
        for c in word1.chars() {
            c1[c as usize - 'a' as usize] += 1;
            l1 += 1;
        }
        for c in word2.chars() {
            c2[c as usize - 'a' as usize] += 1;
            l2 += 1;
        }
        let mut diff = 0;
        for i in 0..26 {
            if c1[i] > 0 && c2[i] == 0 {
                diff += 1;
            }
            if c1[i] == 0 && c2[i] > 0 {
                diff += 1;
            }
        }
        let mut same = 0;
        for i in 0..26 {
            same += c1[i].min(c2[i]);
        }
        if diff <= 2 && same >= l1 - 2 && same >= l2 - 2 {
            return true;
        }
        false

=======

        
    }
}

=======

        let mut count1 = vec![0; 26];
        let mut count2 = vec![0; 26];
        let mut diff = 0;
        for i in 0..word1.len() {
            if word1[i..i+1] != word2[i..i+1] {
                diff += 1;
            }
            count1[(word1[i..i+1].chars().next().unwrap() as u8 - 'a' as u8) as usize] += 1;
            count2[(word2[i..i+1].chars().next().unwrap() as u8 - 'a' as u8) as usize] += 1;
        }
        if diff > 2 {
            return false;
        }
        let mut count = 0;
        for i in 0..26 {
            if count1[i] > 0 && count2[i] > 0 {
                count += 1;
            }
        }
        if diff == 1 {
            return count > 1;
        }
        if diff == 2 {
            return count > 0;
        }
        return count > 1;
    }
}

=======

        let mut c1 = [0;26];
        let mut c2 = [0;26];
        let mut n1 = 0;
        let mut n2 = 0;
        for c in word1.chars() {
            let i = (c as u8 - 'a' as u8) as usize;
            if c1[i] == 0 {
                n1 += 1;
            }
            c1[i] += 1;
        }
        for c in word2.chars() {
            let i = (c as u8 - 'a' as u8) as usize;
            if c2[i] == 0 {
                n2 += 1;
            }
            c2[i] += 1;
        }
        if n1 < n2 {
            return Solution::is_it_possible(word2, word1);
        }
        if n1 - n2 > 1 {
            return false;
        }
        let mut diff = 0;
        for i in 0..26 {
            if c1[i] > 0 && c2[i] == 0 {
                diff += 1;
            }
        }
        if n1 == n2 {
            return diff <= 2;
        } else {
            return diff <= 1;
        }
    }
}
