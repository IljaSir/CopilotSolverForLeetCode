Synthesizing 9/10 solutions

=======

        let (mut left, mut right) = (weights.iter().max().unwrap(), weights.iter().sum::<i32>());
        while left < right {
            let mid = (left + right) / 2;
            if Solution::can_ship(weights.as_slice(), days, mid) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        left
    }
    fn can_ship(weights: &[i32], days: i32, capacity: i32) -> bool {
        let mut sum = 0;
        let mut days = days;
        for i in 0..weights.len() {
            sum += weights[i];
            if sum > capacity {
                days -= 1;
                sum = weights[i];
            }
        }
        days > 0

=======

        let mut l = 0;
        let mut r = 0;
        for w in weights.iter() {
            l = l.max(*w);
            r += w;
        }
        while l < r {
            let mid = l + (r - l) / 2;
            let mut need = 1;
            let mut cur = 0;
            for w in weights.iter() {
                if cur + w > mid {
                    need += 1;
                    cur = 0;
                }
                cur += w;
            }
            if need <= days {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        l
    }
}

=======

        let mut l = 0;
        let mut r = 0;
        for w in weights.iter() {
            l = l.max(*w);
            r += w;
        }
        while l < r {
            let m = l + (r - l) / 2;
            let mut d = 1;
            let mut s = 0;
            for w in weights.iter() {
                if s + w > m {
                    d += 1;
                    s = 0;
                }
                s += w;
            }
            if d > days {
                l = m + 1;
            } else {
                r = m;
            }
        }
        l
    }
}

=======

        let mut left = 0;
        let mut right = 0;
        for w in weights.iter() {
            if *w > left {
                left = *w;
            }
            right += *w;
        }
        while left < right {
            let mid = left + (right - left) / 2;
            let mut need = 1;
            let mut cur = 0;
            for w in weights.iter() {
                if cur + w > mid {
                    need += 1;
                    cur = 0;
                }
                cur += w;
            }
            if need > days {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        left

=======

        let mut left = weights.iter().max().unwrap();
        let mut right = weights.iter().sum();
        while left < right {
            let mid = (left + right) / 2;
            let mut need = 1;
            let mut cur = 0;
            for &weight in &weights {
                if cur + weight > mid {
                    need += 1;
                    cur = 0;
                }
                cur += weight;
            }
            if need <= days {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        left
    }
}

=======

        let (mut left, mut right) = (1, 500 * weights.len() as i32);
        while left < right {
            let mid = (left + right) / 2;
            let mut cur = 0;
            let mut need = 1;
            for w in weights.iter() {
                if cur + w > mid {
                    need += 1;
                    cur = 0;
                }
                cur += w;
            }
            if need > days {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        left

=======

        let max = weights.iter().max().unwrap();
        let sum = weights.iter().sum::<i32>();
        let mut l = *max;
        let mut r = sum;
        while l < r {
            let mid = l + (r - l) / 2;
            let mut need = 1;
            let mut cur = 0;
            for w in weights.iter() {
                if cur + w > mid {
                    need += 1;
                    cur = 0;
                }
                cur += w;
            }
            if need <= days {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        l
    }
}

=======

        let (mut l, mut r) = (1, 500 * weights.len() as i32);
        while l < r {
            let mid = (l + r) / 2;
            let mut t = 0;
            let mut d = 0;
            for &w in weights.iter() {
                if t + w > mid {
                    t = 0;
                    d += 1;
                }
                t += w;
            }
            if t > 0 {
                d += 1;
            }
            if d > days {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        l

=======

        
    }
}
