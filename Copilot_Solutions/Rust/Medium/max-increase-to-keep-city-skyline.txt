Synthesizing 10/10 solutions

=======

        let n = grid.len();
        let mut row_max = vec![0; n];
        let mut col_max = vec![0; n];
        for i in 0..n {
            for j in 0..n {
                row_max[i] = row_max[i].max(grid[i][j]);
                col_max[j] = col_max[j].max(grid[i][j]);
            }
        }
        let mut res = 0;
        for i in 0..n {
            for j in 0..n {
                res += (row_max[i].min(col_max[j]) - grid[i][j]).abs();
            }
        }
        res

=======

        let n = grid.len();
        let mut row = vec![0; n];
        let mut col = vec![0; n];
        for i in 0..n {
            for j in 0..n {
                row[i] = row[i].max(grid[i][j]);
                col[j] = col[j].max(grid[i][j]);
            }
        }
        let mut res = 0;
        for i in 0..n {
            for j in 0..n {
                res += (row[i].min(col[j]) - grid[i][j]).abs();
            }
        }
        res

=======

        let n = grid.len();
        let mut top = vec![0; n];
        let mut left = vec![0; n];
        for i in 0..n {
            for j in 0..n {
                top[i] = top[i].max(grid[i][j]);
                left[j] = left[j].max(grid[i][j]);
            }
        }
        let mut ans = 0;
        for i in 0..n {
            for j in 0..n {
                ans += top[i].min(left[j]) - grid[i][j];
            }
        }
        ans

=======

        let mut max_row = vec![0; grid.len()];
        let mut max_col = vec![0; grid.len()];
        for i in 0..grid.len() {
            for j in 0..grid.len() {
                max_row[i] = max_row[i].max(grid[i][j]);
                max_col[j] = max_col[j].max(grid[i][j]);
            }
        }
        let mut sum = 0;
        for i in 0..grid.len() {
            for j in 0..grid.len() {
                sum += max_row[i].min(max_col[j]) - grid[i][j];
            }
        }
        sum

=======

        let n = grid.len();
        let mut top = vec![0; n];
        let mut left = vec![0; n];
        let mut ans = 0;
        for i in 0..n {
            for j in 0..n {
                top[i] = top[i].max(grid[i][j]);
                left[j] = left[j].max(grid[i][j]);
            }
        }
        for i in 0..n {
            for j in 0..n {
                ans += top[i].min(left[j]) - grid[i][j];
            }
        }
        ans

=======

        let mut ans = 0;
        let m = grid.len();
        let n = grid[0].len();
        let mut row = vec![0; m];
        let mut col = vec![0; n];
        for i in 0..m {
            for j in 0..n {
                row[i] = row[i].max(grid[i][j]);
                col[j] = col[j].max(grid[i][j]);
            }
        }
        for i in 0..m {
            for j in 0..n {
                ans += row[i].min(col[j]) - grid[i][j];
            }
        }
        ans

=======

        let mut res = 0;
        let mut row_max = vec![0; grid.len()];
        let mut col_max = vec![0; grid.len()];
        for i in 0..grid.len() {
            for j in 0..grid.len() {
                row_max[i] = std::cmp::max(row_max[i], grid[i][j]);
                col_max[j] = std::cmp::max(col_max[j], grid[i][j]);
            }
        }
        for i in 0..grid.len() {
            for j in 0..grid.len() {
                res += std::cmp::min(row_max[i], col_max[j]) - grid[i][j];
            }
        }
        res
    }
}

=======

        let mut top: Vec<i32> = vec![];
        let mut left: Vec<i32> = vec![];
        for i in 0..grid.len() {
            let mut max_top = 0;
            let mut max_left = 0;
            for j in 0..grid.len() {
                if grid[i][j] > max_top {
                    max_top = grid[i][j];
                }
                if grid[j][i] > max_left {
                    max_left = grid[j][i];
                }
            }
            top.push(max_top);
            left.push(max_left);
        }
        let mut sum = 0;
        for i in 0..grid.len() {
            for j in 0..grid.len() {
                let min = std::cmp::min(top[i], left[j]);
                sum += min - grid[i][j];
            }
        }
        sum

=======

        let mut north_skyline: Vec<i32> = vec![0; grid.len()];
        let mut west_skyline: Vec<i32> = vec![0; grid[0].len()];
        let mut increase = 0;
        for i in 0..grid.len() {
            for j in 0..grid[0].len() {
                if grid[i][j] > north_skyline[i] {
                    north_skyline[i] = grid[i][j];
                }
                if grid[i][j] > west_skyline[j] {
                    west_skyline[j] = grid[i][j];
                }
            }
        }
        for i in 0..grid.len() {
            for j in 0..grid[0].len() {
                if north_skyline[i] > west_skyline[j] {
                    increase += west_skyline[j] - grid[i][j];
                } else {
                    increase += north_skyline[i] - grid[i][j];
                }
            }
        }
        increase

=======

        
    }
}
