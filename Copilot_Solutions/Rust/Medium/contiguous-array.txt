Synthesizing 10/10 solutions

=======
Suggestion 1

        let mut map = std::collections::HashMap::new();
        let mut sum = 0;
        let mut max = 0;
        for i in 0..nums.len() {
            if nums[i] == 0 {
                sum -= 1;
            } else {
                sum += 1;
            }
            if sum == 0 {
                max = i + 1;
            } else {
                if let Some(&j) = map.get(&sum) {
                    if i - j > max {
                        max = i - j;
                    }
                } else {
                    map.insert(sum, i);
                }
            }
        }
        max as i32

=======
Suggestion 2

        let mut map = std::collections::HashMap::new();
        let mut count = 0;
        let mut max = 0;
        map.insert(0, -1);
        for (i, &num) in nums.iter().enumerate() {
            count += if num == 0 { -1 } else { 1 };
            if let Some(&j) = map.get(&count) {
                max = max.max(i as i32 - j);
            } else {
                map.insert(count, i as i32);
            }
        }
        max

=======
Suggestion 3

        let mut ans = 0;
        let mut sum = 0;
        let mut map = std::collections::HashMap::new();
        for i in 0..nums.len() {
            sum += if nums[i] == 1 { 1 } else { -1 };
            if sum == 0 {
                ans = i + 1;
            } else {
                if let Some(&last) = map.get(&sum) {
                    ans = ans.max(i - last);
                } else {
                    map.insert(sum, i);
                }
            }
        }
        ans as i32
    }
}

=======
Suggestion 4

        let mut map = std::collections::HashMap::new();
        let mut sum = 0;
        let mut max = 0;
        for (i, &num) in nums.iter().enumerate() {
            if num == 0 {
                sum -= 1;
            } else {
                sum += 1;
            }
            if sum == 0 {
                max = i + 1;
            } else if let Some(&prev) = map.get(&sum) {
                max = max.max(i - prev);
            } else {
                map.insert(sum, i);
            }
        }
        max as i32

=======
Suggestion 5

        let mut map = std::collections::HashMap::new();
        map.insert(0, -1);
        let mut count = 0;
        let mut max_length = 0;
        for (i, num) in nums.iter().enumerate() {
            if *num == 0 {
                count -= 1;
            } else {
                count += 1;
            }
            if let Some(&j) = map.get(&count) {
                max_length = max_length.max(i as i32 - j);
            } else {
                map.insert(count, i as i32);
            }
        }
        max_length

=======
Suggestion 6

        let mut map = std::collections::HashMap::new();
        map.insert(0, -1);
        let mut counter = 0;
        let mut max_len = 0;
        for (i, &num) in nums.iter().enumerate() {
            counter += if num == 0 { -1 } else { 1 };
            match map.get(&counter) {
                Some(&j) => max_len = max_len.max(i as i32 - j),
                None => map.insert(counter, i as i32),
            };
        }
        max_len

=======
Suggestion 7

        let mut map = std::collections::HashMap::new();
        let mut sum = 0;
        let mut ans = 0;
        for (i, &n) in nums.iter().enumerate() {
            if n == 1 {
                sum += 1;
            } else {
                sum -= 1;
            }
            if sum == 0 {
                ans = i + 1;
            }
            if let Some(&j) = map.get(&sum) {
                ans = ans.max(i - j);
            } else {
                map.insert(sum, i);
            }
        }
        ans as i32

=======
Suggestion 8

        let mut sum = 0;
        let mut max_len = 0;
        let mut map = std::collections::HashMap::new();
        map.insert(0, -1);
        for (i, n) in nums.iter().enumerate() {
            sum += if *n == 0 { -1 } else { 1 };
            if let Some(&j) = map.get(&sum) {
                max_len = std::cmp::max(max_len, (i as i32) - j);
            } else {
                map.insert(sum, i as i32);
            }
        }
        max_len

=======
Suggestion 9

        let mut res = 0;
        let mut count = 0;
        let mut map = std::collections::HashMap::new();
        for (i, &num) in nums.iter().enumerate() {
            count += if num == 0 { -1 } else { 1 };
            if count == 0 {
                res = i + 1;
            } else if let Some(&j) = map.get(&count) {
                res = res.max(i - j);
            } else {
                map.insert(count, i);
            }
        }
        res as i32

=======
Suggestion 10

        let mut count = 0;
        let mut max_len = 0;
        let mut map = std::collections::HashMap::new();
        for (i, &n) in nums.iter().enumerate() {
            count += if n == 1 { 1 } else { -1 };
            if count == 0 {
                max_len = i + 1;
            } else if let Some(&j) = map.get(&count) {
                max_len = max_len.max(i - j);
            } else {
                map.insert(count, i);
            }
        }
        max_len as i32
    }
}
