Synthesizing 9/10 solutions

=======

        let mut stack = vec![0];
        for c in s.chars() {
            if c == '(' {
                stack.push(0);
            } else {
                let v = stack.pop().unwrap();
                let w = stack.pop().unwrap();
                stack.push(w + std::cmp::max(2 * v, 1));
            }
        }
        stack.pop().unwrap()
    }
}

=======

        let mut stack = vec![];
        let mut score = 0;
        for c in s.chars() {
            if c == '(' {
                stack.push(score);
                score = 0;
            } else {
                score = stack.pop().unwrap() + std::cmp::max(score * 2, 1);
            }
        }
        score

=======

        let mut stack = vec![];
        let mut score = 0;
        for c in s.chars() {
            if c == '(' {
                stack.push(score);
                score = 0;
            } else {
                score = stack.pop().unwrap() + std::cmp::max(score * 2, 1);
            }
        }
        score
    }
}

=======

        let mut stack = Vec::new();
        for c in s.chars() {
            if c == '(' {
                stack.push(0);
            } else {
                let mut sum = 0;
                while let Some(v) = stack.pop() {
                    if v == 0 {
                        stack.push(if sum == 0 { 1 } else { 2 * sum });
                        break;
                    } else {
                        sum += v;
                    }
                }
            }
        }
        stack.iter().sum()
    }
}

=======

        let mut stack = Vec::new();
        for c in s.chars() {
            if c == '(' {
                stack.push(0);
            } else {
                let mut v = 0;
                while let Some(x) = stack.pop() {
                    if x == 0 {
                        stack.push(if v == 0 { 1 } else { 2 * v });
                        break;
                    } else {
                        v += x;
                    }
                }
            }
        }
        stack.into_iter().sum()

=======

        let mut stack = Vec::new();
        for c in s.chars() {
            if c == '(' {
                stack.push(0);
            } else {
                let mut cur = 0;
                while let Some(v) = stack.pop() {
                    if v == 0 {
                        stack.push(if cur == 0 { 1 } else { 2 * cur });
                        break;
                    } else {
                        cur += v;
                    }
                }
            }
        }
        stack[0]
    }
}

=======

        let mut stack = vec![];
        for c in s.chars() {
            if c == '(' {
                stack.push(0);
            } else {
                let mut n = 0;
                while let Some(x) = stack.pop() {
                    if x == 0 {
                        stack.push(if n == 0 { 1 } else { 2 * n });
                        break;
                    } else {
                        n += x;
                    }
                }
            }
        }
        stack.iter().sum()

=======

        let mut stack = vec![];
        for c in s.chars() {
            if c == '(' {
                stack.push(c);
            } else {
                let mut sum = 0;
                while let Some(c) = stack.pop() {
                    if c == '(' {
                        if sum == 0 {
                            sum = 1;
                        } else {
                            sum *= 2;
                        }
                        stack.push(sum as u8 as char);
                        break;
                    } else {
                        sum += c.to_digit(10).unwrap() as i32;
                    }
                }
            }
        }
        stack.iter().map(|c| c.to_digit(10).unwrap() as i32).sum()
    }
}

=======

        let mut stack = vec![];
        for c in s.chars() {
            match c {
                '(' => stack.push(0),
                ')' => {
                    let mut tmp = 0;
                    while let Some(top) = stack.pop() {
                        if top == 0 {
                            if tmp == 0 {
                                stack.push(1);
                            } else {
                                stack.push(2 * tmp);
                            }
                            break;
                        } else {
                            tmp += top;
                        }
                    }
                }
                _ => unreachable!(),
            }
        }
        stack.iter().sum()
