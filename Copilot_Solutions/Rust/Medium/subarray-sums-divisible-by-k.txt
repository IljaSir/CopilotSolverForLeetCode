Synthesizing 10/10 solutions

=======

        let mut sum = 0;
        let mut map = std::collections::HashMap::new();
        map.insert(0, 1);
        let mut res = 0;
        for num in nums {
            sum += num;
            let key = (sum % k + k) % k;
            let count = map.entry(key).or_insert(0);
            *count += 1;
            res += count - 1;
        }
        res

=======

        let mut sum = 0;
        let mut map = vec![0; k as usize];
        map[0] = 1;
        let mut count = 0;
        for i in 0..nums.len() {
            sum += nums[i];
            let index = (sum % k + k) % k;
            count += map[index as usize];
            map[index as usize] += 1;
        }
        count

=======

        let mut map = std::collections::HashMap::new();
        let mut sum = 0;
        let mut ans = 0;
        map.insert(0, 1);
        for n in nums {
            sum = (sum + n) % k;
            if sum < 0 {
                sum += k;
            }
            if let Some(v) = map.get(&sum) {
                ans += v;
            }
            *map.entry(sum).or_insert(0) += 1;
        }
        ans

=======

        let mut sum = 0;
        let mut count = 0;
        let mut map = std::collections::HashMap::new();
        map.insert(0, 1);
        for num in nums {
            sum += num;
            let m = (sum % k + k) % k;
            let c = map.entry(m).or_insert(0);
            count += *c;
            *c += 1;
        }
        count

=======

        let mut sum = 0;
        let mut count = 0;
        let mut map = std::collections::HashMap::new();
        map.insert(0, 1);
        for num in nums {
            sum += num;
            let n = sum % k;
            let m = map.entry(n).or_insert(0);
            *m += 1;
        }
        for v in map.values() {
            count += v * (v - 1) / 2;
        }
        count

=======

        let mut sum = vec![0; nums.len() + 1];
        for i in 0..nums.len() {
            sum[i + 1] = sum[i] + nums[i];
        }
        let mut map = std::collections::HashMap::new();
        for i in 0..sum.len() {
            let s = sum[i] % k;
            *map.entry(s).or_insert(0) += 1;
        }
        let mut ans = 0;
        for v in map.values() {
            ans += v * (v - 1) / 2;
        }
        ans

=======

        let mut sum = 0;
        let mut map = std::collections::HashMap::new();
        map.insert(0, 1);
        let mut res = 0;
        for n in nums {
            sum = (sum + n) % k;
            if sum < 0 {
                sum += k;
            }
            let count = map.entry(sum).or_insert(0);
            *count += 1;
            res += count - 1;
        }
        res

=======

        let mut sum = 0;
        let mut cnt = vec![0; k as usize];
        cnt[0] = 1;
        let mut ans = 0;
        for &num in nums.iter() {
            sum += num;
            let m = (sum % k + k) % k;
            ans += cnt[m as usize];
            cnt[m as usize] += 1;
        }
        ans

=======

        let mut sum = 0;
        let mut cnt = vec![0; k as usize];
        cnt[0] = 1;
        for i in 0..nums.len() {
            sum += nums[i];
            sum %= k;
            if sum < 0 {
                sum += k;
            }
            cnt[sum as usize] += 1;
        }
        let mut ans = 0;
        for i in 0..k as usize {
            ans += cnt[i] * (cnt[i] - 1) / 2;
        }
        ans

=======

        let mut sum = 0i32;
        let mut map = std::collections::HashMap::<i32, i32>::new();
        map.insert(0, 1);
        let mut count = 0i32;
        for num in nums {
            sum += num;
            let key = sum % k;
            if let Some(v) = map.get(&key) {
                count += v;
                map.insert(key, v+1);
            } else {
                map.insert(key, 1);
            }
        }
        count
