Synthesizing 10/10 solutions

=======

        let mut count = 0;
        let mut nums = nums;
        nums.sort();
        let mut i = 0;
        let mut j = nums.len() - 1;
        while i < j {
            if nums[i] + nums[j] == k {
                count += 1;
                i += 1;
                j -= 1;
            } else if nums[i] + nums[j] > k {
                j -= 1;
            } else {
                i += 1;
            }
        }
        count
    }
}

=======

        let mut count = 0;
        let mut nums = nums;
        nums.sort();
        let mut i = 0;
        let mut j = nums.len() - 1;
        while i < j {
            if nums[i] + nums[j] == k {
                count += 1;
                i += 1;
                j -= 1;
            } else if nums[i] + nums[j] > k {
                j -= 1;
            } else {
                i += 1;
            }
        }
        count

=======

        let mut nums = nums;
        nums.sort();
        let mut i = 0;
        let mut j = nums.len() - 1;
        let mut ans = 0;
        while i < j {
            let sum = nums[i] + nums[j];
            if sum == k {
                ans += 1;
                i += 1;
                j -= 1;
            } else if sum < k {
                i += 1;
            } else {
                j -= 1;
            }
        }
        ans

=======

        use std::collections::HashMap;
        let mut map = HashMap::new();
        for num in nums {
            *map.entry(num).or_insert(0) += 1;
        }
        let mut res = 0;
        for (num, count) in map {
            if let Some(other_count) = map.get(&(k - num)) {
                if num == k - num {
                    res += count / 2;
                } else {
                    res += std::cmp::min(count, *other_count);
                }
            }
        }
        res

=======

        let mut nums = nums;
        nums.sort();
        let mut i = 0;
        let mut j = nums.len() - 1;
        let mut ret = 0;
        while i < j {
            let sum = nums[i] + nums[j];
            if sum == k {
                ret += 1;
                i += 1;
                j -= 1;
            } else if sum > k {
                j -= 1;
            } else {
                i += 1;
            }
        }
        ret
    }
}

=======

        let mut map = std::collections::HashMap::new();
        let mut res = 0;
        for num in nums {
            if let Some(v) = map.get_mut(&(k - num)) {
                if *v > 0 {
                    *v -= 1;
                    res += 1;
                    continue;
                }
            }
            *map.entry(num).or_insert(0) += 1;
        }
        res
    }
}

=======

        let mut count = 0;
        let mut map = std::collections::HashMap::new();
        for n in nums {
            if let Some(v) = map.get_mut(&n) {
                if *v > 0 {
                    *v -= 1;
                    count += 1;
                } else {
                    *map.entry(k-n).or_insert(0) += 1;
                }
            } else {
                *map.entry(k-n).or_insert(0) += 1;
            }
        }
        count

=======

        let mut map = std::collections::HashMap::new();
        let mut ans = 0;
        for n in nums {
            if let Some(v) = map.get_mut(&(k-n)) {
                if *v > 0 {
                    *v -= 1;
                    ans += 1;
                    continue;
                }
            }
            *map.entry(n).or_insert(0) += 1;
        }
        ans
    }
}

=======

        let mut map = std::collections::HashMap::new();
        let mut ans = 0;
        for n in nums {
            let t = k - n;
            match map.get_mut(&t) {
                Some(v) => {
                    if v > &mut 0 {
                        *v -= 1;
                        ans += 1;
                    } else {
                        *map.entry(n).or_insert(0) += 1;
                    }
                }
                None => {
                    *map.entry(n).or_insert(0) += 1;
                }
            }
        }
        ans

=======

        let mut count = 0;
        let mut map = std::collections::HashMap::new();
        for num in nums {
            let pair = k - num;
            if let Some(value) = map.get(&pair) {
                if *value > 0 {
                    map.insert(pair, value - 1);
                    count += 1;
                } else {
                    map.insert(num, map.get(&num).unwrap_or(&0) + 1);
                }
            } else {
                map.insert(num, map.get(&num).unwrap_or(&0) + 1);
            }
        }
        count
