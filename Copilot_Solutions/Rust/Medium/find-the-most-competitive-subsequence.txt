Synthesizing 10/10 solutions

=======

        let mut stack = vec![];
        let n = nums.len();
        let k = k as usize;
        for i in 0..n {
            while !stack.is_empty() && nums[i] < stack[stack.len() - 1] && stack.len() + n - i > k {
                stack.pop();
            }
            if stack.len() < k {
                stack.push(nums[i]);
            }
        }
        stack

=======

        let mut stack = vec![];
        let n = nums.len();
        let k = k as usize;
        for (i, &num) in nums.iter().enumerate() {
            while !stack.is_empty() && stack.last().unwrap() > &num && n - i + stack.len() > k {
                stack.pop();
            }
            if stack.len() < k {
                stack.push(num);
            }
        }
        stack

=======

        let mut stack: Vec<i32> = Vec::new();
        let mut k = k;
        for i in 0..nums.len() {
            while stack.len() > 0 && nums[i] < stack[stack.len() - 1] && (k as usize) < (stack.len() + (nums.len() - i)) {
                stack.pop();
            }
            if stack.len() < k as usize {
                stack.push(nums[i]);
            }
        }
        stack

=======

        let mut k = k as usize;
        let mut stack = Vec::new();
        for (i, &num) in nums.iter().enumerate() {
            while !stack.is_empty() && stack[stack.len() - 1] > num && nums.len() - i + stack.len() > k {
                stack.pop();
            }
            if stack.len() < k {
                stack.push(num);
            }
        }
        stack

=======

        let mut stack = Vec::new();
        let mut k = k as usize;
        for i in 0..nums.len() {
            while stack.len() > 0 && nums[i] < *stack.last().unwrap() && stack.len() + nums.len() - i > k {
                stack.pop();
            }
            if stack.len() < k {
                stack.push(nums[i]);
            }
        }
        stack

=======

        let mut stack: Vec<i32> = Vec::new();
        let k = k as usize;
        let mut i = 0;
        while i < nums.len() {
            while !stack.is_empty() && stack[stack.len() - 1] > nums[i] && stack.len() - 1 + nums.len() - i >= k {
                stack.pop();
            }
            if stack.len() < k {
                stack.push(nums[i]);
            }
            i += 1;
        }
        stack

=======

        let mut stack = vec![];
        let mut k = k;
        for (i, &n) in nums.iter().enumerate() {
            while !stack.is_empty() && stack.last().unwrap() > &n && stack.len() + nums.len() - i > k as usize {
                stack.pop();
            }
            if stack.len() < k as usize {
                stack.push(n);
            }
        }
        stack

=======

        let mut k = k as usize;
        let mut stack = Vec::new();
        let mut n = nums.len();
        for i in 0..n {
            while !stack.is_empty() && nums[i] < *stack.last().unwrap() && n - i - 1 >= k - stack.len() {
                stack.pop();
            }
            if stack.len() < k {
                stack.push(nums[i]);
            }
        }
        stack
    }
}

=======

        let mut k = k as usize;
        let mut nums = nums;
        let mut stack = vec![];
        for i in 0..nums.len() {
            while !stack.is_empty() && nums[i] < stack[stack.len()-1] && stack.len() - 1 + nums.len() - i >= k {
                stack.pop();
            }
            if stack.len() < k {
                stack.push(nums[i]);
            }
        }
        stack

=======

        let mut stack: Vec<i32> = Vec::new();
        let mut k = k;
        for n in nums {
            while let Some(&top) = stack.last() {
                if n < top && stack.len() + nums.len() - 1 - nums.iter().position(|&x| x == n).unwrap() >= k as usize {
                    stack.pop();
                } else {
                    break;
                }
            }
            if stack.len() < k as usize {
                stack.push(n);
            }
        }
        stack
    }
}
