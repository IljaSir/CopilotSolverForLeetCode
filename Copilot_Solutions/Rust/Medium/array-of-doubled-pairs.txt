Synthesizing 9/10 solutions

=======

        let mut arr = arr;
        arr.sort();
        let mut map = std::collections::HashMap::new();
        for i in 0..arr.len() {
            *map.entry(arr[i]).or_insert(0) += 1;
        }
        for i in 0..arr.len() {
            if let Some(v) = map.get_mut(&arr[i]) {
                if *v > 0 {
                    let target = arr[i] * 2;
                    if let Some(v2) = map.get_mut(&target) {
                        if *v2 > 0 {
                            *v -= 1;
                            *v2 -= 1;
                        } else {
                            return false;
                        }
                    } else {
                        return false;
                    }
                }
            }
        }
        true

=======

        let mut arr = arr;
        arr.sort_unstable_by(|a, b| a.abs().cmp(&b.abs()));
        let mut map = std::collections::HashMap::new();
        for n in arr {
            *map.entry(n).or_insert(0) += 1;
        }
        for n in arr {
            if let Some(&count) = map.get(&n) {
                if count == 0 {
                    continue;
                }
                let double = n * 2;
                if n == 0 {
                    if count % 2 != 0 {
                        return false;
                    }
                } else if let Some(&count_double) = map.get(&double) {
                    if count_double < count {
                        return false;
                    }
                    map.insert(double, count_double - count);
                } else {
                    return false;
                }
            }
        }
        true

=======

        let mut arr = arr;
        arr.sort();
        let mut counts = std::collections::HashMap::new();
        for &n in &arr {
            *counts.entry(n).or_insert(0) += 1;
        }
        for &n in &arr {
            if let Some(c) = counts.get_mut(&n) {
                if *c == 0 {
                    continue;
                }
                let target = if n < 0 { n / 2 } else { n * 2 };
                if let Some(c2) = counts.get_mut(&target) {
                    if *c2 > 0 {
                        *c -= 1;
                        *c2 -= 1;
                    } else {
                        return false;
                    }
                } else {
                    return false;
                }
            }
        }
        true

=======

        let mut arr = arr;
        arr.sort_unstable();
        let mut map: std::collections::HashMap<i32, i32> = std::collections::HashMap::new();
        for x in arr {
            *map.entry(x).or_insert(0) += 1;
        }
        for x in arr {
            if map[&x] == 0 {
                continue;
            }
            let y = if x < 0 && x % 2 == 0 {
                x / 2
            } else {
                x * 2
            };
            if map[&x] > map[&y] {
                return false;
            }
            map.entry(y).and_modify(|e| *e -= map[&x]);
        }
        true

=======

        let mut arr = arr;
        arr.sort_unstable_by(|a, b| a.abs().cmp(&b.abs()));
        let mut map = std::collections::HashMap::new();
        for &x in &arr {
            *map.entry(x).or_insert(0) += 1;
        }
        for &x in &arr {
            if let Some(&mut cnt) = map.get_mut(&x) {
                if cnt <= 0 {
                    continue;
                }
                if let Some(&mut cnt2) = map.get_mut(&(x * 2)) {
                    if cnt2 <= 0 {
                        return false;
                    }
                    cnt -= 1;
                    cnt2 -= 1;
                } else {
                    return false;
                }
            }
        }
        true

=======

        let mut arr = arr;
        arr.sort_unstable();
        let mut i = 0;
        while i < arr.len() {
            if arr[i] < 0 {
                if arr[i] % 2 != 0 {
                    return false;
                } else {
                    let mut j = i + 1;
                    while j < arr.len() {
                        if arr[j] == arr[i] / 2 {
                            arr.remove(j);
                            arr.remove(i);
                            i -= 1;
                            break;
                        } else {
                            j += 1;
                        }
                    }
                    if j == arr.len() {
                        return false;
                    }
                }
            } else {
                let mut j = i + 1;
                while j < arr.len() {
                    if arr[j] == arr[i] * 2 {
                        arr.remove(j);
                        arr.remove(i);
                        i -= 1;
                        break;
                    } else {
                        j += 1;
                    }
                }
                if j == arr.len() {
                    return false;
                }
            }
            i += 1;
        }
        true

=======

        let mut arr = arr;
        arr.sort_unstable_by(|a, b| a.abs().cmp(&b.abs()));
        let mut map = std::collections::HashMap::new();
        for x in arr {
            let count = map.entry(x).or_insert(0);
            *count += 1;
        }
        for x in arr {
            if let Some(count) = map.get_mut(&x) {
                if *count > 0 {
                    let count2 = map.entry(x * 2).or_insert(0);
                    if *count2 > 0 {
                        *count -= 1;
                        *count2 -= 1;
                    } else {
                        return false;
                    }
                }
            }
        }
        true
    }
}

=======

        let mut arr = arr;
        arr.sort_unstable();
        let mut count = vec![0; 200001];
        for &num in &arr {
            count[(num + 100000) as usize] += 1;
        }
        for &num in &arr {
            if count[(num + 100000) as usize] == 0 {
                continue;
            }
            count[(num + 100000) as usize] -= 1;
            if num < 0 && num % 2 != 0 {
                return false;
            }
            let target = if num < 0 { num / 2 } else { num * 2 };
            if count[(target + 100000) as usize] == 0 {
                return false;
            }
            count[(target + 100000) as usize] -= 1;
        }
        true

=======

        let mut arr = arr;
        arr.sort();
        let mut count = 0;
        let mut i = 0;
        let mut j = 1;
        while i < arr.len() && j < arr.len() {
            if arr[i] < 0 && arr[j] < 0 {
                if arr[j] == arr[i] / 2 {
                    count += 1;
                    i += 2;
                    j += 2;
                } else if arr[j] > arr[i] / 2 {
                    i += 1;
                    j += 1;
                } else {
                    j += 1;
                }
            } else if arr[i] > 0 && arr[j] > 0 {
                if arr[j] == arr[i] * 2 {
                    count += 1;
                    i += 2;
                    j += 2;
                } else if arr[j] > arr[i] * 2 {
                    i += 1;
                    j += 1;
                } else {
                    j += 1;
                }
            } else {
                j += 1;
            }
        }
        count == arr.len() / 2
