Synthesizing 10/10 solutions

=======

        let sum = stones.iter().sum::<i32>();
        let n = stones.len();
        let mut dp = vec![false; (sum / 2 + 1) as usize];
        dp[0] = true;
        for stone in stones {
            for i in (stone as usize..=sum as usize / 2).rev() {
                dp[i] = dp[i] || dp[i - stone as usize];
            }
        }
        for i in (0..=sum / 2).rev() {
            if dp[i as usize] {
                return sum - i * 2;
            }
        }
        0

=======

        let sum = stones.iter().sum::<i32>();
        let n = stones.len();
        let mut dp = vec![false; (sum / 2 + 1) as usize];
        dp[0] = true;
        for &stone in stones.iter() {
            for i in (stone..=sum / 2).rev() {
                dp[i as usize] |= dp[(i - stone) as usize];
            }
        }
        for i in (0..=sum / 2).rev() {
            if dp[i as usize] {
                return sum - i * 2;
            }
        }
        0

=======

        let sum = stones.iter().sum::<i32>();
        let mut dp = vec![false; (sum / 2 + 1) as usize];
        dp[0] = true;
        for &stone in stones.iter() {
            for i in (stone..=sum / 2).rev() {
                dp[i as usize] = dp[i as usize] || dp[(i - stone) as usize];
            }
        }
        let mut res = sum;
        for i in 0..=sum / 2 {
            if dp[i as usize] {
                res = res.min(sum - 2 * i);
            }
        }
        res

=======

        let sum = stones.iter().sum::<i32>();
        let mut dp = vec![false; (sum / 2 + 1) as usize];
        dp[0] = true;
        for &stone in stones.iter() {
            for i in (stone..=sum / 2).rev() {
                dp[i as usize] |= dp[(i - stone) as usize];
            }
        }
        for i in (0..=sum / 2).rev() {
            if dp[i as usize] {
                return sum - 2 * i;
            }
        }
        unreachable!()

=======

        let sum: i32 = stones.iter().sum();
        let mut dp = vec![false; (sum / 2 + 1) as usize];
        dp[0] = true;
        for &stone in stones.iter() {
            for i in (stone..=sum / 2).rev() {
                dp[i as usize] = dp[i as usize] || dp[(i - stone) as usize];
            }
        }
        for i in (0..=sum / 2).rev() {
            if dp[i as usize] {
                return sum - i * 2;
            }
        }
        sum

=======

        let mut dp = vec![false; 1501];
        dp[0] = true;
        let mut sum = 0;
        for &stone in stones.iter() {
            sum += stone;
            for i in (stone..=sum).rev() {
                dp[i] = dp[i] || dp[i - stone];
            }
        }
        for i in (sum / 2..=sum).rev() {
            if dp[i] {
                return sum - 2 * i;
            }
        }
        0
    }
}

=======

        let mut dp = vec![false; 1501];
        dp[0] = true;
        let mut sum = 0;
        for &x in stones.iter() {
            sum += x;
            for i in (x..=sum).rev() {
                dp[i as usize] |= dp[(i - x) as usize];
            }
        }
        for i in (sum / 2)..=sum {
            if dp[i as usize] {
                return (sum - i) as i32;
            }
        }
        0

=======

        let sum: i32 = stones.iter().sum();
        let mut dp = vec![false; (sum / 2) as usize + 1];
        dp[0] = true;
        for &stone in stones.iter() {
            for i in (stone..=sum / 2).rev() {
                dp[i as usize] = dp[i as usize] || dp[(i - stone) as usize];
            }
        }
        let mut i = (sum / 2) as usize;
        while i >= 0 && !dp[i] {
            i -= 1;
        }
        sum - i as i32 * 2

=======

        let n = stones.len();
        let mut dp = vec![0; 1501];
        dp[0] = 1;
        let mut sum = 0;
        for i in 0..n {
            sum += stones[i];
            for j in (stones[i]..=sum).rev() {
                dp[j as usize] |= dp[(j - stones[i]) as usize];
            }
        }
        for i in (sum/2..=sum).rev() {
            if dp[i as usize] == 1 {
                return sum - i;
            }
        }
        0

=======

        let mut dp = vec![0; 1501];
        dp[0] = 1;
        let mut sum = 0;
        for stone in stones {
            sum += stone;
            for i in (stone..=sum).rev() {
                dp[i as usize] |= dp[(i - stone) as usize];
            }
        }
        for i in (sum / 2)..=sum {
            if dp[i as usize] == 1 {
                return sum - i;
            }
        }
        0
    }
}
