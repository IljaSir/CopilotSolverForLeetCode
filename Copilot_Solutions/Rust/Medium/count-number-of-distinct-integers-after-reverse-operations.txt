Synthesizing 10/10 solutions

=======

        let mut s: std::collections::HashSet<i32> = std::collections::HashSet::new();
        for i in nums {
            s.insert(i);
            s.insert(i.to_string().chars().rev().collect::<String>().parse::<i32>().unwrap());
        }
        s.len() as i32
    }
}

=======

        let mut nums: Vec<_> = nums.into_iter().map(|x| x.to_string().chars().rev().collect::<String>().parse::<i32>().unwrap()).collect();
        nums.sort();
        nums.dedup();
        nums.len() as i32

=======

        let mut set = std::collections::HashSet::new();
        for num in nums {
            let mut x = num;
            let mut y = 0;
            while x > 0 {
                y = y * 10 + x % 10;
                x /= 10;
            }
            set.insert(y);
        }
        set.len() as i32
    }
}

=======

        let mut set = std::collections::HashSet::new();
        for n in nums {
            set.insert(n);
            let mut rev = 0;
            let mut m = n;
            while m > 0 {
                rev = rev * 10 + m % 10;
                m /= 10;
            }
            set.insert(rev);
        }
        set.len() as i32
    }
}

=======

        use std::collections::HashSet;
        let mut set = HashSet::new();
        for n in nums {
            let mut n = n;
            let mut r = 0;
            while n > 0 {
                r = 10 * r + n % 10;
                n /= 10;
            }
            set.insert(r);
        }
        set.len() as i32

=======

        let mut set = std::collections::HashSet::new();
        for n in nums {
            let mut s = n.to_string();
            s.chars().rev().collect::<String>().parse::<i32>().unwrap();
            set.insert(s);
        }
        set.len() as i32
    }
}

=======

        let mut set = std::collections::HashSet::new();
        for n in nums.iter() {
            let mut s = n.to_string();
            s.reverse();
            let n = s.parse::<i32>().unwrap();
            set.insert(n);
        }
        set.len() as i32

=======

        let mut nums = nums;
        nums.sort();
        nums.dedup();
        let mut res = nums.len();
        for i in 0..nums.len() {
            let mut num = nums[i];
            while num > 0 {
                if nums.binary_search(&(num % 10)).is_err() {
                    res += 1;
                    nums.push(num % 10);
                    nums.sort();
                    nums.dedup();
                }
                num /= 10;
            }
        }
        res as i32

=======

        let mut nums = nums;
        let mut set = std::collections::HashSet::new();
        for i in nums.iter_mut() {
            let mut n = 0;
            let mut j = *i;
            while j > 0 {
                n = n * 10 + j % 10;
                j /= 10;
            }
            set.insert(n);
        }
        set.len() as i32
    }
}

=======

        let mut ans = 0;
        let mut map = std::collections::HashMap::new();
        for num in nums.iter() {
            let mut num = *num;
            let mut rev = 0;
            while num > 0 {
                rev = rev * 10 + num % 10;
                num /= 10;
            }
            if !map.contains_key(&rev) {
                map.insert(rev, true);
                ans += 1;
            }
        }
        ans
