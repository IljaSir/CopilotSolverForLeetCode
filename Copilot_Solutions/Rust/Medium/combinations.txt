Synthesizing 10/10 solutions

=======
Suggestion 1

        let mut result = Vec::new();
        let mut path = Vec::new();
        Self::backtrack(n, k, &mut result, &mut path, 1);
        result
    }
    fn backtrack(n: i32, k: i32, result: &mut Vec<Vec<i32>>, path: &mut Vec<i32>, start: i32) {
        if path.len() == k as usize {
            result.push(path.clone());
            return;
        }
        for i in start..=n {
            path.push(i);
            Self::backtrack(n, k, result, path, i + 1);
            path.pop();
        }
    }
}

=======
Suggestion 2

        let mut res = Vec::new();
        let mut temp = Vec::new();
        Solution::helper(n, k, 1, &mut temp, &mut res);
        res
    }
    fn helper(n: i32, k: i32, start: i32, temp: &mut Vec<i32>, res: &mut Vec<Vec<i32>>) {
        if temp.len() == k as usize {
            res.push(temp.clone());
            return;
        }
        for i in start..=n {
            temp.push(i);
            Solution::helper(n, k, i + 1, temp, res);
            temp.pop();
        }

=======
Suggestion 3

        let mut result = vec![];
        let mut current = vec![];
        Self::backtrack(&mut result, &mut current, n, k, 1);
        result
    }
    fn backtrack(result: &mut Vec<Vec<i32>>, current: &mut Vec<i32>, n: i32, k: i32, start: i32) {
        if current.len() == k as usize {
            result.push(current.clone());
            return;
        }
        for i in start..=n {
            current.push(i);
            Self::backtrack(result, current, n, k, i + 1);
            current.pop();
        }

=======
Suggestion 4

        let mut res = Vec::new();
        let mut path = Vec::new();
        Self::backtrack(&mut res, &mut path, 1, k, n);
        res
    }
    fn backtrack(res: &mut Vec<Vec<i32>>, path: &mut Vec<i32>, start: i32, k: i32, n: i32) {
        if path.len() == k as usize {
            res.push(path.clone());
            return;
        }
        for i in start..=n {
            path.push(i);
            Self::backtrack(res, path, i + 1, k, n);
            path.pop();
        }
    }
}

=======
Suggestion 5

        let mut result: Vec<Vec<i32>> = Vec::new();
        let mut tmp: Vec<i32> = Vec::new();
        let n = n as usize;
        let k = k as usize;
        Self::dfs(&mut result, &mut tmp, n, k, 1);
        result
    }
    
    fn dfs(result: &mut Vec<Vec<i32>>, tmp: &mut Vec<i32>, n: usize, k: usize, start: usize) {
        if tmp.len() == k {
            result.push(tmp.clone());
            return;
        }
        for i in start..=n {
            tmp.push(i as i32);
            Self::dfs(result, tmp, n, k, i + 1);
            tmp.pop();
        }
    }
}

=======
Suggestion 6

        let mut res = vec![];
        let mut cur = vec![];
        Self::dfs(&mut res, &mut cur, n, k, 1);
        res
    }
    
    pub fn dfs(res: &mut Vec<Vec<i32>>, cur: &mut Vec<i32>, n: i32, k: i32, start: i32) {
        if cur.len() == k as usize {
            res.push(cur.clone());
            return;
        }
        for i in start..=n {
            cur.push(i);
            Self::dfs(res, cur, n, k, i+1);
            cur.pop();
        }

=======
Suggestion 7

        let mut res = Vec::new();
        let mut comb = Vec::new();
        Self::dfs(1, n, k, &mut comb, &mut res);
        res
    }
    fn dfs(i: i32, n: i32, k: i32, comb: &mut Vec<i32>, res: &mut Vec<Vec<i32>>) {
        if comb.len() as i32 == k {
            res.push(comb.clone());
            return;
        }
        for j in i..=n {
            comb.push(j);
            Self::dfs(j + 1, n, k, comb, res);
            comb.pop();
        }

=======
Suggestion 8

        let mut res = Vec::new();
        let mut nums = Vec::new();
        for i in 1..=n {
            nums.push(i);
        }
        let mut tmp = Vec::new();
        Self::dfs(&mut res, &mut tmp, &nums, k as usize);
        res
    }
    fn dfs(res: &mut Vec<Vec<i32>>, tmp: &mut Vec<i32>, nums: &[i32], k: usize) {
        if tmp.len() == k {
            res.push(tmp.clone());
            return;
        }
        for i in 0..nums.len() {
            tmp.push(nums[i]);
            Self::dfs(res, tmp, &nums[i + 1..], k);
            tmp.pop();
        }
    }
}

=======
Suggestion 9

        let mut res = vec![];
        let mut curr = vec![];
        let mut used = vec![false; n as usize];
        Self::backtrack(&mut res, &mut curr, &mut used, n, k, 0);
        res
    }
    fn backtrack(res: &mut Vec<Vec<i32>>, curr: &mut Vec<i32>, used: &mut Vec<bool>, n: i32, k: i32, start: usize) {
        if curr.len() == k as usize {
            res.push(curr.clone());
            return;
        }
        for i in start..n as usize {
            if used[i] { continue; }
            curr.push((i + 1) as i32);
            used[i] = true;
            Self::backtrack(res, curr, used, n, k, i + 1);
            curr.pop();
            used[i] = false;
        }

=======
Suggestion 10

        let mut res = Vec::new();
        let mut temp = Vec::new();
        backtrack(n, k, &mut res, 1, &mut temp);
        res
    }
}
