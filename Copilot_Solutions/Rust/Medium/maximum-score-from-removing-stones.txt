Synthesizing 10/10 solutions

=======

        let mut a = a;
        let mut b = b;
        let mut c = c;
        if a < b {
            std::mem::swap(&mut a, &mut b);
        }
        if a < c {
            std::mem::swap(&mut a, &mut c);
        }
        if b < c {
            std::mem::swap(&mut b, &mut c);
        }
        let mut score = 0;
        while a > 0 && b > 0 {
            a -= 1;
            b -= 1;
            score += 1;
        }
        if a > 0 {
            let s = std::cmp::min(a, c);
            a -= s;
            c -= s;
            score += s;
        }
        score

=======

        let mut v = vec![a, b, c];
        v.sort();
        let (a, b, c) = (v[0], v[1], v[2]);
        if a + b <= c {
            a + b
        } else {
            (a + b + c) / 2
        }

=======

        let mut arr = vec![a, b, c];
        arr.sort();
        let (a, b, c) = (arr[0], arr[1], arr[2]);
        if a + b <= c {
            a + b
        } else {
            (a + b + c) / 2
        }

=======

        let mut arr = [a, b, c];
        arr.sort();
        let (a, b, c) = (arr[0], arr[1], arr[2]);
        if a + b <= c {
            a + b
        } else {
            (a + b + c) / 2
        }

=======

        let (a, b, c) = (a as usize, b as usize, c as usize);
        let (mut a, mut b, mut c) = (a, b, c);
        if a > b { std::mem::swap(&mut a, &mut b); }
        if b > c { std::mem::swap(&mut b, &mut c); }
        if a > b { std::mem::swap(&mut a, &mut b); }
        let mut res = 0;
        if a == 0 {
            res += b / 2;
            b %= 2;
            res += c / 2;
            c %= 2;
        } else if a + b == c {
            res += a;
        } else if a + b < c {
            res += a;
            res += (b + c - a) / 2;
        } else {
            res += (a + b + c) / 2;
        }
        res as i32

=======

        let mut a = a;
        let mut b = b;
        let mut c = c;
        let mut res = 0;
        let mut v = vec![a, b, c];
        v.sort();
        if v[0] + v[1] <= v[2] {
            return v[0] + v[1];
        }
        res += v[2];
        v[0] -= 1;
        v[1] -= 1;
        v.sort();
        if v[0] + v[1] <= v[2] {
            return res + v[0] + v[1];
        }
        res += (v[0] + v[1] - v[2]) / 2;
        res
    }
}

=======

        let mut a = a;
        let mut b = b;
        let mut c = c;
        let mut sum = 0;
        while a > 0 && b > 0 && c > 0 {
            sum += 1;
            let max = std::cmp::max(a, std::cmp::max(b, c));
            if max == a {
                a -= 1;
                b -= 1;
            } else if max == b {
                b -= 1;
                c -= 1;
            } else {
                c -= 1;
                a -= 1;
            }
        }
        sum

=======

        let mut arr = [a, b, c];
        arr.sort();
        let mut ans = 0;
        if arr[0] + arr[1] <= arr[2] {
            ans = arr[0] + arr[1];
        } else {
            ans = (arr[0] + arr[1] + arr[2]) / 2;
        }
        ans

=======

        let mut a = a;
        let mut b = b;
        let mut c = c;
        let mut r = 0;
        while a + b + c > 2 {
            let m = std::cmp::max(a, std::cmp::max(b, c));
            if m == a {
                a -= 1;
                b -= 1;
            } else if m == b {
                a -= 1;
                c -= 1;
            } else {
                b -= 1;
                c -= 1;
            }
            r += 1;
        }
        r

=======

        let mut v = vec![a, b, c];
        v.sort();
        let mut s = 0;
        while v[2] > 0 {
            if v[1] > 0 {
                v[1] -= 1;
                v[2] -= 1;
                s += 1;
            } else {
                v[2] -= 2;
                s += 1;
            }
            v.sort();
        }
        s
