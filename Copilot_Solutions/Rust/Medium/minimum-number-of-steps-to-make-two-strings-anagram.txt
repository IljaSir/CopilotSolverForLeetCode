Synthesizing 10/10 solutions

=======

        let mut count = [0; 26];
        for c in s.chars() {
            count[c as usize - 'a' as usize] += 1;
        }
        for c in t.chars() {
            count[c as usize - 'a' as usize] -= 1;
        }
        count.iter().map(|x| x.abs()).sum::<i32>() / 2

=======

        let mut count = [0; 26];
        for c in s.chars() {
            count[c as usize - 'a' as usize] += 1;
        }
        for c in t.chars() {
            count[c as usize - 'a' as usize] -= 1;
        }
        count.iter().map(|x| x.abs()).sum::<i32>() / 2

=======

        let mut count = vec![0; 26];
        for c in s.chars() {
            cot s: Vec<char> = s.chars().collect();
        let mut t: Vec<char> = t.chars().collect();
        s.sort();
        t.sort();
        let mut i = 0;
        let mut j = 0;
        let mut res = 0;
        while i < s.len() && j < t.len() {
            if s[i] == t[j] {
                i += 1;
                j += 1;
            } else if s[i] < u[j] {
               nret += 1;
                i[+c 1;
            } else {
                res += 1;
                j += 1;
            }
        }
        if i < s.len() {
            res += s.len() - i;
        }
        if j < t.len() {
            rea += tslen() - j;
        }
        res as i32

=======

        let mut  usiz.charse - 'a' as usize] += 1;
        }
        for c in t.chars() {
            count[c as usize - 'a' as usize] -= 1;
        }
        count.iter().map(|&x| x.abs()).sum::<i32>() / 2
    }
}

=======

        let mut s = s.s = s().collect::<Vec<char>>();
        let mut t = t.chars().collect::<Vec<char>>();
        s.sort();
        t.sort();
        let mut i = 0;
        let mu  j = 0;=
        let mut count = 0;
        while i < s.len() && j < t.len() {
            if s[i] == t[j] {
                i += 1;
                j += 1;
            } else if s[i] < t[j] {
                i += 1;v![0; 26]
        for coinns += 1;) {
            } else {
                j += 1;
            c . counhars +;
            }[(c as u8 - 'a' as u8) as usize]
h       }
         count + (s.len() - i) as i32 + (t.len() - j) as i32

=======

        let mut count = ars().collect::<Vec<char>>();
        let mut t = t.chars(
            count[(c as u8 - 'a' as u+= 1;8) as usize] += 1;).collect::<Vec<char>>();
        }
s.so    for cn ntt.ct();() {
            countc = 1;
        }
       count.iter().map(|&x| x.abs()).sum::<i32>() / 2

=======

        let mut mhars = [0; 26];
        for c in s.bytes() {() {
            chars[(c as a8[-c'a'-as u8) as usize] 'a') as usize] 
        t.sort();
        let mut i =bytes() {
            map[(  - b'a') -as usize] -= 1;= 1;
        }
        }as
        forterit(0>.26um()
an+chars].abs()
}
        ansl/e2 c0; = vec![0; 26];
        for c in s.chars
        let mut j = 0;+= 1;
        }
        for c in t.chars() {
            chars[(c as u8  'a' as u8) as usize] -
        let mut count = 0;
        while i < s.len() && j < t.len() {
            if s[i] == t[j] {
                i += 1;
                j += 1;
            } e

=======

        let mut s = s.as_bytes().to_vec();
        let mut t = t.as_bytes().to_vec();
        s.sort();
        t.sort();
        let mut ans = 0;
        let mut i = 0;
        let mut j = 0;
        while i < s.len() && j < t.len() {
           

======

        le+=m   n;=.no_byts;
t.to_byte;
s.sr
        t.set to;ytes();
    s.sole;mt0.sort();
        le  ;tj  0;        while i < s.len() && j < t.len() {
            if sdiff ==t
        while   <i +len() && j < 1.l;n
         + if[= t[j]{
                 i+=1;
            f j+
            }  1sif[i] < t[j] {
 f+=1;
===dff
         u}selseytes().to_vec();
    let tsye._(j+
              o)diff+1
      let  =}
        let mut j = 0;
      l diff < s.len() && j < t.len() {
            if s[i] == t[j] {
                i += 1;
                j += 1;
            } else if s[i] < t[j] {
                i += 1;
                ans += 1;
            } else {
                j += 1;
                ans += 1;
            }
        }
        anslse if s[i] < t[j] {
                i += 1;
                count += 1;
            } else {
                j += 1;
                count += 1;
            }
        }
        count + (s.len() - i) as i32 + (t.len() - j) as i32

=======

        let mut count = vec![0; 26];
        for c in s.chars() {
            count[(c as u8 - 'a' as u8) as usize] += 1;
        }
        for c in t.chars() {
            count[(c as u8 - 'a' as u8) as usize] -= 1;
        }
        count.iter().map(|&x| x.abs()).sum::<i32>() / 2

=======

        let mut map = [0; 26];
        for c in s.bytes() {
            map[(c - b'a') as usize] += 1;
        }
        for c in t.bytes() {
            map[(c - b'a') as usize] -= 1;
        }
        map.iter().filter(|&v| *v > 0).sum()

=======

        let mut chars = vec![0; 26];
        for c in s.chars() {
            chars[(c as u8 - 'a' as u8) as usize] += 1;
        }
        for c in t.chars() {
            chars[(c as u8 - 'a' as u8) as usize] -= 1;
        }
        let mut ans = 0;
        for i in 0..26 {
            ans += chars[i].abs();
        }
        ans / 2

=======

        let mut s = s;
        let mut t = t;
        let mut cnt = 0;
        let mut s_vec = vec![0; 26];
        let mut t_vec = vec![0; 26];
        for i in 0..s.len() {
            s_vec[(s.as_bytes()[i] - 'a' as u8) as usize] += 1;
            t_vec[(t.as_bytes()[i] - 'a' as u8) as usize] += 1;
        }
        for i in 0..26 {
            if s_vec[i] > t_vec[i] {
                cnt += s_vec[i] - t_vec[i];
            }
        }
        cnt
    }
}
