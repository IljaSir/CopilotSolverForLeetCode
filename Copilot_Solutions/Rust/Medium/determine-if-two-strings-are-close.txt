Synthesizing 10/10 solutions

=======

        let mut w1 = word1.into_bytes();
        let mut w2 = word2.into_bytes();
        w1.sort();
        w2.sort();
        if w1 != w2 {
            return false;
        }
        let mut c1 = vec![0; 26];
        let mut c2 = vec![0; 26];
        for i in 0..w1.len() {
            c1[(w1[i] - b'a') as usize] += 1;
            c2[(w2[i] - b'a') as usize] += 1;
        }
        c1.sort();
        c2.sort();
        c1 == c2

=======

        let mut c1 = vec![0; 26];
        let mut c2 = vec![0; 26];
        let mut s1 = vec![false; 26];
        let mut s2 = vec![false; 26];
        for c in word1.chars() {
            c1[c as usize - 'a' as usize] += 1;
            s1[c as usize - 'a' as usize] = true;
        }
        for c in word2.chars() {
            c2[c as usize - 'a' as usize] += 1;
            s2[c as usize - 'a' as usize] = true;
        }
        c1.sort();
        c2.sort();
        c1 == c2 && s1 == s2

=======

        let mut count1 = vec![0; 26];
        let mut count2 = vec![0; 26];
        for ch in word1.chars() {
            count1[ch as usize - 'a' as usize] += 1;
        }
        for ch in word2.chars() {
            count2[ch as usize - 'a' as usize] += 1;
        }
        for i in 0..26 {
            if (count1[i] == 0 && count2[i] > 0) || (count1[i] > 0 && count2[i] == 0) {
                return false;
            }
        }
        count1.sort();
        count2.sort();
        count1 == count2

=======

        let mut c1 = vec![0; 26];
        let mut c2 = vec![0; 26];
        for c in word1.chars() {
            c1[(c as u8 - b'a') as usize] += 1;
        }
        for c in word2.chars() {
            c2[(c as u8 - b'a') as usize] += 1;
        }
        for i in 0..26 {
            if (c1[i] == 0 && c2[i] != 0) || (c1[i] != 0 && c2[i] == 0) {
                return false;
            }
        }
        c1.sort();
        c2.sort();
        c1 == c2

=======

        let mut a = [0; 26];
        let mut b = [0; 26];
        for c in word1.chars() {
            a[c as usize - 97] += 1;
        }
        for c in word2.chars() {
            b[c as usize - 97] += 1;
        }
        a.iter().zip(b.iter()).all(|(x, y)| x == y && (x == &0 || y != &0)) && a.iter().any(|&x| x != 0) && b.iter().any(|&x| x != 0)

=======

        let mut c1 = vec![0; 26];
        let mut c2 = vec![0; 26];
        let mut s1 = vec![0; 26];
        let mut s2 = vec![0; 26];
        for c in word1.chars() {
            c1[c as usize - 'a' as usize] += 1;
            s1[c as usize - 'a' as usize] = 1;
        }
        for c in word2.chars() {
            c2[c as usize - 'a' as usize] += 1;
            s2[c as usize - 'a' as usize] = 1;
        }
        c1.sort();
        c2.sort();
        s1.sort();
        s2.sort();
        c1 == c2 && s1 == s2

=======

        let mut char_count1 = vec![0; 26];
        let mut char_count2 = vec![0; 26];
        for c in word1.chars() {
            char_count1[c as usize - 'a' as usize] += 1;
        }
        for c in word2.chars() {
            char_count2[c as usize - 'a' as usize] += 1;
        }
        let mut char_count1 = char_count1.into_iter().filter(|&x| x > 0).collect::<Vec<_>>();
        let mut char_count2 = char_count2.into_iter().filter(|&x| x > 0).collect::<Vec<_>>();
        char_count1.sort();
        char_count2.sort();
        char_count1 == char_count2

=======

        let mut cnt1 = [0; 26];
        let mut cnt2 = [0; 26];
        let mut used1 = [false; 26];
        let mut used2 = [false; 26];
        for c in word1.chars() {
            cnt1[c as usize - 'a' as usize] += 1;
            used1[c as usize - 'a' as usize] = true;
        }
        for c in word2.chars() {
            cnt2[c as usize - 'a' as usize] += 1;
            used2[c as usize - 'a' as usize] = true;
        }
        if used1 != used2 {
            return false;
        }
        cnt1.sort();
        cnt2.sort();
        cnt1 == cnt2

=======

        let mut h1 = std::collections::HashMap::new();
        let mut h2 = std::collections::HashMap::new();
        for ch in word1.chars() {
            *h1.entry(ch).or_insert(0) += 1;
        }
        for ch in word2.chars() {
            *h2.entry(ch).or_insert(0) += 1;
        }
        if h1.len() != h2.len() {
            return false;
        }
        let mut v1 = h1.values().collect::<Vec<_>>();
        let mut v2 = h2.values().collect::<Vec<_>>();
        v1.sort();
        v2.sort();
        if v1 != v2 {
            return false;
        }
        let mut v1 = h1.keys().collect::<Vec<_>>();
        let mut v2 = h2.keys().collect::<Vec<_>>();
        v1.sort();
        v2.sort();
        if v1 != v2 {
            return false;
        }
        true

=======

        let mut cnt1 = [0; 26];
        let mut cnt2 = [0; 26];
        let mut set1 = std::collections::BTreeSet::new();
        let mut set2 = std::collections::BTreeSet::new();
        for c in word1.chars() {
            cnt1[c as usize - 'a' as usize] += 1;
            set1.insert(c);
        }
        for c in word2.chars() {
            cnt2[c as usize - 'a' as usize] += 1;
            set2.insert(c);
        }
        set1 == set2 && cnt1.iter().copied().sorted().collect::<Vec<_>>() == cnt2.iter().copied().sorted().collect::<Vec<_>>()
