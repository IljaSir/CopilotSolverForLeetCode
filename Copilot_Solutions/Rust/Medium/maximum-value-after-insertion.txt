Synthesizing 10/10 solutions

=======

        let mut s = n.as_bytes().to_vec();
        let mut i = 0;
        if s[0] == b'-' {
            i = 1;
            while i < s.len() && s[i] - b'0' <= x as u8 {
                i += 1;
            }
        } else {
            while i < s.len() && s[i] - b'0' >= x as u8 {
                i += 1;
            }
        }
        s.insert(i, x as u8 + b'0');
        String::from_utf8(s).unwrap()
    }
}

=======

        let mut v = n.chars().collect::<Vec<char>>();
        let x = x as u8;
        if v[0] == '-' {
            for i in 1..v.len() {
                if v[i] > x as char {
                    v.insert(i, x as char);
                    return v.into_iter().collect();
                }
            }
        } else {
            for i in 0..v.len() {
                if v[i] < x as char {
                    v.insert(i, x as char);
                    return v.into_iter().collect();
                }
            }
        }
        v.push(x as char);
        v.into_iter().collect()

=======

        let mut res = String::new();
        let mut i = 0;
        if n.as_bytes()[0] == b'-' {
            res.push('-');
            i += 1;
            while i < n.len() && n.as_bytes()[i] <= b'0' + x as u8 {
                res.push(n.as_bytes()[i] as char);
                i += 1;
            }
        } else {
            while i < n.len() && n.as_bytes()[i] >= b'0' + x as u8 {
                res.push(n.as_bytes()[i] as char);
                i += 1;
            }
        }
        res.push(x.to_string().as_bytes()[0] as char);
        while i < n.len() {
            res.push(n.as_bytes()[i] as char);
            i += 1;
        }
        res

=======

        let mut n = n.into_bytes();
        let is_negative = n[0] == b'-';
        let mut i = if is_negative { 1 } else { 0 };
        while i < n.len() && (is_negative ^ (n[i] - b'0' as u8) < x as u8) {
            i += 1;
        }
        n.insert(i, b'0' + x as u8);
        String::from_utf8(n).unwrap()

=======

        let mut s = n.clone();
        let x = x.to_string();
        if s.starts_with('-') {
            for (i, c) in s.chars().enumerate() {
                if c > x.chars().next().unwrap() {
                    s.insert(i, x.chars().next().unwrap());
                    return s;
                }
            }
        } else {
            for (i, c) in s.chars().enumerate() {
                if c < x.chars().next().unwrap() {
                    s.insert(i, x.chars().next().unwrap());
                    return s;
                }
            }
        }
        s.push(x.chars().next().unwrap());
        s

=======

        let mut n = n.as_bytes();
        let mut i = 0;
        let mut x = x as u8;
        if n[0] == b'-' {
            while i < n.len() && n[i] == b'-' || n[i] <= x {
                i += 1;
            }
        } else {
            while i < n.len() && n[i] == b'-' || n[i] >= x {
                i += 1;
            }
        }
        let mut res = Vec::new();
        res.extend_from_slice(&n[..i]);
        res.push(x);
        res.extend_from_slice(&n[i..]);
        String::from_utf8(res).unwrap()
    }
}

=======

        let mut n = n;
        if n.starts_with('-') {
            let x = (x + '0' as i32) as u8;
            let mut i = 1;
            while i < n.len() && n.as_bytes()[i] <= x {
                i += 1;
            }
            n.insert(i, x as char);
        } else {
            let x = (x + '0' as i32) as u8;
            let mut i = 0;
            while i < n.len() && n.as_bytes()[i] >= x {
                i += 1;
            }
            n.insert(i, x as char);
        }
        n

=======

        let mut s = String::new();
        let mut flag = false;
        let mut i = 0;
        if n.chars().nth(0).unwrap() == '-' {
            s.push('-');
            i = 1;
        }
        while i < n.len() {
            if (n.chars().nth(i).unwrap() as i32 - '0' as i32) < x && !flag {
                s.push((x + '0' as i32) as u8 as char);
                flag = true;
            }
            s.push(n.chars().nth(i).unwrap());
            i += 1;
        }
        if !flag {
            s.push((x + '0' as i32) as u8 as char);
        }
        s
    }
}

=======

        let (mut i, mut sign) = (0, 1);
        let mut n = n;
        if n.starts_with('-') {
            sign = -1;
            n = n[1..].to_string();
        }
        if sign == 1 {
            while i < n.len() && n[i..i+1].parse::<i32>().unwrap() >= x {
                i += 1;
            }
        } else {
            while i < n.len() && n[i..i+1].parse::<i32>().unwrap() <= x {
                i += 1;
            }
        }
        n.insert_str(i, &x.to_string());
        if sign == -1 {
            n.insert_str(0, "-");
        }
        n

=======

        let mut x = x as u8 - '0' as u8;
        let mut chars = n.chars();
        let mut res = String::new();
        let mut neg = false;
        let mut inserted = false;
        if let Some(c) = chars.next() {
            if c == '-' {
                neg = true;
                res.push(c);
            } else {
                res.push(c);
            }
        }
        if neg {
            while let Some(c) = chars.next() {
                let c = c as u8 - '0' as u8;
                if c <= x {
                    res.push((c + '0' as u8) as char);
                } else {
                    res.push((x + '0' as u8) as char);
                    res.push((c + '0' as u8) as char);
                    inserted = true;
                    break;
                }
            }
        } else {
            while let Some(c) = chars.next() {
                let c = c as u8 - '0' as u8;
                if c >= x {
                    res.push((c + '0' as u8) as char);
                } else {
                    res.push((x + '0' as u8) as char);
                    res.push((c + '0' as u8) as char);
                    inserted = true;
                    break;
                }
            }
        }
        if !inserted {
            res.push((x + '0' as u8) as char);
        }
        res
