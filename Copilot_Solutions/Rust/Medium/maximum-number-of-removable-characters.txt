Synthesizing 10/10 solutions

=======

        let s: Vec<char> = s.chars().collect();
        let p: Vec<char> = p.chars().collect();
        let mut l = 0;
        let mut r = removable.len();
        while l < r {
            let m = (l + r + 1) >> 1;
            if Solution::is_subsequence(&s, &p, &removable[..m]) {
                l = m;
            } else {
                r = m - 1;
            }
        }
        l as i32
    }
    fn is_subsequence(s: &Vec<char>, p: &Vec<char>, removable: &[i32]) -> bool {
        let mut i = 0;
        let mut j = 0;
        let mut k = 0;
        while i < s.len() && j < p.len() {
            if k < removable.len() && removable[k] == i as i32 {
                k += 1;
                i += 1;
            } else {
                if s[i] == p[j] {
                    j += 1;
                }
                i += 1;
            }
        }
        j == p.len()

=======

        let s: Vec<char> = s.chars().collect();
        let p: Vec<char> = p.chars().collect();
        let mut left = 0;
        let mut right = removable.len();
        while left < right {
            let mid = left + (right - left) / 2;
            if Solution::is_subsequence(&s, &p, &removable[..mid]) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        left as i32 - 1
    }
    pub fn is_subsequence(s: &[char], p: &[char], removable: &[i32]) -> bool {
        let mut i = 0;
        let mut j = 0;
        let mut k = 0;
        while i < s.len() && j < p.len() {
            if k < removable.len() && i == removable[k] as usize {
                i += 1;
                k += 1;
            } else if s[i] == p[j] {
                i += 1;
                j += 1;
            } else {
                i += 1;
            }
        }
        j == p.len()

=======

        let mut l = 0;
        let mut r = removable.len();
        let s: Vec<char> = s.chars().collect();
        let p: Vec<char> = p.chars().collect();
        while l < r {
            let m = (l + r + 1) / 2;
            let mut t = s.clone();
            for i in 0..m {
                t[removable[i] as usize] = ' ';
            }
            let mut i = 0;
            let mut j = 0;
            while i < p.len() && j < t.len() {
                if p[i] == t[j] {
                    i += 1;
                }
                j += 1;
            }
            if i == p.len() {
                l = m;
            } else {
                r = m - 1;
            }
        }
        l as i32

=======

        let s: Vec<char> = s.chars().collect();
        let p: Vec<char> = p.chars().collect();
        let mut removable = removable;
        let mut l = 0;
        let mut r = removable.len();
        while l < r {
            let m = (l + r + 1) / 2;
            let mut t = s.clone();
            for i in 0..m {
                t[removable[i] as usize] = '0';
            }
            if Self::is_subsequence(&t, &p) {
                l = m;
            } else {
                r = m - 1;
            }
        }
        l as i32
    }
    fn is_subsequence(s: &Vec<char>, p: &Vec<char>) -> bool {
        let mut i = 0;
        let mut j = 0;
        while i < s.len() && j < p.len() {
            if s[i] == p[j] {
                j += 1;
            }
            i += 1;
        }
        j == p.len()

=======

        let mut left = 0;
        let mut right = removable.len();
        let mut s = s.as_bytes().to_vec();
        let p = p.as_bytes().to_vec();
        while left < right {
            let mid = (left + right + 1) / 2;
            let mut mask = vec![true; s.len()];
            for i in 0..mid {
                mask[removable[i] as usize] = false;
            }
            if Solution::check(&s, &p, &mask) {
                left = mid;
            } else {
                right = mid - 1;
            }
        }
        left as i32
    }
    fn check(s: &Vec<u8>, p: &Vec<u8>, mask: &Vec<bool>) -> bool {
        let mut i = 0;
        for j in 0..s.len() {
            if mask[j] && s[j] == p[i] {
                i += 1;
                if i == p.len() {
                    return true;
                }
            }
        }
        false

=======

        let mut l = 0;
        let mut r = removable.len();
        let mut s = s.into_bytes();
        let p = p.into_bytes();
        while l < r {
            let mid = (l + r + 1) / 2;
            for i in 0..mid {
                s[removable[i] as usize] = b'\0';
            }
            if Self::is_subsequence(&s, &p) {
                l = mid;
            } else {
                for i in 0..mid {
                    s[removable[i] as usize] = removable[i] as u8;
                }
                r = mid - 1;
            }
        }
        l as i32
    }
    fn is_subsequence(s: &[u8], p: &[u8]) -> bool {
        let mut i = 0;
        for j in 0..s.len() {
            if s[j] == p[i] {
                i += 1;
                if i == p.len() {
                    return true;
                }
            }
        }
        false

=======

        let mut s = s.as_bytes().to_vec();
        let p = p.as_bytes();
        let mut l = 0;
        let mut r = removable.len();
        while l < r {
            let m = l + (r - l) / 2;
            for i in 0..=m {
                s[removable[i] as usize] = 0;
            }
            let mut j = 0;
            for i in 0..s.len() {
                if s[i] == p[j] {
                    j += 1;
                    if j == p.len() {
                        break;
                    }
                }
            }
            if j == p.len() {
                l = m + 1;
            } else {
                r = m;
            }
            for i in 0..=m {
                s[removable[i] as usize] = p[i];
            }
        }
        l as i32

=======

        let mut lo = 0;
        let mut hi = removable.len() as i32;
        while lo < hi {
            let mid = lo + (hi - lo + 1) / 2;
            if Self::is_subsequence(&s, &p, &removable, mid) {
                lo = mid;
            } else {
                hi = mid - 1;
            }
        }
        lo
    }
    fn is_subsequence(s: &str, p: &str, removable: &[i32], k: i32) -> bool {
        let mut s = s.to_string();
        for i in 0..k {
            s.remove(removable[i as usize] as usize);
        }
        let mut j = 0;
        for c in s.chars() {
            if j < p.len() && p.chars().nth(j).unwrap() == c {
                j += 1;
            }
        }
        j == p.len()

=======

        let mut s = s.into_bytes();
        let p = p.into_bytes();
        let mut left = 0;
        let mut right = removable.len() as i32;
        while left < right {
            let mid = left + (right - left + 1) / 2;
            let mut set = std::collections::HashSet::new();
            for i in 0..mid {
                set.insert(removable[i as usize]);
            }
            if Solution::is_subsequence(&s, &p, &set) {
                left = mid;
            } else {
                right = mid - 1;
            }
        }
        left
    }
    fn is_subsequence(s: &Vec<u8>, p: &Vec<u8>, set: &std::collections::HashSet<i32>) -> bool {
        let mut i = 0;
        let mut j = 0;
        while i < s.len() && j < p.len() {
            if set.contains(&(i as i32)) {
                i += 1;
                continue;
            }
            if s[i] == p[j] {
                j += 1;
            }
            i += 1;
        }
        j == p.len()

=======

        let mut left = 0;
        let mut right = removable.len();
        let mut s = s;
        let mut p = p;
        let mut removable = removable;
        while left < right {
            let mid = left + (right - left + 1) / 2;
            for i in 0..mid {
                s.remove(removable[i] as usize);
            }
            if is_subsequence(&s, &p) {
                left = mid;
            } else {
                for i in 0..mid {
                    s.insert(removable[i] as usize, removable[i] as u8 as char);
                }
                right = mid - 1;
            }
        }
        left as i32
    }
}
