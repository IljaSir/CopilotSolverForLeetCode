Synthesizing 9/10 solutions

=======

        let mut capacity = capacity;
        let mut rocks = rocks;
        let mut additional_rocks = additional_rocks;
        capacity.sort();
        rocks.sort();
        let mut i = 0;
        let mut j = 0;
        while j < rocks.len() && additional_rocks > 0 {
            if capacity[i] > rocks[j] {
                additional_rocks -= capacity[i] - rocks[j];
                rocks[j] = capacity[i];
                i += 1;
            }
            j += 1;
        }
        while additional_rocks > 0 {
            additional_rocks -= capacity[i];
            rocks.push(capacity[i]);
            i += 1;
        }
        i as i32
    }
}

=======

        let mut left = 0;
        let mut right = 0;
        for i in 0..capacity.len() {
            left = left.max(capacity[i] - rocks[i]);
            right += capacity[i];
        }
        while left < right {
            let mid = (left + right + 1) >> 1;
            let mut sum = 0;
            for i in 0..capacity.len() {
                sum += mid.min(capacity[i]) - rocks[i];
            }
            if sum > additional_rocks {
                right = mid - 1;
            } else {
                left = mid;
            }
        }
        left

=======

        let mut capacity = capacity;
        let mut rocks = rocks;
        let mut additional_rocks = additional_rocks;
        capacity.sort();
        rocks.sort();
        let mut l = 0;
        let mut r = capacity.len() - 1;
        while l < r {
            let mid = (l + r + 1) >> 1;
            let mut sum = 0;
            for i in 0..mid {
                sum += capacity[i] - rocks[i];
            }
            if sum <= additional_rocks {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        l as i32 + 1

=======

        let mut l = 0;
        let mut r = additional_rocks;
        let mut ans = 0;
        while l <= r {
            let mid = l + (r - l) / 2;
            let mut cnt = 0;
            for i in 0..capacity.len() {
                if rocks[i] + mid > capacity[i] {
                    cnt += rocks[i] + mid - capacity[i];
                }
            }
            if cnt <= additional_rocks {
                ans = mid;
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        ans

=======

        let mut capacity = capacity;
        let mut rocks = rocks;
        let mut additional_rocks = additional_rocks;
        capacity.sort();
        rocks.sort();
        let mut l = 0;
        let mut r = rocks.len() as i32 - 1;
        let mut ans = 0;
        while l <= r {
            let mid = (l + r) / 2;
            let mut can = additional_rocks;
            let mut i = rocks.len() - 1;
            while i >= mid as usize {
                can -= capacity[i] - rocks[i];
                i -= 1;
            }
            if can >= 0 {
                ans = mid + 1;
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        ans

=======

        let mut v = capacity.iter().zip(rocks.iter()).map(|(c, r)| *c - *r).collect::<Vec<i32>>();
        v.sort();
        let mut sum = 0;
        let mut i = 0;
        while i < v.len() && sum <= additional_rocks {
            sum += v[i];
            i += 1;
        }
        i as i32
    }
}

=======

        let mut capacity = capacity;
        let mut rocks = rocks;
        let mut additional_rocks = additional_rocks;
        let n = capacity.len();
        let mut left = 0;
        let mut right = capacity.iter().max().unwrap();
        while left < right {
            let mid = (left + right + 1) / 2;
            let mut need = 0;
            for i in 0..n {
                if capacity[i] - rocks[i] < mid {
                    need += mid - (capacity[i] - rocks[i]);
                }
            }
            if need <= additional_rocks {
                left = mid;
            } else {
                right = mid - 1;
            }
        }
        left
    }
}

=======

        let mut rocks = rocks;
        let mut additional_rocks = additional_rocks;
        let mut capacity = capacity;
        let mut ans = 0;
        let mut i = 0;
        while i < capacity.len() {
            let mut j = i + 1;
            while j < capacity.len() {
                if capacity[j] - rocks[j] < capacity[i] - rocks[i] {
                    let tmp = capacity[j];
                    capacity[j] = capacity[i];
                    capacity[i] = tmp;
                    let tmp = rocks[j];
                    rocks[j] = rocks[i];
                    rocks[i] = tmp;
                }
                j += 1;
            }
            if capacity[i] - rocks[i] <= additional_rocks {
                additional_rocks -= capacity[i] - rocks[i];
                ans += 1;
            }
            i += 1;
        }
        ans

=======

        let mut cap = capacity;
        let mut rocks = rocks;
        let mut additional_rocks = additional_rocks;
        let mut i = 0;
        let mut cnt = 0;
        while i < cap.len() {
            if cap[i] - rocks[i] <= additional_rocks {
                additional_rocks -= cap[i] - rocks[i];
                rocks[i] = cap[i];
                cnt += 1;
            } else {
                i += 1;
            }
        }
        cnt
    }
}
