Synthesizing 10/10 solutions

=======
Suggestion 1

        let mut left = 0;
        let mut right = nums.len() - 1;
        let mut result = vec![-1, -1];
        while left <= right {
            let mid = left + (right - left) / 2;
            if nums[mid] == target {
                let mut l = mid;
                let mut r = mid;
                while l > 0 {
                    if nums[l] == nums[l - 1] {
                        l -= 1;
                    } else {
                        break;
                    }
                }
                while r < nums.len() - 1 {
                    if nums[r] == nums[r + 1] {
                        r += 1;
                    } else {
                        break;
                    }
                }
                result[0] = l as i32;
                result[1] = r as i32;
                break;
            } else if nums[mid] < target {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        result

=======
Suggestion 2

        let mut left = 0;
        let mut right = nums.len() - 1;
        let mut res = vec![-1, -1];
        while left <= right {
            let mid = left + (right - left) / 2;
            if nums[mid] == target {
                res[0] = mid as i32;
                res[1] = mid as i32;
                let mut l = left;
                let mut r = mid;
                while l <= r {
                    let m = l + (r - l) / 2;
                    if nums[m] == target {
                        res[0] = m as i32;
                        r = m - 1;
                    } else {
                        l = m + 1;
                    }
                }
                l = mid;
                r = right;
                while l <= r {
                    let m = l + (r - l) / 2;
                    if nums[m] == target {
                        res[1] = m as i32;
                        l = m + 1;
                    } else {
                        r = m - 1;
                    }
                }
                break;
            } else if nums[mid] > target {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        res
    }
}

=======
Suggestion 3

        let mut result = vec![-1, -1];
        let mut left = 0;
        let mut right = nums.len() - 1;
        while left <= right {
            let mid = (left + right) / 2;
            if nums[mid] == target {
                result[0] = mid as i32;
                result[1] = mid as i32;
                let mut left = mid - 1;
                let mut right = mid + 1;
                while left >= 0 {
                    if nums[left] == target {
                        result[0] = left as i32;
                    } else {
                        break;
                    }
                    left -= 1;
                }
                while right < nums.len() {
                    if nums[right] == target {
                        result[1] = right as i32;
                    } else {
                        break;
                    }
                    right += 1;
                }
                break;
            } else if nums[mid] < target {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        result
    }
}

=======
Suggestion 4

        let mut first = -1;
        let mut last = -1;
        let mut left = 0;
        let mut right = nums.len() - 1;
        while left <= right {
            let mid = (left + right) / 2;
            if nums[mid] == target {
                first = mid as i32;
                right = mid - 1;
            } else if nums[mid] > target {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        left = 0;
        right = nums.len() - 1;
        while left <= right {
            let mid = (left + right) / 2;
            if nums[mid] == target {
                last = mid as i32;
                left = mid + 1;
            } else if nums[mid] > target {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        vec![first, last]

=======
Suggestion 5

        let mut result = vec![-1, -1];
        let mut left = 0;
        let mut right = nums.len();
        while left < right {
            let mid = (left + right) / 2;
            if nums[mid] < target {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        if left == nums.len() || nums[left] != target {
            return result;
        }
        result[0] = left as i32;
        right = nums.len();
        while left < right {
            let mid = (left + right) / 2;
            if nums[mid] <= target {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        result[1] = left as i32 - 1;
        result
    }
}

=======
Suggestion 6

        let mut l = 0;
        let mut r = nums.len() as i32 - 1;
        let mut ans = vec![-1, -1];
        while l <= r {
            let mid = (l + r) / 2;
            if nums[mid as usize] == target {
                ans[0] = mid;
                r = mid - 1;
            } else if nums[mid as usize] > target {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        l = 0;
        r = nums.len() as i32 - 1;
        while l <= r {
            let mid = (l + r) / 2;
            if nums[mid as usize] == target {
                ans[1] = mid;
                l = mid + 1;
            } else if nums[mid as usize] > target {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        ans

=======
Suggestion 7

        let mut left = 0;
        let mut right = nums.len();
        let mut result = vec![-1, -1];
        while left < right {
            let mid = left + (right - left) / 2;
            if nums[mid] < target {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        if left == nums.len() || nums[left] != target {
            return result;
        }
        result[0] = left as i32;
        right = nums.len();
        while left < right {
            let mid = left + (right - left) / 2;
            if nums[mid] > target {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        result[1] = left as i32 - 1;
        result
    }
}

=======
Suggestion 8

        let mut start = 0;
        let mut end = nums.len() - 1;
        let mut result = vec![-1, -1];
        while start <= end {
            let mid = start + (end - start) / 2;
            if nums[mid] == target {
                if mid == 0 || nums[mid - 1] != target {
                    result[0] = mid as i32;
                    break;
                } else {
                    end = mid - 1;
                }
            } else if nums[mid] < target {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        if result[0] == -1 {
            return result;
        }
        start = result[0] as usize;
        end = nums.len() - 1;
        while start <= end {
            let mid = start + (end - start) / 2;
            if nums[mid] == target {
                if mid == nums.len() - 1 || nums[mid + 1] != target {
                    result[1] = mid as i32;
                    break;
                } else {
                    start = mid + 1;
                }
            } else if nums[mid] < target {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        result
    }
}

=======
Suggestion 9

        let mut result = vec![-1, -1];
        let mut left = 0;
        let mut right = nums.len() - 1;
        while left <= right {
            let middle = (left + right) / 2;
            if nums[middle] == target {
                if result[0] == -1 || middle < result[0] as usize {
                    result[0] = middle as i32;
                }
                if result[1] == -1 || middle > result[1] as usize {
                    result[1] = middle as i32;
                }
                if middle > 0 && nums[middle - 1] == target {
                    right = middle - 1;
                } else if middle + 1 < nums.len() && nums[middle + 1] == target {
                    left = middle + 1;
                } else {
                    break;
                }
            } else if nums[middle] > target {
                right = middle - 1;
            } else {
                left = middle + 1;
            }
        }
        result
    }
}

=======
Suggestion 10

        let mut begin = 0;
        let mut end = nums.len();
        let mut mid = 0;
        let mut result = vec![-1, -1];
        while begin < end {
            mid = (begin + end) / 2;
            if nums[mid] < target {
                begin = mid + 1;
            } else {
                end = mid;
            }
        }
        if begin == nums.len() || nums[begin] != target {
            return result;
        }
        result[0] = begin as i32;
        end = nums.len();
        while begin < end {
            mid = (begin + end) / 2;
            if nums[mid] > target {
                end = mid;
            } else {
                begin = mid + 1;
            }
        }
        result[1] = end as i32 - 1;
        result
    }
}
