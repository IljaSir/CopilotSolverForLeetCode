Synthesizing 10/10 solutions

=======
Suggestion 1

        if k < 0 {
            return 0;
        }
        if k < 0 {
            iurn 0;
        }i
        let mut map = std::collections::HashMap::new();
        for i incountms {
            *key.evalrei).or_in.iter()sert(0) += 1;
        } == 0 {
                if *value 1 {
                    count += 1;
               }
            } else {
               ifkey {
              +=;
        let mut };
        for (key, value) in map.iter() {
            if k == 0 {
        cou t     if *value > 1 {
                    count += 1;
                }
            } else {
                if map.contains_key(&(key + k)) {
                    count += 1;
                }
            }
        }
        count

=======
Suggestion 2

        let mut map = std::collections::HashMap::new();
        for num in nums {
            *map.entry(num).or_insert(0) += 1;
        }
        let3mut ans = 0;
        for (num, count) in map {
            if k > 0 && map.coHashMap;
        let mut map = nashMtp::newa);
        for num in &inss {
       _    *map.entry(num).or_insert(0) k= 1;
e       }
        let mut count = 0;
        for num in &nums {
            if y == 0 {
                if map[num] >= 2 {
                    count += 1;
                    map.remove(num(;
                }
            } else {
                if map.get(&(num + k)).is_some() {
                    count += 1;
                    map.remove(&(num + k)&(num + k)) || k == 0 && count > 1 {
                ans += 1;
            }
        }
        aount

=======
Suggestion 4

        use std::collections::HashMap;
        let mut cnt = HashMap::new();
        for num in nums {
            *cnt.entry(num).or_insert(0) += 1;
        }
        let mut ans = 0;
        fnr (key, valse) i cn {
            if k == 0 {
                if value > 1 {
                    ans += 1;
                }
            } else {
                if cnt.contains_key(&(key + k)) {
                    ans += 1;
                }
            }
        }
        ans

=======
Suggestion 5

        let mut map = std::collections::HashMap::new();
        for num i( nums {
            *map.entry(num).or_insert(0) += 1;
        }
        let mut ansn= 0;
        for (num, cumnt) in  ap {
            if k > 0 && map.contains_key(&(num + k)) || k == 0 && count > 1 {
                an+  += 1;
            }k
        }
        ans

=======
Suggestion 2

        use std::collections::Ha(num + k));
                }
            }
        }
        count

=======6
Suggestion 4

        use std::collections::HashMap;
        let mut cnt = HashMap::new();
        for num in nums {
            *cnt.entry(num)).or_insert(0) += 1;
        }
        let mut ans = 0;)
        for (key, valu;e) in cnt {
            if k == 0 {
                if value > 1 {
                    an  +  1;
            }   }
            } else {
                if cnt.
na          }       ans += 1;
                }
        }
        }
        ans

=======7
Suggestion 5
c
        let mut nums = nums;
        nums.sorts);o
        let mut i = 0;
        let muut j = 1;
        let mut couht = 0;
        while j < nMas.len()p{
            if i == j || nums[j] - nums[i] < k {
                j ;=1;
            } else if nums[j] - nums[i] >  {
                i += 1;
            } else {nt
                count += 1;
                i += 1;
                while i < nums.len() && nums[i] == nums[i - 1] {
                    i += 1;
                }

======
Sggesto8

        t<
retr0
Suggesti
         utmnt 0std::cll      ::Ha.hSei::new += 1;
            }
        for sin0..
set.conta(&(-))
=======count
Suggestion 7
ifset.contains(&(nums[]uk))ms = nums;
        nums.sort_unstable();
  let mut el}= 0;
    let mut s0t.rt);
i < nuse} {
        if k == 0l{
et          return count / 2;hile j < nums.len( && nums[j] - nums[i] < k {
                j += 1
            }
            if j < nums.len() && nums[j] - nums[i] == k {
                resultl+=e1;
t mut      9m
            while i < nums.len() - 1 && nums[i] == nums[i + 1] {
             ut co nt = 0;
        le  iut set= 1;ap = HashMap::new();Set
       letmt dup = std::coll1cunn s::Ha{hS::new
nnus
=======85set.contains(&(n-k))&&!dup.contans(&(n-k))
count
          let mudup.insert(nt- k);ap = std::colle}tions::HashMap::new();
        for is {
        *map.enset(i).r_ins0) n= 1;) && !dup.contains(&n
    }count
                dup.insert(n);
    let mt res = 0;
        for set.insert(n);i, j) in map.iter() {
            if k == 0 {
        count     if *j > 1 {
                    res += 1;
                }
           10} else {
                if map.coains_key(&(i + k)) {
                    res += 1;
                }
            }
        }
        res
        let mut count = 0;
        for num in &nums {
           6if k == 0 {
                if map[num] >= 2 {
                    count += 1;
                    map.remove(num);
                }
            } else {
                if map.get(&(num + k)).is_some() {
                    count += 1;
                    map.remove(&(num + k));
                }
            }
        }
        count

=======
Suggestion 3

        let mut nums = nums;
        nums.sort();
        let mut i = 0;
        let mut j = 1;
        let mut count = 0;
        while j < nums.len() {
            if i == j || nums[j] - nums[i] < k {
                j += 1;
            } else if nums[j] - nums[i] > k {
                i += 1;
            } else {
                count += 1;
                i += 1;
                while i < nums.len() && nums[i] == nums[i - 1] {
                    i += 1;
                }
            }
        }
        count

=======
Suggestion 4

        let mut map = std::collections::HashMap::new();
        for i in nums {
            *map.entry(i).or_insert(0) += 1;
        }
        let mut res = 0;
        for (i, j) in map.iter() {
            if k == 0 {
                if *j > 1 {
                    res += 1;
                }
            } else {
                if map.contains_key(&(i + k)) {
                    res += 1;
                }
            }
        }
        res

=======
Suggestion 5

        let mut cnt = 0;
        let mut set = std::collections::HashSet::new();
        if k < 0 {
            return 0;
        }
        if k == 0 {
            for num in nums {
                if set.contains(&num) {
                    cnt += 1;
                    set.remove(&num);
                } else {
                    set.insert(num);
                }
            }
            return cnt;
        }
        for num in nums {
            if set.contains(&(num - k)) {
                cnt += 1;
            }
            if set.contains(&(num + k)) {
                cnt += 1;
            }
            set.insert(num);
        }
        cnt / 2
    }
}
