Synthesizing 10/10 solutions (Duplicates hidden)

=======
Suggestion 1

        let mut sorted = nums.clone();
        sorted.sort();
        let mut start = 0;
        let mut end = 0;
        for i in 0..nums.len() {
            if nums[i] != sorted[i] {
                start = i;
                break;
            }
        }
        for i in (0..nums.len()).rev() {
            if nums[i] != sorted[i] {
                end = i;
                break;
            }
        }
        if start == end {
            0
        } else {
            (end - start + 1) as i32
        }

=======
Suggestion 2

        let mut sorted = nums.clone();
        sorted.sort();
        let mut start = 0;
        let mut end = 0;
        for i in 0..nums.len() {
            if nums[i] != sorted[i] {
                start = i;
                break;
            }
        }
        for i in (0..nums.len()).rev() {
            if nums[i] != sorted[i] {
                end = i;
                break;
            }
        }
        if start == end {
            return 0;
        }
        (end - start + 1) as i32

=======
Suggestion 3

        let mut sorted = nums.clone();
        sorted.sort();
        let mut i = 0;
        let mut j = nums.len() - 1;
        while i < nums.len() && nums[i] == sorted[i] {
            i += 1;
        }
        while j > i && nums[j] == sorted[j] {
            j -= 1;
        }
        (j - i + 1) as i32

=======
Suggestion 4

        let mut sorted_nums = nums.clone();
        sorted_nums.sort();
        let mut start = -1;
        let mut end = -1;
        for i in 0..nums.len() {
            if nums[i] != sorted_nums[i] {
                start = i as i32;
                break;
            }
        }
        if start == -1 {
            return 0;
        }
        for i in (0..nums.len()).rev() {
            if nums[i] != sorted_nums[i] {
                end = i as i32;
                break;
            }
        }
        end - start + 1

=======
Suggestion 5

        let mut nums = nums;
        let mut sorted = nums.clone();
        sorted.sort();
        let mut start = -1;
        let mut end = -1;
        for i in 0..nums.len() {
            if nums[i] != sorted[i] {
                if start == -1 {
                    start = i as i32;
                }
                end = i as i32;
            }
        }
        if start == -1 {
            0
        } else {
            end - start + 1
        }

=======
Suggestion 6

        if nums.len() == 1 {
            return 0;
        }
        let mut min = std::i32::MAX;
        let mut max = std::i32::MIN;
        let mut start = 0;
        let mut end = 0;
        for i in 0..nums.len() {
            if nums[i] < max {
                end = i;
            } else {
                max = nums[i];
            }
            if nums[nums.len() - i - 1] > min {
                start = nums.len() - i - 1;
            } else {
                min = nums[nums.len() - i - 1];
            }
        }
        if end == 0 {
            0
        } else {
            (end - start + 1) as i32
        }

=======
Suggestion 7

        let mut nums = nums;
        let mut snums = nums.clone();
        snums.sort();
        let mut i = 0;
        while i < nums.len() {
            if nums[i] != snums[i] {
                break;
            }
            i += 1;
        }
        if i == nums.len() {
            return 0;
        }
        let mut j = nums.len() - 1;
        while j >= i {
            if nums[j] != snums[j] {
                break;
            }
            j -= 1;
        }
        (j - i + 1) as i32

=======
Suggestion 8

        let mut nums = nums;
        let mut sorted = nums.clone();
        sorted.sort();
        let mut start = 0;
        let mut end = nums.len();
        while start < nums.len() && nums[start] == sorted[start] {
            start += 1;
        }
        while end > 0 && nums[end - 1] == sorted[end - 1] {
            end -= 1;
        }
        if start >= end {
            return 0;
        }
        (end - start) as i32

=======
Suggestion 9

        let mut nums = nums;
        let mut left = nums.len();
        let mut right = 0;
        let mut stack = vec![];
        for i in 0..nums.len() {
            while let Some(&j) = stack.last() {
                if nums[j] > nums[i] {
                    left = left.min(j);
                    right = right.max(i);
                } else {
                    break;
                }
                stack.pop();
            }
            stack.push(i);
        }
        if right >= left {
            (right - left + 1) as i32
        } else {
            0
        }
