Synthesizing 10/10 solutions

=======

        let mut res = 0;
        let mut map = vec![vec![]; 26];
        for (i, c) in s.chars().enumerate() {
            map[(c as u8 - b'a') as usize].push(i);
        }
        for word in words {
            let mut prev = -1;
            let mut found = true;
            for c in word.chars() {
                let idx = (c as u8 - b'a') as usize;
                if let Ok(i) = map[idx].binary_search(&(prev + 1)) {
                    prev = map[idx][i];
                } else {
                    found = false;
                    break;
                }
            }
            if found {
                res += 1;
            }
        }
        res

=======

        let mut res = 0;
        let mut idx = vec![vec![]; 26];
        for (i, c) in s.chars().enumerate() {
            idx[(c as u8 - 'a' as u8) as usize].push(i);
        }
        'outer: for word in words {
            let mut prev = -1;
            for c in word.chars() {
                let c = c as u8 - 'a' as u8;
                match idx[c as usize].binary_search(&prev + 1) {
                    Ok(i) => prev = idx[c as usize][i],
                    Err(i) => {
                        if i == idx[c as usize].len() {
                            continue 'outer;
                        }
                        prev = idx[c as usize][i];
                    }
                }
            }
            res += 1;
        }
        res
    }
}

=======

        let mut ans = 0;
        let mut map = [Vec::new(); 26];
        for (i, c) in s.chars().enumerate() {
            map[c as usize - 'a' as usize].push(i);
        }
        'outer: for word in words {
            let mut last = -1;
            for c in word.chars() {
                let mut found = false;
                for &i in &map[c as usize - 'a' as usize] {
                    if i > last {
                        last = i;
                        found = true;
                        break;
                    }
                }
                if !found {
                    continue 'outer;
                }
            }
            ans += 1;
        }
        ans

=======

        let mut result = 0;
        let mut s = s.chars().collect::<Vec<char>>();
        for word in words {
            let mut word = word.chars().collect::<Vec<char>>();
            let mut i = 0;
            let mut j = 0;
            while i < s.len() && j < word.len() {
                if s[i] == word[j] {
                    i += 1;
                    j += 1;
                } else {
                    i += 1;
                }
            }
            if j == word.len() {
                result += 1;
            }
        }
        result

=======

        let mut res = 0;
        let mut arr = vec![vec![]; 26];
        for word in words {
            arr[word.as_bytes()[0] as usize - 97].push(word);
        }
        for c in s.chars() {
            let mut i = 0;
            while i < arr[c as usize - 97].len() {
                let mut word = arr[c as usize - 97][i].clone();
                if word.len() == 1 {
                    res += 1;
                    arr[c as usize - 97].swap_remove(i);
                } else {
                    arr[c as usize - 97][i].remove(0);
                    arr[word.as_bytes()[0] as usize - 97].push(word);
                    i += 1;
                }
            }
        }
        res
    }
}

=======

        let mut count = 0;
        for word in words {
            let mut i = 0;
            let mut j = 0;
            let mut s = s.clone();
            while i < word.len() && j < s.len() {
                if word.chars().nth(i).unwrap() == s.chars().nth(j).unwrap() {
                    i += 1;
                }
                j += 1;
            }
            if i == word.len() {
                count += 1;
            }
        }
        count

=======

        let mut ans = 0;
        let mut words: Vec<Vec<char>> = words.into_iter().map(|word| word.chars().collect()).collect();
        let mut pos: Vec<Vec<usize>> = vec![vec![]; 26];
        for (i, ch) in s.chars().enumerate() {
            pos[ch as usize - 'a' as usize].push(i);
        }
        for word in words {
            let mut cur = 0;
            let mut ok = true;
            for ch in word {
                let index = ch as usize - 'a' as usize;
                let next = pos[index].binary_search(&cur);
                if let Ok(i) = next {
                    cur = pos[index][i] + 1;
                } else if let Err(i) = next {
                    if i == pos[index].len() {
                        ok = false;
                        break;
                    }
                    cur = pos[index][i] + 1;
                }
            }
            if ok {
                ans += 1;
            }
        }
        ans
    }
}

=======

        let mut words = words.into_iter().map(|word| word.into_bytes().into_iter().collect::<VecDeque<_>>()).collect::<Vec<_>>();
        let mut count = 0;
        for c in s.bytes() {
            for word in &mut words {
                if word.len() > 0 && word[0] == c {
                    word.pop_front();
                    if word.len() == 0 {
                        count += 1;
                    }
                }
            }
        }
        count

=======

        let mut res: i32 = 0;
        for w in words {
            let mut s = s.clone();
            let mut w = w;
            let mut i = 0;
            while i < w.len() {
                let c = w.chars().nth(i).unwrap();
                let mut found = false;
                while let Some(j) = s.find(c) {
                    found = true;
                    s = s[j+1..].to_string();
                    break;
                }
                if !found {
                    break;
                }
                i += 1;
            }
            if i == w.len() {
                res += 1;
            }
        }
        res

=======

        let mut ans = 0;
        let mut map = std::collections::HashMap::new();
        for w in words {
            let mut p = 0;
            if let Some(v) = map.get(&w) {
                if *v {
                    ans += 1;
                }
                continue;
            }
            for c in s.chars() {
                if p == w.len() {
                    break;
                }
                if c == w.chars().nth(p).unwrap() {
                    p += 1;
                }
            }
            if p == w.len() {
                ans += 1;
                map.insert(w, true);
            } else {
                map.insert(w, false);
            }
        }
        ans
    }
}
