Synthesizing 7/10 solutions (Duplicates hidden)

=======

        
    }
}

=======

        let n = encoded_text.len();
        let cols = n / rows as usize;
        let mut res = vec![vec![' '; cols]; rows as usize];
        let mut i = 0;
        let mut j = 0;
        let mut k = 0;
        while i < n {
            // first row
            while j < cols && i < n {
                res[k][j] = encoded_text.chars().nth(i).unwrap();
                i += 1;
                j += 1;
            }
            k += 1;
            j -= 1;
            // last row
            while k < rows as usize - 1 && i < n {
                res[k][j] = encoded_text.chars().nth(i).unwrap();
                i += 1;
                k += 1;
                j -= 1;
            }
            k += 1;
            j += 1;
        }
        let mut ret = String::new();
        for i in 0..rows as usize {
            for j in 0..cols {
                if res[i][j] != ' ' {
                    ret.push(res[i][j]);
                }
            }
        }
        ret

=======

        if rows == 1 {
            return encoded_text;
        }
        let mut encoded_text = encoded_text;
        let mut result = String::new();
        let mut index = 0;
        let mut step = 2 * rows - 2;
        while index < encoded_text.len() {
            result.push(encoded_text[index..index+1].parse().unwrap());
            index += step as usize;
        }
        for i in 1..rows-1 {
            index = i as usize;
            step = 2 * (rows - i - 1);
            while index < encoded_text.len() {
                result.push(encoded_text[index..index+1].parse().unwrap());
                index += step as usize;
                step = 2 * rows - 2 - step;
            }
        }
        index = rows as usize - 1;
        step = 2 * rows - 2;
        while index < encoded_text.len() {
            result.push(encoded_text[index..index+1].parse().unwrap());
            index += step as usize;
        }
        result

=======

        if rows == 1 {
            return encoded_text;
        }
        let mut result = String::new();
        let mut index = 0;
        let mut step = 1;
        let mut n = 0;
        let mut chars = encoded_text.chars();
        let mut char = chars.next();
        while char.is_some() {
            result.push(char.unwrap());
            n += 1;
            if n == rows {
                step = -1;
            } else if n == 1 {
                step = 1;
            }
            n += step;
            index += 2 * (rows - 1);
            char = chars.nth(index as usize);
        }
        result

=======

        let mut decoded = String::new();
        let mut encoded = encoded_text.chars().collect::<Vec<_>>();
        let mut index = 0;
        let mut step = 1;
        for _ in 0..rows {
            while index < encoded.len() {
                decoded.push(encoded[index]);
                index += step;
            }
            index = step / 2;
            step += 2;
        }
        decoded
