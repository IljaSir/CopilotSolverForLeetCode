Synthesizing 10/10 solutions

=======
Suggestion 1

        let mut set = std::collections::HashSet::new();
        for num in nums {
            set.insert(num);
        }
        let mut max = 0;
        for num in set {
            if !set.contains(&(num - 1)) {
                let mut cur = num;
                let mut count = 1;
                while set.contains(&(cur + 1)) {
                    cur += 1;
                    count += 1;
                }
                max = max.max(count);
            }
        }
        max

=======
Suggestion 2

        let mut set = std::collections::HashSet::new();
        for num in nums {
            set.insert(num);
        }
        let mut max = 0;
        for num in set {
            if !set.contains(&(num - 1)) {
                let mut cur = num + 1;
                while set.contains(&cur) {
                    cur += 1;
                }
                max = max.max(cur - num);
            }
        }
        max

=======
Suggestion 3

        let mut nums = nums;
        nums.sort();
        let mut max = 0;
        let mut count = 1;
        for i in 1..nums.len() {
            if nums[i] == nums[i - 1] {
                continue;
            } else if nums[i] == nums[i - 1] + 1 {
                count += 1;
            } else {
                max = max.max(count);
                count = 1;
            }
        }
        max.max(count)

=======
Suggestion 4

        let mut set = std::collections::HashSet::new();
        for n in nums {
            set.insert(n);
        }
        let mut max = 0;
        for n in &set {
            if !set.contains(&(n - 1)) {
                let mut curr = n + 1;
                while set.contains(&curr) {
                    curr += 1;
                }
                max = max.max(curr - n);
            }
        }
        max

=======
Suggestion 5

        let mut nums = nums;
        nums.sort();
        let mut max = 0;
        let mut count = 1;
        for i in 1..nums.len() {
            if nums[i] == nums[i-1] {
                continue;
            }
            if nums[i] == nums[i-1] + 1 {
                count += 1;
            } else {
                max = std::cmp::max(max, count);
                count = 1;
            }
        }
        max = std::cmp::max(max, count);
        max

=======
Suggestion 6

        let mut nums = nums;
        nums.sort();
        let mut max = 0;
        let mut count = 1;
        for i in 1..nums.len() {
            if nums[i] == nums[i-1] {
                continue;
            }
            if nums[i] == nums[i-1] + 1 {
                count += 1;
            } else {
                max = max.max(count);
                count = 1;
            }
        }
        max.max(count)

=======
Suggestion 7

        let mut nums = nums;
        nums.sort();
        let mut max = 0;
        let mut cur = 1;
        for i in 1..nums.len() {
            if nums[i] == nums[i - 1] {
                continue;
            }
            if nums[i] == nums[i - 1] + 1 {
                cur += 1;
            } else {
                max = max.max(cur);
                cur = 1;
            }
        }
        max.max(cur)

=======
Suggestion 8

        let mut set = std::collections::HashSet::new();
        for &num in nums.iter() {
            set.insert(num);
        }
        let mut max_len = 0;
        for &num in set.iter() {
            if !set.contains(&(num - 1)) {
                let mut cur_len = 1;
                let mut cur_num = num + 1;
                while set.contains(&cur_num) {
                    cur_num += 1;
                    cur_len += 1;
                }
                max_len = std::cmp::max(max_len, cur_len);
            }
        }
        max_len
    }
}

=======
Suggestion 9

        let mut max_len = 0;
        let mut num_set: std::collections::HashSet<i32> = std::collections::HashSet::new();
        for num in nums {
            num_set.insert(num);
        }
        for num in nums {
            if !num_set.contains(&(num - 1)) {
                let mut cur_num = num;
                let mut cur_len = 1;
                while num_set.contains(&(cur_num + 1)) {
                    cur_len += 1;
                    cur_num += 1;
                }
                max_len = max_len.max(cur_len);
            }
        }
        max_len

=======
Suggestion 10

        let mut nums = nums;
        nums.sort_unstable();
        let mut max = 0;
        let mut count = 0;
        for i in 0..nums.len() {
            if i > 0 && nums[i] == nums[i - 1] + 1 {
                count += 1;
            } else if i > 0 && nums[i] == nums[i - 1] {
                continue;
            } else {
                count = 1;
            }
            max = max.max(count);
        }
        max
