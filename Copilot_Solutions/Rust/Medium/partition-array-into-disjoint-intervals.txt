Synthesizing 8/10 solutions

=======

        let mut maxs = vec![0; nums.len()];
        let mut mins = vec![0; nums.len()];
        let mut max = nums[0];
        let mut min = nums[nums.len() - 1];
        for i in 0..nums.len() {
            max = max.max(nums[i]);
            maxs[i] = max;
        }
        for i in (0..nums.len()).rev() {
            min = min.min(nums[i]);
            mins[i] = min;
        }
        for i in 0..nums.len() - 1 {
            if maxs[i] <= mins[i + 1] {
                return (i + 1) as i32;
            }
        }
        0

=======

        let mut max_left = nums[0];
        let mut max = nums[0];
        let mut ans = 0;
        for i in 1..nums.len() {
            max = max.max(nums[i]);
            if nums[i] < max_left {
                max_left = max;
                ans = i;
            }
        }
        ans as i32 + 1

=======

        let mut max_left = nums[0];
        let mut max = nums[0];
        let mut ans = 1;
        for i in 1..nums.len() {
            max = max.max(nums[i]);
            if nums[i] < max_left {
                max_left = max;
                ans = i + 1;
            }
        }
        ans as i32
    }
}

=======

        let mut max = nums[0];
        let mut left_max = nums[0];
        let mut res = 0;
        for i in 1..nums.len() {
            if nums[i] < left_max {
                res = i;
                left_max = max;
            } else {
                max = max.max(nums[i]);
            }
        }
        res as i32 + 1
    }
}

=======

        let mut max = nums[0];
        let mut max_left = nums[0];
        let mut ans = 0;
        for i in 1..nums.len() {
            max = max.max(nums[i]);
            if nums[i] < max_left {
                max_left = max;
                ans = i as i32;
            }
        }
        ans + 1

=======

        let mut left_max = nums[0];
        let mut right_min = nums[0];
        let mut right_min_index = 0;
        let mut i = 1;
        while i < nums.len() {
            if nums[i] < right_min {
                right_min = nums[i];
                right_min_index = i;
            }
            if nums[i] > left_max {
                left_max = nums[i];
            }
            if nums[i] < left_max && i > right_min_index {
                left_max = right_min;
                right_min_index = i;
            }
            i += 1;
        }
        (right_min_index + 1) as i32
    }
}

=======

        let mut max = nums[0];
        let mut max_left = nums[0];
        let mut ans = 0;
        for (i, &n) in nums.iter().enumerate() {
            max = max.max(n);
            if n < max_left {
                max_left = max;
                ans = i;
            }
        }
        ans as i32 + 1
    }
}

=======

        let (mut min, mut max) = (nums[0], nums[0]);
        let (mut p, mut q) = (0, 0);
        for (i, &x) in nums.iter().enumerate() {
            if x < min {
                min = x;
                p = i;
            }
            if x > max {
                max = x;
                q = i;
            }
        }
        if p > q {
            return (q + 1) as i32;
        }
        (p + 1) as i32
