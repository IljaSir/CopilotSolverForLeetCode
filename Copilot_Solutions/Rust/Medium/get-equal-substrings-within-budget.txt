Synthesizing 10/10 solutions

=======

        let s: Vec<i32> = s.chars().map(|c| c as i32).collect();
        let t: Vec<i32> = t.chars().map(|c| c as i32).collect();
        let mut cost = 0;
        let mut ans = 0;
        let mut begin = 0;
        for i in 0..s.len() {
            cost += (s[i] - t[i]).abs();
            while cost > max_cost {
                cost -= (s[begin] - t[begin]).abs();
                begin += 1;
            }
            ans = ans.max(i - begin + 1);
        }
        ans as i32

=======

        let s = s.as_bytes();
        let t = t.as_bytes();
        let n = s.len();
        let mut cost = 0;
        let mut ans = 0;
        let mut l = 0;
        for r in 0..n {
            cost += (s[r] as i32 - t[r] as i32).abs();
            while cost > max_cost {
                cost -= (s[l] as i32 - t[l] as i32).abs();
                l += 1;
            }
            ans = ans.max(r - l + 1);
        }
        ans as i32

=======

        let s: Vec<char> = s.chars().collect();
        let t: Vec<char> = t.chars().collect();
        let mut cost: Vec<i32> = s.iter().zip(t.iter()).map(|(a, b)| (a as u8 - b as u8) as i32).collect();
        let mut cost_sum: i32 = 0;
        let mut max_len: i32 = 0;
        let mut start: i32 = 0;
        for (i, c) in cost.iter().enumerate() {
            cost_sum += c;
            if cost_sum <= max_cost {
                max_len = i as i32 + 1;
            } else {
                cost_sum -= cost[start as usize];
                start += 1;
            }
        }
        max_len

=======

        let s = s.as_bytes();
        let t = t.as_bytes();
        let mut max_len = 0;
        let mut cost = 0;
        let mut start = 0;
        for end in 0..s.len() {
            cost += (s[end] as i32 - t[end] as i32).abs();
            while cost > max_cost {
                cost -= (s[start] as i32 - t[start] as i32).abs();
                start += 1;
            }
            max_len = max_len.max(end - start + 1);
        }
        max_len as i32

=======

        let mut max_len = 0;
        let mut cost = 0;
        let mut start = 0;
        let mut end = 0;
        let s: Vec<char> = s.chars().collect();
        let t: Vec<char> = t.chars().collect();
        while end < s.len() {
            cost += (s[end] as i32 - t[end] as i32).abs();
            while cost > max_cost {
                cost -= (s[start] as i32 - t[start] as i32).abs();
                start += 1;
            }
            max_len = max_len.max(end - start + 1);
            end += 1;
        }
        max_len as i32
    }
}

=======

        let s = s.as_bytes();
        let t = t.as_bytes();
        let mut sum = 0;
        let mut l = 0;
        let mut r = 0;
        let mut max_len = 0;
        while r < s.len() {
            sum += (s[r] as i32 - t[r] as i32).abs();
            while sum > max_cost {
                sum -= (s[l] as i32 - t[l] as i32).abs();
                l += 1;
            }
            max_len = max_len.max(r - l + 1);
            r += 1;
        }
        max_len as i32

=======

        let mut cost = 0;
        let mut l = 0;
        let mut r = 0;
        let mut max_len = 0;
        let s = s.into_bytes();
        let t = t.into_bytes();
        while r < s.len() {
            cost += (s[r] as i32 - t[r] as i32).abs();
            while cost > max_cost {
                cost -= (s[l] as i32 - t[l] as i32).abs();
                l += 1;
            }
            max_len = max_len.max(r - l + 1);
            r += 1;
        }
        max_len as i32

=======

        let mut cost = 0;
        let mut max = 0;
        let mut i = 0;
        let mut j = 0;
        let mut n = s.len();
        while j < n {
            cost += (s.as_bytes()[j] as i32 - t.as_bytes()[j] as i32).abs();
            while cost > max_cost {
                cost -= (s.as_bytes()[i] as i32 - t.as_bytes()[i] as i32).abs();
                i += 1;
            }
            max = max.max(j - i + 1);
            j += 1;
        }
        max as i32

=======

        let mut cost = 0;
        let mut ans = 0;
        let mut left = 0;
        let mut right = 0;
        let mut cost_vec = vec![];
        for (a, b) in s.chars().zip(t.chars()) {
            let c = (a as u32 - b as u32).abs();
            cost_vec.push(c);
        }
        while right < cost_vec.len() {
            cost += cost_vec[right];
            while cost > max_cost {
                cost -= cost_vec[left];
                left += 1;
            }
            ans = ans.max(right - left + 1);
            right += 1;
        }
        ans as i32

=======

        let mut sum = 0;
        let mut l = 0;
        let mut r = 0;
        let mut res = 0;
        let mut arr = vec![0; s.len()];
        for (i, (a, b)) in s.chars().zip(t.chars()).enumerate() {
            arr[i] = (a as i32 - b as i32).abs();
        }
        while r < s.len() {
            sum += arr[r];
            while sum > max_cost {
                sum -= arr[l];
                l += 1;
            }
            res = res.max(r - l + 1);
            r += 1;
        }
        res as i32
