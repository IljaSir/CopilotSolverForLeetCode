Synthesizing 10/10 solutions

=======
Suggestion 1

        let mut start = 0;
        let mut end = 0;
        let mut max_count = 0;
        let mut counts = vec![0; 26];
        let s = s.as_bytes();
        while end < s.len() {
            counts[(s[end] - b'A') as usize] += 1;
            max_count = max_count.max(counts[(s[end] - b'A') as usize]);
            if end - start + 1 > max_count + k as usize {
                counts[(s[start] - b'A') as usize] -= 1;
                start += 1;
            }
            end += 1;
        }
        (end - start) as i32

=======
Suggestion 2

        let s = s.as_bytes();
        let mut max_cnt = 0;
        let mut max_len = 0;
        let mut l = 0;
        let mut r = 0;
        let mut cnt = vec![0; 26];
        while r < s.len() {
            let idx = (s[r] - b'A') as usize;
            cnt[idx] += 1;
            max_cnt = max_cnt.max(cnt[idx]);
            while r - l + 1 - max_cnt > k as usize {
                cnt[(s[l] - b'A') as usize] -= 1;
                l += 1;
            }
            max_len = max_len.max(r - l + 1);
            r += 1;
        }
        max_len as i32

=======
Suggestion 3

        let mut max_count = 0;
        let mut max_len = 0;
        let mut left = 0;
        let mut right = 0;
        let mut count = vec![0; 26];
        for c in s.chars() {
            let idx = (c as u8 - b'A') as usize;
            count[idx] += 1;
            max_count = max_count.max(count[idx]);
            right += 1;
            if right - left > max_count + k {
                count[(s.chars().nth(left).unwrap() as u8 - b'A') as usize] -= 1;
                left += 1;
            }
            max_len = max_len.max(right - left);
        }
        max_len as i32

=======
Suggestion 4

        let mut ans = 0;
        let mut cnt = vec![0; 26];
        let mut maxn = 0;
        let mut left = 0;
        let mut right = 0;
        let s = s.as_bytes();
        while right < s.len() {
            cnt[(s[right] - b'A') as usize] += 1;
            maxn = maxn.max(cnt[(s[right] - b'A') as usize]);
            if right - left + 1 - maxn > k {
                cnt[(s[left] - b'A') as usize] -= 1;
                left += 1;
            }
            ans = ans.max(right - left + 1);
            right += 1;
        }
        ans as i32

=======
Suggestion 5

        let mut count = vec![0; 26];
        let mut max_count = 0;
        let mut start = 0;
        let mut max_len = 0;
        let s: Vec<char> = s.chars().collect();
        for (end, c) in s.iter().enumerate() {
            let c = c as u8 - 'A' as u8;
            count[c as usize] += 1;
            max_count = max_count.max(count[c as usize]);
            while end - start + 1 - max_count > k {
                count[s[start] as u8 - 'A' as u8] -= 1;
                start += 1;
            }
            max_len = max_len.max(end - start + 1);
        }
        max_len as i32
    }
}

=======
Suggestion 6

        let mut max_cnt = 0;
        let mut start = 0;
        let mut cnt = vec![0; 26];
        let mut res = 0;
        let s: Vec<char> = s.chars().collect();
        for end in 0..s.len() {
            max_cnt = max_cnt.max(++cnt[s[end] as usize - 65]);
            while end - start + 1 - max_cnt > k as usize {
                cnt[s[start] as usize - 65] -= 1;
                start += 1;
            }
            res = res.max(end - start + 1);
        }
        res as i32
    }
}

=======
Suggestion 7

        let mut count = [0; 26];
        let mut max = 0;
        let mut left = 0;
        let mut right = 0;
        let k = k as usize;
        let s: Vec<char> = s.chars().collect();
        while right < s.len() {
            count[(s[right] as u8 - b'A') as usize] += 1;
            max = max.max(count[(s[right] as u8 - b'A') as usize]);
            if right - left + 1 - max > k {
                count[(s[left] as u8 - b'A') as usize] -= 1;
                left += 1;
            }
            right += 1;
        }
        (right - left) as i32

=======
Suggestion 8

        let s = s.into_bytes();
        let mut cnt = vec![0; 26];
        let mut max = 0;
        let mut res = 0;
        for (i, j) in (0..s.len()).zip(0..s.len()) {
            cnt[(s[i] - b'A') as usize] += 1;
            max = max.max(cnt[(s[i] - b'A') as usize]);
            if i - j + 1 - max > k {
                cnt[(s[j] - b'A') as usize] -= 1;
                j += 1;
            }
            res = res.max(i - j + 1);
        }
        res as i32

=======
Suggestion 9

        let mut count = [0; 26];
        let s: Vec<char> = s.chars().collect();
        let mut max = 1;
        let mut left = 0;
        let mut right = 0;
        while right < s.len() {
            count[(s[right] as u8 - b'A') as usize] += 1;
            right += 1;
            while right - left - count.iter().max().unwrap() > k {
                count[(s[left] as u8 - b'A') as usize] -= 1;
                left += 1;
            }
            max = max.max(right - left);
        }
        max as i32
    }
}

=======
Suggestion 10

        let mut a = s.as_bytes();
        let mut b = vec![0; 26];
        let mut i = 0;
        let mut j = 0;
        let mut max_cnt = 0;
        while j < a.len() {
            b[(a[j] - b'A') as usize] += 1;
            max_cnt = max_cnt.max(b[(a[j] - b'A') as usize]);
            if j - i + 1 - max_cnt > k as usize {
                b[(a[i] - b'A') as usize] -= 1;
                i += 1;
            }
            j += 1;
        }
        j - i as usize as i32
