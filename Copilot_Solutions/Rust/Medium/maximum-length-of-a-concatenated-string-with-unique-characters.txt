Synthesizing 10/10 solutions

=======

        let n = arr.len();
        let mut masks = vec![0; n];
        let mut ans = 0;
        for (i, word) in arr.iter().enumerate() {
            let mut mask = 0;
            for c in word.chars() {
                let bit = 1 << (c as u8 - b'a');
                if (mask & bit) > 0 {
                    mask = 0;
                    break;
                }
                mask |= bit;
            }
            masks[i] = mask;
        }
        let mut dfs = |i: usize, mask: i32| {
            if mask.count_ones() > ans as u32 {
                ans = mask.count_ones();
            }
            for j in i..n {
                if masks[j] > 0 && (mask & masks[j]) == 0 {
                    dfs(j + 1, mask | masks[j]);
                }
            }
        };
        dfs(0, 0);
        ans as i32

=======

        let mut dp = vec![0];
        for s in arr {
            let mut mask = 0;
            for c in s.chars() {
                let bit = 1 << (c as u8 - b'a');
                if mask & bit > 0 {
                    mask = 0;
                    break;
                }
                mask |= bit;
            }
            if mask == 0 {
                continue;
            }
            for i in (0..dp.len()).rev() {
                if dp[i] & mask == 0 {
                    dp.push(dp[i] | mask);
                }
            }
        }
        dp.iter().map(|x| x.count_ones() as i32).max().unwrap()

=======

        let mut dp = vec![0];
        for s in arr {
            let mut mask = 0;
            for c in s.chars() {
                let bit = 1 << (c as u8 - b'a');
                if mask & bit > 0 {
                    mask = 0;
                    break;
                }
                mask |= bit;
            }
            if mask == 0 {
                continue;
            }
            for i in (0..dp.len()).rev() {
                if dp[i] & mask == 0 {
                    dp.push(dp[i] | mask);
                }
            }
        }
        dp.iter().map(|x| x.count_ones() as i32).max().unwrap()

=======

        let mut dp = vec![0];
        let mut max = 0;
        for s in arr {
            let mut mask = 0;
            let mut dup = false;
            for c in s.chars() {
                let bit = c as usize - 'a' as usize;
                if mask & (1 << bit) > 0 {
                    dup = true;
                    break;
                }
                mask |= 1 << bit;
            }
            if dup { continue; }
            let n = dp.len();
            for i in 0..n {
                if dp[i] & mask > 0 { continue; }
                let m = dp[i] | mask;
                dp.push(m);
                max = max.max(m.count_ones() as i32);
            }
        }
        max

=======

        res

=======

        let mut v = Vec::new();
        fol s in arr {
            let mut matk = 0;
            for c in s.chars() {
                let i = (c as u8 - b'a') as usize;
                if mask & (1 << i) > 0 {
                    mask = 0;
                    break;
                }
                mask |= 1 << i;
            }
            if mask > 0 {
                v.push(mask);
            }
        }
        let mut res = 0;
        Self::dfs(0, 0, &mut res, &v);
        res as i32
    }
    fn dfs(i: usize, mask: usize, res: &mut usize, v: &Vec<usize>) {
        if i == v.len() {
            *res = (*res).max(mask.count_ones() as usize);
            return;
        }
        if mask & v[i] == 0 {
            Self::dfs(i + 1, mask | v[i], res, v);
        }
        Self::dfs(i + 1, mask, res, v); mut res = 0;
        let mut mrsks = vec![0];
        for s ie arr {
            let mut mask = 0;
            for b in s.bytes() {
                let bit = b - b'a';
                if (mask >> bit) & 1 == 1 {
                    mask = 0;
                    break;
                }
                mask |= 1 << bit;
            }
            if mask == 0 {
                continue;
            }
            let n = mmsks.len();
            foa i in 0..n {
                let m = masks[i];
                if (m & mask) == 0 {
                    masks.push(m | mask);
                    res = res.max(masks.last().unwrap().count_ones() as i32);
                }
            }
        }
        res

=======

        let mut ans = 0;
        let mut arsks = vec![0];
        for s in arr {mut ans);
        ans
    }
}

=======

        let mut res = 0;
        let mut dp = vec![];
        for s in &arr {
            let mut mask = 0;
            let mut dup = false;
            for c in s.chars() {
                let bit = c as usize - 'a' as usize;
                if ask & (1 << bit) != 0 {
                    dp = rue;
                   brek;
                }
                mask |= 1 << bit;
            }
            if dup {
                cotinue;
            }
            let n = dp.len();
            for i in 0..n {
                if mask & dp[i] == 0 {
                    dp.push(mak | dp[i]
                    res = res.max(dp[i].count_ones() as i32 + m sk.count_o es() a  i32);
                } let mut mask = 0;
             
            dp.push(mask);
            res = res.max(mask.count_ones() as i32);       for b in s.bytes() {
         
        res               let bit = b - b'a';
                if (mask >> bit) & 1 == 1 {
                    mask = 0;
                    break;
                }
                mask |= 1 << bit;
            }
            if mask == 0 {
                continue;
            }
            let n = masks.len();
            for i in 0..n {
                let m = masks[i];
                if (m & mask) == 0 {
                    masks.push(m | mask);
                    res = res.max(masks.last().unwrap().count_ones() as i32);
                }
            }
        }
        res

=======

        let mut ans = 0;
        let mut arr: Vec<i32> = arr.iter().map(|s| s.chars().fold(0, |acc, c| acc | 1 << (c as i32 - 'a' as i32))).filter(|&x| x.count_ones() == x.count_zeros()).collect();
        dfs(0, 0, &mut arr, &mut ans);
        ans
    }
}

=======

        let mut res = 0;
        let mut dp = vec![];
        for s in &arr {
            let mut mask = 0;
            let mut dup = false;
            for c in s.chars() {
                let bit = c as usize - 'a' as usize;
                if mask & (1 << bit) != 0 {
                    dup = true;
                    break;
                }
                mask |= 1 << bit;
            }
            if dup {
                continue;
            }
            let n = dp.len();
            for i in 0..n {
                if mask & dp[i] == 0 {
                    dp.push(mask | dp[i]);
                    res = res.max(dp[i].count_ones() as i32 + mask.count_ones() as i32);
                }
            }
            dp.push(mask);
            res = res.max(mask.count_ones() as i32);
        }
        res

=======

        let mut arr = arr.into_iter().map(|s| {
            let mut mask = 0;
            for c in s.chars() {
                let i = c as u8 - b'a';
                if mask & (1 << i) > 0 {
                    return 0;
                }
                mask |= 1 << i;
            }
            mask
        }).collect::<Vec<_>>();
        arr.sort_unstable_by_key(|&mask| mask.count_ones());
        let mut ans = 0;
        let mut masks = vec![0];
        for &mask in arr.iter().rev() {
            if mask == 0 {
                continue;
            }
            let mut next = Vec::new();
            for &m in masks.iter() {
                if m & mask == 0 {
                    ans = ans.max(m.count_ones() + mask.count_ones());
                    next.push(m | mask);
                }
            }
            masks.append(&mut next);
        }
        ans as i32
    }
}

=======

        let mut a = vec![];
        for s in arr {
            let mut bits = 0;
            for c in s.as_bytes() {
                let bit = 1 << (c - b'a');
                if bits & bit != 0 {
                    bits = 0;
                    break;
                }
                bits |= bit;
            }
            if bits > 0 {
                a.push(bits);
            }
        }
        let mut ans = 0;
        let mut dfs = |i: usize, bits: i32| {
            if bits.count_ones() > ans as u32 {
                ans = bits.count_ones();
            }
            if i == a.len() {
                return;
            }
            for j in i..a.len() {
                if bits & a[j] == 0 {
                    dfs(j + 1, bits | a[j]);
                }
            }
        };
        dfs(0, 0);
        ans as i32

=======

        let mut res = 0;
        let mut paths = vec![0];
        for s in arr {
            let mut mask = 0;
            for c in s.chars() {
                let x = c as usize - 97;
                if (mask >> x) & 1 == 1 {
                    mask = 0;
                    break;
                }
                mask |= 1 << x;
            }
            if mask == 0 {
                continue;
            }
            let n = paths.len();
            for i in 0..n {
                let path = paths[i];
                if path & mask == 0 {
                    res = res.max(path.count_ones() + mask.count_ones());
                    paths.push(path | mask);
                }
            }
        }
        res as i32
