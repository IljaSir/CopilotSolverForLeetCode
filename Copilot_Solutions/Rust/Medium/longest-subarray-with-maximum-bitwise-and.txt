Synthesizing 10/10 solutions

=======

        let mut ans = 0;
        let mut mask = 0;
        for i in (0..=30).rev() {
            mask |= 1 << i;
            let mut set = std::collections::HashSet::new();
            for &x in &nums {
                set.insert(x & mask);
            }
            let tmp = ans | (1 << i);
            for prefix in set {
                if set.contains(&(tmp ^ prefix)) {
                    ans = tmp;
                    break;
                }
            }
        }
        ans
    }
}

=======

        let mut max = 0;
        let mut max_idx = 0;
        for i in 0..nums.len() {
            if nums[i] > max {
                max = nums[i];
                max_idx = i;
            }
        }
        let mut max2 = 0;
        for i in 0..max_idx {
            let tmp = max & nums[i];
            if tmp > max2 {
                max2 = tmp;
            }
        }
        let mut max3 = 0;
        for i in (max_idx + 1)..nums.len() {
            let tmp = max & nums[i];
            if tmp > max3 {
                max3 = tmp;
            }
        }
        if max2 == max {
            return 1;
        }
        if max3 == max {
            return 1;
        }
        2
    }
}

=======

        let mut max = 0;
        let mut res = 0;
        for i in 0..nums.len() {
            max &= nums[i];
            max = max.max(nums[i]);
            res = res.max(max.count_ones() as i32);
        }
        res

=======

        let mut ans = 0;
        let mut mask = 0;
        for i in (0..30).rev() {
            mask |= 1 << i;
            let mut st = std::collections::HashSet::new();
            for &num in nums.iter() {
                st.insert(num & mask);
            }
            let tmp = ans | (1 << i);
            for prefix in st {
                if st.contains(&(prefix ^ tmp)) {
                    ans = tmp;
                    break;
                }
            }
        }
        ans
    }
}

=======

        let mut ans = 0;
        let mut max = 0;
        for i in 0..nums.len() {
            max &= nums[i];
            max = std::cmp::max(max, nums[i]);
            ans = std::cmp::max(ans, max & (max - 1));
        }
        for i in 0..nums.len() {
            if (nums[i] & ans) == ans {
                return (nums.len() - i) as i32;
            }
        }
        0

=======

        
    }
}

=======

        let mut ans = 0;
        let mut mask = -1;
        let n = nums.len();
        for i in 0..30 {
            let mut set = std::collections::HashSet::new();
            for &x in &nums {
                set.insert(x & mask);
            }
            let mut found = false;
            let t = ans | (1 << i);
            for &x in &set {
                if set.contains(&(x ^ t)) {
                    ans = t;
                    found = true;
                    break;
                }
            }
            if !found {
                mask &= !(1 << i);
            }
        }
        ans
    }
}

=======

        let mut pre = nums[0];
        let mut ans = 0;
        for i in 1..nums.len() {
            let cur = pre & nums[i];
            if cur == pre {
                ans += 1;
            } else {
                pre = cur;
                ans = 0;
            }
        }
        ans

=======

        let mut max = 0;
        let mut max_len = 0;
        let mut count = 0;
        for i in 0..nums.len() {
            if nums[i] > max {
                max = nums[i];
                max_len = 1;
            } else if nums[i] == max {
                max_len += 1;
            }
            if max_len == 1 {
                count += 1;
            } else {
                count = max_len;
            }
        }
        count
    }
}

=======

        let mut ans = 0;
        let mut mask = 1 << 30;
        while mask > 0 {
            let mut cnt = 0;
            let mut cur = 0;
            for &x in nums.iter() {
                if (x & mask) > 0 {
                    cur += 1;
                } else {
                    cnt = cnt.max(cur);
                    cur = 0;
                }
            }
            cnt = cnt.max(cur);
            if cnt > ans + 1 {
                ans += 1;
            } else {
                ans = cnt;
                break;
            }
            mask >>= 1;
        }
        ans
