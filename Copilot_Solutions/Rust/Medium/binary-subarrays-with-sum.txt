Synthesizing 10/10 solutions

=======

        let mut prefix = vec![0; nums.len() + 1];
        let mut sum = 0;
        for i in 0..nums.len() {
            sum += nums[i];
            prefix[sum as usize] += 1;
        }
        let mut ret = 0;
        for i in 0..=nums.len() {
            ret += prefix[i] * prefix[i + goal as usize];
        }
        ret as i32

=======

        let mut prefix = vec![0; nums.len()+1];
        for i in 0..nums.len() {
            prefix[i+1] = prefix[i] + nums[i];
        }
        let mut count = 0;
        for i in 0..prefix.len() {
            let j = prefix.binary_search(&(prefix[i] + goal)).unwrap_or_else(|x| x);
            count += j - i - 1;
        }
        count as i32
    }
}

=======

        let mut sum = 0;
        let mut map = std::collections::HashMap::new();
        let mut res = 0;
        for i in 0..nums.len() {
            sum += nums[i];
            if sum == goal {
                res += 1;
            }
            if map.contains_key(&(sum - goal)) {
                res += map[&(sum - goal)];
            }
            *map.entry(sum).or_insert(0) += 1;
        }
        res

=======

        let mut sum = 0;
        let mut cnt = vec![0; nums.len() + 1];
        for i in 0..nums.len() {
            sum += nums[i];
            cnt[sum as usize] += 1;
        }
        let mut res = 0;
        for i in 0..cnt.len() {
            if cnt[i] > 0 {
                if goal == 0 {
                    res += cnt[i] * (cnt[i] + 1) / 2;
                } else if i + goal as usize < cnt.len() {
                    res += cnt[i] * cnt[i + goal as usize];
                }
            }
        }
        res

=======

        let mut sum = 0;
        let mut count = 0;
        let mut map = std::collections::HashMap::new();
        map.insert(0, 1);
        for i in 0..nums.len() {
            sum += nums[i];
            let diff = sum - goal;
            if map.contains_key(&diff) {
                count += map[&diff];
            }
            *map.entry(sum).or_insert(0) += 1;
        }
        count

=======

        let mut sum = 0;
        let mut count = 0;
        let mut map = std::collections::HashMap::new();
        for i in 0..nums.len() {
            sum += nums[i];
            if sum == goal {
                count += 1;
            }
            if let Some(c) = map.get(&(sum - goal)) {
                count += c;
            }
            *map.entry(sum).or_insert(0) += 1;
        }
        count

=======

        let mut map = std::collections::HashMap::new();
        let mut sum = 0;
        let mut ans = 0;
        for n in nums {
            map.entry(sum).and_modify(|v| *v += 1).or_insert(1);
            sum += n;
            ans += map.get(&(sum - goal)).unwrap_or(&0);
        }
        ans

=======

        let mut sum = 0;
        let mut map: std::collections::HashMap<i32, i32> = std::collections::HashMap::new();
        let mut res = 0;
        for n in nums {
            map.entry(sum).and_modify(|e| *e += 1).or_insert(1);
            sum += n;
            res += map.get(&(sum - goal)).unwrap_or(&0);
        }
        res

=======

        let mut sum = 0;
        let mut map = std::collections::HashMap::new();
        let mut count = 0;
        for num in nums {
            map.entry(sum).and_modify(|v| *v += 1).or_insert(1);
            sum += num;
            count += map.get(&(sum - goal)).cloned().unwrap_or(0);
        }
        count

=======

        let mut res = 0;
        let mut sum = 0;
        let mut cnt = std::collections::HashMap::new();
        for n in nums {
            cnt.entry(sum).and_modify(|x| *x += 1).or_insert(1);
            sum += n;
            res += *cnt.get(&(sum - goal)).unwrap_or(&0);
        }
        res
