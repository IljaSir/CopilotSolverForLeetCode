Synthesizing 10/10 solutions

=======
Suggestion 1

        let mut candidates = candidates;
        candidates.sort();
        let mut res = Vec::new();
        Self::dfs(&candidates, target, 0, &mut Vec::new(), &mut res);
        res
    }
    fn dfs(candidates: &[i32], target: i32, start: usize, cur: &mut Vec<i32>, res: &mut Vec<Vec<i32>>) {
        if target == 0 {
            res.push(cur.clone());
            return;
        }
        for i in start..candidates.len() {
            if target < candidates[i] {
                break;
            }
            if i > start && candidates[i] == candidates[i - 1] {
                continue;
            }
            cur.push(candidates[i]);
            Self::dfs(candidates, target - candidates[i], i + 1, cur, res);
            cur.pop();
        }
    }
}

=======
Suggestion 2

        let mut candidates = candidates;
        candidates.sort();
        let mut result = Vec::new();
        let mut path = Vec::new();
        Self::dfs(&candidates, target, 0, &mut path, &mut result);
        result
    }

    fn dfs(candidates: &Vec<i32>, target: i32, start: usize, path: &mut Vec<i32>, result: &mut Vec<Vec<i32>>) {
        if target == 0 {
            result.push(path.clone());
            return;
        }
        if target < 0 {
            return;
        }
        for i in start..candidates.len() {
            if i > start && candidates[i] == candidates[i-1] {
                continue;
            }
            path.push(candidates[i]);
            Self::dfs(candidates, target - candidates[i], i + 1, path, result);
            path.pop();
        }
    }
}

=======
Suggestion 3

        let mut candidates = candidates;
        candidates.sort();
        let mut res = Vec::new();
        Solution::dfs(&candidates, target, 0, &mut Vec::new(), &mut res);
        res
    }
    fn dfs(candidates: &Vec<i32>, target: i32, start: usize, tmp: &mut Vec<i32>, res: &mut Vec<Vec<i32>>) {
        if target < 0 {
            return
        }
        if target == 0 {
            res.push(tmp.clone());
        } else {
            for i in start..candidates.len() {
                if i > start && candidates[i] == candidates[i-1] {
                    continue;
                }
                tmp.push(candidates[i]);
                Solution::dfs(candidates, target-candidates[i], i+1, tmp, res);
                tmp.pop();
            }
        }

=======
Suggestion 4

        let mut candidates = candidates;
        candidates.sort();
        let mut result = Vec::new();
        let mut path = Vec::new();
        Solution::backtrack(&candidates, target, 0, &mut path, &mut result);
        result
    }
    fn backtrack(candidates: &Vec<i32>, target: i32, start: usize, path: &mut Vec<i32>, result: &mut Vec<Vec<i32>>) {
        if target < 0 {
            return;
        } else if target == 0 {
            result.push(path.clone());
            return;
        }
        for i in start..candidates.len() {
            if i > start && candidates[i] == candidates[i-1] {
                continue;
            }
            path.push(candidates[i]);
            Solution::backtrack(candidates, target - candidates[i], i+1, path, result);
            path.pop();
        }

=======
Suggestion 5

        let mut candidates = candidates;
        candidates.sort();
        let mut res = vec![];
        Self::backtrack(&candidates, 0, target, &mut vec![], &mut res);
        res
    }
    
    fn backtrack(candidates: &Vec<i32>, start: usize, target: i32, cur: &mut Vec<i32>, res: &mut Vec<Vec<i32>>) {
        if target == 0 {
            res.push(cur.clone());
            return;
        }
        for i in start..candidates.len() {
            if candidates[i] > target {
                break;
            }
            if i > start && candidates[i] == candidates[i-1] {
                continue;
            }
            cur.push(candidates[i]);
            Self::backtrack(candidates, i+1, target-candidates[i], cur, res);
            cur.pop();
        }
    }
}

=======
Suggestion 6

        let mut candidates = candidates;
        candidates.sort();
        let mut ret = vec![];
        let mut tmp = vec![];
        Self::dfs(&candidates, target, 0, &mut tmp, &mut ret);
        ret
    }
    fn dfs(candidates: &Vec<i32>, target: i32, start: usize, tmp: &mut Vec<i32>, ret: &mut Vec<Vec<i32>>) {
        if target == 0 {
            ret.push(tmp.clone());
            return;
        }
        for i in start..candidates.len() {
            if i > start && candidates[i] == candidates[i-1] {
                continue;
            }
            if target - candidates[i] < 0 {
                break;
            }
            tmp.push(candidates[i]);
            Self::dfs(candidates, target - candidates[i], i+1, tmp, ret);
            tmp.pop();
        }

=======
Suggestion 7

        let mut candidates = candidates;
        candidates.sort();
        let mut ans = vec![];
        let mut path = vec![];
        let mut used = vec![false; candidates.len()];
        Self::dfs(&candidates, target, 0, &mut used, &mut path, &mut ans);
        ans
    }

    fn dfs(candidates: &Vec<i32>, target: i32, start: usize, used: &mut Vec<bool>, path: &mut Vec<i32>, ans: &mut Vec<Vec<i32>>) {
        if target == 0 {
            ans.push(path.clone());
            return;
        }
        let mut last = -1;
        for i in start..candidates.len() {
            if used[i] { continue; }
            if last == candidates[i] { continue; }
            if candidates[i] > target { break; }
            last = candidates[i];
            used[i] = true;
            path.push(candidates[i]);
            Self::dfs(candidates, target - candidates[i], i + 1, used, path, ans);
            path.pop();
            used[i] = false;
        }
    }
}

=======
Suggestion 8

        let mut candidates = candidates;
        candidates.sort();
        let mut ans = Vec::new();
        let mut tmp = Vec::new();
        let mut visited = vec![false; candidates.len()];
        Self::dfs(&candidates, target, 0, &mut ans, &mut tmp, &mut visited);
        ans
    }
    fn dfs(candidates: &Vec<i32>, target: i32, start: usize, ans: &mut Vec<Vec<i32>>, tmp: &mut Vec<i32>, visited: &mut Vec<bool>) {
        if target == 0 {
            ans.push(tmp.clone());
            return;
        }
        for i in start..candidates.len() {
            if target - candidates[i] < 0 {
                break;
            }
            if i > 0 && candidates[i] == candidates[i - 1] && !visited[i - 1] {
                continue;
            }
            tmp.push(candidates[i]);
            visited[i] = true;
            Self::dfs(candidates, target - candidates[i], i + 1, ans, tmp, visited);
            tmp.pop();
            visited[i] = false;
        }

=======
Suggestion 9

        let mut candidates = candidates;
        candidates.sort_unstable();
        let mut result = Vec::new();
        let mut path = Vec::new();
        Self::backtrack(&mut result, &candidates, target, &mut path, 0);
        result
    }
    fn backtrack(result: &mut Vec<Vec<i32>>, candidates: &Vec<i32>, target: i32, path: &mut Vec<i32>, start: usize) {
        if target == 0 {
            result.push(path.clone());
            return;
        }
        if target < 0 {
            return;
        }
        for i in start..candidates.len() {
            if i > start && candidates[i] == candidates[i - 1] {
                continue;
            }
            path.push(candidates[i]);
            Self::backtrack(result, candidates, target - candidates[i], path, i + 1);
            path.pop();
        }
    }
}

=======
Suggestion 10

        let mut candidates = candidates;
        candidates.sort();
        let mut result = vec![];
        Solution::combination_sum2_rec(&candidates, target, &mut result, vec![]);
        result
    }
    fn combination_sum2_rec(candidates: &Vec<i32>, target: i32, result: &mut Vec<Vec<i32>>, mut current: Vec<i32>) {
        if target == 0 {
            result.push(current);
            return;
        }
        if candidates.is_empty() {
            return;
        }
        let mut i = 0;
        while i < candidates.len() {
            if candidates[i] > target {
                break;
            }
            let mut j = i + 1;
            while j < candidates.len() && candidates[j] == candidates[i] {
                j += 1;
            }
            current.push(candidates[i]);
            Solution::combination_sum2_rec(&candidates[j..].to_vec(), target - candidates[i], result, current.clone());
            current.pop();
            i = j;
        }
