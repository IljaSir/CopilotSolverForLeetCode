Synthesizing 10/10 solutions

=======

        let mut res = 0;
        for i in 0..strs[0].len() {
            for j in 0..strs.len() - 1 {
                if strs[j].as_bytes()[i] > strs[j + 1].as_bytes()[i] {
                    res += 1;
                    break;
                }
            }
        }
        res

=======

        let mut count = 0;
        for i in 0..strs[0].len() {
            for j in 1..strs.len() {
                if strs[j].as_bytes()[i] < strs[j-1].as_bytes()[i] {
                    count += 1;
                    break;
                }
            }
        }
        count

=======

        let n = strs.len();
        let m = strs[0].len();
        let mut dp = vec![1; m];
        let mut ans = 0;
        for j in 1..m {
            for i in 0..j {
                let mut ok = true;
                for k in 0..n {
                    if strs[k].as_bytes()[i] > strs[k].as_bytes()[j] {
                        ok = false;
                        break;
                    }
                }
                if ok {
                    dp[j] = dp[j].max(dp[i] + 1);
                }
            }
            ans = ans.max(dp[j]);
        }
        (m - ans) as i32

=======

        let mut strs: Vec<Vec<char>> = strs.iter().map(|s| s.chars().collect()).collect();
        let mut res = 0;
        for i in 0..strs[0].len() {
            let mut sorted = true;
            for j in 1..strs.len() {
                if strs[j][i] < strs[j-1][i] {
                    sorted = false;
                    break;
                }
            }
            if !sorted {
                res += 1;
            } else {
                for j in 1..strs.len() {
                    if strs[j][i] > strs[j-1][i] {
                        strs[j-1][i] = ' ';
                    }
                }
            }
        }
        res
    }
}

=======

        let mut res = 0;
        let n = strs[0].len();
        let m = strs.len();
        for i in 0..n {
            let mut flag = false;
            for j in 1..m {
                if strs[j].chars().nth(i).unwrap() < strs[j - 1].chars().nth(i).unwrap() {
                    flag = true;
                    break;
                }
            }
            if flag {
                res += 1;
            }
        }
        res
    }
}

=======

        let n = strs.len();
        let m = strs[0].len();
        let mut ans = 0;
        let mut flag = vec![true; n];
        for j in 0..m {
            for i in 1..n {
                if flag[i] && strs[i].as_bytes()[j] < strs[i - 1].as_bytes()[j] {
                    ans += 1;
                    break;
                }
                if flag[i] && strs[i].as_bytes()[j] > strs[i - 1].as_bytes()[j] {
                    flag[i] = false;
                }
            }
        }
        ans

=======

        let mut sorted = vec![true; strs.len()];
        let mut res = 0;
        for i in 0..strs[0].len() {
            let mut is_sorted = true;
            for j in 1..strs.len() {
                if sorted[j] && strs[j].chars().nth(i).unwrap() < strs[j - 1].chars().nth(i).unwrap() {
                    is_sorted = false;
                    break;
                }
            }
            if !is_sorted {
                res += 1;
            } else {
                for j in 1..strs.len() {
                    if strs[j].chars().nth(i).unwrap() > strs[j - 1].chars().nth(i).unwrap() {
                        sorted[j] = false;
                    }
                }
            }
        }
        res

=======

        let mut count = 0;
        let mut prev = strs[0].chars().collect::<Vec<char>>();
        for i in 1..strs.len() {
            let mut curr = strs[i].chars().collect::<Vec<char>>();
            for j in 0..curr.len() {
                if curr[j] < prev[j] {
                    count += 1;
                    break;
                }
                if curr[j] > prev[j] {
                    prev[j] = curr[j];
                }
            }
        }
        count
    }
}

=======

        let mut res = 0;
        let n = strs.len();
        let m = strs[0].len();
        let mut sorted = vec![false; n];
        for j in 0..m {
            let mut sorted2 = sorted.clone();
            for i in 0..n - 1 {
                if !sorted[i] && strs[i].chars().nth(j).unwrap() > strs[i + 1].chars().nth(j).unwrap() {
                    res += 1;
                    break;
                } else if !sorted[i] && strs[i].chars().nth(j).unwrap() < strs[i + 1].chars().nth(j).unwrap() {
                    sorted2[i] = true;
                }
            }
            sorted = sorted2;
        }
        res

=======

        let mut strs = strs;
        let m = strs.len();
        let n = strs[0].len();
        let mut count = 0;
        for j in 0..n {
            let mut flag = true;
            for i in 1..m {
                if strs[i].as_bytes()[j] < strs[i - 1].as_bytes()[j] {
                    flag = false;
                    break;
                }
            }
            if !flag {
                count += 1;
            } else {
                for i in 1..m {
                    strs[i].as_bytes_mut()[j] = strs[i - 1].as_bytes()[j];
                }
            }
        }
        count
    }
}
