Synthesizing 7/10 solutions

=======

        let n = candies_count.len();
        let mut prefix = vec![0; n + 1];
        for i in 1..=n {
            prefix[i] = prefix[i - 1] + candies_count[i - 1];
        }
        let mut ans = vec![];
        for q in queries {
            let (t, d, c) = (q[0] as usize, q[1], q[2]);
            let min = prefix[t] + 1;
            let max = prefix[t + 1];
            let min_day = min / c;
            let max_day = max / c;
            if d >= min_day && d <= max_day {
                ans.push(true);
            } else {
                ans.push(false);
            }
        }
        ans

=======

        let mut prefix_sum = vec![0;candies_count.len()];
        prefix_sum[0] = candies_count[0];
        for i in 1..candies_count.len() {
            prefix_sum[i] = prefix_sum[i-1] + candies_count[i];
        }
        let mut result = Vec::new();
        for q in queries {
            let (type_i, day_i, cap_i) = (q[0] as usize, q[1], q[2]);
            let min = if type_i == 0 { 0 } else { prefix_sum[type_i-1] };
            let max = prefix_sum[type_i];
            let min_day = min / cap_i;
            let max_day = max;
            result.push(day_i >= min_day && day_i < max_day);
        }
        result

=======

        let mut answer = Vec::new();
        let mut sum = vec![0; candies_count.len()];
        sum[0] = candies_count[0];
        for i in 1..candies_count.len() {
            sum[i] = sum[i - 1] + candies_count[i];
        }
        for q in queries {
            let (favorite_type, favorite_day, daily_cap) = (q[0] as usize, q[1], q[2]);
            let min = if favorite_type == 0 { 1 } else { sum[favorite_type - 1] + 1 };
            let max = sum[favorite_type];
            answer.push(favorite_day < max / daily_cap && favorite_day + 1 >= min);
        }
        answer

=======

        let mut ans = Vec::new();
        let mut sum = Vec::new();
        sum.push(0);
        for i in 0..candies_count.len() {
            sum.push(sum[i] + candies_count[i]);
        }
        for q in queries {
            let (f_type, f_day, daily_cap) = (q[0] as usize, q[1], q[2]);
            let min = f_day + 1;
            let max = (f_day + 1) * daily_cap;
            let pre = sum[f_type];
            let suc = sum[f_type + 1];
            ans.push(pre < max && suc >= min);
        }
        ans

=======

        let mut c = vec![0];
        for i in 0..candies_count.len() {
            c.push(c[i] + candies_count[i]);
        }
        let mut ans = Vec::new();
        for q in queries {
            let (t, d, c) = (q[0] as usize, q[1], q[2]);
            let min = d + 1;
            let max = (d + 1) * c;
            if c[t] < min || c[t + 1] > max {
                ans.push(false);
            } else {
                ans.push(true);
            }
        }
        ans
    }
}

=======

        let mut result = Vec::new();
        let mut sum = Vec::new();
        let mut count = 0;
        for i in 0..candies_count.len() {
            count += candies_count[i];
            sum.push(count);
        }
        for q in queries {
            let (t, d, c) = (q[0] as usize, q[1], q[2]);
            let min = d + 1;
            let max = (d + 1) * c;
            let mut left = 0;
            let mut right = sum.len() - 1;
            let mut mid = 0;
            while left <= right {
                mid = (left + right) / 2;
                if sum[mid] > t {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
            let mut left = 0;
            let mut right = sum.len() - 1;
            let mut mid = 0;
            while left <= right {
                mid = (left + right) / 2;
                if sum[mid] > t + 1 {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
            if (min <= sum[mid] && max >= sum[mid - 1]) {
                result.push(true);
            } else {
                result.push(false);
            }
        }
        result

=======

        let mut pre = vec![0];
        for i in candies_count {
            pre.push(pre.last().unwrap() + i);
        }
        let mut res = vec![];
        for q in queries {
            let tp = q[0];
            let day = q[1];
            let cap = q[2];
            let min = pre[tp as usize];
            let max = pre[tp as usize + 1] - 1;
            if min > day * cap || max < day {
                res.push(false);
            } else {
                res.push(true);
            }
        }
        res
