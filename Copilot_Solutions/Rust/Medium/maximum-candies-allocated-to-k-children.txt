Synthesizing 10/10 solutions

=======

        let mut left = 0;
        let mut right = *candies.iter().max().unwrap() as i64;
        while left < right {
            let mid = (left + right + 1) / 2;
            let mut count = 0;
            for &candy in candies.iter() {
                count += candy as i64 / mid;
            }
            if count >= k {
                left = mid;
            } else {
                right = mid - 1;
            }
        }
        left as i32

=======

        let mut l = 0;
        let mut r = *candies.iter().max().unwrap() as i64;
        while l < r {
            let m = (l + r + 1) / 2;
            let mut n = 0;
            for &c in &candies {
                n += std::cmp::min(m, c as i64) / m;
            }
            if n >= k {
                l = m;
            } else {
                r = m - 1;
            }
        }
        l as i32

=======

        let mut l = 0;
        let mut r = *candies.iter().max().unwrap() as i64;
        while l < r {
            let m = l + (r - l + 1) / 2;
            let mut n = 0;
            for x in candies.iter() {
                n += *x as i64 / m;
            }
            if n >= k {
                l = m;
            } else {
                r = m - 1;
            }
        }
        l as i32

=======

        let mut left = 0;
        let mut right = *candies.iter().max().unwrap() as i64;
        while left < right {
            let mid = (left + right + 1) >> 1;
            let mut count = 0;
            for &c in candies.iter() {
                count += c as i64 / mid;
            }
            if count >= k {
                left = mid;
            } else {
                right = mid - 1;
            }
        }
        left as i32
    }
}

=======

        let mut candies = candies;
        candies.sort();
        let mut l = 0;
        let mut r = candies.len() as i64;
        while l < r {
            let m = (l + r + 1) / 2;
            let mut sum = 0;
            for i in 0..candies.len() {
                sum += (candies[i] as i64 / m) as i32;
            }
            if sum as i64 >= k {
                l = m;
            } else {
                r = m - 1;
            }
        }
        l as i32

=======

        let mut candies = candies;
        candies.sort();
        let mut lo = 0;
        let mut hi = candies.len() as i64 - 1;
        while lo <= hi {
            let mid = (lo + hi) / 2;
            let mut sum = 0;
            for i in 0..candies.len() {
                sum += candies[i].min(mid) as i64;
            }
            if sum > k {
                hi = mid - 1;
            } else {
                lo = mid + 1;
            }
        }
        hi as i32

=======

        let mut candies = candies;
        candies.sort();
        let mut l = 0;
        let mut r = candies.len() as i64;
        let mut ans = 0;
        while l <= r {
            let mid = (l + r) / 2;
            let mut cnt = 0;
            for i in (0..candies.len()).rev() {
                if candies[i] as i64 >= mid {
                    cnt += (candies[i] as i64 - mid + 1) * k;
                } else {
                    break;
                }
            }
            if cnt >= mid * k {
                ans = ans.max(mid as i32);
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        ans

=======

        let mut candies = candies;
        candies.sort();
        let mut l = 0;
        let mut r = candies.len() - 1;
        let mut ans = 0;
        while l <= r {
            let mid = l + (r - l) / 2;
            if Solution::check(&candies, mid, k) {
                ans = mid;
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        ans as i32
    }

    fn check(candies: &Vec<i32>, mid: usize, k: i64) -> bool {
        let mut cnt = 0;
        for i in 0..candies.len() {
            if candies[i] as usize > mid {
                cnt += (candies[i] as usize - mid) as i64;
            }
        }
        cnt >= k

=======

        let mut candies = candies;
        candies.sort();
        let mut lo = 0;
        let mut hi = candies.len();
        let mut mid = (lo + hi) >> 1;
        let mut res = 0;
        while lo < hi {
            mid = (lo + hi) >> 1;
            let mut sum = 0;
            for i in 0..candies.len() {
                sum += candies[i].min(mid as i32) as i64;
            }
            if sum <= k {
                res = mid;
                lo = mid + 1;
            } else {
                hi = mid;
            }
        }
        res as i32

=======

        let mut lo = 0;
        let mut hi = 10000000000000000;
        while lo < hi {
            let mid = (lo + hi + 1) / 2;
            if Solution::can_allocate(&candies, k, mid) {
                lo = mid;
            } else {
                hi = mid - 1;
            }
        }
        lo as i32
    }
    fn can_allocate(candies: &Vec<i32>, k: i64, mid: i64) -> bool {
        let mut count = 0;
        for &candy in candies.iter() {
            count += (candy as i64 / mid) as i64;
        }
        count >= k
