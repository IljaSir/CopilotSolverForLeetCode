Synthesizing 10/10 solutions

=======
Suggestion 1

        let mut l = 0;
        let mut r = height.len() - 1;
        let mut max = 0;
        while l < r {
            max = max.max((r - l) as i32 * height[l].min(height[r]));
            if height[l] < height[r] {
                l += 1;
            } else {
                r -= 1;
            }
        }
        max
    }
}

=======
Suggestion 2

        let mut l = 0;
        let mut r = height.len() - 1;
        let mut max_area = 0;
        while l < r {
            let area = (r - l) as i32 * height[l].min(height[r]);
            max_area = max_area.max(area);
            if height[l] < height[r] {
                l += 1;
            } else {
                r -= 1;
            }
        }
        max_area
    }
}

=======
Suggestion 3

        let mut max = 0;
        let mut i = 0;
        let mut j = height.len() - 1;
        while i < j {
            let area = (j - i) as i32 * height[i].min(height[j]);
            if area > max {
                max = area;
            }
            if height[i] < height[j] {
                i += 1;
            } else {
                j -= 1;
            }
        }
        max
    }
}

=======
Suggestion 4

        let mut i = 0;
        let mut j = height.len() - 1;
        let mut max = 0;
        while i < j {
            let h = height[i].min(height[j]);
            max = max.max(h * (j - i) as i32);
            if height[i] < height[j] {
                i += 1;
            } else {
                j -= 1;
            }
        }
        max

=======
Suggestion 5

        let mut max_area = 0;
        let mut l = 0;
        let mut r = height.len() - 1;
        while l < r {
            let h = height[l].min(height[r]);
            max_area = max_area.max(h * (r - l) as i32);
            if height[l] < height[r] {
                l += 1;
            } else {
                r -= 1;
            }
        }
        max_area
    }
}

=======
Suggestion 6

        let mut max = 0;
        let mut l = 0;
        let mut r = height.len() - 1;
        while l < r {
            let area = (r - l) as i32 * i32::min(height[l], height[r]);
            if area > max {
                max = area;
            }
            if height[l] < height[r] {
                l += 1;
            } else {
                r -= 1;
            }
        }
        max

=======
Suggestion 7

        let mut left = 0;
        let mut right = height.len() - 1;
        let mut max_area = 0;
        while left < right {
            let h = height[left].min(height[right]);
            let w = right - left;
            max_area = max_area.max(h * w as i32);
            if height[left] < height[right] {
                left += 1;
            } else {
                right -= 1;
            }
        }
        max_area
    }
}

=======
Suggestion 8

        let mut max = 0;
        let mut left = 0;
        let mut right = height.len() - 1;
        while left < right {
            let h = height[left].min(height[right]);
            let w = right - left;
            max = max.max(h * w as i32);
            if height[left] < height[right] {
                left += 1;
            } else {
                right -= 1;
            }
        }
        max

=======
Suggestion 9

        let len = height.len();
        let mut max = 0;
        let mut i = 0;
        let mut j = len - 1;
        while i < j {
            let h = height[i].min(height[j]);
            let w = j - i;
            max = max.max(h * w as i32);
            if height[i] < height[j] {
                i += 1;
            } else {
                j -= 1;
            }
        }
        max

=======
Suggestion 10

        let mut i = 0;
        let mut j = height.len() - 1;
        let mut max = 0;
        while i < j {
            let min = if height[i] < height[j] {
                height[i]
            } else {
                height[j]
            };
            let area = min * (j - i) as i32;
            if area > max {
                max = area;
            }
            if height[i] < height[j] {
                i += 1;
            } else {
                j -= 1;
            }
        }
        max
    }
}
