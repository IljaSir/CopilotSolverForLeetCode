Synthesizing 10/10 solutions (Duplicates hidden)

=======
Suggestion 1

        let mut res = vec![0; num1.len() + num2.len()];
        for (i, c1) in num1.chars().rev().enumerate() {
            for (j, c2) in num2.chars().rev().enumerate() {
                let sum = (c1 as u8 - b'0') * (c2 as u8 - b'0') + res[i + j];
                res[i + j] = sum % 10;
                res[i + j + 1] += sum / 10;
            }
        }
        let mut s = res.iter().rev().skip_while(|&&x| x == 0).map(|&x| (x + b'0') as char).collect::<String>();
        if s.is_empty() {
            s = "0".to_string();
        }
        s

=======
Suggestion 2

        if num1 == "0" || num2 == "0" { return "0".to_string(); }
        let mut res = vec![0; num1.len() + num2.len()];
        for (i, c1) in num1.chars().rev().enumerate() {
            for (j, c2) in num2.chars().rev().enumerate() {
                let mul = (c1 as u32 - '0' as u32) * (c2 as u32 - '0' as u32);
                let sum = mul + res[i + j] as u32;
                res[i + j] = (sum % 10) as u8;
                res[i + j + 1] += (sum / 10) as u8;
            }
        }
        let mut i = res.len() - 1;
        while res[i] == 0 { i -= 1; }
        res[0..=i].iter().rev().map(|c| (*c as char).to_string()).collect()

=======
Suggestion 3

        let n1 = num1.chars().collect::<Vec<char>>();
        let n2 = num2.chars().collect::<Vec<char>>();
        let mut res = vec![0; n1.len() + n2.len()];
        for i in (0..n1.len()).rev() {
            for j in (0..n2.len()).rev() {
                let sum = (n1[i] as u8 - '0' as u8) * (n2[j] as u8 - '0' as u8) + res[i + j + 1];
                res[i + j + 1] = sum % 10;
                res[i + j] += sum / 10;
            }
        }
        let mut s = String::new();
        for i in 0..res.len() {
            if i == 0 && res[i] == 0 {
                continue;
            }
            s.push((res[i] + '0' as u8) as char);
        }
        if s.len() == 0 {
            s.push('0');
        }
        return s;

=======
Suggestion 4

        let mut res = vec![0; num1.len() + num2.len()];
        let bytes1 = num1.as_bytes();
        let bytes2 = num2.as_bytes();
        for i in (0..bytes1.len()).rev() {
            for j in (0..bytes2.len()).rev() {
                let mul = (bytes1[i] - b'0') * (bytes2[j] - b'0');
                let sum = mul + res[i + j + 1];
                res[i + j + 1] = sum % 10;
                res[i + j] += sum / 10;
            }
        }
        let mut res = res.into_iter().skip_while(|&x| x == 0).collect::<Vec<_>>();
        if res.is_empty() {
            return "0".to_string();
        }
        res.into_iter().map(|x| (x + b'0') as char).collect()

=======
Suggestion 5

        let mut result = vec![0;num1.len()+num2.len()];
        let num1: Vec<char> = num1.chars().collect();
        let num2: Vec<char> = num2.chars().collect();
        for i in 0..num1.len() {
            for j in 0..num2.len() {
                let n1 = num1[num1.len()-1-i].to_digit(10).unwrap();
                let n2 = num2[num2.len()-1-j].to_digit(10).unwrap();
                result[i+j] += n1*n2;
            }
        }
        let mut carry = 0;
        for i in 0..result.len() {
            result[i] += carry;
            carry = result[i]/10;
            result[i] %= 10;
        }
        while result.len() > 1 && result[result.len()-1] == 0 {
            result.pop();
        }
        result.reverse();
        result.iter().map(|&c| (c as u8 + '0' as u8) as char).collect()

=======
Suggestion 6

        let mut num1: Vec<u8> = num1.into_bytes();
        let mut num2: Vec<u8> = num2.into_bytes();
        let mut res: Vec<u8> = vec![0; num1.len() + num2.len()];
        for i in (0..num1.len()).rev() {
            for j in (0..num2.len()).rev() {
                let sum = (num1[i] - b'0') * (num2[j] - b'0') + res[i + j + 1];
                res[i + j + 1] = sum % 10;
                res[i + j] += sum / 10;
            }
        }
        let mut i = 0;
        while i < res.len() - 1 && res[i] == 0 {
            i += 1;
        }
        res[i..].iter().map(|x| (x + b'0') as char).collect()

=======
Suggestion 7

        let mut res: Vec<u32> = vec![0; num1.len() + num2.len()];
        let num1 = num1.as_bytes();
        let num2 = num2.as_bytes();
        for (i, &v1) in num1.iter().enumerate().rev() {
            for (j, &v2) in num2.iter().enumerate().rev() {
                let sum = (v1 - b'0') * (v2 - b'0') + res[i + j + 1];
                res[i + j] += sum / 10;
                res[i + j + 1] = sum % 10;
            }
        }
        let mut res = res.iter().skip_while(|&&v| v == 0).map(|&v| v + b'0').collect::<Vec<_>>();
        if res.is_empty() {
            res.push(b'0');
        }
        String::from_utf8(res).unwrap()

=======
Suggestion 8

        
    }
}

=======
Suggestion 9

        let mut result = vec![0;num1.len() + num2.len()];
        let num1 = num1.as_bytes();
        let num2 = num2.as_bytes();
        for (i, &ni) in num1.iter().rev().enumerate() {
            for (j, &nj) in num2.iter().rev().enumerate() {
                let sum = (ni - b'0') * (nj - b'0') + result[i + j];
                result[i + j] = sum % 10;
                result[i + j + 1] += sum / 10;
            }
        }
        let mut result = result.into_iter().rev().skip_while(|&x| x == 0);
        if let Some(x) = result.next() {
            let mut result = String::new();
            result.push((x + b'0') as char);
            for &x in result {
                result.push((x + b'0') as char);
            }
            result
        } else {
            "0".to_string()
        }
