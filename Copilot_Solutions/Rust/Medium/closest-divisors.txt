Synthesizing 10/10 solutions

=======

        let mut a = Self::divisors(num + 1);
        let mut b = Self::divisors(num + 2);
        if (a[0] - a[1]).abs() > (b[0] - b[1]).abs() {
            std::mem::swap(&mut a, &mut b);
        }
        a
    }
    fn divisors(num: i32) -> Vec<i32> {
        let mut i = (num as f64).sqrt() as i32;
        while num % i != 0 {
            i -= 1;
        }
        vec![i, num / i]

=======

        let (a, b) = (num + 1, num + 2);
        let (mut x, mut y) = (0, 0);
        for i in 1..=(a as f64).sqrt() as i32 {
            if a % i == 0 {
                x = i;
            }
        }
        for i in 1..=(b as f64).sqrt() as i32 {
            if b % i == 0 {
                y = i;
            }
        }
        if (a / x - x).abs() < (b / y - y).abs() {
            vec![x, a / x]
        } else {
            vec![y, b / y]
        }

=======

        let (a, b) = (num + 1, num + 2);
        let (mut x, mut y) = (1, 1);
        for i in 1..=a {
            if a % i == 0 {
                x = i;
            }
        }
        for i in 1..=b {
            if b % i == 0 {
                y = i;
            }
        }
        let (a, b) = (a / x, a / y);
        let (c, d) = (b - x, a - y);
        if c < d {
            vec![x, b]
        } else {
            vec![y, a]
        }
    }
}

=======

        let mut a = Self::find_divisors(num+1);
        let mut b = Self::find_divisors(num+2);
        
        if (a[0]-a[1]).abs() < (b[0]-b[1]).abs() {
            a
        } else {
            b
        }
    }
    
    fn find_divisors(num: i32) -> Vec<i32> {
        for i in (1..=num).rev() {
            if num % i == 0 {
                return vec![i, num/i];
            }
        }
        vec![]

=======

        let mut a = (num + 1) as f64;
        let mut b = (num + 2) as f64;
        let mut a_div = 0;
        let mut b_div = 0;
        for i in 1..=(num as f64).sqrt() as i32 {
            if num % i == 0 {
                a_div = i;
            }
        }
        a = a / a_div as f64;
        for i in 1..=(num as f64).sqrt() as i32 {
            if (num + 1) % i == 0 {
                b_div = i;
            }
        }
        b = b / b_div as f64;
        if (a - a_div as f64).abs() < (b - b_div as f64).abs() {
            return vec![a_div, a as i32];
        } else {
            return vec![b_div, b as i32];
        }
    }
}

=======

        let num1 = num + 1;
        let num2 = num + 2;
        let mut result1 = Self::find_closest_divisor(num1);
        let result2 = Self::find_closest_divisor(num2);
        if (result1[0] - result1[1]).abs() > (result2[0] - result2[1]).abs() {
            result1 = result2;
        }
        result1
    }
    
    fn find_closest_divisor(num: i32) -> Vec<i32> {
        let mut result = vec![];
        let mut i = 1;
        while i * i <= num {
            if num % i == 0 {
                result.clear();
                result.push(i);
                result.push(num / i);
            }
            i += 1;
        }
        result

=======

        let mut n1 = num + 1;
        let mut n2 = num + 2;
        while n1 > 0 {
            let mut n = (n1 as f64).sqrt() as i32;
            while n > 0 {
                if n1 % n == 0 {
                    return vec![n, n1 / n];
                }
                n -= 1;
            }
            n1 -= 1;
        }
        while n2 > 0 {
            let mut n = (n2 as f64).sqrt() as i32;
            while n > 0 {
                if n2 % n == 0 {
                    return vec![n, n2 / n];
                }
                n -= 1;
            }
            n2 -= 1;
        }
        vec![]

=======

        let mut res1 = Solution::closest_divisors_helper(num+1);
        let mut res2 = Solution::closest_divisors_helper(num+2);
        if res1[1]-res1[0] < res2[1]-res2[0] {
            res2
        } else {
            res1
        }
    }
    fn closest_divisors_helper(num: i32) -> Vec<i32> {
        let mut res = vec![];
        let mut i = 1;
        while i*i <= num {
            if num % i == 0 {
                res = vec![i, num/i];
            }
            i += 1;
        }
        res

=======

        let mut a = num + 1;
        let mut b = num + 2;
        let mut i = 1;
        let mut j = 1;
        let mut min = 0;
        while i * i <= a {
            if a % i == 0 {
                j = a / i;
                min = i;
            }
            i += 1;
        }
        let a = vec![min, j];
        i = 1;
        j = 1;
        min = 0;
        while i * i <= b {
            if b % i == 0 {
                j = b / i;
                min = i;
            }
            i += 1;
        }
        let b = vec![min, j];
        if (a[0] - a[1]).abs() <= (b[0] - b[1]).abs() {
            a
        } else {
            b
        }

=======

        let n = num as i64;
        let v1 = Self::find(n + 1);
        let v2 = Self::find(n + 2);
        if v1.0 <= v2.0 {
            vec![v1.1 as i32, v1.2 as i32]
        } else {
            vec![v2.1 as i32, v2.2 as i32]
        }
    }
    fn find(n: i64) -> (i64, i64, i64) {
        let mut i = (n as f64).sqrt() as i64;
        while i > 0 {
            if n % i == 0 {
                return (n / i - i, i, n / i);
            }
            i -= 1;
        }
        unreachable!()
