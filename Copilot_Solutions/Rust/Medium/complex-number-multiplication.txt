Synthesizing 10/10 solutions

=======
Suggestion 1

        let (a, b) = num1.split_at(num1.find('+').unwrap());
        let (c, d) = num2.split_at(num2.find('+').unwrap());
        let a = a.parse::<i32>().unwrap();
        let b = b.trim_end_matches('i').parse::<i32>().unwrap();
        let c = c.parse::<i32>().unwrap();
        let d = d.trim_end_matches('i').parse::<i32>().unwrap();
        format!("{}+{}i", a * c - b * d, a * d + b * c)

=======
Suggestion 2

        let (a, b) = Self::parse(&num1);
        let (c, d) = Self::parse(&num2);
        format!("{}+{}i", a * c - b * d, a * d + b * c)

=======
Suggestion 3

        let (a, b) = Self::parse_complex(&num1);
        let (c, d) = Self::parse_complex(&num2);
        let real = a * c - b * d;
        let imaginary = a * d + b * c;
        format!("{}+{}i", real, imaginary)

=======
Suggestion 4

        let nums1: Vec<i32> = num1.split("+").map(|x| x.replace("i", "").parse::<i32>().unwrap()).collect();
        let nums2: Vec<i32> = num2.split("+").map(|x| x.replace("i", "").parse::<i32>().unwrap()).collect();
        let a = nums1[0];
        let b = nums1[1];
        let c = nums2[0];
        let d = nums2[1];
        let real = a * c - b * d;
        let imaginary = a * d + b * c;
        format!("{}+{}i", real, imaginary)

=======
Suggestion 5

        let (a, b) = Self::get_complex(&num1);
        let (c, d) = Self::get_complex(&num2);
        format!("{}+{}i", a * c - b * d, a * d + b * c)

=======
Suggestion 6

        let mut num1 = num1.split('+');
        let mut num2 = num2.split('+');
        let real1 = num1.next().unwrap().parse::<i32>().unwrap();
        let imaginary1 = num1.next().unwrap().replace("i", "").parse::<i32>().unwrap();
        let real2 = num2.next().unwrap().parse::<i32>().unwrap();
        let imaginary2 = num2.next().unwrap().replace("i", "").parse::<i32>().unwrap();
        let real = real1 * real2 - imaginary1 * imaginary2;
        let imaginary = real1 * imaginary2 + real2 * imaginary1;
        format!("{}+{}i", real, imaginary)

=======
Suggestion 7

        let mut num1 = num1.split("+");
        let mut num2 = num2.split("+");
        let (a, b) = (num1.next().unwrap().parse::<i32>().unwrap(), num1.next().unwrap().trim_end_matches("i").parse::<i32>().unwrap());
        let (c, d) = (num2.next().unwrap().parse::<i32>().unwrap(), num2.next().unwrap().trim_end_matches("i").parse::<i32>().unwrap());
        let (e, f) = (a * c - b * d, a * d + b * c);
        format!("{}+{}i", e, f)

=======
Suggestion 8

        let (a,b) = Self::parse(num1);
        let (c,d) = Self::parse(num2);
        let real = a*c - b*d;
        let imag = a*d + b*c;
        format!("{}+{}i", real, imag)
    }
    fn parse(s: String) -> (i32, i32) {
        let (a,b) = s.split_at(s.find('+').unwrap());
        let a = a.parse::<i32>().unwrap();
        let b = b[1..b.len()-1].parse::<i32>().unwrap();
        (a,b)

=======
Suggestion 9

        let mut n1 = num1.split("+").map(|x| x.replace("i", "")).map(|x| x.parse::<i32>().unwrap()).collect::<Vec<i32>>();
        let mut n2 = num2.split("+").map(|x| x.replace("i", "")).map(|x| x.parse::<i32>().unwrap()).collect::<Vec<i32>>();
        let a = n1[0];
        let b = n1[1];
        let c = n2[0];
        let d = n2[1];
        let real = a*c - b*d;
        let imag = a*d + b*c;
        format!("{}+{}i", real, imag)

=======
Suggestion 10

        let mut num1 = num1.split("+").collect::<Vec<&str>>();
        let mut num2 = num2.split("+").collect::<Vec<&str>>();
        let mut num1_real = num1[0].parse::<i32>().unwrap();
        let mut num1_imaginary = num1[1].replace("i", "").parse::<i32>().unwrap();
        let mut num2_real = num2[0].parse::<i32>().unwrap();
        let mut num2_imaginary = num2[1].replace("i", "").parse::<i32>().unwrap();
        let mut res_real = num1_real * num2_real - num1_imaginary * num2_imaginary;
        let mut res_imaginary = num1_real * num2_imaginary + num1_imaginary * num2_real;
        format!("{}+{}i", res_real, res_imaginary)
