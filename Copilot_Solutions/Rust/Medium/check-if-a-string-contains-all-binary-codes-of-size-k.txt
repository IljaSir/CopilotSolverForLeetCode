Synthesizing 10/10 solutions (Duplicates hidden)

=======

        let mut set = std::collections::HashSet::new();
        for i in 0..=(s.len() - k as usize) {
            set.insert(&s[i..i + k as usize]);
        }
        set.len() == 1 << k

=======

        let k = k as usize;
        let mut set = std::collections::HashSet::new();
        for i in 0..=s.len() - k {
            set.insert(&s[i..i + k]);
        }
        set.len() == 1 << k

=======

        let k = k as usize;
        let mut set = std::collections::HashSet::new();
        for i in 0..=(s.len() - k) {
            set.insert(&s[i..i + k]);
        }
        set.len() == 1 << k

=======

        let mut set = std::collections::HashSet::new();
        let k = k as usize;
        for i in 0..=s.len() - k {
            set.insert(&s[i..i + k]);
        }
        set.len() == 1 << k
    }
}

=======

        let k = k as usize;
        let mut set = std::collections::HashSet::new();
        let mut i = 0;
        while i + k <= s.len() {
            set.insert(&s[i..i+k]);
            i += 1;
        }
        set.len() == 1 << k

=======

        let mut set = std::collections::HashSet::new();
        let k = k as usize;
        let s = s.as_bytes();
        for i in 0..=s.len() - k {
            set.insert(&s[i..i+k]);
        }
        set.len() == 1 << k

=======

        let k = k as usize;
        if s.len() <= k {
            return false;
        }
        let mut set = std::collections::HashSet::new();
        for i in 0..s.len() - k + 1 {
            set.insert(&s[i..i + k]);
        }
        set.len() == 1 << k

=======

        let k = k as usize;
        let mut count = 0;
        let mut visited = vec![false; 1 << k];
        let mut i = 0;
        let mut j = 0;
        let mut num = 0;
        let mut base = 1 << (k - 1);
        while j < s.len() {
            if s.as_bytes()[j] == b'1' {
                num += base;
            }
            if j - i + 1 == k {
                if !visited[num] {
                    visited[num] = true;
                    count += 1;
                }
                if s.as_bytes()[i] == b'1' {
                    num -= base;
                }
                i += 1;
            }
            j += 1;
        }
        count == 1 << k
    }
}

=======

        let (s, k) = (s.into_bytes(), k as usize);
        let mut count = 0;
        let mut len = 0;
        let mut set = std::collections::HashSet::new();
        for (i, &c) in s.iter().enumerate() {
            len += 1;
            count = (count << 1) + (c - b'0') as usize;
            if len == k {
                set.insert(count);
                count -= (s[i - k + 1] - b'0') as usize << (k - 1);
                len -= 1;
            }
        }
        set.len() == 1 << k
