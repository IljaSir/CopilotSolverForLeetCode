Synthesizing 10/10 solutions

=======

        let mut nums = nums;
        nums.sort();
        let mut ans = Vec::new();
        for q in queries {
            let mut l = 0;
            let mut r = nums.len();
            while l < r {
                let m = l + (r - l) / 2;
                if nums[m] <= q {
                    l = m + 1;
                } else {
                    r = m;
                }
            }
            ans.push(l as i32);
        }
        ans
    }
}

=======

        let mut nums = nums;
        nums.sort();
        let mut ret = Vec::new();
        for q in queries {
            let mut l = 0;
            let mut r = nums.len();
            while l < r {
                let m = l + (r - l) / 2;
                if nums[m] > q {
                    r = m;
                } else {
                    l = m + 1;
                }
            }
            ret.push(l as i32);
        }
        ret

=======

        let mut nums = nums;
        nums.sort();
        let mut res = Vec::new();
        for q in queries {
            let mut left = 0;
            let mut right = nums.len() - 1;
            while left <= right {
                let mid = left + (right - left) / 2;
                if nums[mid] <= q {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            res.push(left as i32);
        }
        res
    }
}

=======

        let mut ans = Vec::new();
        let mut nums = nums;
        nums.sort();
        for q in queries {
            let mut l = 0;
            let mut r = nums.len();
            while l < r {
                let m = l + (r - l) / 2;
                if nums[m] <= q {
                    l = m + 1;
                } else {
                    r = m;
                }
            }
            ans.push(l as i32);
        }
        ans
    }
}

=======

        let mut nums = nums;
        nums.sort();
        let mut results = Vec::new();
        for query in queries {
            let mut left = 0;
            let mut right = nums.len();
            while left < right {
                let mid = (left + right) / 2;
                if nums[mid] > query {
                    right = mid;
                } else {
                    left = mid + 1;
                }
            }
            results.push(left as i32);
        }
        results
    }
}

=======

        let mut ans = Vec::new();
        let mut nums = nums;
        nums.sort();
        for q in queries {
            let mut l = 0;
            let mut r = nums.len() - 1;
            while l < r {
                let mid = l + (r - l + 1) / 2;
                if nums[mid] <= q {
                    l = mid;
                } else {
                    r = mid - 1;
                }
            }
            ans.push(if nums[l] <= q { l + 1 } else { l } as i32);
        }
        ans
    }
}

=======

        let mut nums = nums;
        let mut queries = queries;
        nums.sort();
        let mut res = vec![];
        for q in queries {
            let mut left = 0;
            let mut right = nums.len() - 1;
            let mut mid = 0;
            while left <= right {
                mid = (left + right) / 2;
                if nums[mid] > q {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
            if left == 0 {
                res.push(0);
            } else {
                res.push(left as i32);
            }
        }
        res
    }
}

=======

        let mut queries = queries;
        let mut nums = nums;
        nums.sort();
        queries.sort();
        let mut res = Vec::new();
        let mut j = 0;
        for i in 0..queries.len() {
            while j < nums.len() && nums[j] <= queries[i] {
                j += 1;
            }
            res.push(j as i32);
        }
        res

=======

        let mut nums = nums;
        nums.sort_unstable();
        let mut res = Vec::new();
        for &q in &queries {
            res.push(nums.binary_search_by(|&x| x.cmp(&q)).unwrap_or_else(|e| e) as i32);
        }
        res
    }
}

=======

        let mut result: Vec<i32> = vec![];
        let mut prefix_sum: Vec<i32> = vec![0; nums.len() + 1];
        let mut index: usize = 1;
        for num in nums {
            prefix_sum[index] = prefix_sum[index - 1] + num;
            index += 1;
        }
        for query in queries {
            let mut left: usize = 0;
            let mut right: usize = nums.len();
            while left < right {
                let mid: usize = left + (right - left) / 2;
                if prefix_sum[mid + 1] <= query {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            result.push(left as i32);
        }
        result
    }
}
