Synthesizing 10/10 solutions

=======

        let mut map = std::collections::HashMap::new();
        for word in s1.split_whitespace() {
            *map.entry(word).or_insert(0) += 1;
        }
        for word in s2.split_whitespace() {
            *map.entry(word).or_insert(0) += 1;
        }
        map.into_iter()
            .filter(|&(_k, v)| v == 1)
            .map(|(k, _v)| k.to_string())
            .collect()
    }
}

=======

        let mut map = std::collections::HashMap::new();
        for w in s1.split_whitespace() {
            *map.entry(w).or_insert(0) += 1;
        }
        for w in s2.split_whitespace() {
            *map.entry(w).or_insert(0) += 1;
        }
        map.iter().filter(|(_, v)| **v == 1).map(|(k, _)| k.to_string()).collect()

=======

        let mut s1 = s1.split_whitespace().collect::<Vec<&str>>();
        let mut s2 = s2.split_whitespace().collect::<Vec<&str>>();
        s1.sort();
        s2.sort();
        let mut res = Vec::new();
        let mut i = 0;
        let mut j = 0;
        while i < s1.len() || j < s2.len() {
            let mut i1 = i;
            let mut j1 = j;
            while i1 < s1.len() && s1[i1] == s1[i] {
                i1 += 1;
            }
            while j1 < s2.len() && s2[j1] == s2[j] {
                j1 += 1;
            }
            if i1 - i == 1 && j1 - j == 0 {
                res.push(s1[i].to_string());
            }
            if i1 - i == 0 && j1 - j == 1 {
                res.push(s2[j].to_string());
            }
            i = i1;
            j = j1;
        }
        res
    }
}

=======

        let mut map = std::collections::HashMap::new();
        let mut ret = vec![];
        for s in s1.split_whitespace() {
            *map.entry(s).or_insert(0) += 1;
        }
        for s in s2.split_whitespace() {
            *map.entry(s).or_insert(0) += 1;
        }
        for (s, n) in map {
            if n == 1 {
                ret.push(s.to_string());
            }
        }
        ret

=======

        let mut ret: Vec<String> = Vec::new();
        let mut map: std::collections::HashMap<&str, i32> = std::collections::HashMap::new();
        for word in s1.split(' ') {
            *map.entry(word).or_insert(0) += 1;
        }
        for word in s2.split(' ') {
            *map.entry(word).or_insert(0) += 1;
        }
        for (k, v) in map {
            if v == 1 {
                ret.push(k.to_string());
            }
        }
        ret

=======

        let mut s1 = s1.split_whitespace().collect::<Vec<&str>>();
        let mut s2 = s2.split_whitespace().collect::<Vec<&str>>();
        let mut ret = Vec::new();
        for i in 0..s1.len() {
            let mut j = 0;
            while j < s2.len() {
                if s1[i] == s2[j] {
                    s1.remove(i);
                    s2.remove(j);
                    break;
                }
                j += 1;
            }
        }
        for i in s1 {
            ret.push(i.to_string());
        }
        for i in s2 {
            ret.push(i.to_string());
        }
        ret
    }
}

=======

        let mut s1 = s1.split(" ");
        let mut s2 = s2.split(" ");
        let mut s1_map = HashMap::new();
        let mut s2_map = HashMap::new();
        let mut res = Vec::new();
        for i in s1 {
            if s1_map.contains_key(i) {
                s1_map.insert(i, s1_map.get(i).unwrap() + 1);
            } else {
                s1_map.insert(i, 1);
            }
        }
        for i in s2 {
            if s2_map.contains_key(i) {
                s2_map.insert(i, s2_map.get(i).unwrap() + 1);
            } else {
                s2_map.insert(i, 1);
            }
        }
        for (k, v) in s1_map {
            if !s2_map.contains_key(k) && v == 1 {
                res.push(k.to_string());
            }
        }
        for (k, v) in s2_map {
            if !s1_map.contains_key(k) && v == 1 {
                res.push(k.to_string());
            }
        }
        res
    }
}

=======

        let mut words = s1.split(" ").chain(s2.split(" ")).collect::<Vec<_>>();
        words.sort();
        let mut res = vec![];
        let mut i = 0;
        while i < words.len() {
            let mut j = i;
            while j < words.len() && words[i] == words[j] {
                j += 1;
            }
            if j - i == 1 {
                res.push(words[i].to_string());
            }
            i = j;
        }
        res

=======

        let mut res: Vec<String> = Vec::new();
        let mut map: HashMap<String, i32> = HashMap::new();
        for s in s1.split(' ') {
            let count = map.entry(s.to_string()).or_insert(0);
            *count += 1;
        }
        for s in s2.split(' ') {
            let count = map.entry(s.to_string()).or_insert(0);
            *count += 1;
        }
        
        for (k, v) in map {
            if v == 1 {
                res.push(k);
            }
        }
        res

=======

        let mut m: HashMap<String, i32> = HashMap::new();
        let mut v: Vec<String> = vec![];
        for i in s1.split_whitespace() {
            *m.entry(i.to_string()).or_insert(0) += 1;
        }
        for i in s2.split_whitespace() {
            *m.entry(i.to_string()).or_insert(0) += 1;
        }
        for (k, v) in m {
            if v == 1 {
                v.push(k);
            }
        }
        v
