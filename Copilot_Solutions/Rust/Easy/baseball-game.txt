Synthesizing 10/10 solutions

=======

        let mut scores: Vec<i32> = Vec::new();
        for op in operations {
            match op.as_str() {
                "C" => {
                    scores.pop();
                }
                "D" => {
                    scores.push(scores.last().unwrap() * 2);
                }
                "+" => {
                    let n = scores.len();
                    scores.push(scores[n - 1] + scores[n - 2]);
                }
                _ => {
                    scores.push(op.parse::<i32>().unwrap());
                }
            }
        }
        scores.iter().sum()

=======

        let mut scores = vec![];
        for op in operations {
            match op.as_str() {
                "C" => { scores.pop(); },
                "D" => { scores.push(scores.last().unwrap() * 2); },
                "+" => { scores.push(scores.last().unwrap() + scores[scores.len() - 2]); },
                _ => { scores.push(op.parse::<i32>().unwrap()); },
            }
        }
        scores.iter().sum()

=======

        let mut scores = vec![];
        for op in operations {
            match op.as_str() {
                "C" => {
                    scores.pop();
                }
                "D" => {
                    scores.push(scores.last().unwrap() * 2);
                }
                "+" => {
                    let last = scores.last().unwrap();
                    let second_last = scores[scores.len() - 2];
                    scores.push(last + second_last);
                }
                _ => {
                    scores.push(op.parse().unwrap());
                }
            }
        }
        scores.iter().sum()
    }
}

=======

        let mut scores: Vec<i32> = Vec::new();
        for op in operations {
            match op.as_str() {
                "C" => {
                    scores.pop();
                }
                "D" => {
                    if let Some(&score) = scores.last() {
                        scores.push(score * 2);
                    }
                }
                "+" => {
                    if let Some(&score1) = scores.last() {
                        if let Some(&score2) = scores.get(scores.len() - 2) {
                            scores.push(score1 + score2);
                        }
                    }
                }
                _ => {
                    scores.push(op.parse::<i32>().unwrap());
                }
            }
        }
        scores.iter().sum()

=======

        let mut scores = vec![];
        for op in operations {
            match op.as_str() {
                "C" => {
                    scores.pop();
                },
                "D" => {
                    scores.push(scores.last().unwrap() * 2);
                },
                "+" => {
                    scores.push(scores.last().unwrap() + scores[scores.len() - 2]);
                },
                _ => {
                    scores.push(op.parse::<i32>().unwrap());
                }
            }
        }
        scores.iter().sum()

=======

        let mut scores: Vec<i32> = Vec::new();
        for op in operations {
            match op.as_str() {
                "C" => {
                    scores.pop();
                },
                "D" => {
                    let last = scores.last().unwrap();
                    scores.push(last * 2);
                },
                "+" => {
                    let last = scores.last().unwrap();
                    let last2 = scores[scores.len() - 2];
                    scores.push(last + last2);
                },
                _ => {
                    let score = op.parse::<i32>().unwrap();
                    scores.push(score);
                }
            }
        }
        scores.iter().sum()
    }
}

=======

        let mut scores: Vec<i32> = Vec::new();
        for op in operations {
            match op.as_str() {
                "C" => { scores.pop(); },
                "D" => { scores.push(2 * scores[scores.len() - 1]); },
                "+" => { scores.push(scores[scores.len() - 1] + scores[scores.len() - 2]); },
                _ => { scores.push(op.parse::<i32>().unwrap()); },
            }
        }
        scores.iter().sum()

=======

        let mut stack = Vec::new();
        for op in operations {
            match op.as_str() {
                "+" => {
                    let a = stack.pop().unwrap();
                    let b = stack.pop().unwrap();
                    let sum = a + b;
                    stack.push(b);
                    stack.push(a);
                    stack.push(sum);
                },
                "D" => {
                    let a = stack.pop().unwrap();
                    let sum = a * 2;
                    stack.push(a);
                    stack.push(sum);
                },
                "C" => {
                    stack.pop();
                },
                _ => {
                    stack.push(op.parse::<i32>().unwrap());
                },
            }
        }
        stack.iter().sum()
    }
}

=======

        let mut stack = Vec::new();
        for item in operations {
            match item.as_str() {
                "C" => {stack.pop();},
                "D" => {stack.push(stack.last().unwrap() * 2);},
                "+" => {stack.push(stack.last().unwrap() + stack[stack.len() - 2]);},
                _ => {stack.push(item.parse::<i32>().unwrap());}
            }
        }
        stack.iter().sum()
    }
}

=======

        let mut result = Vec::new();
        for op in operations {
            match op.as_str() {
                "+" => {
                    let last = result.pop().unwrap();
                    let second_last = result.pop().unwrap();
                    result.push(second_last);
                    result.push(last);
                    result.push(last + second_last);
                }
                "D" => {
                    let last = result.pop().unwrap();
                    result.push(last);
                    result.push(last * 2);
                }
                "C" => {
                    result.pop();
                }
                _ => {
                    result.push(op.parse::<i32>().unwrap());
                }
            }
        }
        result.iter().sum()
    }
}
