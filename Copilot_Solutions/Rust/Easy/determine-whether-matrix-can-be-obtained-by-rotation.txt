Synthesizing 10/10 solutions

=======

        let n = mat.len();
        let mut mat = mat;
        for _ in 0..4 {
            for i in 0..n {
                for j in 0..i {
                    mat[i][j] ^= mat[j][i];
                    mat[j][i] ^= mat[i][j];
                    mat[i][j] ^= mat[j][i];
                }
            }
            for i in 0..n {
                for j in 0..n/2 {
                    mat[i][j] ^= mat[i][n-1-j];
                    mat[i][n-1-j] ^= mat[i][j];
                    mat[i][j] ^= mat[i][n-1-j];
                }
            }
            if mat == target {
                return true;
            }
        }
        false

=======

        let n = mat.len();
        let mut mat = mat;
        for _ in 0..4 {
            let mut tmp = vec![vec![0; n]; n];
            for i in 0..n {
                for j in 0..n {
                    tmp[j][n - i - 1] = mat[i][j];
                }
            }
            if tmp == target {
                return true;
            }
            mat = tmp;
        }
        false

=======

        let n = mat.len();
        let mut mat = mat;
        for _ in 0..4 {
            for i in 0..n {
                for j in i+1..n {
                    mat[i][j] ^= mat[j][i];
                    mat[j][i] ^= mat[i][j];
                    mat[i][j] ^= mat[j][i];
                }
            }
            for i in 0..n {
                for j in 0..n/2 {
                    mat[i][j] ^= mat[i][n-1-j];
                    mat[i][n-1-j] ^= mat[i][j];
                    mat[i][j] ^= mat[i][n-1-j];
                }
            }
            if mat == target {
                return true;
            }
        }
        false

=======

        let n = mat.len();
        let mut mat = mat;
        let mut target = target;
        for _ in 0..4 {
            for i in 0..n {
                for j in 0..n {
                    if mat[i][j] != target[i][j] {
                        return false;
                    }
                }
            }
            for i in 0..n {
                for j in 0..n {
                    mat[i][j] = mat[n - 1 - j][i];
                }
            }
        }
        true

=======

        let mut mat = mat;
        for _ in 0..4 {
            let mut rotated = vec![vec![0; mat.len()]; mat.len()];
            for i in 0..mat.len() {
                for j in 0..mat.len() {
                    rotated[i][j] = mat[mat.len() - 1 - j][i];
                }
            }
            mat = rotated;
            if mat == target {
                return true;
            }
        }
        false
    }
}

=======

        let n = mat.len();
        let mut mat = mat;
        for _ in 0..4 {
            mat = (0..n).map(|i| (0..n).map(|j| mat[j][n - 1 - i]).collect()).collect();
            if mat == target {
                return true;
            }
        }
        false

=======

        let mut mat = mat;
        for _ in 0..4 {
            if mat == target { return true; }
            let n = mat.len();
            for i in 0..n {
                for j in 0..n {
                    mat[i][j] = mat[n-1-j][i];
                }
            }
        }
        false

=======

        let n = mat.len();
        if n == 1 {
            return mat[0][0] == target[0][0];
        }
        let mut mat = mat;
        for _ in 0..4 {
            mat = Solution::rotate(&mat);
            if mat == target {
                return true;
            }
        }
        false
    }
    fn rotate(mat: &Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        let n = mat.len();
        let mut res = vec![vec![0; n]; n];
        for i in 0..n {
            for j in 0..n {
                res[i][j] = mat[n - j - 1][i];
            }
        }
        res
    }
}

=======

        let n = mat.len();
        let mut m = mat;
        for _ in 0..4 {
            m = Self::rotate(m, n);
            if m == target {
                return true;
            }
        }
        false
    }
    fn rotate(mat: Vec<Vec<i32>>, n: usize) -> Vec<Vec<i32>> {
        let mut m = mat;
        for i in 0..n {
            for j in 0..n {
                m[i][j] = mat[n - 1 - j][i];
            }
        }
        m

=======

        let n = mat.len();
        if n == 0 {
            return true;
        }
        let mut mat = mat;
        for _ in 0..4 {
            for i in 0..n {
                for j in 0..n {
                    if mat[i][j] != target[i][j] {
                        return false;
                    }
                }
            }
            mat = Self::rotate(mat);
        }
        true
    }
    fn rotate(mat: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        let n = mat.len();
        let mut res = vec![vec![0; n]; n];
        for i in 0..n {
            for j in 0..n {
                res[i][j] = mat[n - j - 1][i];
            }
        }
        res
