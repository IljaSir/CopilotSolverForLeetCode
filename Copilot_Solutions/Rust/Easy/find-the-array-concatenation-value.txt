Synthesizing 10/10 solutions

=======

        let mut nums = nums;
        let mut ans = 0;
        while nums.len() > 0 {
            if nums.len() == 1 {
                ans += nums[0] as i64;
                nums.remove(0);
            } else {
                let x = nums[0];
                let y = nums[nums.len() - 1];
                ans += (x * 10_i32.pow(y.to_string().len() as u32) + y) as i64;
                nums.remove(0);
                nums.remove(nums.len() - 1);
            }
        }
        ans
    }
}

=======

        let mut nums = nums;
        let mut res = 0;
        while !nums.is_empty() {
            if nums.len() == 1 {
                res += nums[0] as i64;
                nums.remove(0);
            } else {
                let mut x = nums[0];
                let mut y = nums[nums.len() - 1];
                let mut xlen = 0;
                let mut ylen = 0;
                while x > 0 {
                    x /= 10;
                    xlen += 1;
                }
                while y > 0 {
                    y /= 10;
                    ylen += 1;
                }
                res += (nums[0] as i64) * 10_i64.pow(ylen as u32) + nums[nums.len() - 1] as i64;
                nums.remove(0);
                nums.remove(nums.len() - 1);
            }
        }
        res

=======

        let mut nums = nums;
        let mut result = 0;
        while !nums.is_empty() {
            if nums.len() == 1 {
                result += nums[0] as i64;
                nums.remove(0);
            } else {
                result += (nums[0] * 10 + nums[nums.len() - 1]) as i64;
                nums.remove(0);
                nums.remove(nums.len() - 1);
            }
        }
        result

=======

        let mut nums = nums;
        let mut ans = 0;
        loop {
            if nums.len() == 0 {
                break;
            }
            if nums.len() == 1 {
                ans += nums[0] as i64;
                break;
            }
            let mut a = nums[0];
            let mut b = nums[nums.len() - 1];
            let mut c = 0;
            while a > 0 {
                c += 1;
                a /= 10;
            }
            ans += (b + nums[0] * i32::pow(10, c)) as i64;
            nums.remove(0);
            nums.pop();
        }
        ans
    }
}

=======

        let mut nums = nums;
        let mut val = 0;
        while nums.len() > 0 {
            if nums.len() == 1 {
                val += nums[0] as i64;
                nums.remove(0);
            } else {
                let mut num1 = nums[0];
                let mut num2 = nums[nums.len() - 1];
                let mut tens = 1;
                while num1 > 0 {
                    tens *= 10;
                    num1 /= 10;
                }
                val += (num2 + tens * nums[0]) as i64;
                nums.remove(0);
                nums.remove(nums.len() - 1);
            }
        }
        val

=======

        let mut nums = nums;
        let mut ans = 0;
        while !nums.is_empty() {
            let n = nums.len();
            if n == 1 {
                ans = ans * 10 + nums[0] as i64;
                nums.clear();
            } else {
                ans = ans * 100 + nums[0] as i64 * 10 + nums[n - 1] as i64;
                nums.remove(0);
                nums.pop();
            }
        }
        ans
    }
}

=======

        let mut nums = nums;
        let mut ans = 0;
        while nums.len() > 0 {
            let (first, last) = (nums[0], nums[nums.len() - 1]);
            ans += (first * 10_i32.pow(nums.len() as u32) + last) as i64;
            nums.remove(0);
            if nums.len() > 0 {
                nums.remove(nums.len() - 1);
            }
        }
        ans

=======

        let mut nums = nums;
        let mut res = 0;
        while !nums.is_empty() {
            let (a, b) = (nums[0], nums[nums.len() - 1]);
            res += format!("{}{}", a, b).parse::<i64>().unwrap();
            nums.remove(0);
            if !nums.is_empty() {
                nums.remove(nums.len() - 1);
            }
        }
        res

=======

        let mut nums = nums;
        let mut ans = 0;
        while nums.len() > 0 {
            let first = nums[0];
            let last = nums[nums.len() - 1];
            let mut first_len = first.to_string().len() as i32;
            let mut last_len = last.to_string().len() as i32;
            let mut first_val = first;
            let mut last_val = last;
            while first_len > 0 {
                first_val *= 10;
                first_len -= 1;
            }
            ans += (first_val + last_val) as i64;
            nums.remove(0);
            if nums.len() > 0 {
                nums.remove(nums.len() - 1);
            }
        }
        ans

=======

        let mut nums = nums;
        let mut res = 0;
        while nums.len() > 0 {
            let left = nums.remove(0);
            let right = nums.pop().unwrap_or(left);
            res += (left * 10i32.pow(right.to_string().len() as u32) + right) as i64;
        }
        res
