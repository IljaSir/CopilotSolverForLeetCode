Synthesizing 10/10 solutions

=======

        let mut first = 0;
        let mut second = 0;
        let mut target = 0;
        for c in first_word.chars() {
            first = first * 10 + c as i32 - 'a' as i32;
        }
        for c in second_word.chars() {
            second = second * 10 + c as i32 - 'a' as i32;
        }
        for c in target_word.chars() {
            target = target * 10 + c as i32 - 'a' as i32;
        }
        first + second == target

=======

        let mut f = 0;
        let mut s = 0;
        let mut t = 0;
        for c in first_word.chars() {
            f *= 10;
            f += (c as u8 - 'a' as u8) as i32;
        }
        for c in second_word.chars() {
            s *= 10;
            s += (c as u8 - 'a' as u8) as i32;
        }
        for c in target_word.chars() {
            t *= 10;
            t += (c as u8 - 'a' as u8) as i32;
        }
        f + s == t

=======

        let mut f = 0;
        let mut s = 0;
        let mut t = 0;
        for c in first_word.chars() {
            f = f * 10 + (c as u8 - b'a') as i32;
        }
        for c in second_word.chars() {
            s = s * 10 + (c as u8 - b'a') as i32;
        }
        for c in target_word.chars() {
            t = t * 10 + (c as u8 - b'a') as i32;
        }
        f + s == t

=======

        let mut first = 0;
        let mut second = 0;
        let mut target = 0;
        for c in first_word.chars() {
            first *= 10;
            first += (c as u8 - 97) as i32;
        }
        for c in second_word.chars() {
            second *= 10;
            second += (c as u8 - 97) as i32;
        }
        for c in target_word.chars() {
            target *= 10;
            target += (c as u8 - 97) as i32;
        }
        first + second == target
    }
}

=======

        let mut f = 0;
        for c in first_word.chars() {
            f = f * 10 + (c as usize - 'a' as usize);
        }
        let mut s = 0;
        for c in second_word.chars() {
            s = s * 10 + (c as usize - 'a' as usize);
        }
        let mut t = 0;
        for c in target_word.chars() {
            t = t * 10 + (c as usize - 'a' as usize);
        }
        f + s == t

=======

        let mut first_word = first_word.chars().map(|c| (c as u8 - 'a' as u8) as i32).collect::<Vec<i32>>();
        let mut second_word = second_word.chars().map(|c| (c as u8 - 'a' as u8) as i32).collect::<Vec<i32>>();
        let mut target_word = target_word.chars().map(|c| (c as u8 - 'a' as u8) as i32).collect::<Vec<i32>>();
        let mut first_word_num = 0;
        let mut second_word_num = 0;
        let mut target_word_num = 0;
        for i in 0..first_word.len() {
            first_word_num += first_word[i] * 10_i32.pow((first_word.len() - i - 1) as u32);
            second_word_num += second_word[i] * 10_i32.pow((second_word.len() - i - 1) as u32);
            target_word_num += target_word[i] * 10_i32.pow((target_word.len() - i - 1) as u32);
        }
        first_word_num + second_word_num == target_word_num

=======

        let mut first_word = first_word.chars().map(|c| (c as u8 - 'a' as u8) as i32).collect::<Vec<i32>>();
        let mut second_word = second_word.chars().map(|c| (c as u8 - 'a' as u8) as i32).collect::<Vec<i32>>();
        let mut target_word = target_word.chars().map(|c| (c as u8 - 'a' as u8) as i32).collect::<Vec<i32>>();
        let mut first_word = first_word.iter().fold(0, |acc, x| acc * 10 + x);
        let mut second_word = second_word.iter().fold(0, |acc, x| acc * 10 + x);
        let mut target_word = target_word.iter().fold(0, |acc, x| acc * 10 + x);
        first_word + second_word == target_word

=======

        let mut first_word = first_word;
        let mut second_word = second_word;
        let mut target_word = target_word;
        let mut first = 0;
        let mut second = 0;
        let mut target = 0;
        for c in first_word.chars() {
            first = first * 10 + (c as u8 - 'a' as u8) as i32;
        }
        for c in second_word.chars() {
            second = second * 10 + (c as u8 - 'a' as u8) as i32;
        }
        for c in target_word.chars() {
            target = target * 10 + (c as u8 - 'a' as u8) as i32;
        }
        first + second == target

=======

        let mut first_word = first_word;
        let mut second_word = second_word;
        let mut target_word = target_word;
        let mut first_num = String::new();
        let mut second_num = String::new();
        let mut target_num = String::new();
        for c in first_word.chars() {
            first_num.push((c as u8 - 97) as char);
        }
        for c in second_word.chars() {
            second_num.push((c as u8 - 97) as char);
        }
        for c in target_word.chars() {
            target_num.push((c as u8 - 97) as char);
        }
        let first_num: i32 = first_num.parse().unwrap();
        let second_num: i32 = second_num.parse().unwrap();
        let target_num: i32 = target_num.parse().unwrap();
        first_num + second_num == target_num

=======

        fn word_to_num(word: String) -> i32 {
            word.chars().map(|c| (c as u8 - b'a') as i32).collect::<Vec<i32>>().join("").parse::<i32>().unwrap()
        }
        word_to_num(first_word) + word_to_num(second_word) == word_to_num(target_word)
