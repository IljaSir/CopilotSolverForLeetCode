Synthesizing 10/10 solutions

=======

        let mut i = 0;
        let mut j = 0;
        let name = name.as_bytes();
        let typed = typed.as_bytes();
        while i < name.len() && j < typed.len() {
            if name[i] == typed[j] {
                i += 1;
                j += 1;
            } else {
                if j == 0 || typed[j] != typed[j - 1] {
                    return false;
                }
                j += 1;
            }
        }
        if i < name.len() {
            return false;
        }
        while j < typed.len() {
            if typed[j] != typed[j - 1] {
                return false;
            }
            j += 1;
        }
        true

=======

        let mut i = 0;
        let mut j = 0;
        let name = name.as_bytes();
        let typed = typed.as_bytes();
        while j < typed.len() {
            if i < name.len() && name[i] == typed[j] {
                i += 1;
                j += 1;
            } else if j > 0 && typed[j] == typed[j-1] {
                j += 1;
            } else {
                return false;
            }
        }
        i == name.len()

=======

        let mut i = 0;
        let mut j = 0;
        let name = name.chars().collect::<Vec<char>>();
        let typed = typed.chars().collect::<Vec<char>>();
        while i < name.len() && j < typed.len() {
            if name[i] == typed[j] {
                i += 1;
                j += 1;
            } else if j > 0 && typed[j] == typed[j - 1] {
                j += 1;
            } else {
                return false;
            }
        }
        if i == name.len() {
            while j < typed.len() {
                if typed[j] != typed[j - 1] {
                    return false;
                }
                j += 1;
            }
            true
        } else {
            false
        }

=======

        let mut i = 0;
        let mut j = 0;
        let name = name.chars().collect::<Vec<_>>();
        let typed = typed.chars().collect::<Vec<_>>();
        while i < name.len() && j < typed.len() {
            if name[i] == typed[j] {
                i += 1;
                j += 1;
            } else if j > 0 && typed[j] == typed[j - 1] {
                j += 1;
            } else {
                return false;
            }
        }
        if i == name.len() {
            while j < typed.len() {
                if typed[j] != typed[j - 1] {
                    return false;
                }
                j += 1;
            }
            return true;
        } else {
            return false;
        }

=======

        let mut name = name.chars();
        let mut typed = typed.chars();
        let mut n = name.next();
        let mut t = typed.next();
        while n.is_some() && t.is_some() {
            if n == t {
                n = name.next();
                t = typed.next();
            } else if t == name.clone().next() {
                t = typed.next();
            } else {
                return false;
            }
        }
        if n.is_none() && t.is_none() {
            true
        } else if n.is_none() && t.is_some() {
            t == name.clone().next()
        } else {
            false
        }

=======

        let mut name = name.chars().peekable();
        let mut typed = typed.chars().peekable();
        while let Some(c) = name.next() {
            if let Some(&d) = typed.peek() {
                if c == d {
                    typed.next();
                } else {
                    return false;
                }
            } else {
                return false;
            }
        }
        true

=======

        let mut i = 0;
        let mut j = 0;
        let mut last = ' ';
        while j < typed.len() {
            if i < name.len() && name.as_bytes()[i] == typed.as_bytes()[j] {
                last = name.as_bytes()[i] as char;
                i += 1;
                j += 1;
            } else if typed.as_bytes()[j] == last as u8 {
                j += 1;
            } else {
                return false;
            }
        }
        i == name.len()

=======

        let mut name = name.chars().peekable();
        let mut typed = typed.chars().peekable();
        while let Some(c) = name.next() {
            if let Some(&d) = typed.peek() {
                if d == c {
                    typed.next();
                } else {
                    while let Some(&d) = typed.peek() {
                        if d == c {
                            typed.next();
                            break;
                        } else {
                            return false;
                        }
                    }
                }
            } else {
                return false;
            }
        }
        true

=======

        let mut last = ' ';
        let mut i = 0;
        let mut j = 0;
        while i < name.len() && j < typed.len() {
            if name.as_bytes()[i] == typed.as_bytes()[j] {
                last = name.as_bytes()[i] as char;
                i += 1;
                j += 1;
            } else if typed.as_bytes()[j] == last as u8 {
                j += 1;
            } else {
                return false;
            }
        }
        if i < name.len() {
            return false;
        }
        while j < typed.len() {
            if typed.as_bytes()[j] != last as u8 {
                return false;
            }
            j += 1;
        }
        return true;

=======

        let mut i = 0;
        let mut j = 0;
        let mut last_c = ' ';
        while j < typed.len() {
            let c = typed.chars().nth(j).unwrap();
            if i < name.len() && name.chars().nth(i).unwrap() == c {
                i += 1;
                j += 1;
            } else if last_c == c {
                j += 1;
            } else {
                return false;
            }
            last_c = c;
        }
        i == name.len()
