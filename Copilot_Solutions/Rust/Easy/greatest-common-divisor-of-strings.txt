Synthesizing 10/10 solutions (Duplicates hidden)

=======

        let (mut s1, mut s2) = (str1, str2);
        if s1.len() < s2.len() {
            std::mem::swap(&mut s1, &mut s2);
        }
        let mut res = String::new();
        for i in 0..s2.len() {
            if s1.len() % (i+1) != 0 || s2.len() % (i+1) != 0 {
                continue;
            }
            let s = &s2[0..=i];
            if s1.matches(s).count() * s.len() == s1.len() && s2.matches(s).count() * s.len() == s2.len() {
                res = s.to_owned();
            }
        }
        res
    }
}

=======

        if str1.len() < str2.len() {
            return Solution::gcd_of_strings(str2, str1);
        } else if !str1.starts_with(&str2) {
            return String::new();
        } else if str2.is_empty() {
            return str1;
        } else {
            return Solution::gcd_of_strings(str1[str2.len()..].to_string(), str2);
        }
    }
}

=======

        if str1 == str2 {
            return str1;
        }
        if str1.len() < str2.len() {
            return Solution::gcd_of_strings(str2, str1);
        }
        if str1.starts_with(&str2) {
            return Solution::gcd_of_strings(str1[str2.len()..].to_string(), str2);
        }
        return String::new();
    }
}

=======

        let (mut s1, mut s2) = (str1, str2);
        while s1.len() != s2.len() {
            if s1.len() > s2.len() {
                s1 = s1.replace(&s2, "");
            } else {
                s2 = s2.replace(&s1, "");
            }
        }
        if s1 == s2 {
            s1
        } else {
            "".to_string()
        }
    }
}

=======

        let (mut s1, mut s2) = (str1, str2);
        while s1 != s2 {
            if s1.len() > s2.len() {
                s1 = s1.replace(&s2, "");
            } else {
                s2 = s2.replace(&s1, "");
            }
        }
        s1

=======

        let mut str1 = str1;
        let mut str2 = str2;
        while str1 != str2 {
            if str1.len() < str2.len() {
                std::mem::swap(&mut str1, &mut str2);
            }
            if !str1.starts_with(&str2) {
                return String::new();
            }
            str1 = str1[str2.len()..].to_string();
        }
        str1
    }
}

=======

        let mut s1 = str1;
        let mut s2 = str2;
        while s1.len() != s2.len() {
            if s1.len() > s2.len() {
                s1 = s1.replace(&s2, "");
            } else {
                s2 = s2.replace(&s1, "");
            }
        }
        if s1 == s2 {
            s1
        } else {
            "".to_string()
        }

=======

        let (mut str1, mut str2) = (str1, str2);
        while str1.len() != str2.len() {
            if str1.len() < str2.len() {
                str2 = str2.replace(&str1, "");
            } else {
                str1 = str1.replace(&str2, "");
            }
        }
        if str1 == str2 {
            str1
        } else {
            "".to_string()
        }
    }
}

=======

        let (str1, str2) = (str1.as_bytes(), str2.as_bytes());
        let (len1, len2) = (str1.len(), str2.len());
        let mut res = String::new();
        for i in 0..len1.min(len2) {
            if str1[i] != str2[i] {
                break;
            }
            res.push(str1[i] as char);
        }
        if !res.is_empty() {
            let mut s1 = String::new();
            let mut s2 = String::new();
            for _ in 0..(len1 / res.len()) {
                s1.push_str(&res);
            }
            for _ in 0..(len2 / res.len()) {
                s2.push_str(&res);
            }
            if s1 == str1 && s2 == str2 {
                return res;
            }
        }
        String::new()
    }
}
