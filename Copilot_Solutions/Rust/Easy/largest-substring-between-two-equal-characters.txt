Synthesizing 10/10 solutions

=======

        let mut max = -1;
        for i in 0..s.len() {
            for j in (i+1..s.len()).rev() {
                if s[i..i+1] == s[j..j+1] {
                    max = std::cmp::max(max, (j-i-1) as i32);
                }
            }
        }
        max

=======

        let mut res = -1;
        let s: Vec<char> = s.chars().collect();
        for i in 0..s.len() {
            for j in (i+1..s.len()).rev() {
                if s[i] == s[j] {
                    res = res.max((j - i - 1) as i32);
                    break;
                }
            }
        }
        res

=======

        let mut max = -1;
        let mut i = 0;
        while i < s.len() {
            let mut j = i + 1;
            while j < s.len() {
                if s.chars().nth(i) == s.chars().nth(j) {
                    max = max.max((j - i - 1) as i32);
                }
                j += 1;
            }
            i += 1;
        }
        max

=======

        let mut map = std::collections::HashMap::new();
        let mut max = -1;
        for (i, c) in s.char_indices() {
            if map.contains_key(&c) {
                max = std::cmp::max(i as i32 - map[&c], max);
            } else {
                map.insert(c, i as i32);
            }
        }
        max

=======

        let mut i = 0;
        let mut j = s.len() - 1;
        let mut max = -1;
        while i < j {
            if s.chars().nth(i).unwrap() == s.chars().nth(j).unwrap() {
                max = max.max((j - i - 1) as i32);
                i += 1;
                j -= 1;
            } else {
                i += 1;
                j -= 1;
            }
        }
        max
    }
}

=======

        let mut res = -1;
        let mut h = std::collections::HashMap::new();
        for (i, c) in s.chars().enumerate() {
            if let Some(&j) = h.get(&c) {
                res = res.max(i as i32 - j as i32 - 1);
            } else {
                h.insert(c, i);
            }
        }
        res

=======

        let mut max_len = -1;
        let mut i = 0;
        while i < s.len() {
            let mut j = s.len() - 1;
            while j > i {
                if s.chars().nth(i).unwrap() == s.chars().nth(j).unwrap() {
                    let len = (j - i - 1) as i32;
                    if max_len < len {
                        max_len = len;
                    }
                    break;
                }
                j -= 1;
            }
            i += 1;
        }
        max_len

=======

        let mut chars = [0; 26];
        for (i, c) in s.bytes().enumerate() {
            let c = c - b'a';
            if chars[c as usize] == 0 {
                chars[c as usize] = i as i32 + 1;
            } else {
                chars[c as usize] = i as i32 - chars[c as usize] + 1;
            }
        }
        *chars.iter().max().unwrap_or(&-1)

=======

        let mut m = vec![-1;26];
        let mut res = -1;
        for (i, x) in s.chars().enumerate() {
            let x = x as usize - 'a' as usize;
            if m[x] == -1 {
                m[x] = i as i32;
            } else {
                res = res.max(i as i32 - m[x] - 1);
            }
        }
        res

=======

        let mut max = -1;
        let mut pos = vec![300; 26];
        for (i, c) in s.bytes().enumerate() {
            let j = c - b'a';
            max = max.max(i as i32 - pos[j as usize]);
            pos[j as usize] = pos[j as usize].min(i as i32);
        }
        max - 1
    }
}
