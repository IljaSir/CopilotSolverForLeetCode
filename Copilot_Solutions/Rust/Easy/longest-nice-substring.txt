Synthesizing 9/10 solutions

=======

        let mut res = String::new();
        for i in 0..s.len() {
            let mut set = HashSet::new();
            for j in i..s.len() {
                let c = s.chars().nth(j).unwrap();
                if c.is_ascii_uppercase() {
                    set.insert(c.to_ascii_lowercase());
                } else {
                    set.insert(c.to_ascii_uppercase());
                }
                if set.is_empty() {
                    if j - i + 1 > res.len() {
                        res = s[i..j + 1].to_string();
                    }
                }
            }
        }
        res

=======

        let s = s.as_bytes();
        let mut res = String::new();
        for i in 0..s.len() {
            let mut v = vec![0; 52];
            for j in i..s.len() {
                let c = s[j];
                if c >= b'a' {
                    v[(c - b'a') as usize] |= 1;
                } else {
                    v[(c - b'A' + 26) as usize] |= 2;
                }
                if v.iter().all(|&x| x == 3) {
                    let ss = String::from_utf8(s[i..j+1].to_vec()).unwrap();
                    if ss.len() > res.len() {
                        res = ss;
                    }
                }
            }
        }
        res

=======

        let mut ans = String::new();
        for i in 0..s.len() {
            for j in i..s.len() {
                let mut cnt = vec![0; 26];
                for c in s[i..=j].chars() {
                    cnt[c as usize - 'A' as usize] += 1;
                }
                let mut ok = true;
                for c in 0..26 {
                    if cnt[c] > 0 && cnt[c + 26] == 0 {
                        ok = false;
                        break;
                    }
                }
                if ok && j - i + 1 > ans.len() {
                    ans = s[i..=j].to_string();
                }
            }
        }
        ans

=======

        let s = s.as_bytes();
        let mut ans = String::new();
        let mut queue = std::collections::VecDeque::new();
        queue.push_back((0, s.len()));
        while let Some((l, r)) = queue.pop_front() {
            let mut count = [0; 26];
            for i in l..r {
                let c = s[i];
                count[(c - b'a') as usize] += 1;
            }
            let mut ok = true;
            for i in 0..26 {
                if count[i] > 0 && count[i] < 2 {
                    ok = false;
                    break;
                }
            }
            if ok {
                if r - l > ans.len() {
                    ans = String::from_utf8(s[l..r].to_vec()).unwrap();
                }
            } else {
                for i in l..r {
                    if count[(s[i] - b'a') as usize] == 1 {
                        queue.push_back((l, i));
                        queue.push_back((i + 1, r));
                        break;
                    }
                }
            }
        }
        ans

=======

        let s = s.as_bytes();
        let mut i = 0;
        let mut j = s.len()-1;
        let mut res = String::new();
        while i < j {
            if s[i].is_ascii_uppercase() && s[j].is_ascii_lowercase() {
                if s[i].to_ascii_lowercase() == s[j] {
                    let left = Self::longest_nice_substring(String::from_utf8(s[i+1..j].to_vec()).unwrap());
                    let right = Self::longest_nice_substring(String::from_utf8(s[i+1..j].to_vec()).unwrap());
                    if left.len() > res.len() {
                        res = left;
                    }
                    if right.len() > res.len() {
                        res = right;
                    }
                    i = j;
                } else {
                    j -= 1;
                }
            } else {
                i += 1;
            }
        }
        res
    }
}

=======

        let mut res = "".to_string();
        for i in 0..s.len() {
            for j in i..s.len() {
                let mut flag = true;
                let mut cnt = vec![0; 26];
                for k in i..=j {
                    let c = s.as_bytes()[k];
                    if c >= b'a' && c <= b'z' {
                        cnt[(c - b'a') as usize] += 1;
                    } else {
                        cnt[(c - b'A') as usize] += 2;
                    }
                }
                for k in 0..26 {
                    if cnt[k] == 1 || cnt[k] == 2 {
                        flag = false;
                        break;
                    }
                }
                if flag && j - i + 1 > res.len() {
                    res = s[i..=j].to_string();
                }
            }
        }
        res
    }
}

=======

        let mut ans = String::new();
        let mut stack = Vec::new();
        for c in s.chars() {
            if stack.is_empty() {
                stack.push(c);
                continue;
            }
            if c.is_ascii_lowercase() {
                if stack.iter().any(|&x| x.to_ascii_uppercase() == c) {
                    stack.push(c);
                } else {
                    ans = ans.max(Self::longest_nice_substring(stack.iter().collect()));
                    stack.clear();
                }
            } else {
                if stack.iter().any(|&x| x.to_ascii_lowercase() == c) {
                    stack.push(c);
                } else {
                    ans = ans.max(Self::longest_nice_substring(stack.iter().collect()));
                    stack.clear();
                }
            }
        }
        ans.max(Self::longest_nice_substring(stack.iter().collect()))

=======

        let mut res = "".to_string();
        let mut stack = vec![];
        let mut i = 0;
        while i < s.len() {
            let c = s.chars().nth(i).unwrap();
            if stack.is_empty() {
                stack.push(c);
                i += 1;
                continue;
            }
            let t = stack.last().unwrap();
            if t.is_lowercase() && t.to_uppercase().to_string() == c.to_string() {
                stack.pop();
                i += 1;
                continue;
            }
            if t.is_uppercase() && t.to_lowercase().to_string() == c.to_string() {
                stack.pop();
                i += 1;
                continue;
            }
            stack.push(c);
            i += 1;
        }
        let mut j = 0;
        while j < stack.len() {
            let mut k = j + 1;
            let mut t = stack[j].to_string();
            while k < stack.len() {
                t.push(stack[k]);
                k += 1;
            }
            if t.len() > res.len() {
                res = t;
            }
            j += 1;
        }
        res

=======

        let mut s = s.into_bytes();
        let mut res = Vec::new();
        for i in 0..s.len() {
            let mut seen = [false; 26];
            let mut ok = true;
            for j in i..s.len() {
                let c = s[j];
                if c.is_ascii_uppercase() {
                    seen[(c - b'A') as usize] = true;
                } else {
                    seen[(c - b'a') as usize] = true;
                }
                if seen.iter().all(|&x| x) {
                    if res.len() < j - i + 1 {
                        res = s[i..j + 1].to_vec();
                    }
                } else {
                    ok = false;
                }
            }
            if ok {
                break;
            }
        }
        String::from_utf8(res).unwrap()
