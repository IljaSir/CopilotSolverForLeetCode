Synthesizing 10/10 solutions

=======

        let mut max = 0;
        for i in 0..nums.len() {
            if nums[i].abs() > max {
                max = nums[i].abs();
            }
        }
        let mut count = vec![0; (max + 1) as usize];
        for i in 0..nums.len() {
            let index = nums[i].abs() as usize;
            count[index] += 1;
        }
        for i in (1..count.len()).rev() {
            if count[i] > 0 && count[i as i32 * -1] > 0 {
                return i as i32;
            }
        }
        -1
    }
}

=======

        let mut nums = nums;
        nums.sort();
        let mut i = nums.len() - 1;
        while i > 0 {
            if nums[i] == nums[i - 1] * -1 {
                return nums[i];
            }
            i -= 1;
        }
        -1
    }
}

=======

        let mut max_k = -1;
        for i in 0..nums.len() {
            for j in i..nums.len() {
                if nums[i] == -nums[j] && nums[i].abs() > max_k {
                    max_k = nums[i].abs();
                }
            }
        }
        max_k
    }
}

=======

        let mut set = std::collections::HashSet::new();
        let mut max = 0;
        for i in nums {
            if i > 0 {
                set.insert(i);
                max = max.max(i);
            }
        }
        for i in 1..=max {
            if !set.contains(&i) {
                return -i as i32;
            }
        }
        -1
    }
}

=======

        let mut max = 0;
        for i in 0..nums.len() {
            if nums[i].abs() > max {
                max = nums[i].abs();
            }
        }
        let mut hash = vec![0; max as usize + 1];
        for i in 0..nums.len() {
            if nums[i] > 0 {
                hash[nums[i] as usize] = 1;
            }
        }
        for i in (1..hash.len()).rev() {
            if hash[i] == 1 && hash[hash.len() - i] == 1 {
                return i as i32;
            }
        }
        return -1;

=======

        let mut max_k = -1;
        for i in 0..nums.len() {
            if nums[i] > 0 {
                if nums.contains(&-nums[i]) {
                    if nums[i] > max_k {
                        max_k = nums[i];
                    }
                }
            }
        }
        max_k
    }
}

=======

        let mut nums = nums;
        nums.sort();
        for i in (0..nums.len()).rev() {
            if nums[i] <= 0 {
                return -1;
            }
            if nums[i] == -nums[i] {
                return nums[i];
            }
        }
        -1

=======

        let mut nums = nums;
        nums.sort();
        nums.reverse();
        let mut i = 0;
        while i < nums.len() {
            let j = i + 1;
            while j < nums.len() {
                if nums[i] == -nums[j] {
                    return nums[i];
                }
                j += 1;
            }
            i += 1;
        }
        -1

=======

        let mut nums = nums;
        nums.sort();
        let mut max = 0;
        for i in 0..nums.len() {
            if nums[i] < 0 {
                let mut j = i + 1;
                while j < nums.len() && nums[j] < 0 {
                    j += 1;
                }
                if j < nums.len() && nums[j] > 0 && -nums[i] == nums[j] {
                    max = max.max(nums[j]);
                }
            }
        }
        if max == 0 {
            return -1;
        }
        max

=======

        let mut a = nums.clone();
        a.sort();
        let mut i = a.len() - 1;
        while i > 0 {
            if a[i] + a[i - 1] == 0 {
                return a[i];
            }
            i -= 1;
        }
        -1
    }
}
