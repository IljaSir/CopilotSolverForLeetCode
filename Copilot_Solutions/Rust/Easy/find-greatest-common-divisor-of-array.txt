Synthesizing 10/10 solutions

=======

        let mut min = nums[0];
        let mut max = nums[0];
        for i in 1..nums.len() {
            if nums[i] < min {
                min = nums[i];
            }
            if nums[i] > max {
                max = nums[i];
            }
        }
        let mut gcd = 1;
        for i in 1..min+1 {
            if min % i == 0 && max % i == 0 {
                gcd = i;
            }
        }
        gcd

=======

        let mut min = nums[0];
        let mut max = nums[0];
        for i in nums {
            if i < min {
                min = i;
            }
            if i > max {
                max = i;
            }
        }
        let mut gcd = 1;
        for i in 2..min+1 {
            if min % i == 0 && max % i == 0 {
                gcd = i;
            }
        }
        gcd
    }
}

=======

        let (mut min, mut max) = (nums[0], nums[0]);
        for n in nums {
            if n < min {
                min = n;
            }
            if n > max {
                max = n;
            }
        }
        //println!("min: {}, max: {}", min, max);
        let mut gcd = 1;
        for i in 1..=min {
            if min % i == 0 && max % i == 0 {
                gcd = i;
            }
        }
        gcd
    }
}

=======

        let mut max = nums[0];
        let mut min = nums[0];
        for i in 1..nums.len() {
            if nums[i] > max {
                max = nums[i];
            }
            if nums[i] < min {
                min = nums[i];
            }
        }
        let mut i = 1;
        let mut gcd = 1;
        while i <= min {
            if min % i == 0 && max % i == 0 {
                gcd = i;
            }
            i += 1;
        }
        gcd

=======

        let min = nums.iter().min().unwrap();
        let max = nums.iter().max().unwrap();
        let mut gcd = 1;
        for i in 1..=*min {
            if min % i == 0 && max % i == 0 {
                gcd = i;
            }
        }
        gcd
    }
}

=======

        let min = nums.iter().min().unwrap();
        let max = nums.iter().max().unwrap();
        let mut gcd = 1;
        for i in 2..=*min {
            if min % i == 0 && max % i == 0 {
                gcd = i;
            }
        }
        gcd
    }
}

=======

        let min = nums.iter().min().unwrap();
        let max = nums.iter().max().unwrap();
        let mut i = min;
        while i > 0 {
            if min % i == 0 && max % i == 0 {
                return *i;
            }
            i -= 1;
        }
        1

=======

        let (mut min, mut max) = (nums[0], nums[0]);
        for &num in nums.iter() {
            min = min.min(num);
            max = max.max(num);
        }
        Self::gcd(min, max)
    }
    fn gcd(a: i32, b: i32) -> i32 {
        if b == 0 {
            a
        } else {
            Self::gcd(b, a % b)
        }

=======

        let max = nums.iter().max().unwrap();
        let min = nums.iter().min().unwrap();
        let mut i = min.clone();
        while i > 0 {
            if max % i == 0 && min % i == 0 {
                return i;
            }
            i -= 1;
        }
        1
    }
}

=======

        let (min, max) = nums.iter().minmax().into_option().unwrap();
        let mut d = *min;
        while d > 1 {
            if min % d == 0 && max % d == 0 {
                return d;
            }
            d -= 1;
        }
        1
    }
}
