Synthesizing 10/10 solutions

=======

        let mut s = String::new();
        for c in word.chars() {
            if c.is_digit(10) {
                s.push(c);
            } else {
                s.push(' ');
            }
        }
        let mut set = std::collections::HashSet::new();
        for s in s.split(' ') {
            if s.len() > 0 {
                set.insert(s.trim_start_matches('0'));
            }
        }
        set.len() as i32

=======

        let mut s = String::new();
        for c in word.chars() {
            if c.is_digit(10) {
                s.push(c);
            } else {
                s.push(' ');
            }
        }
        let mut set = std::collections::HashSet::new();
        for i in s.split_whitespace() {
            let mut s = i.to_string();
            while s.starts_with('0') {
                s.remove(0);
            }
            if s.is_empty() {
                s.push('0');
            }
            set.insert(s);
        }
        set.len() as i32

=======

        let mut s = String::new();
        for c in word.chars() {
            if c.is_ascii_digit() {
                s.push(c);
            } else {
                s.push(' ');
            }
        }
        let mut set = std::collections::HashSet::new();
        for s in s.split_whitespace() {
            set.insert(s.trim_start_matches('0'));
        }
        set.len() as i32

=======

        let mut set = std::collections::HashSet::new();
        let mut str = String::new();
        for c in word.chars() {
            if c.is_digit(10) {
                str.push(c);
            } else {
                if !str.is_empty() {
                    let mut i = 0;
                    while i < str.len() && str.as_bytes()[i] == b'0' {
                        i += 1;
                    }
                    set.insert(str[i..].to_string());
                    str.clear();
                }
            }
        }
        if !str.is_empty() {
            let mut i = 0;
            while i < str.len() && str.as_bytes()[i] == b'0' {
                i += 1;
            }
            set.insert(str[i..].to_string());
        }
        set.len() as i32

=======

        let mut v: Vec<i32> = Vec::new();
        let mut s = String::new();
        for c in word.chars() {
            if c.is_digit(10) {
                s.push(c);
            } else {
                if !s.is_empty() {
                    let n = s.parse().unwrap();
                    if !v.contains(&n) {
                        v.push(n);
                    }
                    s.clear();
                }
            }
        }
        if !s.is_empty() {
            let n = s.parse().unwrap();
            if !v.contains(&n) {
                v.push(n);
            }
        }
        v.len() as i32

=======

        let mut set = std::collections::HashSet::new();
        let mut num = String::new();
        for c in word.chars() {
            if c.is_digit(10) {
                if c == '0' && num.is_empty() {
                    continue;
                }
                num.push(c);
            } else {
                if !num.is_empty() {
                    set.insert(num);
                    num = String::new();
                }
            }
        }
        if !num.is_empty() {
            set.insert(num);
        }
        set.len() as i32

=======

        let mut num = String::new();
        let mut res = HashSet::new();
        for c in word.chars() {
            if c.is_digit(10) {
                num.push(c);
            } else {
                if !num.is_empty() {
                    res.insert(num.trim_start_matches('0').to_string());
                    num.clear();
                }
            }
        }
        if !num.is_empty() {
            res.insert(num.trim_start_matches('0').to_string());
        }
        res.len() as i32

=======

        let mut res: Vec<i32> = vec![];
        let mut num = String::new();
        for c in word.chars() {
            if c.is_digit(10) {
                num.push(c);
            } else {
                if !num.is_empty() {
                    res.push(num.parse::<i32>().unwrap());
                    num.clear();
                }
            }
        }
        if !num.is_empty() {
            res.push(num.parse::<i32>().unwrap());
        }
        res.sort();
        res.dedup();
        res.len() as i32
    }
}

=======

        let mut count = 0;
        let mut num = false;
        let mut set = std::collections::HashSet::new();
        for c in word.chars() {
            if c.is_numeric() {
                if !num {
                    count += 1;
                    num = true;
                }
            } else {
                if num {
                    num = false;
                    set.insert(count);
                    count = 0;
                }
            }
        }
        if num {
            set.insert(count);
        }
        set.len() as i32

=======

        let mut n = 0;
        let mut s = String::new();
        let mut v = Vec::new();
        for c in word.chars() {
            if c.is_numeric() {
                s.push(c);
            } else {
                if !s.is_empty() {
                    v.push(s);
                    s = String::new();
                }
            }
        }
        if !s.is_empty() {
            v.push(s);
        }
        let mut v1 = Vec::new();
        for s in v {
            let mut s1 = String::new();
            for c in s.chars() {
                if c != '0' {
                    s1.push(c);
                }
            }
            if !s1.is_empty() {
                v1.push(s1);
            }
        }
        let mut v2 = Vec::new();
        for s in v1 {
            if !v2.contains(&s) {
                v2.push(s);
                n += 1;
            }
        }
        n
    }
}
