Synthesizing 8/10 solutions

=======

        let sum_alice = alice_sizes.iter().sum::<i32>();
        let sum_bob = bob_sizes.iter().sum::<i32>();
        let diff = (sum_alice - sum_bob) / 2;
        let mut alice_set: std::collections::HashSet<i32> = alice_sizes.into_iter().collect();
        for bob in bob_sizes.into_iter() {
            if alice_set.contains(&(bob + diff)) {
                return vec![bob + diff, bob];
            }
        }
        vec![]
    }
}

=======

        let mut alice_sizes = alice_sizes;
        let mut bob_sizes = bob_sizes;
        alice_sizes.sort();
        bob_sizes.sort();
        let alice_sum: i32 = alice_sizes.iter().sum();
        let bob_sum: i32 = bob_sizes.iter().sum();
        let diff = (alice_sum - bob_sum) / 2;
        let mut i = 0;
        let mut j = 0;
        while i < alice_sizes.len() && j < bob_sizes.len() {
            if alice_sizes[i] - bob_sizes[j] == diff {
                return vec![alice_sizes[i], bob_sizes[j]];
            } else if alice_sizes[i] - bob_sizes[j] > diff {
                j += 1;
            } else {
                i += 1;
            }
        }
        vec![]
    }
}

=======

        let (mut alice, mut bob): (i32, i32) = (0, 0);
        let (mut alice_set, mut bob_set): (std::collections::HashSet<i32>, std::collections::HashSet<i32>) = (std::collections::HashSet::new(), std::collections::HashSet::new());
        for i in alice_sizes.iter() {
            alice += i;
            alice_set.insert(*i);
        }
        for i in bob_sizes.iter() {
            bob += i;
            bob_set.insert(*i);
        }
        let delta = (alice - bob) / 2;
        for i in alice_set.iter() {
            if bob_set.contains(&(i - delta)) {
                return vec![*i, i - delta];
            }
        }
        vec![]
    }
}

=======

        let (mut alice, mut bob) = (0, 0);
        for &x in alice_sizes.iter() {
            alice += x;
        }
        for &x in bob_sizes.iter() {
            bob += x;
        }
        let (mut alice_set, mut bob_set) = (std::collections::HashSet::new(), std::collections::HashSet::new());
        for &x in alice_sizes.iter() {
            alice_set.insert(x);
        }
        for &x in bob_sizes.iter() {
            bob_set.insert(x);
        }
        let (mut alice_vec, mut bob_vec) = (Vec::new(), Vec::new());
        for &x in alice_set.iter() {
            alice_vec.push(x);
        }
        for &x in bob_set.iter() {
            bob_vec.push(x);
        }
        for &x in alice_vec.iter() {
            if bob_set.contains(&(bob - alice + 2 * x)) {
                return vec![x, bob - alice + 2 * x];
            }
        }
        vec![]

=======

        let (mut alice, mut bob) = (0, 0);
        let (mut alice_set, mut bob_set) = (std::collections::HashSet::new(), std::collections::HashSet::new());
        for candy in alice_sizes {
            alice += candy;
            alice_set.insert(candy);
        }
        for candy in bob_sizes {
            bob += candy;
            bob_set.insert(candy);
        }
        let diff = (alice - bob) / 2;
        for candy in alice_set {
            if bob_set.contains(&(candy - diff)) {
                return vec![candy, candy - diff];
            }
        }
        vec![]
    }
}

=======

        let sum_a: i32 = alice_sizes.iter().sum();
        let sum_b: i32 = bob_sizes.iter().sum();
        let mut bob_set: std::collections::HashSet<i32> = bob_sizes.into_iter().collect();
        for a in alice_sizes {
            let b = (sum_b - sum_a) / 2 + a;
            if bob_set.contains(&b) {
                return vec![a, b];
            }
        }
        vec![]

=======

        let (mut sum_a, mut sum_b) = (alice_sizes.iter().sum(), bob_sizes.iter().sum());
        let (mut alice_sizes, mut bob_sizes) = (alice_sizes, bob_sizes);
        alice_sizes.sort();
        bob_sizes.sort();
        let (mut i, mut j) = (0, 0);
        while i < alice_sizes.len() && j < bob_sizes.len() {
            let (a, b) = (alice_sizes[i], bob_sizes[j]);
            if sum_a - a + b == sum_b - b + a {
                return vec![a, b];
            } else if sum_a - a + b > sum_b - b + a {
                j += 1;
            } else {
                i += 1;
            }
        }
        vec![0, 0]
    }
}

=======

        let sum_alice = alice_sizes.iter().sum::<i32>();
        let sum_bob = bob_sizes.iter().sum::<i32>();
        let diff = sum_alice - sum_bob;
        let bob_set: std::collections::HashSet<i32> = bob_sizes.iter().cloned().collect();
        for x in alice_sizes {
            if bob_set.contains(&(x - diff / 2)) {
                return vec![x, x - diff / 2];
            }
        }
        unreachable!()
