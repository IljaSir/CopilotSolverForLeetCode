Synthesizing 8/10 solutions

=======

        let mut rows = vec![0; m as usize];
        let mut cols = vec![0; n as usize];
        for index in indices {
            rows[index[0] as usize] += 1;
            cols[index[1] as usize] += 1;
        }
        let mut odd = 0;
        for row in rows {
            for col in &cols {
                if (row + col) % 2 == 1 {
                    odd += 1;
                }
            }
        }
        odd

=======

        let mut rows = vec![0; m as usize];
        let mut cols = vec![0; n as usize];
        for i in indices {
            rows[i[0] as usize] += 1;
            cols[i[1] as usize] += 1;
        }
        let mut result = 0;
        for i in 0..m {
            for j in 0..n {
                if (rows[i as usize] + cols[j as usize]) % 2 != 0 {
                    result += 1;
                }
            }
        }
        result

=======

        let mut rows = vec![0; m as usize];
        let mut cols = vec![0; n as usize];
        for i in indices {
            rows[i[0] as usize] += 1;
            cols[i[1] as usize] += 1;
        }
        let mut res = 0;
        for i in 0..m {
            for j in 0..n {
                if (rows[i as usize] + cols[j as usize]) % 2 == 1 {
                    res += 1;
                }
            }
        }
        res

=======

        let mut row = vec![0; m as usize];
        let mut col = vec![0; n as usize];
        for i in 0..indices.len() {
            row[indices[i][0] as usize] += 1;
            col[indices[i][1] as usize] += 1;
        }
        let mut odd = 0;
        for i in 0..m as usize {
            for j in 0..n as usize {
                if (row[i] + col[j]) % 2 == 1 {
                    odd += 1;
                }
            }
        }
        odd
    }
}

=======

        let mut matrix = vec![vec![0; n as usize]; m as usize];
        for i in 0..indices.len() {
            let ri = indices[i][0] as usize;
            let ci = indices[i][1] as usize;
            for j in 0..n as usize {
                matrix[ri][j] += 1;
            }
            for j in 0..m as usize {
                matrix[j][ci] += 1;
            }
        }
        let mut res = 0;
        for i in 0..m as usize {
            for j in 0..n as usize {
                if matrix[i][j] % 2 == 1 {
                    res += 1;
                }
            }
        }
        res

=======

        let mut matrix = vec![vec![0; n as usize]; m as usize];
        for index in indices {
            let (r, c) = (index[0] as usize, index[1] as usize);
            for i in 0..n as usize {
                matrix[r][i] += 1;
            }
            for i in 0..m as usize {
                matrix[i][c] += 1;
            }
        }
        let mut count = 0;
        for row in matrix {
            for cell in row {
                if cell % 2 == 1 {
                    count += 1;
                }
            }
        }
        count

=======

        let mut row = vec![0; m as usize];
        let mut col = vec![0; n as usize];
        for i in 0..indices.len() {
            let r = indices[i][0] as usize;
            let c = indices[i][1] as usize;
            row[r] += 1;
            col[c] += 1;
        }
        let mut odd = 0;
        for i in 0..m {
            for j in 0..n {
                let r = row[i as usize];
                let c = col[j as usize];
                if (r + c) & 1 == 1 {
                    odd += 1;
                }
            }
        }
        odd

=======

        let mut matrix = vec![vec![0; n as usize]; m as usize];
        for index in indices {
            let (i, j) = (index[0] as usize, index[1] as usize);
            for k in 0..n as usize {
                matrix[i][k] += 1;
            }
            for k in 0..m as usize {
                matrix[k][j] += 1;
            }
        }
        let mut count = 0;
        for row in matrix {
            for cell in row {
                if cell % 2 == 1 {
                    count += 1;
                }
            }
        }
        count
