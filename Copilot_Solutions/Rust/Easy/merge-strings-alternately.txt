Synthesizing 10/10 solutions (Duplicates hidden)

=======

        let mut res = String::new();
        let mut i = 0;
        let mut j = 0;
        while i < word1.len() || j < word2.len() {
            if i < word1.len() {
                res.push(word1.chars().nth(i).unwrap());
                i += 1;
            }
            if j < word2.len() {
                res.push(word2.chars().nth(j).unwrap());
                j += 1;
            }
        }
        res
    }
}

=======

        let mut res = String::new();
        let mut i = 0;
        let mut j = 0;
        while i < word1.len() || j < word2.len() {
            if i < word1.len() {
                res.push(word1.chars().nth(i).unwrap());
                i += 1;
            }
            if j < word2.len() {
                res.push(word2.chars().nth(j).unwrap());
                j += 1;
            }
        }
        res

=======

        let mut result = String::new();
        let mut i = 0;
        while i < word1.len() && i < word2.len() {
            result.push(word1.chars().nth(i).unwrap());
            result.push(word2.chars().nth(i).unwrap());
            i += 1;
        }
        if word1.len() > word2.len() {
            result.push_str(&word1[i..]);
        } else {
            result.push_str(&word2[i..]);
        }
        result

=======

        let mut res = String::new();
        let mut i = 0;
        let mut j = 0;
        while i < word1.len() && j < word2.len() {
            res.push(word1.chars().nth(i).unwrap());
            res.push(word2.chars().nth(j).unwrap());
            i += 1;
            j += 1;
        }
        if i < word1.len() {
            res.push_str(&word1[i..]);
        }
        if j < word2.len() {
            res.push_str(&word2[j..]);
        }
        res

=======

        let mut res = String::new();
        let mut i = 0;
        let mut j = 0;
        while i < word1.len() && j < word2.len() {
            res.push(word1.chars().nth(i).unwrap());
            res.push(word2.chars().nth(j).unwrap());
            i += 1;
            j += 1;
        }
        while i < word1.len() {
            res.push(word1.chars().nth(i).unwrap());
            i += 1;
        }
        while j < word2.len() {
            res.push(word2.chars().nth(j).unwrap());
            j += 1;
        }
        res

=======

        let mut result = String::new();
        let mut i = 0;
        let mut j = 0;
        while i < word1.len() && j < word2.len() {
            result.push(word1.chars().nth(i).unwrap());
            result.push(word2.chars().nth(j).unwrap());
            i += 1;
            j += 1;
        }
        if i < word1.len() {
            result.push_str(&word1[i..]);
        }
        if j < word2.len() {
            result.push_str(&word2[j..]);
        }
        result
    }
}

=======

        let mut result = String::new();
        let mut word1 = word1.chars();
        let mut word2 = word2.chars();
        loop {
            match (word1.next(), word2.next()) {
                (Some(c1), Some(c2)) => {
                    result.push(c1);
                    result.push(c2);
                }
                (Some(c1), None) => {
                    result.push(c1);
                    result.push_str(word1.as_str());
                    break;
                }
                (None, Some(c2)) => {
                    result.push(c2);
                    result.push_str(word2.as_str());
                    break;
                }
                (None, None) => break,
            }
        }
        result
    }
}

=======

        let mut result = String::new();
        let mut w1 = word1.chars();
        let mut w2 = word2.chars();
        loop {
            match (w1.next(), w2.next()) {
                (Some(c1), Some(c2)) => {
                    result.push(c1);
                    result.push(c2);
                },
                (Some(c1), None) => {
                    result.push(c1);
                },
                (None, Some(c2)) => {
                    result.push(c2);
                },
                (None, None) => {
                    break;
                },
            }
        }
        result
    }
}
