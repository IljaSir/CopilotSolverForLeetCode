Synthesizing 10/10 solutions

=======

        let mut digits = Vec::new();
        let mut n = num;
        while n > 0 {
            digits.push(n % 10);
            n /= 10;
        }
        digits.reverse();
        let mut sum = 0;
        for i in 0..4 {
            let mut new1 = 0;
            for j in 0..i {
                new1 = new1 * 10 + digits[j];
            }
            let mut new2 = 0;
            for j in i..4 {
                new2 = new2 * 10 + digits[j];
            }
            sum = sum.max(new1 + new2);
        }
        sum

=======

        let mut num = num;
        let mut digits = Vec::new();
        while num > 0 {
            digits.push(num % 10);
            num /= 10;
        }
        digits.sort();
        let mut new1 = 0;
        let mut new2 = 0;
        for i in 0..digits.len() {
            if i < 2 {
                new1 = new1 * 10 + digits[i];
            } else {
                new2 = new2 * 10 + digits[i];
            }
        }
        new1 + new2

=======

        let mut num = num;
        let mut digits = Vec::new();
        while num > 0 {
            digits.push(num % 10);
            num /= 10;
        }
        digits.reverse();
        let mut min = 10000;
        for i in 1..4 {
            let mut sum = 0;
            for j in 0..4 {
                if j < i {
                    sum = sum * 10 + digits[j];
                } else {
                    sum += digits[j];
                }
            }
            min = min.min(sum);
        }
        min

=======

        let mut s = num.to_string().chars().collect::<Vec<char>>();
        let mut a = s[0].to_digit(10).unwrap();
        let mut b = s[1].to_digit(10).unwrap();
        let mut c = s[2].to_digit(10).unwrap();
        let mut d = s[3].to_digit(10).unwrap();
        let mut m = 0;
        if a == 0 {
            a = 10;
        }
        if b == 0 {
            b = 10;
        }
        if c == 0 {
            c = 10;
        }
        if d == 0 {
            d = 10;
        }
        if a < b {
            m += a;
            if c < d {
                m += c;
            } else {
                m += d;
            }
        } else {
            m += b;
            if c < d {
                m += c;
            } else {
                m += d;
            }
        }
        return m;

=======

        let mut num = num;
        let mut a = 0;
        let mut b = 0;
        let mut i = 0;
        while num > 0 {
            let r = num % 10;
            num = num / 10;
            if i % 2 == 0 {
                a = a * 10 + r;
            } else {
                b = b * 10 + r;
            }
            i += 1;
        }
        a + b

=======

        let mut num = num;
        let mut num1 = 0;
        let mut num2 = 0;
        let mut i = 0;
        while num > 0 {
            let digit = num % 10;
            if i % 2 == 0 {
                num1 = num1 * 10 + digit;
            } else {
                num2 = num2 * 10 + digit;
            }
            num /= 10;
            i += 1;
        }
        num1 + num2

=======

        let mut sum = num;
        for i in 0..4 {
            let mut new1 = 0;
            let mut new2 = 0;
            for j in 0..4 {
                if j < i {
                    new1 = new1 * 10 + num / 10i32.pow(j as u32) % 10;
                } else {
                    new2 = new2 * 10 + num / 10i32.pow(j as u32) % 10;
                }
            }
            sum = std::cmp::min(sum, new1 + new2);
        }
        sum

=======

        let mut num = num.to_string();
        let mut min = i32::max_value();
        for i in 1..num.len() {
            let mut new1 = num[..i].to_string();
            let mut new2 = num[i..].to_string();
            while new1.len() > 1 && new1.starts_with('0') {
                new1.remove(0);
            }
            while new2.len() > 1 && new2.starts_with('0') {
                new2.remove(0);
            }
            let new1 = new1.parse::<i32>().unwrap();
            let new2 = new2.parse::<i32>().unwrap();
            min = min.min(new1 + new2);
        }
        min

=======

        let mut num = num.to_string().chars().collect::<Vec<char>>();
        num.sort();
        let mut sum = 0;
        let mut i = 0;
        while i < 2 {
            sum += num[i].to_digit(10).unwrap() * 10 + num[i + 2].to_digit(10).unwrap();
            i += 1;
        }
        sum
    }
}

=======

        let mut num = num.to_string();
        let mut min = 10000;
        for i in 1..num.len() {
            let mut l = num[..i].to_string();
            let mut r = num[i..].to_string();
            if l.starts_with('0') {
                l = l[1..].to_string();
            }
            if r.starts_with('0') {
                r = r[1..].to_string();
            }
            let sum = l.parse::<i32>().unwrap() + r.parse::<i32>().unwrap();
            if sum < min {
                min = sum;
            }
        }
        min
