Synthesizing 10/10 solutions

=======

        let mut candy_type = candy_type;
        candy_type.sort();
        let mut count = 0;
        for i in 0..candy_type.len() {
            if i == 0 || candy_type[i] != candy_type[i - 1] {
                count += 1;
            }
        }
        let n = candy_type.len();
        if count > n / 2 {
            return n as i32 / 2;
        }
        count as i32

=======

        let n = candy_type.len() / 2;
        let mut candy_type = candy_type;
        candy_type.sort();
        candy_type.dedup();
        let m = candy_type.len();
        if n < m {
            n as i32
        } else {
            m as i32
        }

=======

        let mut candy_type = candy_type;
        candy_type.sort();
        let mut count = 1;
        let mut i = 1;
        while i < candy_type.len() {
            if candy_type[i] != candy_type[i - 1] {
                count += 1;
            }
            i += 1;
        }
        (candy_type.len() / 2).min(count) as i32
    }
}

=======

        let n = candy_type.len() / 2;
        let mut candy_type = candy_type;
        candy_type.sort();
        candy_type.dedup();
        let m = candy_type.len();
        if n >= m {
            m as i32
        } else {
            n as i32
        }
    }
}

=======

        let n = candy_type.len() / 2;
        let mut candy_type = candy_type;
        candy_type.sort();
        let mut unique_candies = 1;
        for i in 1..candy_type.len() {
            if candy_type[i] != candy_type[i-1] {
                unique_candies += 1;
            }
        }
        unique_candies.min(n) as i32
    }
}

=======

        let n = candy_type.len() / 2;
        let mut kinds = std::collections::HashSet::new();
        for &t in candy_type.iter() {
            kinds.insert(t);
            if kinds.len() >= n {
                break;
            }
        }
        kinds.len().min(n) as i32

=======

        let n = candy_type.len();
        let mut set = std::collections::HashSet::new();
        for candy in candy_type {
            set.insert(candy);
        }
        let m = set.len();
        if m >= n/2 {
            return n as i32 / 2;
        }
        return m as i32;

=======

        let n = candy_type.len() as i32 / 2;
        let mut kinds = std::collections::HashSet::new();
        for t in candy_type {
            kinds.insert(t);
        }
        let kinds = kinds.len() as i32;
        if kinds < n {
            kinds
        } else {
            n
        }

=======

        let mut candy_type = candy_type;
        candy_type.sort();
        let mut candy_type = candy_type.into_iter().unique();
        let mut count = 0;
        while let Some(_) = candy_type.next() {
            count += 1;
        }
        let n = candy_type.len();
        let m = candy_type.len() / 2;
        if count > m {
            m as i32
        } else {
            count as i32
        }

=======

        let mut candy_type = candy_type;
        candy_type.sort();
        let mut count = 0;
        let mut last = candy_type[0];
        for &candy in candy_type.iter() {
            if candy != last {
                count += 1;
                last = candy;
            }
        }
        count.min(candy_type.len() / 2) as i32
    }
}
