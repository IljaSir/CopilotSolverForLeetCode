Synthesizing 10/10 solutions

=======

        let mut set = std::collections::HashSet::new();
        for path in &paths {
            set.insert(&path[0]);
        }
        for path in &paths {
            if !set.contains(&path[1]) {
                return path[1].clone();
            }
        }
        String::new()
    }
}

=======

        let mut start = Vec::new();
        let mut end = Vec::new();
        for p in paths {
            start.push(p[0].clone());
            end.push(p[1].clone());
        }
        for e in end {
            if !start.contains(&e) {
                return e;
            }
        }
        String::from("")

=======

        let mut cities = Vec::new();
        for path in paths {
            cities.push(path[0].clone());
        }
        for path in paths {
            if !cities.contains(&path[1]) {
                return path[1].clone();
            }
        }
        String::new()
    }
}

=======

        let mut map = std::collections::HashMap::new();
        for path in paths {
            map.insert(path[0].clone(), path[1].clone());
        }
        let mut city = map.get("JFK").unwrap().clone();
        while map.contains_key(&city) {
            city = map.get(&city).unwrap().clone();
        }
        city
    }
}

=======

        let mut start = String::new();
        let mut end = String::new();
        for path in paths {
            if start.is_empty() {
                start = path[0].clone();
                end = path[1].clone();
            } else if start == path[0] {
                start = path[1].clone();
            } else if start == path[1] {
                start = path[0].clone();
            } else if end == path[0] {
                end = path[1].clone();
            } else {
                end = path[0].clone();
            }
        }
        end
    }
}

=======

        let mut start = String::new();
        let mut end = String::new();
        for path in paths {
            if start.is_empty() {
                start = path[0].clone();
                end = path[1].clone();
            } else {
                if start == path[0] {
                    start = path[1].clone();
                } else if start == path[1] {
                    start = path[0].clone();
                } else if end == path[0] {
                    end = path[1].clone();
                } else if end == path[1] {
                    end = path[0].clone();
                }
            }
        }
        end

=======

        paths.iter().fold(String::new(), |acc, x| {
            if !paths.iter().any(|y| y[0] == x[1]) {
                return x[1].clone();
            }
            acc
        })
    }
}

=======

        let mut paths = paths;
        let mut start = paths[0][0].clone();
        let mut end = paths[0][1].clone();
        paths.remove(0);
        while paths.len() > 0 {
            let mut i = 0;
            while i < paths.len() {
                if paths[i][0] == start {
                    start = paths[i][1].clone();
                    paths.remove(i);
                    break;
                } else if paths[i][0] == end {
                    end = paths[i][1].clone();
                    paths.remove(i);
                    break;
                } else if paths[i][1] == start {
                    start = paths[i][0].clone();
                    paths.remove(i);
                    break;
                } else if paths[i][1] == end {
                    end = paths[i][0].clone();
                    paths.remove(i);
                    break;
                } else {
                    i += 1;
                }
            }
        }
        end

=======

        let mut hm: std::collections::HashMap<&str, i32> = std::collections::HashMap::new();
        for p in paths.iter() {
            let (a, b) = (p[0].as_str(), p[1].as_str());
            hm.insert(a, hm.get(a).unwrap_or(&0) - 1);
            hm.insert(b, hm.get(b).unwrap_or(&0) + 1);
        }
        for (k, v) in hm.iter() {
            if *v == 1 {
                return k.to_string();
            }
        }
        return "".to_string();
    }
}

=======

        let mut cities = Vec::new();
        for p in paths {
            if let Some(idx) = cities.iter().position(|x| x == &p[0]) {
                cities.remove(idx);
            }
            cities.push(p[1]);
        }
        cities[0].clone()
