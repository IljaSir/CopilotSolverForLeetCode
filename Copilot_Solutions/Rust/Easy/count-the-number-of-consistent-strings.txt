Synthesizing 10/10 solutions (Duplicates hidden)

=======

        let mut count = 0;
        for word in words {
            let mut consistent = true;
            for c in word.chars() {
                if !allowed.contains(c) {
                    consistent = false;
                    break;
                }
            }
            if consistent {
                count += 1;
            }
        }
        count

=======

        let mut count = 0;
        for word in words {
            let mut is_consistent = true;
            for c in word.chars() {
                if !allowed.contains(c) {
                    is_consistent = false;
                    break;
                }
            }
            if is_consistent {
                count += 1;
            }
        }
        count

=======

        let mut count = 0;
        for word in words {
            let mut is_consistent = true;
            for c in word.chars() {
                if !allowed.contains(c) {
                    is_consistent = false;
                    break;
                }
            }
            if is_consistent {
                count += 1;
            }
        }
        return count;

=======

        let mut count = 0;
        for word in words {
            let mut flag = true;
            for ch in word.chars() {
                if !allowed.contains(ch) {
                    flag = false;
                    break;
                }
            }
            if flag {
                count += 1;
            }
        }
        count

=======

        let mut res = 0;
        for word in words {
            let mut flag = true;
            for ch in word.chars() {
                if !allowed.contains(ch) {
                    flag = false;
                    break;
                }
            }
            if flag {
                res += 1;
            }
        }
        res

=======

        let mut cnt = 0;
        for w in words {
            let mut flag = true;
            for c in w.chars() {
                if !allowed.contains(c) {
                    flag = false;
                    break;
                }
            }
            if flag {
                cnt += 1;
            }
        }
        cnt
    }
}

=======

        let mut count = 0;
        let mut allowed = allowed.chars().collect::<Vec<char>>();
        allowed.sort();
        for word in words {
            let mut word = word.chars().collect::<Vec<char>>();
            word.sort();
            let mut i = 0;
            let mut j = 0;
            while i < word.len() && j < allowed.len() {
                if word[i] == allowed[j] {
                    i += 1;
                } else {
                    j += 1;
                }
            }
            if i == word.len() {
                count += 1;
            }
        }
        count
    }
}

=======

        let mut count = 0;
        let mut allowed_set = std::collections::HashSet::new();
        for c in allowed.chars() {
            allowed_set.insert(c);
        }
        for word in words {
            let mut is_consistent = true;
            for c in word.chars() {
                if !allowed_set.contains(&c) {
                    is_consistent = false;
                    break;
                }
            }
            if is_consistent {
                count += 1;
            }
        }
        count
    }
}

=======

        let mut res = 0;
        let mut allowed = allowed.chars().collect::<Vec<char>>();
        allowed.sort_unstable();
        for word in words.iter() {
            let mut chars = word.chars().collect::<Vec<char>>();
            chars.sort_unstable();
            let mut i = 0;
            let mut j = 0;
            while i < allowed.len() && j < chars.len() {
                if allowed[i] == chars[j] {
                    j += 1;
                }
                i += 1;
            }
            if j == chars.len() {
                res += 1;
            }
        }
        res
    }
}
