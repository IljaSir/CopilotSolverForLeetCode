Synthesizing 6/10 solutions

=======

        let mut graph = vec![vec![]; n as usize];
        for edge in edges {
            graph[edge[0] as usize].push(edge[1]);
            graph[edge[1] as usize].push(edge[0]);
        }
        let mut visited = vec![false; n as usize];
        let mut queue = std::collections::VecDeque::new();
        queue.push_back(source);
        while !queue.is_empty() {
            let u = queue.pop_front().unwrap();
            visited[u as usize] = true;
            if u == destination {
                return true;
            }
            for v in &graph[u as usize] {
                if !visited[*v as usize] {
                    queue.push_back(*v);
                }
            }
        }
        false

=======

        let mut graph = vec![vec![]; n as usize];
        for edge in edges {
            graph[edge[0] as usize].push(edge[1]);
            graph[edge[1] as usize].push(edge[0]);
        }
        let mut visited = vec![false; n as usize];
        let mut stack = vec![source];
        while let Some(node) = stack.pop() {
            if node == destination {
                return true;
            }
            visited[node as usize] = true;
            for &neighbor in &graph[node as usize] {
                if !visited[neighbor as usize] {
                    stack.push(neighbor);
                }
            }
        }
        false

=======

        let mut graph = vec![vec![]; n as usize];
        for e in edges {
            graph[e[0] as usize].push(e[1] as usize);
            graph[e[1] as usize].push(e[0] as usize);
        }
        let mut visited = vec![false; n as usize];
        let mut q = std::collections::VecDeque::new();
        q.push_back(source as usize);
        while !q.is_empty() {
            let curr = q.pop_front().unwrap();
            if curr == destination as usize {
                return true;
            }
            visited[curr] = true;
            for &next in &graph[curr] {
                if !visited[next] {
                    q.push_back(next);
                }
            }
        }
        false

=======

        let mut adj = vec![vec![]; n as usize];
        for e in edges {
            adj[e[0] as usize].push(e[1]);
            adj[e[1] as usize].push(e[0]);
        }
        let mut visited = vec![false; n as usize];
        let mut q = vec![source];
        visited[source as usize] = true;
        while !q.is_empty() {
            let mut nq = vec![];
            for u in q {
                if u == destination {
                    return true;
                }
                for v in adj[u as usize].iter() {
                    if !visited[*v as usize] {
                        visited[*v as usize] = true;
                        nq.push(*v);
                    }
                }
            }
            q = nq;
        }
        false

=======

        let mut graph = vec![vec![]; n as usize];
        for e in edges.iter() {
            graph[e[0] as usize].push(e[1] as usize);
            graph[e[1] as usize].push(e[0] as usize);
        }
        let mut visited = vec![false; n as usize];
        let mut stack = vec![source as usize];
        while !stack.is_empty() {
            let i = stack.pop().unwrap();
            if i == destination as usize {
                return true;
            }
            if visited[i] {
                continue;
            }
            visited[i] = true;
            for j in graph[i].iter() {
                stack.push(*j);
            }
        }
        false

=======

        
    }
}
