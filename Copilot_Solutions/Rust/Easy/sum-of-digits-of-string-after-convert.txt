Synthesizing 10/10 solutions

=======

        let mut sum = 0;
        for c in s.chars() {
            let n = c as i32 - 'a' as i32 + 1;
            sum += n / 10 + n % 10;
        }
        let mut k = k;
        while k > 1 {
            let mut tmp = 0;
            while sum > 0 {
                tmp += sum % 10;
                sum /= 10;
            }
            sum = tmp;
            k -= 1;
        }
        sum

=======

        let mut sum = 0;
        for c in s.chars() {
            let mut n = c as i32 - 'a' as i32 + 1;
            while n > 0 {
                sum += n % 10;
                n /= 10;
            }
        }
        if k == 1 {
            return sum;
        }
        return Self::get_lucky(sum.to_string(), k - 1);
    }
}

=======

        let mut sum = 0;
        for c in s.chars() {
            let n = c as i32 - 'a' as i32 + 1;
            sum += n / 10;
            sum += n % 10;
        }
        let mut res = sum;
        for _ in 0..k - 1 {
            res = Self::sum_digits(res);
        }
        res
    }
    fn sum_digits(n: i32) -> i32 {
        let mut sum = 0;
        let mut n = n;
        while n > 0 {
            sum += n % 10;
            n /= 10;
        }
        sum

=======

        let mut sum = 0;
        for c in s.chars() {
            let mut n = c as i32 - 96;
            while n > 0 {
                sum += n % 10;
                n /= 10;
            }
        }
        let mut k = k - 1;
        while k > 0 {
            let mut n = sum;
            sum = 0;
            while n > 0 {
                sum += n % 10;
                n /= 10;
            }
            k -= 1;
        }
        sum

=======

        let mut ans = 0;
        for c in s.chars() {
            ans += (c as i32 - 'a' as i32 + 1) % 10 + (c as i32 - 'a' as i32 + 1) / 10;
        }
        for _ in 1..k {
            let mut tmp = 0;
            while ans > 0 {
                tmp += ans % 10;
                ans /= 10;
            }
            ans = tmp;
        }
        ans

=======

        let mut res: i32 = 0;
        for c in s.chars() {
            let mut n = c as i32 - 96;
            while n > 0 {
                res += n % 10;
                n /= 10;
            }
        }
        for _ in 1..k {
            let mut n = res;
            res = 0;
            while n > 0 {
                res += n % 10;
                n /= 10;
            }
        }
        res

=======

        let mut sum = 0;
        for c in s.chars() {
            let i = c as u8 - b'a' + 1;
            sum += i / 10 + i % 10;
        }
        let mut res = sum;
        for _ in 1..k {
            res = 0;
            while sum > 0 {
                res += sum % 10;
                sum /= 10;
            }
            sum = res;
        }
        res

=======

        let mut r = 0;
        for c in s.chars() {
            let mut n = (c as u8 - b'a') as i32 + 1;
            while n > 0 {
                r += n % 10;
                n /= 10;
            }
        }
        for _ in 1..k {
            let mut n = r;
            r = 0;
            while n > 0 {
                r += n % 10;
                n /= 10;
            }
        }
        r

=======

        let mut sum = 0;
        for c in s.chars() {
            let n = c as u8 - 96;
            sum += (n / 10) + (n % 10);
        }
        for _ in 1..k {
            let mut s = 0;
            while sum > 0 {
                s += sum % 10;
                sum /= 10;
            }
            sum = s;
        }
        sum

=======

        let mut t = String::new();
        for c in s.chars() {
            t.push_str(&(c as u8 - b'a' + 1).to_string());
        }
        let mut x = t.parse::<i32>().unwrap();
        for _ in 0..k {
            let mut y = 0;
            while x > 0 {
                y += x % 10;
                x /= 10;
            }
            x = y;
        }
        x
