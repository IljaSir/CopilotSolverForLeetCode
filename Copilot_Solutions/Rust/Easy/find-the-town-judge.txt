Synthesizing 10/10 solutions

=======

        let mut trust_count = vec![0; n as usize + 1];
        for t in trust {
            trust_count[t[0] as usize] -= 1;
            trust_count[t[1] as usize] += 1;
        }
        for i in 1..=n {
            if trust_count[i as usize] == n - 1 {
                return i;
            }
        }
        -1

=======

        let mut trust_count = vec![0; n as usize];
        for t in trust {
            trust_count[t[0] as usize - 1] -= 1;
            trust_count[t[1] as usize - 1] += 1;
        }
        for i in 0..n as usize {
            if trust_count[i] == n - 1 {
                return (i + 1) as i32;
            }
        }
        -1

=======

        let mut judge = vec![0; n as usize + 1];
        for t in trust {
            judge[t[0] as usize] -= 1;
            judge[t[1] as usize] += 1;
        }
        for i in 1..=n {
            if judge[i as usize] == n - 1 {
                return i;
            }
        }
        -1

=======

        let mut trust_count = vec![0; n as usize];
        for t in trust {
            trust_count[(t[0] - 1) as usize] -= 1;
            trust_count[(t[1] - 1) as usize] += 1;
        }
        for i in 0..n {
            if trust_count[i as usize] == n - 1 {
                return i + 1;
            }
        }
        -1

=======

        let mut count: Vec<i32> = vec![0; n as usize];
        for t in trust {
            count[(t[0] - 1) as usize] -= 1;
            count[(t[1] - 1) as usize] += 1;
        }
        for i in 0..n as usize {
            if count[i] == n - 1 {
                return (i + 1) as i32;
            }
        }
        -1
    }
}

=======

        let mut trust_count = vec![0; n as usize];
        for t in trust.iter() {
            trust_count[(t[0] - 1) as usize] -= 1;
            trust_count[(t[1] - 1) as usize] += 1;
        }
        for i in 0..n {
            if trust_count[i as usize] == n - 1 {
                return i + 1;
            }
        }
        -1

=======

        let mut trust_count = vec![0; n as usize];
        for t in trust.iter() {
            trust_count[(t[0] - 1) as usize] -= 1;
            trust_count[(t[1] - 1) as usize] += 1;
        }
        for (i, c) in trust_count.iter().enumerate() {
            if *c == n - 1 {
                return (i + 1) as i32;
            }
        }
        -1

=======

        let mut trust_counts = vec![0; n as usize];
        for t in trust {
            trust_counts[(t[0] - 1) as usize] -= 1;
            trust_counts[(t[1] - 1) as usize] += 1;
        }
        for (i, c) in trust_counts.iter().enumerate() {
            if *c == n - 1 {
                return (i + 1) as i32;
            }
        }
        -1

=======

        let mut in_degree = vec![0; n as usize];
        let mut out_degree = vec![0; n as usize];
        for edge in trust {
            out_degree[(edge[0] - 1) as usize] += 1;
            in_degree[(edge[1] - 1) as usize] += 1;
        }
        for i in 0..n as usize {
            if in_degree[i] == n - 1 && out_degree[i] == 0 {
                return (i + 1) as i32;
            }
        }
        -1
    }
}

=======

        if n == 1 {
            return 1;
        }
        let mut trust_map = vec![0; n as usize];
        for t in trust {
            trust_map[t[0] as usize - 1] -= 1;
            trust_map[t[1] as usize - 1] += 1;
        }
        for i in 0..n as usize {
            if trust_map[i] == n - 1 {
                return (i + 1) as i32;
            }
        }
        -1
