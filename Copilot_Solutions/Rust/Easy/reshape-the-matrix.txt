Synthesizing 10/10 solutions

=======

        let r = r as usize;
        let c = c as usize;
        let m = mat.len();
        let n = mat[0].len();
        if m * n != r * c {
            return mat;
        }
        let mut res: Vec<Vec<i32>> = vec![vec![0; c]; r];
        for i in 0..m {
            for j in 0..n {
                let idx = i * n + j;
                res[idx / c][idx % c] = mat[i][j];
            }
        }
        res

=======

        let m = mat.len();
        let n = mat[0].len();
        let r = r as usize;
        let c = c as usize;
        if m * n != r * c {
            return mat;
        }
        let mut res = vec![vec![0i32; c]; r];
        for i in 0..m {
            for j in 0..n {
                let k = i * n + j;
                res[k / c][k % c] = mat[i][j];
            }
        }
        res

=======

        let m = mat.len();
        let n = mat[0].len();
        if m * n != (r * c) as usize {
            return mat;
        }
        let mut res = vec![vec![0; c as usize]; r as usize];
        for i in 0..m {
            for j in 0..n {
                let k = i * n + j;
                res[k / c as usize][k % c as usize] = mat[i][j];
            }
        }
        res

=======

        let m = mat.len();
        let n = mat[0].len();
        if m * n != r as usize * c as usize {
            return mat;
        }
        let mut res = vec![vec![0; c as usize]; r as usize];
        for i in 0..m {
            for j in 0..n {
                let idx = i * n + j;
                res[idx / c as usize][idx % c as usize] = mat[i][j];
            }
        }
        res

=======

        let m = mat.len() as i32;
        let n = mat[0].len() as i32;
        if m * n != r * c {
            return mat;
        }
        let mut ret = vec![vec![0; c as usize]; r as usize];
        for i in 0..m {
            for j in 0..n {
                let mut idx = i * n + j;
                let x = idx / c;
                let y = idx % c;
                ret[x as usize][y as usize] = mat[i as usize][j as usize];
            }
        }
        return ret;

=======

        let m = mat.len();
        let n = mat[0].len();
        if m * n != (r * c) as usize {
            return mat;
        }
        let mut result = vec![vec![0; c as usize]; r as usize];
        for i in 0..m {
            for j in 0..n {
                let k = i * n + j;
                result[k / c as usize][k % c as usize] = mat[i][j];
            }
        }
        result

=======

        let (m, n) = (mat.len(), mat[0].len());
        if m * n != (r * c) as usize { return mat; }
        let mut ans = vec![vec![0; c as usize]; r as usize];
        for i in 0..m {
            for j in 0..n {
                ans[(i * n + j) / c as usize][(i * n + j) % c as usize] = mat[i][j];
            }
        }
        ans

=======

        let (m, n) = (mat.len(), mat[0].len());
        if m * n != (r * c) as usize {
            return mat;
        }
        let mut mat = mat.into_iter().flatten().collect::<Vec<_>>();
        let mut res = vec![vec![0; c as usize]; r as usize];
        for i in 0..r {
            for j in 0..c {
                res[i as usize][j as usize] = mat.remove(0);
            }
        }
        res

=======

        let rows = mat.len();
        let columns = mat[0].len();
        let mut v = Vec::new();
        if rows * columns == (r * c) as usize {
            for i in 0..rows {
                for j in 0..columns {
                    v.push(mat[i][j]);
                }
            }
            v.chunks(c as usize).map(|x| x.to_vec()).collect()
        } else {
            mat
        }

=======

        let mut result = Vec::new();
        
        let mut row = Vec::new();
        for v in mat {
            for i in v {
                row.push(i);
            }
        }
        
        if row.len() != r as usize * c as usize {
            return mat;
        }
        
        let mut i = 0;
        while i < row.len() {
            result.push(row[i..i+c as usize].to_vec());
            i += c as usize;
        }
        
        result
