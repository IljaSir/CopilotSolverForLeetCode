Synthesizing 10/10 solutions

=======

        let mut map1 = std::collections::HashMap::new();
        let mut map2 = std::collections::HashMap::new();
        for word in words1 {
            *map1.entry(word).or_insert(0) += 1;
        }
        for word in words2 {
            *map2.entry(word).or_insert(0) += 1;
        }
        let mut count = 0;
        for (word, times) in map1.iter() {
            if *times == 1 && map2.contains_key(word) && map2[word] == 1 {
                count += 1;
            }
        }
        for (word, times) in map2.iter() {
            if *times == 1 && map1.contains_key(word) && map1[word] == 1 {
                count += 1;
            }
        }
        count
    }
}

=======

        let mut map1 = std::collections::HashMap::new();
        let mut map2 = std::collections::HashMap::new();
        for word in words1 {
            *map1.entry(word).or_insert(0) += 1;
        }
        for word in words2 {
            *map2.entry(word).or_insert(0) += 1;
        }
        let mut res = 0;
        for (word, count) in map1 {
            if count == 1 && map2.contains_key(&word) {
                res += 1;
            }
        }
        for (word, count) in map2 {
            if count == 1 && map1.contains_key(&word) {
                res += 1;
            }
        }
        res

=======

        let mut m1 = std::collections::HashMap::new();
        let mut m2 = std::collections::HashMap::new();
        for w in words1 {
            *m1.entry(w).or_insert(0) += 1;
        }
        for w in words2 {
            *m2.entry(w).or_insert(0) += 1;
        }
        let mut ans = 0;
        for (k, v) in m1 {
            if v == 1 && m2.contains_key(&k) && m2[&k] == 1 {
                ans += 1;
            }
        }
        for (k, v) in m2 {
            if v == 1 && m1.contains_key(&k) && m1[&k] == 1 {
                ans += 1;
            }
        }
        ans
    }
}

=======

        let mut map1 = std::collections::HashMap::new();
        let mut map2 = std::collections::HashMap::new();
        for w in words1 {
            *map1.entry(w).or_insert(0) += 1;
        }
        for w in words2 {
            *map2.entry(w).or_insert(0) += 1;
        }
        let mut ans = 0;
        for (k, v) in map1 {
            if v == 1 && map2.get(&k).is_some() {
                ans += 1;
            }
        }
        for (k, v) in map2 {
            if v == 1 && map1.get(&k).is_some() {
                ans += 1;
            }
        }
        ans

=======

        let mut m1 = std::collections::HashMap::new();
        let mut m2 = std::collections::HashMap::new();
        for word in &words1 {
            *m1.entry(word).or_insert(0) += 1;
        }
        for word in &words2 {
            *m2.entry(word).or_insert(0) += 1;
        }
        let mut count = 0;
        for (k, v) in m1 {
            if v == 1 && m2.contains_key(&k) {
                count += 1;
            }
        }
        for (k, v) in m2 {
            if v == 1 && m1.contains_key(&k) {
                count += 1;
            }
        }
        count

=======

        let mut map = std::collections::HashMap::new();
        for w in words1 {
            let count = map.entry(w).or_insert(0);
            *count += 1;
        }
        for w in words2 {
            let count = map.entry(w).or_insert(0);
            *count += 1;
        }
        map.values().filter(|v| **v == 1).count() as i32
    }
}

=======

        let mut count = 0;
        let mut map = std::collections::HashMap::new();
        for word in &words1 {
            *map.entry(word).or_insert(0) += 1;
        }
        for word in &words2 {
            *map.entry(word).or_insert(0) += 1;
        }
        for (_, v) in map {
            if v == 1 {
                count += 1;
            }
        }
        count

=======

        use std::collections::HashMap;
        let mut result = 0;
        let mut map1 = HashMap::new();
        let mut map2 = HashMap::new();
        for word in words1 {
            *map1.entry(word).or_insert(0) += 1;
        }
        for word in words2 {
            *map2.entry(word).or_insert(0) += 1;
        }
        for (word, count) in map1 {
            if count == 1 && map2.contains_key(&word) {
                result += 1;
            }
        }
        for (word, count) in map2 {
            if count == 1 && map1.contains_key(&word) {
                result += 1;
            }
        }
        result

=======

        let mut count = 0;
        let mut words1 = words1;
        let mut words2 = words2;
        words1.sort();
        words2.sort();
        let mut i = 0;
        let mut j = 0;
        while i < words1.len() && j < words2.len() {
            if words1[i] == words2[j] {
                let mut count1 = 0;
                let mut count2 = 0;
                while i < words1.len() && words1[i] == words1[i + count1] {
                    count1 += 1;
                }
                while j < words2.len() && words2[j] == words2[j + count2] {
                    count2 += 1;
                }
                if count1 == 1 && count2 == 1 {
                    count += 1;
                }
                i += count1;
                j += count2;
            } else if words1[i] < words2[j] {
                i += 1;
            } else {
                j += 1;
            }
        }
        count
    }
}

=======

        
    }
}
