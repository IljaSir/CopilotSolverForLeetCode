Synthesizing 10/10 solutions (Duplicates hidden)

=======

        let mut nums = nums;
        nums.sort();
        (nums[nums.len() - 1] * nums[nums.len() - 2]) - (nums[0] * nums[1])

=======

        let mut nums = nums;
        nums.sort();
        nums[nums.len() - 1] * nums[nums.len() - 2] - nums[0] * nums[1]

=======

        let mut nums = nums;
        nums.sort();
        let n = nums.len();
        (nums[n - 1] * nums[n - 2]) - (nums[0] * nums[1])

=======

        let mut nums = nums;
        nums.sort();
        let n = nums.len();
        nums[n - 1] * nums[n - 2] - nums[0] * nums[1]

=======

        let mut nums = nums;
        nums.sort();
        let n = nums.len();
        (nums[n-1] * nums[n-2]) - (nums[0] * nums[1])
    }
}

=======

        let mut nums = nums;
        nums.sort();
        let n = nums.len();
        let a = nums[n - 1] * nums[n - 2];
        let b = nums[0] * nums[1];
        a - b

=======

        let (mut a, mut b, mut c, mut d) = (0, 0, i32::MAX, i32::MAX);
        for i in 0..nums.len() {
            if nums[i] > a {
                b = a;
                a = nums[i];
            } else if nums[i] > b {
                b = nums[i];
            }
            if nums[i] < c {
                d = c;
                c = nums[i];
            } else if nums[i] < d {
                d = nums[i];
            }
        }
        a * b - c * d

=======

        let (mut max, mut min) = (0, 0);
        let (mut max2, mut min2) = (0, 0);
        for &n in nums.iter() {
            if n > max {
                max2 = max;
                max = n;
            } else if n > max2 {
                max2 = n;
            }
            if n < min {
                min2 = min;
                min = n;
            } else if n < min2 {
                min2 = n;
            }
        }
        max * max2 - min * min2
