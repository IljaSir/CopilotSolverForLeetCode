Synthesizing 10/10 solutions

=======

        let mut max1 = std::i32::MIN;
        let mut max2 = std::i32::MIN;
        let mut max3 = std::i32::MIN;
        let mut count = 0;
        for num in nums.iter() {
            if *num > max1 {
                max3 = max2;
                max2 = max1;
                max1 = *num;
                count += 1;
            } else if *num > max2 && *num < max1 {
                max3 = max2;
                max2 = *num;
                count += 1;
            } else if *num > max3 && *num < max2 {
                max3 = *num;
                count += 1;
            }
        }
        if count >= 3 {
            return max3;
        } else {
            return max1;
        }

=======

        let mut max1 = std::i32::MIN;
        let mut max2 = std::i32::MIN;
        let mut max3 = std::i32::MIN;
        for i in 0..nums.len() {
            if nums[i] > max1 {
                max3 = max2;
                max2 = max1;
                max1 = nums[i];
            } else if nums[i] > max2 && nums[i] < max1 {
                max3 = max2;
                max2 = nums[i];
            } else if nums[i] > max3 && nums[i] < max2 {
                max3 = nums[i];
            }
        }
        if max3 == std::i32::MIN {
            max1
        } else {
            max3
        }

=======

        let mut nums = nums;
        nums.sort();
        nums.dedup();
        if nums.len() < 3 {
            return nums[nums.len() - 1];
        } else {
            return nums[nums.len() - 3];
        }

=======

        let mut max = std::i32::MIN;
        let mut second = std::i32::MIN;
        let mut third = std::i32::MIN;
        for num in nums {
            if num > max {
                third = second;
                second = max;
                max = num;
            } else if num > second && num < max {
                third = second;
                second = num;
            } else if num > third && num < second {
                third = num;
            }
        }
        if third == std::i32::MIN {
            max
        } else {
            third
        }
    }
}

=======

        let mut set: std::collections::HashSet<i32> = std::collections::HashSet::new();
        for i in nums {
            set.insert(i);
        }
        let mut vec: Vec<i32> = set.into_iter().collect();
        vec.sort();
        if vec.len() < 3 {
            return vec[vec.len() - 1];
        }
        vec[vec.len() - 3]

=======

        let mut max = i32::MIN;
        let mut second = i32::MIN;
        let mut third = i32::MIN;
        for i in nums {
            if i > max {
                third = second;
                second = max;
                max = i;
            } else if i > second && i < max {
                third = second;
                second = i;
            } else if i > third && i < second {
                third = i;
            }
        }
        if third == i32::MIN {
            max
        } else {
            third
        }

=======

        let mut max = std::i32::MIN;
        let mut max2 = std::i32::MIN;
        let mut max3 = std::i32::MIN;
        let mut flag = false;
        for i in nums {
            if i > max {
                max3 = max2;
                max2 = max;
                max = i;
            } else if i > max2 && i < max {
                max3 = max2;
                max2 = i;
            } else if i > max3 && i < max2 {
                max3 = i;
            } else if i == max || i == max2 || i == max3 {
                continue;
            }
            flag = true;
        }
        if flag {
            return max3;
        }
        max

=======

        let mut nums = nums;
        nums.sort();
        let mut i = 1;
        let mut count = 1;
        while i < nums.len() {
            if nums[i] != nums[i - 1] {
                count += 1;
            }
            if count == 3 {
                return nums[i];
            }
            i += 1;
        }
        return nums[nums.len() - 1];

=======

        let mut nums = nums;
        nums.sort();
        nums.reverse();
        let mut count = 1;
        let mut i = 1;
        while i < nums.len() {
            if nums[i] != nums[i - 1] {
                count += 1;
            }
            if count == 3 {
                return nums[i];
            }
            i += 1;
        }
        nums[0]

=======

        let mut nums = nums;
        nums.sort_unstable();
        let mut i = nums.len() - 2;
        let mut cnt = 1;
        while i > 0 {
            if nums[i] != nums[i + 1] {
                cnt += 1;
                if cnt == 3 {
                    return nums[i];
                }
            }
            i -= 1;
        }
        nums[nums.len() - 1]
