Synthesizing 10/10 solutions

=======

        let mut dp = vec![vec![]; s.len() + 1];
        dp[0] = vec![vec![]];
        for i in 0..s.len() {
            if dp[i].is_empty() {
                continue;
            }
            for word in &word_dict {
                if s[i..].starts_with(word) {
                    for v in &dp[i] {
                        let mut v2 = v.clone();
                        v2.push(word.clone());
                        dp[i + word.len()].push(v2);
                    }
                }
            }
        }
        dp[s.len()].iter().map(|v| v.join(" ")).collect()
    }
}

=======

        let mut dp = vec![vec![]; s.len() + 1];
        dp[0] = vec![vec![]];
        for i in 0..s.len() {
            if dp[i].is_empty() {
                continue;
            }
            for word in &word_dict {
                if s[i..].starts_with(word) {
                    for mut v in &dp[i] {
                        let mut v2 = v.clone();
                        v2.push(word.clone());
                        dp[i + word.len()].push(v2);
                    }
                }
            }
        }
        dp[s.len()].iter().map(|v| v.join(" ")).collect()
    }
}

=======

        let mut dp = vec![vec![]; s.len() + 1];
        dp[0] = vec!["".to_string()];
        for i in 1..=s.len() {
            for j in 0..i {
                if dp[j].len() > 0 && word_dict.contains(&s[j..i].to_string()) {
                    for k in 0..dp[j].len() {
                        dp[i].push(format!("{}{}{}", dp[j][k], if dp[j][k].len() > 0 { " " } else { "" }, &s[j..i]));
                    }
                }
            }
        }
        dp[s.len()].clone()
    }
}

=======

        let mut dp = vec![vec![]; s.len() + 1];
        dp[0] = vec![String::new()];
        for i in 1..=s.len() {
            for j in 0..i {
                if !dp[j].is_empty() && word_dict.contains(&s[j..i].to_string()) {
                    for word in &dp[j] {
                        dp[i].push(format!("{}{}", word, if word.is_empty() { "" } else { " " } ).to_string() + &s[j..i].to_string());
                    }
                }
            }
        }
        dp[s.len()].clone()
    }
}

=======

        let mut dp = vec![vec![]; s.len() + 1];
        dp[0] = vec![vec![]];
        for i in 0..s.len() {
            for j in i + 1..=s.len() {
                if dp[i].is_empty() {
                    continue;
                }
                if word_dict.contains(&s[i..j].to_string()) {
                    dp[j].push(dp[i].iter().map(|x| x.clone()).collect());
                }
            }
        }
        if dp[s.len()].is_empty() {
            return vec![];
        }
        let mut res = vec![];
        for path in dp[s.len()].iter() {
            let mut tmp = vec![];
            for i in 0..path.len() {
                if i == 0 {
                    tmp.push(word_dict[path[i]].clone());
                } else {
                    tmp.push(' ');
                    tmp.push_str(&word_dict[path[i]]);
                }
            }
            res.push(tmp.into_iter().collect());
        }
        res

=======

        let mut dp = vec![vec![]; s.len() + 1];
        dp[0] = vec![vec![]];
        for i in 0..s.len() {
            for j in i..s.len() {
                if dp[i].len() > 0 && word_dict.contains(&s[i..j+1].to_string()) {
                    let mut tmp = dp[i].clone();
                    for mut v in tmp.iter_mut() {
                        v.push(s[i..j+1].to_string());
                    }
                    dp[j + 1].append(&mut tmp);
                }
            }
        }
        let mut ans = vec![];
        for v in dp[s.len()].iter() {
            ans.push(v.join(" "));
        }
        ans
    }
}

=======

        let mut words = std::collections::HashSet::new();
        for word in word_dict {
            words.insert(word);
        }
        let mut dp = vec![vec![]; s.len() + 1];
        dp[0].push(0);
        for i in 0..s.len() {
            if !dp[i].is_empty() {
                for j in i + 1..=s.len() {
                    if words.contains(&s[i..j]) {
                        dp[j].push(i);
                    }
                }
            }
        }
        let mut result = vec![];
        if !dp[s.len()].is_empty() {
            Self::backtrack(&s, &dp, s.len(), &mut vec![], &mut result);
        }
        result
    }
    fn backtrack(s: &str, dp: &Vec<Vec<usize>>, i: usize, path: &mut Vec<String>, result: &mut Vec<String>) {
        if i == 0 {
            result.push(path.iter().rev().map(|s| s.as_str()).collect::<Vec<&str>>().join(" "));
        } else {
            for j in &dp[i] {
                path.push(s[*j..i].to_string());
                Self::backtrack(s, dp, *j, path, result);
                path.pop();
            }
        }

=======

        let mut dp = vec![vec![]; s.len() + 1];
        dp[0] = vec![String::new()];
        for i in 0..s.len() {
            for j in i + 1..=s.len() {
                if dp[i].len() > 0 && word_dict.contains(&s[i..j].to_string()) {
                    dp[j] = dp[j]
                        .iter()
                        .map(|x| {
                            if x.len() == 0 {
                                s[i..j].to_string()
                            } else {
                                format!("{} {}", x, s[i..j])
                            }
                        })
                        .collect();
                }
            }
        }
        dp[s.len()].clone()

=======

        let mut dp = vec![false; s.len() + 1];
        dp[0] = true;
        let mut word_set = std::collections::HashSet::new();
        let mut max_word_length = 0;
        for word in word_dict.iter() {
            word_set.insert(word);
            max_word_length = max_word_length.max(word.len());
        }
        for i in 0..s.len() {
            if !dp[i] {
                continue;
            }
            for j in i + 1..=s.len().min(i + max_word_length) {
                if word_set.contains(&s[i..j]) {
                    dp[j] = true;
                }
            }
        }
        if !dp[s.len()] {
            return vec![];
        }
        let mut ans = vec![];
        let mut path = vec![];
        Self::dfs(&s, &word_set, 0, &mut dp, &mut path, &mut ans);
        ans
    }
    fn dfs(s: &str, word_set: &std::collections::HashSet<&String>, start: usize, dp: &mut Vec<bool>, path: &mut Vec<String>, ans: &mut Vec<String>) {
        if start == s.len() {
            ans.push(path.join(" "));
            return;
        }
        for end in start + 1..=s.len() {
            if !dp[end] {
                continue;
            }
            let word = &s[start..end];
            if word_set.contains(word) {
                path.push(word.to_string());
                Self::dfs(s, word_set, end, dp, path, ans);
                path.pop();
            }
        }

=======

        let mut ans = vec![];
        let mut memo = vec![];
        let word_dict: Vec<&str> = word_dict.iter().map(|s| s.as_str()).collect();
        let s: Vec<char> = s.chars().collect();
        let n = s.len();
        memo.resize(n, vec![]);
        for i in (0..n).rev() {
            let mut tmp = vec![];
            for j in i..n {
                let word = &s[i..j + 1];
                let word = word.iter().collect::<String>();
                if word_dict.contains(&word.as_str()) {
                    if j == n - 1 {
                        tmp.push(word);
                    } else {
                        for word2 in &memo[j + 1] {
                            tmp.push(word + " " + word2);
                        }
                    }
                }
            }
            memo[i] = tmp;
        }
        memo[0].clone()
    }
}
