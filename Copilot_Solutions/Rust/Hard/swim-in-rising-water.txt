Synthesizing 9/10 solutions (Duplicates hidden)

=======

        
    }
}

=======

        let n = grid.len();
        let mut low = 0;
        let mut high = n * n - 1;
        while low < high {
            let mid = low + (high - low) / 2;
            if Solution::can_reach(&grid, mid) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        low
    }
    
    fn can_reach(grid: &Vec<Vec<i32>>, t: i32) -> bool {
        let n = grid.len();
        let mut visited = vec![vec![false; n]; n];
        let mut queue = Vec::new();
        queue.push((0, 0));
        visited[0][0] = true;
        while !queue.is_empty() {
            let (x, y) = queue.remove(0);
            if x == n - 1 && y == n - 1 {
                return true;
            }
            let dirs = vec![(0, 1), (0, -1), (1, 0), (-1, 0)];
            for (dx, dy) in dirs {
                let nx = x as i32 + dx;
                let ny = y as i32 + dy;
                if nx >= 0 && nx < n as i32 && ny >= 0 && ny < n as i32 && !visited[nx as usize][ny as usize] && grid[nx as usize][ny as usize] <= t {
                    queue.push((nx as usize, ny as usize));
                    visited[nx as usize][ny as usize] = true;
                }
            }
        }
        false

=======

        let n = grid.len();
        let mut parent = vec![0; n * n];
        for i in 0..n * n {
            parent[i] = i;
        }
        let mut edges = vec![];
        for i in 0..n {
            for j in 0..n {
                let idx = i * n + j;
                if i > 0 {
                    edges.push((idx - n, idx, grid[i][j].max(grid[i - 1][j])));
                }
                if j > 0 {
                    edges.push((idx - 1, idx, grid[i][j].max(grid[i][j - 1])));
                }
            }
        }
        edges.sort_by(|a, b| a.2.cmp(&b.2));
        let mut res = 0;
        for (u, v, w) in edges {
            if !Solution::union(&mut parent, u, v) {
                continue;
            }
            res = w;
            if Solution::find(&mut parent, 0) == Solution::find(&mut parent, n * n - 1) {
                break;
            }
        }
        res
    }
    fn find(parent: &mut Vec<usize>, x: usize) -> usize {
        if parent[x] != x {
            parent[x] = Solution::find(parent, parent[x]);
        }
        parent[x]
    }
    fn union(parent: &mut Vec<usize>, x: usize, y: usize) -> bool {
        let fx = Solution::find(parent, x);
        let fy = Solution::find(parent, y);
        if fx == fy {
            return false;
        }
        parent[fx] = fy;
        true
