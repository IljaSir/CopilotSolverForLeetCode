Synthesizing 10/10 solutions

=======

        let MOD = 1_000_000_007;
        let mut dp = vec![0; 2];
        let mut has_zero = false;
        for c in binary.chars() {
            if c == '0' {
                has_zero = true;
                dp[0] = (dp[0] + dp[1]) % MOD;
            } else {
                dp[1] = (dp[0] + dp[1] + 1) % MOD;
            }
        }
        let ans = (dp[0] + dp[1] + (has_zero as i32)) % MOD;
        if ans < 0 { ans + MOD } else { ans }

=======

        let mut dp = vec![0; 2];
        let mut has_zero = false;
        for ch in binary.chars() {
            if ch == '0' {
                has_zero = true;
                dp[0] = (dp[0] + dp[1]) % 1_000_000_007;
            } else {
                dp[1] = (dp[0] + dp[1] + 1) % 1_000_000_007;
            }
        }
        if has_zero {
            dp[0] = (dp[0] + dp[1]) % 1_000_000_007;
        } else {
            dp[1] = (dp[0] + dp[1]) % 1_000_000_007;
        }
        dp[1]

=======

        
    }
}

=======

        let mut dp = vec![0; 2];
        let mut has_zero = false;
        for ch in binary.chars() {
            let ch = ch as usize - '0' as usize;
            if ch == 0 {
                has_zero = true;
            } else {
                dp[1] = (dp[0] + dp[1]) % 1_000_000_007;
            }
            dp[0] = (dp[0] + dp[1]) % 1_000_000_007;
        }
        if has_zero {
            (dp[0] + dp[1] + 1) % 1_000_000_007
        } else {
            (dp[0] + dp[1]) % 1_000_000_007
        }

=======

        const MOD: i64 = 1_000_000_000 + 7;
        let mut has_zero = false;
        let mut count = 1;
        let mut prev = 0;
        for c in binary.chars() {
            if c == '0' {
                has_zero = true;
            } else if prev == 0 {
                count += 1;
            } else if prev == 1 {
                count = 2 * count - 1;
            }
            prev = if c == '0' { 0 } else { 1 };
            count %= MOD;
        }
        if has_zero { count = (count + MOD - 1) % MOD; }
        count as i32

=======

        let mut a = 0;
        let mut b = 0;
        let mut c = 0;
        for i in binary.chars() {
            if i == '0' {
                c = (a + b + 1) % 1000000007;
            } else {
                b = (a + b + 1) % 1000000007;
            }
            a = c;
        }
        (a + b + 1) as i32 % 1000000007

=======

        let mut dp = vec![0; 2];
        let mut has_zero = false;
        for &c in binary.as_bytes() {
            dp[c as usize - '0' as usize] = (dp[c as usize - '0' as usize] + dp[1 - c as usize - '0' as usize] + 1) % 1_000_000_007;
            has_zero |= c == b'0';
        }
        if has_zero {
            (dp[0] + dp[1]) % 1_000_000_007
        } else {
            (dp[0] + dp[1] - 1) % 1_000_000_007
        }

=======

        let mut has_0 = false;
        let mut has_1 = false;
        let mut dp0 = 1;
        let mut dp1 = 0;
        let mut mod_val = 1_000_000_007;
        for c in binary.chars() {
            if c == '0' {
                has_0 = true;
                dp0 = (dp0 + dp1) % mod_val;
            } else {
                has_1 = true;
                dp1 = (dp0 + dp1) % mod_val;
            }
        }
        let mut res = dp0 + dp1;
        if has_0 {
            res -= 1;
        }
        (res % mod_val) as i32

=======

        let mut count = 0;
        let mut zero = 0;
        let mut one = 0;
        let mut pre = '0';
        for c in binary.chars() {
            if c == '0' {
                if pre == '0' {
                    zero = 1;
                } else {
                    zero = one + 1;
                }
            } else {
                one = zero + one + 1;
            }
            pre = c;
        }
        if pre == '0' {
            one
        } else {
            (one + zero) % 1_000_000_007
        }

=======

        let mut dp = vec![0; 2];
        let mut modval = 1000000007;
        let mut zero = false;
        for c in binary.chars() {
            if c == '0' {
                zero = true;
                dp[0] = (dp[0] + dp[1]) % modval;
            } else {
                dp[1] = (dp[0] + dp[1] + 1) % modval;
            }
        }
        if zero {
            dp[1]
        } else {
            (dp[1] + 1) % modval
        }
