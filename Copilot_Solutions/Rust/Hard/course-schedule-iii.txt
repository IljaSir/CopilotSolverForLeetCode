Synthesizing 10/10 solutions

=======

        let mut courses = courses;
        courses.sort_by(|a, b| a[1].cmp(&b[1]));
        let mut heap = std::collections::BinaryHeap::new();
        let mut time = 0;
        for course in courses {
            time += course[0];
            heap.push(course[0]);
            if time > course[1] {
                time -= heap.pop().unwrap();
            }
        }
        heap.len() as i32
    }
}

=======

        let mut courses = courses;
        courses.sort_by_key(|c| c[1]);
        let mut pq: std::collections::BinaryHeap<i32> = std::collections::BinaryHeap::new();
        let mut time = 0;
        for c in courses {
            pq.push(c[0]);
            time += c[0];
            if time > c[1] {
                time -= pq.pop().unwrap();
            }
        }
        pq.len() as i32
    }
}

=======

        let mut courses = courses;
        courses.sort_by_key(|c| c[1]);
        let mut heap = std::collections::BinaryHeap::new();
        let mut time = 0;
        for course in courses {
            if time + course[0] <= course[1] {
                time += course[0];
                heap.push(course[0]);
            } else if let Some(&top) = heap.peek() {
                if top > course[0] {
                    time += course[0] - top;
                    heap.pop();
                    heap.push(course[0]);
                }
            }
        }
        heap.len() as i32
    }
}

=======

        let mut courses = courses;
        courses.sort_by_key(|c| c[1]);
        let mut time = 0;
        let mut pq = std::collections::BinaryHeap::new();
        for c in courses {
            if time + c[0] <= c[1] {
                time += c[0];
                pq.push(c[0]);
            } else if let Some(&t) = pq.peek() {
                if t > c[0] {
                    time += c[0] - t;
                    pq.pop();
                    pq.push(c[0]);
                }
            }
        }
        pq.len() as i32
    }
}

=======

        let mut courses = courses;
        courses.sort_by_key(|x| x[1]);
        let mut pq = std::collections::BinaryHeap::new();
        let mut time = 0;
        for course in courses {
            if time + course[0] <= course[1] {
                time += course[0];
                pq.push(course[0]);
            } else if let Some(&max) = pq.peek() {
                if max > course[0] {
                    time -= max - course[0];
                    pq.pop();
                    pq.push(course[0]);
                }
            }
        }
        pq.len() as i32
    }
}

=======

        let mut courses = courses;
        courses.sort_by_key(|v| v[1]);
        let mut pq = std::collections::BinaryHeap::new();
        let mut time = 0;
        for course in courses {
            if time + course[0] <= course[1] {
                time += course[0];
                pq.push(course[0]);
            } else if let Some(&top) = pq.peek() {
                if top > course[0] {
                    time = time - top + course[0];
                    pq.pop();
                    pq.push(course[0]);
                }
            }
        }
        pq.len() as i32

=======

        let mut courses = courses;
        courses.sort_by_key(|v| v[1]);
        let mut pq = std::collections::BinaryHeap::new();
        let mut time = 0;
        for v in courses {
            if time + v[0] <= v[1] {
                time += v[0];
                pq.push(v[0]);
            } else if let Some(&x) = pq.peek() {
                if x > v[0] {
                    time += v[0] - x;
                    pq.pop();
                    pq.push(v[0]);
                }
            }
        }
        pq.len() as i32

=======

        let mut courses = courses;
        courses.sort_by_key(|v| v[1]);
        let mut time = 0;
        let mut heap = std::collections::BinaryHeap::new();
        for v in courses {
            if time + v[0] <= v[1] {
                time += v[0];
                heap.push(v[0]);
            } else if !heap.is_empty() && heap.peek().unwrap() > &v[0] {
                time = time - heap.peek().unwrap() + v[0];
                heap.pop();
                heap.push(v[0]);
            }
        }
        heap.len() as i32
    }
}

=======

        let mut courses = courses;
        courses.sort_by_key(|&c| c[1]);
        let mut heap = std::collections::BinaryHeap::new();
        let mut t = 0;
        for c in courses {
            if t + c[0] <= c[1] {
                t += c[0];
                heap.push(c[0]);
            } else if let Some(&top) = heap.peek() {
                if top > c[0] {
                    t += c[0] - top;
                    heap.pop();
                    heap.push(c[0]);
                }
            }
        }
        heap.len() as i32
    }
}

=======

        
    }
}
