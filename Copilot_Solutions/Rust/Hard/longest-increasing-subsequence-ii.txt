Synthesizing 10/10 solutions

=======

        let n = nums.len();
        let mut dp = vec![1; n];
        for i in 0..n {
            for j in 0..i {
                if (nums[i] - nums[j]).abs() <= k {
                    dp[i] = std::cmp::max(dp[i], dp[j] + 1);
                }
            }
        }
        *dp.iter().max().unwrap()

=======

        let n = nums.len();
        let mut dp = vec![1; n];
        for i in 0..n {
            for j in 0..i {
                if nums[i] - nums[j] <= k {
                    dp[i] = dp[i].max(dp[j] + 1);
                }
            }
        }
        *dp.iter().max().unwrap()

=======

        let mut dp = vec![0; nums.len()];
        for i in 0..nums.len() {
            dp[i] = 1;
            for j in 0..i {
                if (nums[i] - nums[j]).abs() <= k {
                    dp[i] = std::cmp::max(dp[i], dp[j] + 1);
                }
            }
        }
        *dp.iter().max().unwrap()
    }
}

=======

        let mut dp = vec![0; nums.len()];
        let mut res = 0;
        for i in 0..nums.len() {
            dp[i] = 1;
            for j in 0..i {
                if nums[i] - nums[j] <= k {
                    dp[i] = dp[i].max(dp[j] + 1);
                }
            }
            res = res.max(dp[i]);
        }
        res

=======

        let mut dp = vec![0; nums.len()];
        let mut res = 1;
        for i in 0..nums.len() {
            dp[i] = 1;
            for j in 0..i {
                if ((nums[i] - nums[j]).abs() as i32) <= k {
                    dp[i] = dp[i].max(dp[j] + 1);
                }
            }
            res = res.max(dp[i]);
        }
        res
    }
}

=======

        let mut dp = vec![1; nums.len()];
        let mut max = 1;
        for i in 1..nums.len() {
            for j in 0..i {
                if nums[i] - nums[j] <= k {
                    dp[i] = dp[i].max(dp[j] + 1);
                }
            }
            max = max.max(dp[i]);
        }
        max
    }
}

=======

        let mut dp = vec![0; nums.len() + 1];
        let mut ans = 0;
        for i in 0..nums.len() {
            dp[i] = 1;
            for j in 0..i {
                if nums[i] - nums[j] <= k {
                    dp[i] = dp[i].max(dp[j] + 1);
                }
            }
            ans = ans.max(dp[i]);
        }
        ans

=======

        let mut dp = vec![1; nums.len()];
        let mut q = Vec::new();
        for i in 0..nums.len() {
            while let Some(&j) = q.last() {
                if nums[i] - nums[j] > k {
                    break;
                }
                dp[i] = std::cmp::max(dp[i], dp[j] + 1);
                q.pop();
            }
            q.push(i);
        }
        dp.into_iter().max().unwrap()

=======

        let mut lis = vec![];
        for &n in nums.iter() {
            let i = lis.binary_search_by(|&x| x.0.cmp(&n)).unwrap_or_else(|x| x);
            if i == lis.len() {
                lis.push((n, 1));
            } else {
                lis[i].0 = n;
                lis[i].1 += 1;
            }
            if i > 0 {
                lis[i].1 = std::cmp::max(lis[i].1, lis[i-1].1 + 1);
            }
            if i + 1 < lis.len() && lis[i].0 - lis[i+1].0 > k {
                lis.remove(i+1);
            }
        }
        lis.last().unwrap().1
    }
}

=======

        
    }
}
