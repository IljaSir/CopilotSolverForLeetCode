Synthesizing 10/10 solutions (Duplicates hidden)

=======

        let n = stones.len();
        let mut dp = vec![0; n];
        dp[n - 1] = stones[n - 1];
        for i in (0..n - 1).rev() {
            dp[i] = dp[i + 1] + stones[i];
        }
        let mut ans = dp[1];
        for i in 2..n {
            ans = ans.max(dp[i] - ans);
        }
        ans
    }
}

=======

        let n = stones.len();
        let mut dp = vec![0; n];
        dp[n - 1] = stones[n - 1];
        for i in (0..n - 1).rev() {
            dp[i] = dp[i + 1] + stones[i];
        }
        let mut ans = dp[1];
        for i in 2..n {
            ans = ans.max(dp[i] - ans);
        }
        ans

=======

        let n = stones.len();
        let mut dp = vec![0; n];
        dp[n-1] = stones[n-1];
        for i in (0..n-1).rev() {
            dp[i] = dp[i+1] + stones[i];
        }
        let mut res = dp[1];
        for i in 2..n {
            res = res.max(dp[i]);
        }
        res
    }
}

=======

        let mut dp = vec![0; stones.len()];
        dp[0] = stones[0];
        for i in 1..stones.len() {
            dp[i] = dp[i - 1] + stones[i];
        }
        let mut ans = dp[stones.len() - 1];
        for i in 1..stones.len() - 1 {
            ans = ans.max(dp[i] - ans);
        }
        ans

=======

        let n = stones.len();
        let mut prefix = vec![0; n + 1];
        for i in 0..n {
            prefix[i + 1] = prefix[i] + stones[i];
        }
        let mut dp = vec![0; n];
        dp[n - 1] = prefix[n];
        for i in (0..n - 1).rev() {
            dp[i] = std::cmp::max(dp[i + 1], prefix[i + 1] - dp[i + 1]);
        }
        dp[0]

=======

        let mut dp = vec![0; stones.len()];
        dp[1] = stones[0] + stones[1];
        for i in 2..stones.len() {
            dp[i] = dp[i - 1] + stones[i];
        }
        let mut best = dp[stones.len() - 1];
        for i in (2..stones.len() - 1).rev() {
            best = best.max(dp[i] - best);
        }
        best

=======

        let mut acc = vec![0; stones.len()];
        acc[0] = stones[0];
        for i in 1..stones.len() {
            acc[i] = acc[i-1] + stones[i];
        }
        let mut dp = vec![0; stones.len()];
        dp[stones.len()-1] = acc[stones.len()-1];
        for i in (0..stones.len()-1).rev() {
            dp[i] = std::cmp::max(dp[i+1], acc[i] - dp[i+1]);
        }
        dp[1]

=======

        
    }
}
