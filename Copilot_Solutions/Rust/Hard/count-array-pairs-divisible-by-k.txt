Synthesizing 10/10 solutions

=======

        let mut count = 0;
        for i in 0..nums.len() {
            for j in i + 1..nums.len() {
                if nums[i] * nums[j] % k == 0 {
                    count += 1;
                }
            }
        }
        count
    }
}

=======

        let mut count = 0;
        let mut map = std::collections::HashMap::new();
        for i in 0..nums.len() {
            for j in i+1..nums.len() {
                if (nums[i] * nums[j]) % k == 0 {
                    count += 1;
                }
            }
        }
        count
    }
}

=======

        let n = nums.len();
        let mut counts = vec![0; k as usize];
        for &x in nums.iter() {
            counts[(x % k) as usize] += 1;
        }
        let mut ans = 0;
        for i in 0..k {
            let j = (k - i) % k;
            if i == j {
                ans += counts[i as usize] as i64 * (counts[i as usize] - 1) as i64 / 2;
            } else {
                ans += counts[i as usize] as i64 * counts[j as usize] as i64;
            }
        }
        ans

=======

        let mut pairs = 0;
        let mut count = vec![0; k as usize];
        for i in 0..nums.len() {
            for j in i + 1..nums.len() {
                if (nums[i] * nums[j]) % k == 0 {
                    pairs += 1;
                }
            }
        }
        pairs
    }
}

=======

        let mut res = 0;
        let mut cnt = vec![0; k as usize];
        for n in nums {
            let n = n % k;
            if n == 0 {
                res += cnt[0];
            } else if 2 * n == k {
                res += cnt[n as usize];
            } else {
                res += cnt[(k - n) as usize];
            }
            cnt[n as usize] += 1;
        }
        res

=======

        let mut count = 0;
        let n = nums.len();
        let mut freq: Vec<i64> = vec![0; k as usize];
        for i in 0..n {
            freq[(nums[i] % k) as usize] += 1;
        }
        for i in 1..(k / 2) as usize {
            count += freq[i] * freq[(k - i as i32) as usize];
        }
        count += freq[0] * (freq[0] - 1) / 2;
        if k % 2 == 0 {
            count += freq[(k / 2) as usize] * (freq[(k / 2) as usize] - 1) / 2;
        }
        count

=======

        let mut count = 0;
        let mut map = vec![0; k as usize];
        for num in nums {
            let remainder = num % k;
            if remainder == 0 {
                count += map[0];
            } else {
                count += map[(k - remainder) as usize];
            }
            map[remainder as usize] += 1;
        }
        count

=======

        let mut m = std::collections::HashMap::new();
        let mut res = 0;
        for n in nums {
            let r = n % k;
            if r == 0 {
                res += m.get(&0).unwrap_or(&0);
            } else {
                res += m.get(&(k - r)).unwrap_or(&0);
            }
            *m.entry(r).or_insert(0) += 1;
        }
        res

=======

        let mut res = 0;
        let mut map = std::collections::HashMap::new();
        for i in 0..nums.len() {
            let x = nums[i] % k;
            let y = (k - x) % k;
            if let Some(&v) = map.get(&y) {
                res += v;
            }
            *map.entry(x).or_insert(0) += 1;
        }
        res
    }
}

=======

        let mut count = 0;
        let mut res = 0;
        let mut map = std::collections::HashMap::new();
        for i in 0..nums.len() {
            let v = nums[i] % k;
            if v == 0 {
                count += map.get(&v).unwrap_or(&0);
            } else {
                count += map.get(&(k - v)).unwrap_or(&0);
            }
            *map.entry(v).or_insert(0) += 1;
        }
        res += count;
        res
    }
}
