Synthesizing 9/10 solutions (Duplicates hidden)

=======

        let (row, col) = (destination[0] as usize, destination[1] as usize);
        let mut dp = vec![vec![0; col + 1]; row + 1];
        dp[row][col] = 1;
        for i in (0..=row).rev() {
            for j in (0..=col).rev() {
                if i == row && j == col {
                    continue;
                }
                dp[i][j] = dp[i + 1][j] + dp[i][j + 1];
            }
        }
        let mut res = String::new();
        let mut (i, j) = (0, 0);
        let mut k = k - 1;
        while i < row || j < col {
            if i == row {
                res.push('H');
                j += 1;
            } else if j == col {
                res.push('V');
                i += 1;
            } else {
                if dp[i + 1][j] > k {
                    res.push('V');
                    i += 1;
                } else {
                    k -= dp[i + 1][j];
                    res.push('H');
                    j += 1;
                }
            }
        }
        res

=======

        
    }
}

=======

        let mut dp = vec![vec![0; destination[1] as usize + 1]; destination[0] as usize + 1];
        for i in 0..=destination[0] as usize {
            for j in 0..=destination[1] as usize {
                if i == 0 && j == 0 {
                    dp[i][j] = 1;
                } else {
                    dp[i][j] = dp.get(i - 1).map_or(0, |v| v[j]) + dp[i].get(j - 1).map_or(0, |v| *v);
                }
            }
        }
        let mut ans = String::new();
        let mut x = destination[0] as usize;
        let mut y = destination[1] as usize;
        let mut k = k - 1;
        while x > 0 || y > 0 {
            if x == 0 {
                y -= 1;
                ans.push('V');
            } else if y == 0 {
                x -= 1;
                ans.push('H');
            } else {
                if dp[x][y - 1] > k as usize {
                    y -= 1;
                    ans.push('V');
                } else {
                    k -= dp[x][y - 1] as i32;
                    x -= 1;
                    ans.push('H');
                }
            }
        }
        ans

=======

        let mut res = String::new();
        let mut k = k;
        let mut row = destination[0];
        let mut col = destination[1];
        while row > 0 || col > 0 {
            if row == 0 {
                res.push('H');
                col -= 1;
            } else if col == 0 {
                res.push('V');
                row -= 1;
            } else {
                let num = Self::combination(row + col - 1, row - 1);
                if k > num {
                    res.push('V');
                    k -= num;
                    row -= 1;
                } else {
                    res.push('H');
                    col -= 1;
                }
            }
        }
        res
    }
    
    fn combination(n: i32, k: i32) -> i32 {
        let mut res = 1;
        for i in 0..k {
            res = res * (n - i) / (i + 1);
        }
        res

=======

        let mut k = k;
        let mut ans = String::new();
        let mut h = destination[1];
        let mut v = destination[0];
        while h > 0 || v > 0 {
            if h == 0 {
                ans.push('V');
                v -= 1;
            } else if v == 0 {
                ans.push('H');
                h -= 1;
            } else {
                let mut cnt = 1;
                for i in 1..=h {
                    cnt *= v + i;
                    cnt /= i;
                    if cnt >= k {
                        break;
                    }
                }
                if cnt >= k {
                    ans.push('H');
                    h -= 1;
                } else {
                    ans.push('V');
                    v -= 1;
                    k -= cnt;
                }
            }
        }
        ans

=======

        let mut res = String::new();
        let mut k = k;
        let mut row = destination[0];
        let mut col = destination[1];
        for _ in 0..(row + col) {
            let s = Solution::combination(row + col - 1, col - 1);
            if k <= s {
                res.push('H');
                col -= 1;
            } else {
                res.push('V');
                k -= s;
                row -= 1;
            }
        }
        res
    }
    
    pub fn combination(n: i32, k: i32) -> i32 {
        let mut res = 1;
        for i in 0..k {
            res = res * (n - i) / (i + 1);
        }
        res
    }
}

=======

        let mut k = k as usize;
        let mut result = String::new();
        let mut row = destination[0];
        let mut col = destination[1];
        while row > 0 || col > 0 {
            if row == 0 {
                result.push('H');
                col -= 1;
            } else if col == 0 {
                result.push('V');
                row -= 1;
            } else {
                let mut count = Self::combination(row + col - 1, row - 1);
                if k > count {
                    result.push('H');
                    col -= 1;
                    k -= count;
                } else {
                    result.push('V');
                    row -= 1;
                }
            }
        }
        result
    }
    fn combination(n: i32, k: i32) -> usize {
        let mut result = 1;
        for i in 1..=k {
            result = result * (n + 1 - i) / i;
        }
        result as usize

=======

        let mut res = String::new();
        let mut k = k;
        let mut row = destination[0];
        let mut col = destination[1];
        for i in 0..(row + col) {
            if col == 0 {
                res.push_str("H");
                continue;
            }
            let mut count = 0;
            let mut j = 0;
            while j <= col {
                count += Self::c(row + col - i - 1, row - j - 1);
                j += 1;
            }
            if count >= k {
                res.push_str("V");
                row -= 1;
            } else {
                res.push_str("H");
                col -= 1;
                k -= count;
            }
        }
        res
    }
    
    fn c(n: i32, m: i32) -> i32 {
        let mut res = 1;
        for i in 0..m {
            res *= n - i;
            res /= i + 1;
        }
        res
