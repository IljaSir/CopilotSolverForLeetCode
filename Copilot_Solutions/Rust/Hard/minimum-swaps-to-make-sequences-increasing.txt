Synthesizing 9/10 solutions

=======

        let mut swap = 1;
        let mut no_swap = 0;
        for i in 1..nums1.len() {
            if nums1[i-1] >= nums1[i] || nums2[i-1] >= nums2[i] {
                swap += 1;
            } else if nums1[i-1] >= nums2[i] || nums2[i-1] >= nums1[i] {
                swap = no_swap + 1;
            } else {
                let tmp = swap;
                swap = no_swap + 1;
                no_swap = tmp.min(no_swap);
            }
        }
        swap.min(no_swap)

=======

        let n = nums1.len();
        let mut dp = vec![vec![std::i32::MAX; 2]; n];
        dp[0][0] = 0;
        dp[0][1] = 1;
        for i in 1..n {
            if nums1[i] > nums1[i-1] && nums2[i] > nums2[i-1] {
                dp[i][0] = dp[i-1][0];
                dp[i][1] = dp[i-1][1] + 1;
            }
            if nums1[i] > nums2[i-1] && nums2[i] > nums1[i-1] {
                dp[i][0] = dp[i][0].min(dp[i-1][1]);
                dp[i][1] = dp[i][1].min(dp[i-1][0] + 1);
            }
        }
        dp[n-1][0].min(dp[n-1][1])

=======

        let n = nums1.len();
        let mut swap = vec![n as i32; n];
        let mut no_swap = vec![n as i32; n];
        no_swap[0] = 0;
        swap[0] = 1;
        for i in 1..n {
            if nums1[i] > nums1[i-1] && nums2[i] > nums2[i-1] {
                no_swap[i] = no_swap[i-1];
                swap[i] = swap[i-1] + 1;
            }
            if nums1[i] > nums2[i-1] && nums2[i] > nums1[i-1] {
                no_swap[i] = no_swap[i].min(swap[i-1]);
                swap[i] = swap[i].min(no_swap[i-1] + 1);
            }
        }
        no_swap[n-1].min(swap[n-1])

=======

        let (mut swap, mut not_swap) = (1, 0);
        for i in 1..nums1.len() {
            if nums1[i] <= nums1[i-1] || nums2[i] <= nums2[i-1] {
                swap += 1;
            } else if nums1[i] <= nums2[i-1] || nums2[i] <= nums1[i-1] {
                std::mem::swap(&mut swap, &mut not_swap);
                swap += 1;
            } else {
                let min = std::cmp::min(swap, not_swap);
                swap = min + 1;
                not_swap = min;
            }
        }
        std::cmp::min(swap, not_swap)

=======

        let mut swap = 1;
        let mut no_swap = 0;
        let n = nums1.len();
        for i in 1..n {
            if nums1[i - 1] >= nums1[i] || nums2[i - 1] >= nums2[i] {
                swap += 1;
            } else if nums1[i - 1] >= nums2[i] || nums2[i - 1] >= nums1[i] {
                let tmp = swap;
                swap = no_swap + 1;
                no_swap = tmp;
            } else {
                let tmp = swap;
                swap = no_swap + 1;
                no_swap = std::cmp::min(tmp, no_swap);
            }
        }
        std::cmp::min(swap, no_swap)

=======

        use std::cmp::min;
        let n = nums1.len();
        let mut dp1 = vec![0; n];
        let mut dp2 = vec![1; n];
        for i in 1..n {
            if nums1[i] > nums1[i-1] && nums2[i] > nums2[i-1] {
                if nums1[i] > nums2[i-1] && nums2[i] > nums1[i-1] {
                    dp2[i] = min(dp1[i-1], dp2[i-1]) + 1;
                }
                dp1[i] = dp1[i-1];
            } else {
                dp1[i] = dp2[i-1];
                dp2[i] = dp1[i-1] + 1;
            }
        }
        min(dp1[n-1], dp2[n-1])

=======

        let mut swap = vec![1; nums1.len()];
        let mut no_swap = vec![0; nums1.len()];
        for i in 1..nums1.len() {
            if nums1[i-1] < nums1[i] && nums2[i-1] < nums2[i] {
                if nums1[i-1] < nums2[i] && nums2[i-1] < nums1[i] {
                    swap[i] = swap[i-1].min(no_swap[i-1]) + 1;
                    no_swap[i] = no_swap[i-1];
                } else {
                    swap[i] = swap[i-1] + 1;
                    no_swap[i] = no_swap[i-1];
                }
            } else {
                swap[i] = no_swap[i-1] + 1;
                no_swap[i] = swap[i-1];
            }
        }
        swap.last().unwrap().min(no_swap.last().unwrap())

=======

        let (mut swap, mut no_swap) = (1, 0);
        for i in 1..nums1.len() {
            let (mut swap_, mut no_swap_) = (nums1.len() as i32, nums1.len() as i32);
            if nums1[i-1] < nums1[i] && nums2[i-1] < nums2[i] {
                swap_ = swap + 1;
                no_swap_ = no_swap;
            }
            if nums1[i-1] < nums2[i] && nums2[i-1] < nums1[i] {
                swap_ = swap_.min(no_swap + 1);
                no_swap_ = no_swap_.min(swap);
            }
            swap = swap_;
            no_swap = no_swap_;
        }
        swap.min(no_swap)

=======

        
    }
}
