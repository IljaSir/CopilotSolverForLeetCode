Synthesizing 7/10 solutions

=======

        let n = nums.len();
        let mut set: std::collections::BTreeSet<usize> = std::collections::BTreeSet::new();
        for i in 0..n {
            set.insert(i);
        }
        let mut ans: Vec<i64> = vec![0; n];
        let mut max = 0;
        for i in (0..n).rev() {
            let j = remove_queries[i] as usize;
            let mut sum = 0;
            if let Some(&k) = set.range(j..).next() {
                sum += nums[k] as i64;
                set.remove(&k);
            }
            if let Some(&k) = set.range(..j).rev().next() {
                sum += nums[k] as i64;
                set.remove(&k);
            }
            max = max.max(sum);
            ans[i] = max;
        }
        ans

=======

        let n = nums.len();
        let mut seg = vec![0; n + 1];
        let mut seg_sum = vec![0; n + 1];
        let mut ans = vec![0; n];
        let mut max_sum = 0;
        let mut max_seg = 0;
        let mut max_seg_sum = 0;
        for i in 0..n {
            seg[i] = 1;
            seg_sum[i] = nums[i] as i64;
            max_sum += nums[i] as i64;
            max_seg = i as i64;
            max_seg_sum = max_sum;
            ans[i] = max_seg_sum;
        }
        for i in (0..n).rev() {
            let idx = remove_queries[i] as usize;
            max_sum -= nums[idx] as i64;
            let left = if idx == 0 { 0 } else { seg_sum[idx - 1] };
            let right = if idx == n - 1 { 0 } else { seg_sum[n - 1] - seg_sum[idx] };
            let sum = left + right;
            if sum > max_seg_sum {
                max_seg_sum = sum;
                max_seg = max_seg - seg[idx] + 1;
            }
            seg_sum[idx] = left + right;
            seg[idx] = 0;
            ans[i] = max_seg_sum + max_seg;
        }
        ans
    }
}

=======

        let n = nums.len();
        let mut nums = nums;
        let mut remove_queries = remove_queries;
        let mut ans = vec![0; n];
        let mut bit = vec![0; n + 1];
        let mut sum = vec![0; n + 1];
        let mut segs = vec![];
        let mut removed = vec![false; n];
        for i in 0..n {
            sum[i + 1] = sum[i] + nums[i];
        }
        for i in 0..n {
            let idx = remove_queries[i] as usize;
            removed[idx] = true;
            let mut l = 0;
            let mut r = segs.len();
            while l < r {
                let mid = (l + r) / 2;
                if segs[mid].1 < idx {
                    l = mid + 1;
                } else {
                    r = mid;
                }
            }
            let mut r = l;
            while r < segs.len() && segs[r].0 <= idx {
                r += 1;
            }
            let mut l = l;
            let mut left = idx;
            let mut right = idx;
            if l > 0 {
                l -= 1;
                if segs[l].1 >= idx {
                    continue;
                }
                left = segs[l].0;
            }
            if r < segs.len() {
                if segs[r].0 <= idx {
                    continue;
                }
                right = segs[r].1;
            }
            let seg = (left, right);
            segs.insert(l, seg);
            let mut idx = left as usize;
            while idx <= right as usize {
                update(&mut bit, idx, nums[idx]);
                idx += idx & idx.wrapping_neg();
            }
            let mut left = 0;
            let mut right = n;
            while left < right {
                let mid = (left + right) / 2;
                if sum[mid] < sum[idx] {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            let mut right = left;
            while right < n && sum[right + 1] <= sum[idx] {
                right += 1;
            }
            let mut left = left;
            while left > 0 && sum[left

=======

        let n = nums.len();
        let mut ans = vec![0; n];
        let mut nums = nums;
        let mut remove_queries = remove_queries;
        let mut remove_queries: Vec<(usize, usize)> = remove_queries.into_iter().enumerate().map(|(i, v)| (i, v as usize)).collect();
        remove_queries.sort_by(|(_, a), (_, b)| b.cmp(a));
        let mut segs = vec![];
        let mut prev = 0;
        for i in 0..n {
            if nums[i] == 0 {
                if prev < i {
                    segs.push((prev, i));
                }
                prev = i + 1;
            }
        }
        if prev < n {
            segs.push((prev, n));
        }
        for &(i, j) in &segs {
            ans[i] = nums[i..j].iter().sum::<i32>() as i64;
        }
        for &(i, j) in &remove_queries {
            nums[j] = 0;
            if let Some(&(k, l)) = segs.iter().find(|&&(k, l)| k <= j && j < l) {
                segs.retain(|&(k, l)| k != j && j != l - 1);
                if k < j {
                    segs.push((k, j));
                }
                if j + 1 < l {
                    segs.push((j + 1, l));
                }
            }
            for &(k, l) in &segs {
                ans[k] = nums[k..l].iter().sum::<i32>() as i64;
            }
        }
        ans

=======

        let mut nums = nums;
        let mut remove_queries = remove_queries;
        let mut res = vec![0; remove_queries.len()];
        let mut max = 0;
        let mut sum = 0;
        let mut removed = vec![false; nums.len()];
        for i in 0..nums.len() {
            sum += nums[i];
            max = std::cmp::max(max, sum);
        }
        for i in 0..remove_queries.len() {
            let idx = remove_queries[i] as usize;
            removed[idx] = true;
            if idx > 0 && !removed[idx - 1] {
                let mut tmp = nums[idx];
                let mut j = idx + 1;
                while j < nums.len() && !removed[j] {
                    tmp += nums[j];
                    j += 1;
                }
                max = std::cmp::max(max, tmp);
            }
            if idx < nums.len() - 1 && !removed[idx + 1] {
                let mut tmp = nums[idx];
                let mut j = idx - 1;
                while j >= 0 && !removed[j] {
                    tmp += nums[j];
                    j -= 1;
                }
                max = std::cmp::max(max, tmp);
            }
            res[i] = max;
        }
        res

=======

        let mut res = vec![0i64; remove_queries.len()];
        let mut nums = nums;
        let mut sum = 0i64;
        let mut max = 0i64;
        let mut removed = vec![false; nums.len()];
        let mut segs = vec![];
        for i in 0..nums.len() {
            let n = nums[i] as i64;
            if n > 0 {
                sum += n;
                max = max.max(sum);
            } else {
                segs.push(sum);
                sum = 0;
            }
        }
        segs.push(sum);
        for i in (0..remove_queries.len()).rev() {
            let idx = remove_queries[i] as usize;
            if nums[idx] > 0 {
                let mut sum = 0i64;
                let mut j = idx;
                while j > 0 && nums[j - 1] > 0 {
                    sum += nums[j - 1] as i64;
                    j -= 1;
                }
                let mut k = idx;
                while k + 1 < nums.len() && nums[k + 1] > 0 {
                    sum += nums[k + 1] as i64;
                    k += 1;
                }
                let mut seg_idx = 0;
                while seg_idx < segs.len() && segs[seg_idx] != sum {
                    seg_idx += 1;
                }
                segs.remove(seg_idx);
                segs.sort();
                segs.reverse();
                res[i] = max;
            } else {
                res[i] = max;
            }
            nums[idx] = 0;
            max = segs[0];
        }
        res

=======

        let n = nums.len();
        let mut remove_queries = remove_queries;
        let mut answer = vec![0i64; n];
        let mut idx = 0;
        let mut last_max = 0i64;
        let mut sum = 0i64;
        let mut removed = vec![false; n];
        let mut max = 0i64;
        for &i in remove_queries.iter().rev() {
            removed[i as usize] = true;
            if i > 0 && removed[(i - 1) as usize] {
                sum += nums[i as usize] as i64;
                max = max.max(sum);
            } else {
                sum = nums[i as usize] as i64;
                max = max.max(sum);
            }
            if i + 1 < n as i32 && removed[(i + 1) as usize] {
                sum += nums[(i + 1) as usize] as i64;
                max = max.max(sum);
            }
            answer[idx] = max;
            idx += 1;
        }
        answer.reverse();
        answer
