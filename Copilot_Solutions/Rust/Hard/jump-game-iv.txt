Synthesizing 10/10 solutions (Duplicates hidden)

=======

        let n = arr.len();
        let mut pos: HashMap<i32, Vec<usize>> = HashMap::new();
        for (i, &a) in arr.iter().enumerate() {
            pos.entry(a).or_default().push(i);
        }
        let mut q = VecDeque::new();
        let mut vis = vec![false; n];
        q.push_back((0, 0));
        vis[0] = true;
        while let Some((i, step)) = q.pop_front() {
            if i == n - 1 {
                return step;
            }
            for &j in &[i + 1, i + n as usize, i + n as usize].iter().filter(|&&j| j < n) {
                if !vis[j] {
                    vis[j] = true;
                    q.push_back((j, step + 1));
                }
            }
            if let Some(v) = pos.get_mut(&arr[i]) {
                for &j in v.drain(..) {
                    if !vis[j] {
                        vis[j] = true;
                        q.push_back((j, step + 1));
                    }
                }
            }
        }
        0

=======

        use std::collections::HashMap;
        let mut map = HashMap::new();
        for (i, &v) in arr.iter().enumerate() {
            map.entry(v).or_insert(vec![]).push(i);
        }
        let mut vis = vec![false; arr.len()];
        let mut q = vec![(0, 0)];
        vis[0] = true;
        while let Some((i, step)) = q.pop() {
            if i == arr.len() - 1 {
                return step;
            }
            if i > 0 && !vis[i - 1] {
                q.push((i - 1, step + 1));
                vis[i - 1] = true;
            }
            if i < arr.len() - 1 && !vis[i + 1] {
                q.push((i + 1, step + 1));
                vis[i + 1] = true;
            }
            if let Some(v) = map.get(&arr[i]) {
                for &j in v {
                    if !vis[j] {
                        q.push((j, step + 1));
                        vis[j] = true;
                    }
                }
                map.remove(&arr[i]);
            }
        }
        0
    }
}

=======

        let n = arr.len();
        let mut pos = std::collections::HashMap::new();
        for (i, &v) in arr.iter().enumerate() {
            pos.entry(v).or_insert(vec![]).push(i);
        }
        let mut q = std::collections::VecDeque::new();
        let mut vis = vec![false; n];
        q.push_back(0);
        vis[0] = true;
        let mut ans = 0;
        while !q.is_empty() {
            let sz = q.len();
            for _ in 0..sz {
                let u = q.pop_front().unwrap();
                if u == n - 1 {
                    return ans;
                }
                if u > 0 && !vis[u - 1] {
                    q.push_back(u - 1);
                    vis[u - 1] = true;
                }
                if u + 1 < n && !vis[u + 1] {
                    q.push_back(u + 1);
                    vis[u + 1] = true;
                }
                if let Some(&vec) = pos.get(&arr[u]) {
                    for &v in vec.iter() {
                        if !vis[v] {
                            q.push_back(v);
                            vis[v] = true;
                        }
                    }
                    pos.remove(&arr[u]);
                }
            }
            ans += 1;
        }
        ans
    }
}

=======

        
    }
}

=======

        let mut last_pos = std::collections::HashMap::new();
        let mut q = std::collections::VecDeque::new();
        let mut visited = std::collections::HashSet::new();
        q.push_back((0, 0));
        visited.insert(0);
        while let Some((idx, step)) = q.pop_front() {
            if idx == arr.len() - 1 {
                return step;
            }
            if let Some(last_idx) = last_pos.get(&arr[idx]) {
                if !visited.contains(last_idx) {
                    q.push_back((*last_idx, step + 1));
                    visited.insert(*last_idx);
                }
            }
            last_pos.insert(arr[idx], idx);
            if idx > 0 && !visited.contains(&(idx - 1)) {
                q.push_back((idx - 1, step + 1));
                visited.insert(idx - 1);
            }
            if idx < arr.len() - 1 && !visited.contains(&(idx + 1)) {
                q.push_back((idx + 1, step + 1));
                visited.insert(idx + 1);
            }
        }
        0
    }
}

=======

        let n = arr.len();
        let mut graph = vec![vec![]; n];
        let mut seen = vec![false; n];
        let mut queue = Vec::new();
        let mut step = 0;
        for i in 0..n {
            if !seen[i] {
                queue.push(i);
                seen[i] = true;
                while !queue.is_empty() {
                    let mut next = Vec::new();
                    for &x in &queue {
                        if x == n - 1 {
                            return step;
                        }
                        graph[x].push(x + 1);
                        if x > 0 {
                            graph[x].push(x - 1);
                        }
                        for j in 0..n {
                            if arr[j] == arr[x] && j != x {
                                graph[x].push(j);
                            }
                        }
                    }
                    for &x in &queue {
                        for &y in &graph[x] {
                            if !seen[y] {
                                next.push(y);
                                seen[y] = true;
                            }
                        }
                    }
                    queue = next;
                    step += 1;
                }
            }
        }
        step
