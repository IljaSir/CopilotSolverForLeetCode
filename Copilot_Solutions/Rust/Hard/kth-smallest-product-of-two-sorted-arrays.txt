Synthesizing 10/10 solutions

=======

        let (n, m) = (nums1.len(), nums2.len());
        let (mut l, mut r) = (nums1[0] * nums2[0], nums1[n - 1] * nums2[m - 1]);
        while l < r {
            let mid = l + (r - l) / 2;
            let mut c = 0;
            for i in 0..n {
                let mut j = m;
                while j > 0 && nums1[i] * nums2[j - 1] > mid {
                    j -= 1;
                }
                c += j as i64;
            }
            if c < k {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        l

=======

        let (n1, n2) = (nums1.len(), nums2.len());
        let (mut l, mut r) = (nums1[0] * nums2[0], nums1[n1 - 1] * nums2[n2 - 1]);
        while l < r {
            let mid = l + (r - l) / 2;
            let mut count = 0;
            for i in 0..n1 {
                count += nums2.iter().take_while(|v| **v * nums1[i] <= mid).count();
            }
            if count as i64 < k {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        l

=======

        let mut lo = nums1[0] * nums2[0];
        let mut hi = nums1[nums1.len() - 1] * nums2[nums2.len() - 1];
        while lo < hi {
            let mid = lo + (hi - lo) / 2;
            let mut cnt = 0;
            for &n1 in &nums1 {
                if n1 * nums2[0] > mid {
                    break;
                }
                cnt += nums2.binary_search(&((mid / n1) + 1)).unwrap_or_else(|x| x) as i64;
            }
            if cnt < k {
                lo = mid + 1;
            } else {
                hi = mid;
            }
        }
        lo

=======

        let n1 = nums1.len();
        let n2 = nums2.len();
        let mut l = nums1[0] * nums2[0];
        let mut r = nums1[n1 - 1] * nums2[n2 - 1];
        while l < r {
            let mid = (l + r) / 2;
            let mut cnt = 0;
            for i in 0..n1 {
                let mut l = 0;
                let mut r = n2;
                while l < r {
                    let mid = (l + r) / 2;
                    if nums2[mid] * nums1[i] <= mid as i32 {
                        l = mid + 1;
                    } else {
                        r = mid;
                    }
                }
                cnt += l;
            }
            if cnt < k {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        l
    }
}

=======

        let n1 = nums1.len();
        let n2 = nums2.len();
        let mut l = nums1[0] * nums2[0];
        let mut r = nums1[n1 - 1] * nums2[n2 - 1];
        while l < r {
            let m = l + (r - l) / 2;
            let mut cnt = 0;
            for i in 0..n1 {
                cnt += nums2.binary_search(&((m / nums1[i]) + 1)).unwrap_or_else(|x| x) as i64;
            }
            if cnt < k {
                l = m + 1;
            } else {
                r = m;
            }
        }
        l
    }
}

=======

        let (m, n) = (nums1.len(), nums2.len());
        let (mut left, mut right) = (nums1[0] * nums2[0], nums1[m - 1] * nums2[n - 1]);
        while left < right {
            let mid = left + (right - left) / 2;
            let mut count = 0;
            for i in 0..m {
                count += nums2.binary_search(&(mid / nums1[i])).unwrap_or(n) as i64;
            }
            if count < k {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        left

=======

        let mut l = nums1[0] * nums2[0];
        let mut r = nums1[nums1.len()-1] * nums2[nums2.len()-1];
        while l < r {
            let mid = (l + r) / 2;
            let mut count = 0;
            for i in 0..nums1.len() {
                let mut j = 0;
                while j < nums2.len() && nums1[i] * nums2[j] <= mid {
                    j += 1;
                }
                count += j as i64;
            }
            if count < k {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        l
    }
}

=======

        let mut left = nums1[0] * nums2[0];
        let mut right = nums1[nums1.len() - 1] * nums2[nums2.len() - 1];
        let mut mid = 0;
        let mut count = 0;
        while left < right {
            mid = (left + right) / 2;
            count = 0;
            for i in 0..nums1.len() {
                count += nums2.binary_search(&(mid / nums1[i])).unwrap_or_else(|x| x) as i64;
            }
            if count < k {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        left
    }
}

=======

        let mut k = k as usize;
        let mut l = nums1[0] * nums2[0];
        let mut r = nums1[nums1.len()-1] * nums2[nums2.len()-1];
        while l < r {
            let m = l + (r - l) / 2;
            let mut cnt = 0;
            let mut j = nums2.len() - 1;
            for i in 0..nums1.len() {
                while j >= 0 && nums1[i] * nums2[j] > m {
                    j -= 1;
                }
                cnt += j + 1;
            }
            if cnt < k {
                l = m + 1;
            } else {
                r = m;
            }
        }
        l

=======

        let mut a = nums1;
        let mut b = nums2;
        let mut n = a.len();
        let mut m = b.len();
        if n > m {
            std::mem::swap(&mut a, &mut b);
            std::mem::swap(&mut n, &mut m);
        }
        let mut lo = std::i64::MIN;
        let mut hi = std::i64::MAX;
        while lo < hi {
            let mid = lo + (hi - lo) / 2;
            let mut count = 0;
            for i in 0..n {
                count += b.binary_search(&(mid / a[i] as i64)).unwrap_or_else(|x| x) as i64;
            }
            if count < k {
                lo = mid + 1;
            } else {
                hi = mid;
            }
        }
        lo as i64
