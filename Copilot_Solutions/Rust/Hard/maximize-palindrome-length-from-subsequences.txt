Synthesizing 10/10 solutions (Duplicates hidden)

=======

        let s = word1 + &word2;
        let n = s.len();
        let mut dp = vec![vec![0; n]; n];
        for i in 0..n {
            dp[i][i] = 1;
        }
        for l in 2..=n {
            for i in 0..=n - l {
                let j = i + l - 1;
                if s[i..=i] == s[j..=j] {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = dp[i][j - 1].max(dp[i + 1][j]);
                }
            }
        }
        let mut res = 0;
        for i in 0..word1.len() {
            for j in word1.len()..n {
                if s[i..=i] == s[j..=j] {
                    res = res.max(dp[0][i - 1] + dp[i + 1][j - 1] + dp[j + 1][n - 1] + 2);
                }
            }
        }
        res

=======

        let word1 = word1.as_bytes();
        let word2 = word2.as_bytes();
        let n1 = word1.len();
        let n2 = word2.len();
        let mut dp = vec![vec![0; n2 + 1]; n1 + 1];
        for i in 1..=n1 {
            for j in 1..=n2 {
                if word1[i - 1] == word2[j - 1] {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = dp[i - 1][j].max(dp[i][j - 1]);
                }
            }
        }
        let mut ans = 0;
        let mut i = n1;
        let mut j = n2;
        while i > 0 && j > 0 {
            if word1[i - 1] == word2[j - 1] {
                ans += 1;
                i -= 1;
                j -= 1;
            } else if dp[i - 1][j] > dp[i][j - 1] {
                i -= 1;
            } else {
                j -= 1;
            }
        }
        ans * 2 + (n1 + n2 - ans * 2) as i32

=======

        
    }
}

=======

        let mut dp = vec![vec![0; word1.len() + word2.len()]; word1.len() + word2.len()];
        let mut res = 0;
        for i in 0..word1.len() + word2.len() {
            for j in (0..=i).rev() {
                if i == j {
                    dp[i][j] = 1;
                } else {
                    let c1 = if i < word1.len() {
                        word1.chars().nth(i).unwrap()
                    } else {
                        word2.chars().nth(i - word1.len()).unwrap()
                    };
                    let c2 = if j < word1.len() {
                        word1.chars().nth(j).unwrap()
                    } else {
                        word2.chars().nth(j - word1.len()).unwrap()
                    };
                    if c1 == c2 {
                        dp[i][j] = dp[i - 1][j + 1] + 2;
                        res = res.max(dp[i][j]);
                    } else {
                        dp[i][j] = dp[i - 1][j].max(dp[i][j + 1]);
                    }
                }
            }
        }
        res

=======

        let word = format!("{}{}", word1, word2);
        let n = word.len();
        let word = word.as_bytes();
        
        let mut dp = vec![vec![0; n]; n];
        for i in 0..n {
            dp[i][i] = 1;
        }
        for i in (0..n).rev() {
            for j in i+1..n {
                if word[i] == word[j] {
                    dp[i][j] = dp[i+1][j-1] + 2;
                } else {
                    dp[i][j] = std::cmp::max(dp[i+1][j], dp[i][j-1]);
                }
            }
        }
        dp[0][n-1]
    }
}

=======

        let mut dp = vec![vec![0; word1.len() + word2.len()]; word1.len() + word2.len()];
        let mut res = 0;
        let mut s = word1 + &word2;
        for i in (0..s.len()).rev() {
            dp[i][i] = 1;
            for j in i+1..s.len() {
                if s[i] == s[j] {
                    dp[i][j] = dp[i+1][j-1] + 2;
                } else {
                    dp[i][j] = std::cmp::max(dp[i+1][j], dp[i][j-1]);
                }
                if i < word1.len() && j >= word1.len() {
                    res = std::cmp::max(res, dp[i][j]);
                }
            }
        }
        res

=======

        let mut dp = vec![vec![0; word1.len() + word2.len()]; word1.len() + word2.len()];
        let mut ans = 0;
        let mut word = word1 + &word2;
        for i in (0..word1.len() + word2.len()).rev() {
            for j in i + 1..word1.len() + word2.len() {
                if word.chars().nth(i).unwrap() == word.chars().nth(j).unwrap() {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                }
                ans = ans.max(dp[i][j]);
            }
        }
        ans

=======

        let mut dp = vec![vec![0; 2001]; 2001];
        let mut s = word1 + &word2;
        let n = s.len();
        for i in 0..n {
            for j in (0..i).rev() {
                dp[j][i] = if s.chars().nth(i) == s.chars().nth(j) {
                    dp[j + 1][i - 1] + 2
                } else {
                    dp[j + 1][i].max(dp[j][i - 1])
                };
            }
        }
        dp[0][n - 1]
