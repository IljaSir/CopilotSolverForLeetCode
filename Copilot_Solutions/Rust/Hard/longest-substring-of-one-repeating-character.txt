Synthesizing 10/10 solutions

=======

        let mut result = Vec::new();
        let mut s = s.as_bytes().to_vec();
        for i in 0..query_indices.len() {
            s[query_indices[i] as usize] = query_characters.as_bytes()[i];
            let mut count = 0;
            let mut max = 0;
            let mut prev = s[0];
            for c in s {
                if c == prev {
                    count += 1;
                    max = max.max(count);
                } else {
                    count = 1;
                    prev = c;
                }
            }
            result.push(max);
        }
        result
    }
}

=======

        let mut s = s.into_bytes();
        let mut ans = vec![];
        for i in 0..query_indices.len() {
            s[query_indices[i] as usize] = query_characters.as_bytes()[i];
            ans.push(Self::longest_repeating_substring(&s));
        }
        ans
    }
    fn longest_repeating_substring(s: &[u8]) -> i32 {
        let mut ans = 1;
        let mut cnt = 1;
        for i in 1..s.len() {
            if s[i] == s[i-1] {
                cnt += 1;
            } else {
                cnt = 1;
            }
            ans = ans.max(cnt);
        }
        ans
    }
}

=======

        let mut s = s.into_bytes();
        let query_characters = query_characters.into_bytes();
        let mut res = vec![];
        for (i, &c) in query_characters.iter().enumerate() {
            s[query_indices[i] as usize] = c;
            let mut max = 0;
            let mut curr = 0;
            let mut prev = 0;
            for &c in s.iter() {
                if c == prev {
                    curr += 1;
                } else {
                    max = max.max(curr);
                    curr = 1;
                    prev = c;
                }
            }
            max = max.max(curr);
            res.push(max);
        }
        res
    }
}

=======

        let mut s = s.into_bytes();
        let query_characters = query_characters.into_bytes();
        let mut res = vec![];
        for (i, &c) in query_characters.iter().enumerate() {
            s[query_indices[i] as usize] = c;
            let mut cnt = 0;
            let mut max = 0;
            for &c in s.iter() {
                if c == query_characters[i] {
                    cnt += 1;
                    if cnt > max {
                        max = cnt;
                    }
                } else {
                    cnt = 0;
                }
            }
            res.push(max);
        }
        res

=======

        let mut s: Vec<char> = s.chars().collect();
        let mut result = vec![];
        for (i, &index) in query_indices.iter().enumerate() {
            s[index as usize] = query_characters.chars().nth(i).unwrap();
            let mut max = 0;
            let mut count = 0;
            let mut last = ' ';
            for c in s.iter() {
                if *c == last {
                    count += 1;
                } else {
                    count = 1;
                    last = *c;
                }
                if count > max {
                    max = count;
                }
            }
            result.push(max);
        }
        result
    }
}

=======

        let mut result = Vec::new();
        let mut s = s.into_bytes();
        for (q, i) in query_characters.into_bytes().iter().zip(query_indices) {
            s[i as usize] = *q;
            let mut count = 1;
            let mut max_count = 1;
            for j in 1..s.len() {
                if s[j] == s[j - 1] {
                    count += 1;
                    if count > max_count {
                        max_count = count;
                    }
                } else {
                    count = 1;
                }
            }
            result.push(max_count);
        }
        result

=======

        let mut s = s.chars().collect::<Vec<char>>();
        let mut ans = vec![];
        for (i, &c) in query_characters.chars().enumerate() {
            let idx = query_indices[i] as usize;
            let old = s[idx];
            s[idx] = c;
            ans.push(Self::longest_repeating_substring(s.as_slice()));
            s[idx] = old;
        }
        ans
    }
    fn longest_repeating_substring(s: &[char]) -> i32 {
        let mut ans = 1;
        let mut cur = 1;
        for i in 1..s.len() {
            if s[i] == s[i - 1] {
                cur += 1;
            } else {
                ans = ans.max(cur);
                cur = 1;
            }
        }
        ans.max(cur)

=======

        let mut s = s.into_bytes();
        let mut res = vec![];
        for (i, &c) in query_characters.as_bytes().iter().enumerate() {
            let index = query_indices[i] as usize;
            let old = s[index];
            s[index] = c;
            let mut count = 0;
            let mut max = 0;
            for &c in s.iter() {
                if c == old {
                    count += 1;
                    if count > max {
                        max = count;
                    }
                } else {
                    count = 0;
                }
            }
            res.push(max);
        }
        res

=======

        let s = s.as_bytes();
        let query_characters = query_characters.as_bytes();
        let mut result = Vec::new();
        for (i, &ch) in query_characters.iter().enumerate() {
            let mut count = 0;
            let mut max = 0;
            for j in 0..s.len() {
                if s[j] == ch {
                    count += 1;
                    max = std::cmp::max(max, count);
                } else {
                    count = 0;
                }
                if j == query_indices[i] as usize {
                    result.push(max);
                }
            }
        }
        result
    }
}

=======

        
    }
}
