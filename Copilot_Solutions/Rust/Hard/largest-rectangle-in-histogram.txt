Synthesizing 10/10 solutions

=======

        let mut heights = heights;
        heights.push(0);
        let mut stack = Vec::new();
        let mut ans = 0;
        for i in 0..heights.len() {
            while !stack.is_empty() && heights[*stack.last().unwrap()] >= heights[i] {
                let h = heights[stack.pop().unwrap()];
                let w = if stack.is_empty() { i } else { i - stack.last().unwrap() - 1 };
                ans = ans.max(h * w as i32);
            }
            stack.push(i);
        }
        ans

=======

        let mut stack = vec![-1];
        let mut max_area = 0;
        for i in 0..heights.len() {
            while stack.len() > 1 && heights[stack[stack.len() - 1] as usize] >= heights[i] {
                let height = heights[stack.pop().unwrap() as usize];
                let width = (i as i32) - stack[stack.len() - 1] - 1;
                max_area = max_area.max(height * width);
            }
            stack.push(i as i32);
        }
        while stack.len() > 1 {
            let height = heights[stack.pop().unwrap() as usize];
            let width = (heights.len() as i32) - stack[stack.len() - 1] - 1;
            max_area = max_area.max(height * width);
        }
        max_area
    }
}

=======

        let mut stack = vec![];
        let mut max_area = 0;
        let mut heights = heights;
        heights.push(0);
        for i in 0..heights.len() {
            while !stack.is_empty() && heights[stack[stack.len()-1]] > heights[i] {
                let h = heights[stack.pop().unwrap()];
                let w = if stack.is_empty() { i } else { i - stack[stack.len()-1] - 1 };
                max_area = max_area.max(h * w as i32);
            }
            stack.push(i);
        }
        max_area

=======

        let mut stack = Vec::new();
        let mut ans = 0;
        let mut heights = heights;
        heights.push(0);
        for i in 0..heights.len() {
            while !stack.is_empty() && heights[*stack.last().unwrap()] > heights[i] {
                let h = heights[stack.pop().unwrap()];
                let w = if stack.is_empty() { i } else { i - stack.last().unwrap() - 1 };
                ans = ans.max(h * w as i32);
            }
            stack.push(i);
        }
        ans

=======

        let mut heights = heights;
        heights.push(0);
        let mut stack = vec![];
        let mut ans = 0;
        for (i, &h) in heights.iter().enumerate() {
            while let Some(&j) = stack.last() {
                if heights[j] < h {
                    break;
                }
                stack.pop();
                let left = if let Some(&k) = stack.last() {
                    k + 1
                } else {
                    0
                };
                ans = ans.max(heights[j] * (i - left) as i32);
            }
            stack.push(i);
        }
        ans

=======

        let mut stack = Vec::new();
        let mut max_area = 0;
        let mut i = 0;
        while i < heights.len() {
            if stack.is_empty() || heights[i] > heights[*stack.last().unwrap()] {
                stack.push(i);
                i += 1;
            } else {
                let top = stack.pop().unwrap();
                let area = heights[top] * (if stack.is_empty() { i as i32 } else { i as i32 - stack.last().unwrap() as i32 - 1 });
                max_area = max_area.max(area);
            }
        }
        while !stack.is_empty() {
            let top = stack.pop().unwrap();
            let area = heights[top] * (if stack.is_empty() { i as i32 } else { i as i32 - stack.last().unwrap() as i32 - 1 });
            max_area = max_area.max(area);
        }
        max_area
    }
}

=======

        let mut max_area = 0;
        let mut stack: Vec<usize> = Vec::new();
        let mut heights = heights;
        heights.push(0);
        for i in 0..heights.len() {
            while let Some(&top) = stack.last() {
                if heights[top] >= heights[i] {
                    stack.pop();
                    let width = if let Some(&last) = stack.last() {
                        i - last - 1
                    } else {
                        i
                    };
                    let area = heights[top] * width as i32;
                    max_area = max_area.max(area);
                } else {
                    break;
                }
            }
            stack.push(i);
        }
        max_area

=======

        let mut stack: Vec<usize> = vec![];
        let mut ans = 0;
        let mut heights = heights;
        heights.push(0);
        for i in 0..heights.len() {
            while let Some(&top) = stack.last() {
                if heights[top] > heights[i] {
                    stack.pop();
                    let width = if let Some(&left) = stack.last() {
                        i - left - 1
                    } else {
                        i
                    };
                    ans = ans.max(width as i32 * heights[top]);
                } else {
                    break;
                }
            }
            stack.push(i);
        }
        ans

=======

        let mut stack: Vec<i32> = Vec::new();
        let mut heights = heights;
        heights.push(0);
        let mut max_area = 0;
        let mut i = 0;
        while i < heights.len() {
            if stack.is_empty() || heights[stack[stack.len() - 1] as usize] < heights[i] {
                stack.push(i as i32);
                i += 1;
            } else {
                let top = stack.pop().unwrap();
                let area = heights[top as usize] * if stack.is_empty() { i as i32 } else { i as i32 - stack[stack.len() - 1] - 1 };
                max_area = max_area.max(area);
            }
        }
        max_area

=======

        let mut stack: Vec<(i32, i32)> = vec![];
        let mut max_area = 0;
        for (i, &h) in heights.iter().enumerate() {
            let mut start = i as i32;
            while !stack.is_empty() && stack.last().unwrap().1 > h {
                let (s, h) = stack.pop().unwrap();
                max_area = max_area.max((i as i32 - s) * h);
                start = s;
            }
            stack.push((start, h));
        }
        while !stack.is_empty() {
            let (s, h) = stack.pop().unwrap();
            max_area = max_area.max((heights.len() as i32 - s) * h);
        }
        max_area
