Synthesizing 10/10 solutions

=======

        let s = s.as_bytes();
        let mut res = 0;
        for i in 0..s.len() {
            if s[i] == s[s.len() - 1] {
                res += s.len() - i;
            }
        }
        res as i64

=======

        let s = s.as_bytes();
        let mut i = 0;
        let mut j = s.len() - 1;
        let mut res = 0;
        while i < j {
            if s[i] == s[j] {
                res += 2;
                i += 1;
                j -= 1;
            } else {
                i = 0;
                j -= 1;
            }
        }
        res as i64

=======

        let mut sum = 0;
        let mut max = 0;
        let mut chars = s.chars().rev();
        while let Some(c) = chars.next() {
            if c == chars.clone().next().unwrap_or(c) {
                max += 1;
            } else {
                max = 0;
            }
            sum += max;
        }
        sum
    }
}

=======

        let mut sum = 0;
        let mut max = 0;
        let mut chars = s.chars().rev();
        while let Some(c) = chars.next() {
            if c == chars.clone().next().unwrap_or(' ') {
                max += 1;
            } else {
                max = 0;
            }
            sum += max;
        }
        sum
    }
}

=======

        let mut sum = 0;
        let mut max = 0;
        let mut s = s.chars().collect::<Vec<_>>();
        for i in (0..s.len()).rev() {
            if s[i] == s[s.len() - 1] {
                max += 1;
            } else {
                max = 0;
            }
            sum += max as i64;
        }
        sum

=======

        let mut sum = 0;
        let mut count = 0;
        let mut i = 0;
        let mut j = s.len() - 1;
        let s = s.as_bytes();
        while i < j {
            if s[i] == s[j] {
                count += 1;
            } else {
                count = 0;
            }
            i += 1;
            j -= 1;
            sum += count as i64;
        }
        sum

=======

        let mut scores = vec![0; s.len()];
        let mut prefix = vec![0; s.len()];
        let mut max = 0;
        for (i, c) in s.chars().rev().enumerate() {
            if i == 0 {
                scores[i] = 1;
                prefix[i] = 1;
            } else {
                if c == s.chars().nth(i - 1).unwrap() {
                    scores[i] = scores[i - 1] + 1;
                    prefix[i] = prefix[i - 1] + 1;
                } else {
                    scores[i] = 1;
                    prefix[i] = 1;
                }
            }
            if prefix[i] > max {
                max = prefix[i];
            } else {
                scores[i] = max;
            }
        }
        scores.into_iter().sum()

=======

        let mut sum = 0;
        let mut common = 0;
        let mut s = s.as_bytes();
        let n = s.len();
        let mut i = n - 1;
        while i > 0 {
            if s[i] == s[i-1] {
                common += 1;
            } else {
                common = 0;
            }
            sum += common as i64;
            i -= 1;
        }
        sum

=======

        let mut res = 0;
        let mut prev = 0;
        let mut n = s.len();
        let mut s = s.into_bytes();
        for i in (0..n).rev() {
            if s[i] == s[n-1] {
                prev += 1;
            } else {
                prev = 0;
            }
            res += prev as i64;
        }
        res

=======

        let mut l = s.len();
        let mut r = 0;
        let mut res = 0;
        let mut c = s.as_bytes();
        for i in 0..s.len() {
            if c[i] == c[l-1] {
                r += 1;
            } else {
                res += r * (r + 1) / 2;
                r = 0;
            }
            l -= 1;
        }
        res += r * (r + 1) / 2;
        res as i64
