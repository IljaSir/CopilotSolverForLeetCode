Synthesizing 9/10 solutions

=======

        let n = nums.len();
        let mut l = vec![0; n];
        let mut r = vec![0; n];
        l[0] = nums[0];
        for i in 1..n {
            l[i] = gcd(l[i - 1], nums[i]);
        }
        r[n - 1] = nums[n - 1];
        for i in (0..n - 1).rev() {
            r[i] = gcd(r[i + 1], nums[i]);
        }
        for i in 0..n {
            if i == 0 && r[i + 1] == 1 {
                return i as i32;
            }
            if i == n - 1 && l[i - 1] == 1 {
                return i as i32;
            }
            if i > 0 && i < n - 1 && gcd(l[i - 1], r[i + 1]) == 1 {
                return i as i32;
            }
        }
        -1
    }
}

=======

        let n = nums.len();
        let mut left = vec![0; n + 1];
        let mut right = vec![0; n + 1];
        for i in 1..=n {
            left[i] = gcd(left[i - 1], nums[i - 1]);
        }
        for i in (0..n).rev() {
            right[i] = gcd(right[i + 1], nums[i]);
        }
        for i in 0..n {
            if gcd(left[i], right[i + 1]) == 1 {
                return i as i32;
            }
        }
        -1
    }
}

=======

        let n = nums.len();
        let mut left = vec![0; n + 1];
        let mut right = vec![0; n + 1];
        for i in 1..=n {
            left[i] = gcd(left[i - 1], nums[i - 1]);
            right[n - i] = gcd(right[n - i + 1], nums[n - i]);
        }
        for i in 1..n {
            if gcd(left[i], right[i + 1]) == 1 {
                return i as i32 - 1;
            }
        }
        -1
    }
}

=======

        let n = nums.len();
        let mut l = vec![1; n];
        let mut r = vec![1; n];
        for i in 1..n {
            l[i] = gcd(l[i - 1], nums[i - 1]);
        }
        for i in (0..n - 1).rev() {
            r[i] = gcd(r[i + 1], nums[i + 1]);
        }
        for i in 0..n {
            if gcd(l[i], r[i]) == 1 {
                return i as i32;
            }
        }
        -1
    }
}

=======

        let n = nums.len();
        let mut left = vec![1; n];
        let mut right = vec![1; n];
        for i in 0..n {
            left[i] = left[i - 1] * nums[i];
        }
        for i in (0..n - 1).rev() {
            right[i] = right[i + 1] * nums[i + 1];
        }
        for i in 0..n {
            if gcd(left[i], right[i]) == 1 {
                return i as i32;
            }
        }
        -1
    }
}

=======

        let n = nums.len();
        let mut prefix = vec![1; n];
        let mut suffix = vec![1; n];
        for i in 0..n {
            prefix[i] = prefix[i] * nums[i];
            suffix[n - i - 1] = suffix[n - i - 1] * nums[n - i - 1];
        }
        for i in 1..n {
            prefix[i] = gcd(prefix[i], prefix[i - 1]);
            suffix[n - i - 1] = gcd(suffix[n - i - 1], suffix[n - i]);
        }
        for i in 0..n {
            if (i == 0 || prefix[i - 1] == 1) && (i == n - 1 || suffix[i + 1] == 1) {
                return i as i32;
            }
        }
        -1
    }
}

=======

        let mut res = -1;
        let mut left = nums[0];
        let mut right = nums.iter().skip(1).product();
        for i in 1..nums.len() {
            if gcd(left, right) == 1 {
                res = i as i32 - 1;
                break;
            }
            left *= nums[i];
            right /= nums[i];
        }
        res
    }
}

=======

        let mut left = 1;
        let mut right = 1;
        let mut ans = -1;
        for i in 0..nums.len() {
            let n = nums[i];
            right *= n;
            let g = gcd(left, right);
            left /= g;
            right /= g;
            if left == 1 && right == 1 {
                ans = i as i32;
            }
        }
        ans
    }
}

=======

        
    }
}
