Synthesizing 9/10 solutions

=======

        
    }
}

=======

        let n = nums.len();
        let mut dp = vec![vec![0; n]; n];
        let mut cost = vec![vec![0; n]; n];
        let mut freq = vec![0; n];
        for i in 0..n {
            dp[i][i] = 1;
            freq[nums[i] as usize] += 1;
        }
        for i in 0..n {
            for j in i + 1..n {
                dp[i][j] = dp[i][j - 1];
                if freq[nums[j] as usize] == 1 {
                    dp[i][j] += 1;
                }
                freq[nums[j] as usize] += 1;
            }
            for j in i..n {
                freq[nums[j] as usize] = 0;
            }
        }
        for i in 0..n {
            for j in i..n {
                cost[i][j] = k + dp[i][j] as i32;
            }
        }
        let mut dp = vec![0; n];
        for i in 0..n {
            dp[i] = cost[0][i];
        }
        for i in 1..n {
            for j in i..n {
                dp[j] = min(dp[j], dp[i - 1] + cost[i][j]);
            }
        }
        dp[n - 1]

=======

        let mut cnt = vec![0; nums.len()];
        let mut s = vec![0; nums.len()];
        for i in 0..nums.len() {
            cnt[nums[i] as usize] += 1;
        }
        let mut t = 0;
        for i in 0..nums.len() {
            if cnt[nums[i] as usize] == 1 {
                t += 1;
            }
            s[i] = t;
        }
        let mut dp = vec![vec![0; nums.len()]; k as usize];
        for i in 0..nums.len() {
            dp[0][i] = k + s[i];
        }
        for i in 1..k as usize {
            for j in (i + 1)..nums.len() {
                let mut m = std::i32::MAX;
                for l in i..j {
                    m = std::cmp::min(m, dp[i - 1][l - 1] + k + s[j] - s[l]);
                }
                dp[i][j] = m;
            }
        }
        dp[k as usize - 1][nums.len() - 1]

=======

        let mut dp = vec![vec![0; nums.len()]; k as usize];
        let mut cost = vec![0; nums.len()];
        let mut count = vec![0; nums.len()];
        for i in 0..nums.len() {
            count[nums[i] as usize] += 1;
            if count[nums[i] as usize] == 1 {
                cost[i] = 1;
            } else if count[nums[i] as usize] == 2 {
                cost[i] = -1;
            } else {
                cost[i] = -2;
            }
            if i > 0 {
                cost[i] += cost[i - 1];
            }
        }
        for i in 0..k as usize {
            for j in 0..nums.len() {
                if i == 0 {
                    dp[i][j] = cost[j];
                } else {
                    let mut min = std::i32::MAX;
                    for m in 0..j {
                        let c = dp[i - 1][m] + cost[j] - cost[m];
                        if c < min {
                            min = c;
                        }
                    }
                    dp[i][j] = min;
                }
            }
        }
        dp[k as usize - 1][nums.len() - 1]

=======

        let mut count = vec![0;nums.len()];
        for i in nums.iter() {
            count[*i as usize] += 1;
        }
        let mut trimmed = vec![];
        for i in count.iter() {
            if *i > 1 {
                trimmed.push(*i);
            }
        }
        let mut dp = vec![vec![0;trimmed.len()+1];k as usize+1];
        for i in 0..trimmed.len() {
            dp[1][i+1] = trimmed[i] + dp[1][i];
        }
        for i in 2..k as usize+1 {
            for j in i..trimmed.len()+1 {
                let mut min = std::i32::MAX;
                for m in i-1..j {
                    min = std::cmp::min(min,dp[i-1][m]+dp[1][j]-dp[1][m]);
                }
                dp[i][j] = min;
            }
        }
        dp[k as usize][trimmed.len()]

=======

        let mut count = vec![0; nums.len()];
        for &n in &nums {
            count[n as usize] += 1;
        }
        let mut cost = 0;
        let mut cur = 0;
        for i in 0..nums.len() {
            if count[nums[i] as usize] > 1 {
                cur += 1;
            } else {
                cost += cur;
                cur = 0;
            }
        }
        cost += cur;
        cost as i32 * k

=======

        let mut dp = vec![0; nums.len()];
        let mut cost = vec![0; nums.len()];
        let mut count = vec![0; nums.len()];
        let mut freq = vec![0; nums.len()];
        for i in 0..nums.len() {
            count[nums[i] as usize] += 1;
            cost[i] = cost[i.saturating_sub(1)] + if count[nums[i] as usize] == 1 { 1 } else { 0 };
            freq[i] = freq[i.saturating_sub(1)] + if count[nums[i] as usize] == 1 { 0 } else { 1 };
        }
        for i in 1..k as usize {
            let mut stack = Vec::new();
            for j in 0..nums.len() {
                while let Some(&k) = stack.last() {
                    if dp[k] + freq[j] - freq[k] <= dp[j] + freq[j] - freq[j] {
                        stack.pop();
                    } else {
                        break;
                    }
                }
                dp[j] = dp[stack.last().copied().unwrap_or(0)] + freq[j] - freq[stack.last().copied().unwrap_or(0)];
                stack.push(j);
            }
        }
        dp[nums.len() - 1] as i32 + cost[nums.len() - 1] * k
    }
}

=======

        let mut cost = 0;
        let mut count = vec![0; nums.len()];
        for n in nums.iter() {
            count[*n as usize] += 1;
        }
        let mut single = vec![];
        for i in 0..count.len() {
            if count[i] == 1 {
                single.push(i as i32);
            }
        }
        let mut result = 0;
        for i in 0..nums.len() {
            if single.contains(&nums[i]) {
                result += 1;
            }
            if i > 0 && nums[i] != nums[i - 1] {
                if single.contains(&nums[i - 1]) {
                    result -= 1;
                }
            }
            if i == nums.len() - 1 || nums[i] != nums[i + 1] {
                cost += std::cmp::min(result, k);
                result = 0;
            }
        }
        cost

=======

        let mut cnt = vec![0; 1001];
        for &x in &nums {
            cnt[x as usize] += 1;
        }
        let mut sub = vec![];
        for i in 0..=1000 {
            if cnt[i] > 1 {
                sub.push(cnt[i]);
            }
        }
        let n = sub.len();
        let mut dp = vec![vec![0; n]; n];
        for i in 0..n {
            dp[i][i] = sub[i];
        }
        for l in 2..=n {
            for i in 0..n-l+1 {
                let j = i + l - 1;
                dp[i][j] = dp[i][j-1] + sub[j];
            }
        }
        let mut sum = vec![0; n];
        sum[0] = sub[0];
        for i in 1..n {
            sum[i] = sum[i-1] + sub[i];
        }
        let mut f = vec![vec![0; n]; k as usize];
        for i in 0..n {
            f[0][i] = sum[i];
        }
        for i in 1..k as usize {
            for j in 0..n {
                f[i][j] = f[i-1][j];
                for k in 0..j {
                    f[i][j] = f[i][j].min(f[i-1][k] + dp[k+1][j]);
                }
            }
        }
        f[k as usize - 1][n-1] as i32
    }
}
