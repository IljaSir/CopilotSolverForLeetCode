Synthesizing 8/10 solutions (Duplicates hidden)

=======

        
    }
}

=======

        let mut stack: Vec<(i32, i32)> = vec![];
        let mut ans = 0;
        for i in 0..strength.len() {
            let mut sum = strength[i];
            while let Some((_, x)) = stack.last() {
                if x > &strength[i] {
                    break;
                }
                stack.pop();
                sum += x;
            }
            ans = (ans + sum * strength[i]) % 1000000007;
            stack.push((i as i32, strength[i]));
        }
        ans

=======

        let mut stack = vec![];
        let mut ans = 0;
        let mut sum = 0;
        for (i, &s) in strength.iter().enumerate() {
            sum += s;
            while !stack.is_empty() && stack.last().unwrap().0 >= s {
                let (t, j) = stack.pop().unwrap();
                ans = (ans + t * (sum - s * (i - j) as i32)) % 1000000007;
            }
            stack.push((s, i as i32));
        }
        while !stack.is_empty() {
            let (t, j) = stack.pop().unwrap();
            ans = (ans + t * (sum - t * (strength.len() as i32 - j))) % 1000000007;
        }
        ans

=======

        let mut stack = Vec::new();
        let mut sum = 0;
        let mut result = 0;
        let mut min = std::i32::MAX;
        for i in 0..strength.len() {
            while let Some(&x) = stack.last() {
                if strength[x] <= strength[i] {
                    break;
                }
                stack.pop();
                sum -= strength[x];
                min = std::cmp::min(min, strength[x]);
            }
            stack.push(i);
            sum += strength[i];
            min = std::cmp::min(min, strength[i]);
            result += min * sum;
            result %= 1000000007;
        }
        result

=======

        let mut sum = 0;
        let mut stack = vec![];
        let mut right = 0;
        let mut left = 0;
        let mut min = std::i32::MAX;
        let mut last = 0;
        for (i, s) in strength.iter().enumerate() {
            right = i;
            sum += s;
            min = std::cmp::min(min, *s);
            while !stack.is_empty() && stack.last().unwrap().0 >= *s {
                let (s, l, r) = stack.pop().unwrap();
                sum -= s * (r - l + 1) as i32;
                last = l;
            }
            stack.push((*s, last, right));
            sum += *s * (right - last + 1) as i32;
            left += sum;
        }
        left
    }
}
