Synthesizing 6/10 solutions (Duplicates hidden)

=======

        
    }
}

=======

        let mut stations = stations;
        stations.sort();
        let mut l = 1;
        let mut r = stations[stations.len() - 1] - stations[0] + 1;
        while l < r {
            let mid = (l + r) / 2;
            let mut need = 0;
            for i in 0..stations.len() - 1 {
                let d = stations[i+1] - stations[i];
                need += (d - 1) / (2 * r + 1);
            }
            if need > k {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        l as i64

=======

        let n = stations.len();
        let mut stations = stations;
        stations.sort();
        let mut l = 0;
        let mut r = 1_000_000_000;
        while l < r {
            let mid = (l + r + 1) / 2;
            let mut cnt = 0;
            for i in 1..n {
                let d = stations[i] - stations[i - 1];
                if d > 2 * r {
                    return -1;
                }
                if d > 2 * r - mid {
                    cnt += (d - 2 * r + mid + mid - 1) / mid;
                }
            }
            if cnt <= k {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        l as i64

=======

        let n = stations.len();
        let mut stations = stations;
        stations.sort();
        let mut l = 0;
        let mut r = stations[n - 1];
        while l < r {
            let mid = (l + r + 1) >> 1;
            let mut count = 0;
            for i in 0..n {
                let left = stations[i] - r;
                let right = stations[i] + r;
                count += (right - left) / (2 * r + 1);
            }
            if count <= k {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        l as i64

=======

        let n = stations.len();
        let mut stations = stations;
        stations.sort();
        let mut l = 0;
        let mut r = stations[n-1] - stations[0] + 1;
        while l < r {
            let mid = (l + r) / 2;
            let mut need = 0;
            for i in 0..n {
                if i > 0 && stations[i] - stations[i-1] <= 2 * r {
                    continue;
                }
                let left = stations[i] - r;
                let right = stations[i] + r;
                let mut j = i;
                while j < n && stations[j] <= right {
                    j += 1;
                }
                let cnt = (j - i + 2 * r as usize) / (2 * r as usize + 1);
                need += cnt as i32 - 1;
                i = j - 1;
            }
            if need <= k {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        l as i64
