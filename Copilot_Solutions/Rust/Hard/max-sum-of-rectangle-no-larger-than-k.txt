Synthesizing 10/10 solutions

=======

        let m = matrix.len();
        let n = matrix[0].len();
        let mut ans = std::i32::MIN;
        for i in 0..m {
            let mut sum = vec![0; n];
            for j in i..m {
                for c in 0..n {
                    sum[c] += matrix[j][c];
                }
                let mut set = std::collections::BTreeSet::new();
                set.insert(0);
                let mut cur = 0;
                for v in sum.iter() {
                    cur += v;
                    if let Some(&x) = set.range(cur - k..).next() {
                        ans = ans.max(cur - x);
                    }
                    set.insert(cur);
                }
            }
        }
        ans

=======

        let (m, n) = (matrix.len(), matrix[0].len());
        let mut ans = std::i32::MIN;
        for i in 0..m {
            let mut sum = vec![0; n];
            for j in i..m {
                for c in 0..n {
                    sum[c] += matrix[j][c];
                }
                let mut set = std::collections::BTreeSet::new();
                set.insert(0);
                let mut cur = 0;
                for &v in &sum {
                    cur += v;
                    if let Some(&it) = set.range(cur - k..).next() {
                        ans = ans.max(cur - it);
                    }
                    set.insert(cur);
                }
            }
        }
        ans
    }
}

=======

        let (m, n) = (matrix.len(), matrix[0].len());
        let mut ans = std::i32::MIN;
        for i in 0..m {
            let mut sum = vec![0; n];
            for j in i..m {
                for c in 0..n {
                    sum[c] += matrix[j][c];
                }
                let mut set = std::collections::BTreeSet::new();
                set.insert(0);
                let mut cur = 0;
                for v in sum.iter() {
                    cur += v;
                    if let Some(&pre) = set.range(cur - k..).next() {
                        ans = ans.max(cur - pre);
                    }
                    set.insert(cur);
                }
            }
        }
        ans

=======

        let m = matrix.len();
        if m == 0 {
            return 0;
        }
        let n = matrix[0].len();
        if n == 0 {
            return 0;
        }
        let mut ans = std::i32::MIN;
        for i in 0..m {
            let mut sum = vec![0; n];
            for j in i..m {
                for c in 0..n {
                    sum[c] += matrix[j][c];
                }
                ans = ans.max(Self::max_sum_subarray(&sum, k));
            }
        }
        ans
    }
    fn max_sum_subarray(nums: &[i32], k: i32) -> i32 {
        let mut ans = std::i32::MIN;
        let mut sum = 0;
        let mut set = std::collections::BTreeSet::new();
        set.insert(0);
        for num in nums {
            sum += num;
            if let Some(&x) = set.range(sum - k..).next() {
                ans = ans.max(sum - x);
            }
            set.insert(sum);
        }
        ans

=======

        let m = matrix.len();
        let n = matrix[0].len();
        let mut max = std::i32::MIN;
        for i in 0..m {
            let mut sum = vec![0; n];
            for j in i..m {
                for c in 0..n {
                    sum[c] += matrix[j][c];
                }
                let mut set = std::collections::BTreeSet::new();
                set.insert(0);
                let mut cur = 0;
                for &s in &sum {
                    cur += s;
                    if let Some(&x) = set.range(cur - k..).next() {
                        max = max.max(cur - x);
                    }
                    set.insert(cur);
                }
            }
        }
        max

=======

        let m = matrix.len();
        let n = matrix[0].len();
        let mut max = i32::MIN;
        for i in 0..m {
            let mut sums = vec![0; n];
            for j in i..m {
                for c in 0..n {
                    sums[c] += matrix[j][c];
                }
                let mut set = std::collections::BTreeSet::new();
                set.insert(0);
                let mut cur = 0;
                for &s in &sums {
                    cur += s;
                    if let Some(&x) = set.range(cur - k..).next() {
                        max = max.max(cur - x);
                    }
                    set.insert(cur);
                }
            }
        }
        max

=======

        let m = matrix.len();
        let n = matrix[0].len();
        let mut res = std::i32::MIN;
        for i in 0..n {
            let mut sum = vec![0; m];
            for j in i..n {
                for r in 0..m {
                    sum[r] += matrix[r][j];
                }
                let mut set = std::collections::BTreeSet::new();
                set.insert(0);
                let mut cur = 0;
                for s in sum {
                    cur += s;
                    if let Some(&x) = set.range(cur - k..).next() {
                        res = res.max(cur - x);
                    }
                    set.insert(cur);
                }
            }
        }
        res

=======

        let m = matrix.len();
        let n = matrix[0].len();
        let mut ret = i32::MIN;
        for i in 0..m {
            let mut sum = vec![0; n];
            for j in i..m {
                for c in 0..n {
                    sum[c] += matrix[j][c];
                }
                let mut set = std::collections::BTreeSet::new();
                set.insert(0);
                let mut cur = 0;
                for x in sum.iter() {
                    cur += x;
                    if let Some(&y) = set.range(cur - k..).next() {
                        ret = ret.max(cur - y);
                    }
                    set.insert(cur);
                }
            }
        }
        ret

=======

        let m = matrix.len();
        let n = matrix[0].len();
        let mut sum = vec![vec![0; n + 1]; m + 1];
        let mut res = i32::MIN;
        for i in 1..=m {
            for j in 1..=n {
                sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + matrix[i - 1][j - 1];
            }
        }
        for i in 1..=m {
            for j in 1..=n {
                for p in i..=m {
                    for q in j..=n {
                        let cur = sum[p][q] - sum[i - 1][q] - sum[p][j - 1] + sum[i - 1][j - 1];
                        if cur <= k {
                            res = res.max(cur);
                        }
                    }
                }
            }
        }
        res

=======

        
    }
}
