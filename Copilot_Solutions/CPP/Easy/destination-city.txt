Synthesizing 10/10 solutions

=======

        unordered_set<string> cities;
        for (auto& p : paths) {
            cities.insert(p[0]);
        }
        for (auto& p : paths) {
            if (cities.find(p[1]) == cities.end()) {
                return p[1];
            }
        }
        return "";

=======

        unordered_set<string> start;
        for (auto& path: paths) {
            start.insert(path[0]);
        }
        for (auto& path: paths) {
            if (!start.count(path[1])) {
                return path[1];
            }
        }
        return "";

=======

        unordered_map<string, string> m;
        for (auto& path : paths) {
            m[path[0]] = path[1];
        }
        string s = paths[0][0];
        while (m.find(s) != m.end()) {
            s = m[s];
        }
        return s;

=======

        int n = paths.size();
        map<string, int> mp;
        for (int i = 0; i < n; i++) {
            mp[paths[i][0]] = 1;
        }
        for (int i = 0; i < n; i++) {
            if (mp[paths[i][1]] == 0) {
                return paths[i][1];
            }
        }
        return "";

=======

        unordered_map<string, int> m;
        for (auto& p : paths) {
            m[p[0]]++;
            m[p[1]]--;
        }
        for (auto& p : m) {
            if (p.second == -1) return p.first;
        }
        return "";

=======

        unordered_map<string, int> um;
        for (int i = 0; i < paths.size(); i++) {
            um[paths[i][0]] = 1;
            if (um.find(paths[i][1]) == um.end()) {
                um[paths[i][1]] = 0;
            }
        }
        for (auto& it : um) {
            if (it.second == 0) {
                return it.first;
            }
        }
        return "";

=======

        unordered_map<string, int> m;
        for (auto& p: paths) {
            m[p[0]]++;
            m[p[1]];
        }
        for (auto& p: paths) {
            m[p[1]] += m[p[0]];
        }
        for (auto& p: m) {
            if (p.second == 1) return p.first;
        }
        return "";

=======

        unordered_map<string, int> m;
        for (auto& p : paths) {
            m[p[0]]++;
            m[p[1]]++;
        }
        for (auto& p : paths) {
            if (m[p[1]] == 1)
                return p[1];
        }
        return "";

=======

        unordered_map<string, int> m;
        for (auto path : paths) {
            m[path[0]]++;
            m[path[1]] = 0;
        }
        for (auto p : m) {
            if (p.second == 0) return p.first;
        }
        return "";

=======

        map<string, int> m;
        for (auto& p : paths) {
            m[p[0]]++;
            m[p[1]]--;
        }
        for (auto& [k, v] : m) {
            if (v == -1) {
                return k;
            }
        }
        return "";
