Synthesizing 9/10 solutions

=======

        int x = 0, y = 0;
        set<pair<int, int>> s;
        s.insert(make_pair(0, 0));
        for (char c : path) {
            if (c == 'N') {
                y++;
            } else if (c == 'S') {
                y--;
            } else if (c == 'E') {
                x++;
            } else if (c == 'W') {
                x--;
            }
            if (s.find(make_pair(x, y)) != s.end()) {
                return true;
            }
            s.insert(make_pair(x, y));
        }
        return false;

=======

        int x = 0, y = 0;
        unordered_map<int, unordered_set<int>> m;
        m[0].insert(0);
        for (char c : path) {
            if (c == 'N') {
                y++;
            } else if (c == 'S') {
                y--;
            } else if (c == 'E') {
                x++;
            } else if (c == 'W') {
                x--;
            }
            if (m.find(x) != m.end() && m[x].find(y) != m[x].end()) {
                return true;
            } else {
                m[x].insert(y);
            }
        }
        return false;

=======

        set<pair<int, int>> visited;
        int x = 0, y = 0;
        visited.insert({x, y});
        for (char c : path) {
            switch (c) {
                case 'N':
                    y++;
                    break;
                case 'S':
                    y--;
                    break;
                case 'E':
                    x++;
                    break;
                case 'W':
                    x--;
                    break;
            }
            if (visited.count({x, y})) {
                return true;
            }
            visited.insert({x, y});
        }
        return false;

=======

        int x = 0;
        int y = 0;
        set<pair<int, int>> s;
        s.insert({x, y});
        for (char c : path) {
            switch (c) {
                case 'N':
                    ++y;
                    break;
                case 'S':
                    --y;
                    break;
                case 'E':
                    ++x;
                    break;
                case 'W':
                    --x;
                    break;
            }
            if (s.find({x, y}) != s.end()) {
                return true;
            } else {
                s.insert({x, y});
            }
        }
        return false;

=======

        set<pair<int, int>> s;
        int x = 0, y = 0;
        s.insert(make_pair(x, y));
        for (auto c: path) {
            switch (c) {
                case 'N': ++y; break;
                case 'S': --y; break;
                case 'E': ++x; break;
                case 'W': --x; break;
            }
            if (s.find(make_pair(x, y)) != s.end()) return true;
            s.insert(make_pair(x, y));
        }
        return false;

=======

        int x = 0;
        int y = 0;
        set<pair<int, int>> visited;
        visited.insert({x, y});
        for (char c : path) {
            switch (c) {
                case 'N': y++; break;
                case 'S': y--; break;
                case 'E': x++; break;
                case 'W': x--; break;
            }
            if (visited.find({x, y}) != visited.end()) {
                return true;
            }
            visited.insert({x, y});
        }
        return false;

=======

        unordered_map<int, unordered_set<int>> m;
        int x = 0;
        int y = 0;
        m[x].insert(y);
        for (char c: path) {
            switch (c) {
                case 'N': ++y; break;
                case 'S': --y; break;
                case 'E': ++x; break;
                case 'W': --x; break;
            }
            if (m[x].find(y) != m[x].end()) {
                return true;
            }
            m[x].insert(y);
        }
        return false;

=======

        int x = 0;
        int y = 0;
        unordered_set<int> visited;
        visited.insert(0);
        for (auto c : path) {
            switch (c) {
                case 'N':
                    ++y;
                    break;
                case 'S':
                    --y;
                    break;
                case 'E':
                    ++x;
                    break;
                case 'W':
                    --x;
                    break;
            }
            auto key = (x << 16) + y;
            if (visited.find(key) != visited.end()) {
                return true;
            }
            visited.insert(key);
        }
        return false;

=======

        unordered_map<int, int> map;
        int x = 0, y = 0;
        for (int i = 0; i < path.size(); i++) {
            if (path[i] == 'N') {
                y++;
            } else if (path[i] == 'S') {
                y--;
            } else if (path[i] == 'E') {
                x++;
            } else if (path[i] == 'W') {
                x--;
            }
            if (map[x] == y) {
                return true;
            }
            map[x] = y;
        }
        return false;
