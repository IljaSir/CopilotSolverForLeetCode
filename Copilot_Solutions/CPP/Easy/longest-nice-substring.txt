Synthesizing 10/10 solutions

=======

        int n = s.size();
        string res;
        for (int i = 0; i < n; ++i) {
            unordered_set<char> st;
            for (int j = i; j < n; ++j) {
                st.insert(s[j]);
                if (st.count(tolower(s[j])) && st.count(toupper(s[j]))) {
                    if (res.size() < j - i + 1) res = s.substr(i, j - i + 1);
                }
            }
        }
        return res;

=======

        string res;
        for (int i = 0; i < s.length(); i++) {
            set<char> st;
            for (int j = i; j < s.length(); j++) {
                st.insert(s[j]);
                if (st.count(tolower(s[j])) && st.count(toupper(s[j]))) {
                    if (res.length() < st.size()) {
                        res = s.substr(i, j - i + 1);
                    }
                }
            }
        }
        return res;

=======

        int n = s.size();
        string ans;
        for (int i = 0; i < n; ++i) {
            for (int j = i; j < n; ++j) {
                string sub = s.substr(i, j - i + 1);
                if (isNice(sub) && sub.size() > ans.size()) {
                    ans = sub;
                }
            }
        }
        return ans;
    }
    
    bool isNice(string s) {
        unordered_set<char> st;
        for (auto c : s) {
            st.insert(c);
        }
        for (auto c : s) {
            if (islower(c) && !st.count(toupper(c))) {
                return false;
            }
            if (isupper(c) && !st.count(tolower(c))) {
                return false;
            }
        }
        return true;

=======

        int n = s.size();
        for(int i = 0; i < n; i++){
            if(islower(s[i]) && find(s.begin(), s.end(), toupper(s[i])) == s.end())
                return max(longestNiceSubstring(s.substr(0, i)), longestNiceSubstring(s.substr(i+1)));
            else if(isupper(s[i]) && find(s.begin(), s.end(), tolower(s[i])) == s.end())
                return max(longestNiceSubstring(s.substr(0, i)), longestNiceSubstring(s.substr(i+1)));
        }
        return s;

=======

        if (s.size() < 2) return "";
        unordered_set<char> set;
        for (auto ch : s) {
            set.insert(ch);
        }
        for (int i = 0; i < s.size(); ++i) {
            if (set.count(tolower(s[i])) && set.count(toupper(s[i]))) continue;
            auto left = longestNiceSubstring(s.substr(0, i));
            auto right = longestNiceSubstring(s.substr(i+1));
            return left.size() > right.size() ? left : right;
        }
        return s;

=======

        int n = s.size();
        if (n < 2) return "";
        vector<vector<int>> dp(n, vector<int>(n));
        for (int i = 0; i < n; ++i) {
            dp[i][i] = 1;
        }
        for (int i = 0; i < n - 1; ++i) {
            if (isNice(s[i], s[i + 1])) dp[i][i + 1] = 1;
        }
        for (int len = 3; len <= n; ++len) {
            for (int i = 0; i <= n - len; ++i) {
                int j = i + len - 1;
                if (isNice(s[i], s[j])) {
                    dp[i][j] = dp[i + 1][j - 1];
                }
            }
        }
        for (int len = n; len >= 2; --len) {
            for (int i = 0; i <= n - len; ++i) {
                int j = i + len - 1;
                if (dp[i][j]) return s.substr(i, len);
            }
        }
        return "";

=======

        int n = s.size();
        for (int i = 0; i < n; i++) {
            if (islower(s[i]) && islower(s[i + 1])) {
                continue;
            }
            if (isupper(s[i]) && isupper(s[i + 1])) {
                continue;
            }
            string left = longestNiceSubstring(s.substr(0, i + 1));
            string right = longestNiceSubstring(s.substr(i + 1));
            return left.size() >= right.size() ? left : right;
        }
        return s;

=======

        int n = s.length();
        if(n <= 1) return "";
        unordered_map<char, int> mp;
        for(int i = 0; i < n; ++i) {
            mp[s[i]]++;
        }
        for(int i = 0; i < n; ++i) {
            if(mp[toupper(s[i])] && mp[tolower(s[i])]) continue;
            string left = longestNiceSubstring(s.substr(0, i));
            string right = longestNiceSubstring(s.substr(i+1, n));
            return left.length() > right.length() ? left : right;
        }
        return s;

=======

        int n = s.size();
        if (n < 2) return "";
        vector<int> cnt(26, 0);
        for (char ch : s) {
            cnt[ch - 'A']++;
        }
        int split = 0;
        for (; split < n; split++) {
            if (cnt[s[split] - 'A'] == 1) break;
        }
        if (split == n) return s;
        string l = longestNiceSubstring(s.substr(0, split));
        string r = longestNiceSubstring(s.substr(split + 1));
        return l.size() > r.size() ? l : r;

=======

        int n = s.size();
        if(n <= 1) return "";
        for(int i=0; i<n; i++) {
            if(s[i] >= 'a' && s[i] <= 'z') {
                if(s.find(toupper(s[i])) == string::npos) {
                    string s1 = longestNiceSubstring(s.substr(0, i));
                    string s2 = longestNiceSubstring(s.substr(i+1));
                    return s1.size() > s2.size() ? s1 : s2;
                }
            } else {
                if(s.find(tolower(s[i])) == string::npos) {
                    string s1 = longestNiceSubstring(s.substr(0, i));
                    string s2 = longestNiceSubstring(s.substr(i+1));
                    return s1.size() > s2.size() ? s1 : s2;
                }
            }
        }
        return s;
