Synthesizing 10/10 solutions (Duplicates hidden)

=======

        return s.size() == goal.size() && (s + s).find(goal) != string::npos;

=======

        return s.size() == goal.size() && (s + s).find(goal) != std::string::npos;

=======

        if (s.length() != goal.length()) return false;
        if (s.length() == 0) return true;
        for (int i = 0; i < s.length(); i++) {
            if (s[i] == goal[0]) {
                int j = 0;
                for (; j < goal.length(); j++) {
                    if (s[(i+j) % s.length()] != goal[j]) {
                        break;
                    }
                }
                if (j == goal.length()) return true;
            }
        }
        return false;

=======

        if (s.length() != goal.length()) return false;
        if (s.empty()) return true;
        for (int i = 0; i < s.length(); ++i) {
            if (s[i] == goal[0]) {
                if (s.substr(i) + s.substr(0, i) == goal) return true;
            }
        }
        return false;

=======

        if (s == goal) return true;
        for (int i = 0; i < s.size(); i++) {
            if (s.substr(i) + s.substr(0, i) == goal) return true;
        }
        return false;

=======

        if (s.length() != goal.length()) return false;
        if (s == goal) return true;
        int n = s.length();
        for (int i = 1; i < n; ++i) {
            if (s[i] == goal[0]) {
                bool flag = true;
                for (int j = 0; j < n; ++j) {
                    if (s[(i + j) % n] != goal[j]) {
                        flag = false;
                        break;
                    }
                }
                if (flag) return true;
            }
        }
        return false;

=======

        if(s.size() != goal.size()) return false;
        if(s == goal) return true;
        for(int i = 0; i < s.size(); ++i) {
            if(s[i] == goal[0]) {
                bool match = true;
                for(int j = 0; j < s.size(); ++j) {
                    if(s[(i + j) % s.size()] != goal[j]) {
                        match = false;
                        break;
                    }
                }
                if(match) return true;
            }
        }
        return false;

=======

        if(s.size() != goal.size()) return false;
        if(s.size() == 0) return true;
        int m = s.size();
        int n = goal.size();
        for(int i=0; i<m; i++){
            if(s[i] == goal[0]){
                int j = i;
                int k = 0;
                while(j < m && k < n){
                    if(s[j] != goal[k]) break;
                    j++;
                    k++;
                }
                if(j == m){
                    for(int l=0; l<i; l++){
                        if(s[l] != goal[k]) return false;
                        k++;
                    }
                    return true;
                }
            }
        }
        return false;

=======

        if(s.size()!=goal.size()) return false;
        string t=s+s;
        return t.find(goal)!=string::npos;
