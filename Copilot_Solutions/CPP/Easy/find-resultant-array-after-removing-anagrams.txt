Synthesizing 10/10 solutions

=======

        unordered_map<string, int> hash;
        for (int i = 0; i < words.size(); i++) {
            string s = words[i];
            sort(s.begin(), s.end());
            hash[s]++;
        }
        vector<string> res;
        for (int i = 0; i < words.size(); i++) {
            string s = words[i];
            sort(s.begin(), s.end());
            if (hash[s] == 1) {
                res.push_back(words[i]);
            }
        }
        return res;

=======

        int n = words.size();
        vector<string> ans;
        unordered_map<string, int> m;
        for(int i = 0; i < n; i++){
            string s = words[i];
            sort(s.begin(), s.end());
            m[s]++;
        }
        for(int i = 0; i < n; i++){
            string s = words[i];
            sort(s.begin(), s.end());
            if(m[s] == 1) ans.push_back(words[i]);
        }
        return ans;

=======

        unordered_map<string, int> m;
        vector<string> ans;
        for (auto w : words) {
            string s = w;
            sort(s.begin(), s.end());
            if (m.find(s) == m.end()) {
                ans.push_back(w);
                m[s] = ans.size() - 1;
            } else {
                ans[m[s]] = "";
            }
        }
        return ans;

=======

        int n = words.size();
        vector<string> res;
        for (int i = 0; i < n; ++i) {
            string s = words[i];
            sort(s.begin(), s.end());
            bool flag = true;
            for (int j = i + 1; j < n; ++j) {
                string t = words[j];
                sort(t.begin(), t.end());
                if (s == t) {
                    flag = false;
                    break;
                }
            }
            if (flag) res.push_back(words[i]);
        }
        return res;

=======

        vector<string> res;
        unordered_map<string, int> m;
        for (auto w : words) {
            string t = w;
            sort(t.begin(), t.end());
            if (m.count(t) == 0) {
                m[t] = res.size();
                res.push_back(w);
            }
        }
        return res;

=======

        unordered_map<string, int> freq;
        for (string s : words) {
            string t = s;
            sort(t.begin(), t.end());
            freq[t]++;
        }
        vector<string> res;
        for (string s : words) {
            string t = s;
            sort(t.begin(), t.end());
            if (freq[t] == 1) res.push_back(s);
        }
        return res;

=======

        vector<string> res;
        for (auto& w : words) {
            bool flag = true;
            for (auto& r : res) {
                if (isAnagram(w, r)) {
                    flag = false;
                    break;
                }
            }
            if (flag) res.push_back(w);
        }
        return res;
    }
    
    bool isAnagram(string& s1, string& s2) {
        if (s1.length() != s2.length()) return false;
        int cnt[26] = {0};
        for (int i = 0; i < s1.length(); i++) {
            cnt[s1[i] - 'a']++;
            cnt[s2[i] - 'a']--;
        }
        for (int i = 0; i < 26; i++) {
            if (cnt[i] != 0) return false;
        }
        return true;

=======

        unordered_map<string, int> m;
        vector<string> result;
        for (auto& word : words) {
            string sorted_word = word;
            sort(sorted_word.begin(), sorted_word.end());
            if (m.find(sorted_word) == m.end()) {
                result.push_back(word);
                m[sorted_word] = result.size() - 1;
            }
            else {
                result[m[sorted_word]] = "";
            }
        }
        return result;

=======

        vector<string> res;
        for(auto s:words){
            if(res.empty()){
                res.push_back(s);
            }else{
                bool isAnagram = false;
                for(int i=0;i<res.size();i++){
                    if(isAnagramString(s,res[i])){
                        res[i] = s;
                        isAnagram = true;
                        break;
                    }
                }
                if(!isAnagram){
                    res.push_back(s);
                }
            }
        }
        return res;
    }
    bool isAnagramString(string s1, string s2){
        if(s1.length() != s2.length()){
            return false;
        }
        vector<int> count(26,0);
        for(int i=0;i<s1.length();i++){
            count[s1[i]-'a']++;
            count[s2[i]-'a']--;
        }
        for(int i=0;i<26;i++){
            if(count[i] != 0){
                return false;
            }
        }
        return true;

=======

        // 1. sort each string and save it in a map
        // 2. if the sorted string is already present in the map, then remove the string from the map
        // 3. return the remaining strings in the map
        unordered_map<string, vector<string>> m;
        for (auto& w: words) {
            string s = w;
            sort(s.begin(), s.end());
            m[s].push_back(w);
        }
        vector<string> res;
        for (auto& p: m) {
            if (p.second.size() == 1) {
                res.push_back(p.second[0]);
            }
        }
        return res;
