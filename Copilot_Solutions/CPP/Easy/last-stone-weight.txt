Synthesizing 10/10 solutions

=======

        priority_queue<int> pq;
        for (int i = 0; i < stones.size(); i++) {
            pq.push(stones[i]);
        }
        while (pq.size() > 1) {
            int x = pq.top();
            pq.pop();
            int y = pq.top();
            pq.pop();
            if (x != y) {
                pq.push(x - y);
            }
        }
        if (pq.size() == 1) {
            return pq.top();
        }
        return 0;

=======

        priority_queue<int> q(stones.begin(), stones.end());
        while (q.size() > 1) {
            int y = q.top(); q.pop();
            int x = q.top(); q.pop();
            if (x != y) {
                q.push(y - x);
            }
        }
        return q.empty() ? 0 : q.top();

=======

        priority_queue<int> pq;
        for (int i = 0; i < stones.size(); i++) {
            pq.push(stones[i]);
        }
        
        while (pq.size() > 1) {
            int x = pq.top();
            pq.pop();
            int y = pq.top();
            pq.pop();
            
            if (x != y) {
                pq.push(x - y);
            }
        }
        
        return pq.size() == 0 ? 0 : pq.top();

=======

        priority_queue<int> pq;
        for (auto s : stones) {
            pq.push(s);
        }
        while (pq.size() > 1) {
            int a = pq.top();
            pq.pop();
            int b = pq.top();
            pq.pop();
            if (a != b) {
                pq.push(a - b);
            }
        }
        return pq.empty() ? 0 : pq.top();

=======

        priority_queue<int> pq;
        for (auto s : stones) pq.push(s);
        while (pq.size() > 1) {
            int x = pq.top();
            pq.pop();
            int y = pq.top();
            pq.pop();
            if (x != y) {
                pq.push(abs(x - y));
            }
        }
        return pq.empty() ? 0 : pq.top();

=======

        priority_queue<int> pq;
        for(auto x: stones) pq.push(x);
        while(pq.size() > 1){
            int x = pq.top(); pq.pop();
            int y = pq.top(); pq.pop();
            if(x != y) pq.push(x-y);
        }
        return pq.empty()? 0: pq.top();

=======

        priority_queue<int> q;
        for (auto i: stones) q.push(i);
        while (q.size() > 1) {
            auto x = q.top(); q.pop();
            auto y = q.top(); q.pop();
            if (x != y) q.push(x - y);
        }
        return q.empty() ? 0 : q.top();

=======

        sort(stones.begin(), stones.end());
        while (stones.size() > 1) {
            int last = stones.size() - 1;
            int secondLast = stones.size() - 2;
            if (stones[last] == stones[secondLast]) {
                stones.erase(stones.begin() + last);
                stones.erase(stones.begin() + secondLast);
            } else {
                stones[secondLast] = stones[last] - stones[secondLast];
                stones.erase(stones.begin() + last);
                sort(stones.begin(), stones.end());
            }
        }
        return stones.size() == 0 ? 0 : stones[0];

=======

        while (stones.size() > 1) {
            int max1 = 0, max2 = 0;
            int index1 = 0, index2 = 0;
            for (int i = 0; i < stones.size(); i++) {
                if (stones[i] > max1) {
                    max2 = max1;
                    index2 = index1;
                    max1 = stones[i];
                    index1 = i;
                } else if (stones[i] > max2) {
                    max2 = stones[i];
                    index2 = i;
                }
            }
            if (max1 == max2) {
                stones.erase(stones.begin() + index1);
                stones.erase(stones.begin() + index2 - 1);
            } else {
                stones[index1] = max1 - max2;
                stones.erase(stones.begin() + index2);
            }
        }
        if (stones.size() == 0) return 0;
        return stones[0];

=======

        int n = stones.size();
        if (n == 1) {
            return stones[0];
        }
        sort(stones.begin(), stones.end());
        while (stones[n - 2] != 0) {
            stones[n - 1] -= stones[n - 2];
            stones[n - 2] = 0;
            sort(stones.begin(), stones.end());
        }
        return stones[n - 1];
