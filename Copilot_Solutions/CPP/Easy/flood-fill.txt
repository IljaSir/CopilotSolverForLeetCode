Synthesizing 10/10 solutions

=======

        int oldColor = image[sr][sc];
        if (oldColor == color) return image;
        dfs(image, sr, sc, color, oldColor);
        return image;

=======

        int m = image.size();
        int n = image[0].size();
        vector<vector<int>> dir = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        queue<pair<int, int>> q;
        q.push({sr, sc});
        int oldColor = image[sr][sc];
        image[sr][sc] = color;
        while (!q.empty()) {
            auto [x, y] = q.front();
            q.pop();
            for (auto d : dir) {
                int nx = x + d[0];
                int ny = y + d[1];
                if (nx < 0 || nx >= m || ny < 0 || ny >= n || image[nx][ny] != oldColor) {
                    continue;
                }
                image[nx][ny] = color;
                q.push({nx, ny});
            }
        }
        return image;

=======

        int m = image.size();
        int n = image[0].size();
        int old_color = image[sr][sc];
        if (old_color == color) return image;
        queue<pair<int, int>> q;
        q.push({sr, sc});
        while (!q.empty()) {
            auto [x, y] = q.front();
            q.pop();
            if (image[x][y] == old_color) {
                image[x][y] = color;
                if (x > 0) q.push({x-1, y});
                if (x < m - 1) q.push({x+1, y});
                if (y > 0) q.push({x, y-1});
                if (y < n - 1) q.push({x, y+1});
            }
        }
        return image;

=======

        int m = image.size(), n = image[0].size();
        int old_color = image[sr][sc];
        if (old_color == color) return image;
        queue<pair<int, int>> q;
        q.push({sr, sc});
        while (!q.empty()) {
            auto p = q.front();
            q.pop();
            int x = p.first, y = p.second;
            image[x][y] = color;
            if (x > 0 && image[x - 1][y] == old_color) q.push({x - 1, y});
            if (x < m - 1 && image[x + 1][y] == old_color) q.push({x + 1, y});
            if (y > 0 && image[x][y - 1] == old_color) q.push({x, y - 1});
            if (y < n - 1 && image[x][y + 1] == old_color) q.push({x, y + 1});
        }
        return image;

=======

        int m = image.size(), n = image[0].size();
        vector<vector<int>> dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        queue<pair<int, int>> q;
        vector<vector<bool>> visited(m, vector<bool>(n, false));
        q.push({sr, sc});
        visited[sr][sc] = true;
        int old_color = image[sr][sc];
        while (!q.empty()) {
            auto [r, c] = q.front();
            q.pop();
            image[r][c] = color;
            for (auto& dir : dirs) {
                int nr = r + dir[0], nc = c + dir[1];
                if (nr < 0 || nr >= m || nc < 0 || nc >= n || visited[nr][nc] || image[nr][nc] != old_color) continue;
                q.push({nr, nc});
                visited[nr][nc] = true;
            }
        }
        return image;

=======

        int m = image.size();
        int n = image[0].size();
        vector<vector<bool>> visited(m, vector<bool>(n, false));
        int old_color = image[sr][sc];
        queue<pair<int, int>> q;
        q.push(make_pair(sr, sc));
        while (!q.empty()) {
            pair<int, int> p = q.front();
            q.pop();
            int x = p.first;
            int y = p.second;
            if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y] || image[x][y] != old_color) {
                continue;
            }
            image[x][y] = color;
            visited[x][y] = true;
            q.push(make_pair(x - 1, y));
            q.push(make_pair(x + 1, y));
            q.push(make_pair(x, y - 1));
            q.push(make_pair(x, y + 1));
        }
        return image;

=======

        int h = image.size(), w = image[0].size();
        int oldColor = image[sr][sc];
        if (oldColor == color) return image;
        queue<pair<int, int>> q;
        q.push({sr, sc});
        while (!q.empty()) {
            auto [x, y] = q.front();
            q.pop();
            if (image[x][y] == oldColor) {
                image[x][y] = color;
                if (x > 0) q.push({x - 1, y});
                if (x < h - 1) q.push({x + 1, y});
                if (y > 0) q.push({x, y - 1});
                if (y < w - 1) q.push({x, y + 1});
            }
        }
        return image;

=======

        int n = image.size();
        int m = image[0].size();
        vector<vector<bool>> vis(n, vector<bool>(m, false));
        int old_color = image[sr][sc];
        queue<pair<int, int>> q;
        q.push(make_pair(sr, sc));
        vis[sr][sc] = true;
        while(!q.empty()) {
            pair<int, int> p = q.front();
            q.pop();
            int x = p.first;
            int y = p.second;
            image[x][y] = color;
            if(x > 0 && image[x - 1][y] == old_color && !vis[x - 1][y]) {
                q.push(make_pair(x - 1, y));
                vis[x - 1][y] = true;
            }
            if(x < n - 1 && image[x + 1][y] == old_color && !vis[x + 1][y]) {
                q.push(make_pair(x + 1, y));
                vis[x + 1][y] = true;
            }
            if(y > 0 && image[x][y - 1] == old_color && !vis[x][y - 1]) {
                q.push(make_pair(x, y - 1));
                vis[x][y - 1] = true;
            }
            if(y < m - 1 && image[x][y + 1] == old_color && !vis[x][y + 1]) {
                q.push(make_pair(x, y + 1));
                vis[x][y + 1] = true;
            }
        }
        return image;

=======

        int m = image.size();
        int n = image[0].size();
        int src = image[sr][sc];
        if (src == color) return image;
        vector<vector<int>> visited(m, vector<int>(n, 0));
        queue<pair<int, int>> q;
        q.push({sr, sc});
        visited[sr][sc] = 1;
        while (!q.empty()) {
            int x = q.front().first;
            int y = q.front().second;
            q.pop();
            image[x][y] = color;
            if (x > 0 && image[x - 1][y] == src && !visited[x - 1][y]) {
                q.push({x - 1, y});
                visited[x - 1][y] = 1;
            }
            if (x < m - 1 && image[x + 1][y] == src && !visited[x + 1][y]) {
                q.push({x + 1, y});
                visited[x + 1][y] = 1;
            }
            if (y > 0 && image[x][y - 1] == src && !visited[x][y - 1]) {
                q.push({x, y - 1});
                visited[x][y - 1] = 1;
            }
            if (y < n - 1 && image[x][y + 1] == src && !visited[x][y + 1]) {
                q.push({x, y + 1});
                visited[x][y + 1] = 1;
            }
        }
        return image;

=======

        int m = image.size();
        int n = image[0].size();
        int oldColor = image[sr][sc];
        if (oldColor == color) return image;
        vector<vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        queue<pair<int, int>> q;
        q.push({sr, sc});
        image[sr][sc] = color;
        while (!q.empty()) {
            auto pos = q.front();
            q.pop();
            for (auto d : dir) {
                int x = pos.first + d[0];
                int y = pos.second + d[1];
                if (x >= 0 && x < m && y >= 0 && y < n && image[x][y] == oldColor) {
                    image[x][y] = color;
                    q.push({x, y});
                }
            }
        }
        return image;
