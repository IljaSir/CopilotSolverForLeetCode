Synthesizing 10/10 solutions

=======

        priority_queue<int> pq;
        for (int x : gifts) {
            pq.push(x);
        }
        for (int i = 0; i < k; ++i) {
            int x = pq.top(); pq.pop();
            pq.push(x - (int)sqrt(x));
        }
        long long ans = 0;
        while (!pq.empty()) {
            ans += pq.top();
            pq.pop();
        }
        return ans;

=======

        priority_queue<int> pq;
        for (auto gift : gifts) {
            pq.push(gift);
        }
        for (int i = 0; i < k; i++) {
            int gift = pq.top();
            pq.pop();
            gift = floor(sqrt(gift));
            pq.push(gift);
        }
        long long sum = 0;
        while (!pq.empty()) {
            sum += pq.top();
            pq.pop();
        }
        return sum;

=======

        long long ans = 0;
        priority_queue<int> pq(gifts.begin(), gifts.end());
        for (int i = 0; i < k; ++i) {
            int g = pq.top();
            pq.pop();
            pq.push(g / 2);
        }
        while (!pq.empty()) {
            ans += pq.top();
            pq.pop();
        }
        return ans;

=======

        priority_queue<int> pq;
        for (auto& g : gifts) {
            pq.push(g);
        }
        while (k-- > 0) {
            int g = pq.top();
            pq.pop();
            pq.push(g - (int)sqrt(g));
        }
        long long ans = 0;
        while (!pq.empty()) {
            int g = pq.top();
            pq.pop();
            ans += g;
        }
        return ans;

=======

        priority_queue<int> pq;
        for (auto& g : gifts) {
            pq.push(g);
        }
        while (k--) {
            auto g = pq.top();
            pq.pop();
            g = sqrt(g);
            pq.push(g);
        }
        long long ans = 0;
        while (!pq.empty()) {
            ans += pq.top();
            pq.pop();
        }
        return ans;

=======

        priority_queue<int> pq;
        for (auto &x : gifts) {
            pq.push(x);
        }
        for (int i = 0; i < k; i++) {
            int t = pq.top();
            pq.pop();
            pq.push(t - sqrt(t));
        }
        long long res = 0;
        while (!pq.empty()) {
            res += pq.top();
            pq.pop();
        }
        return res;

=======

        long long sum = 0;
        for (int i = 0; i < k; ++i) {
            int max = *max_element(gifts.begin(), gifts.end());
            int index = find(gifts.begin(), gifts.end(), max) - gifts.begin();
            sum += max;
            gifts[index] = floor(sqrt(max));
        }
        return sum;

=======

        priority_queue<int> q;
        for (auto g : gifts) {
            q.push(g);
        }
        while (k > 0) {
            int cur = q.top();
            q.pop();
            q.push(cur / 2);
            k--;
        }
        long long ans = 0;
        while (!q.empty()) {
            ans += q.top();
            q.pop();
        }
        return ans;

=======

        priority_queue<int> pq;
        for (auto &g : gifts) {
            pq.push(g);
        }
        while (k--) {
            int v = pq.top(); pq.pop();
            v = sqrt(v);
            pq.push(v);
        }
        long long ans = 0;
        while (!pq.empty()) {
            ans += pq.top(); pq.pop();
        }
        return ans;

=======

        long long sum = 0;
        for (auto& i: gifts) sum += i;
        while (k--) {
            auto max = *max_element(gifts.begin(), gifts.end());
            sum -= max;
            sum += sqrt(max);
            for (auto& i: gifts) {
                if (i == max) {
                    i = sqrt(i);
                    break;
                }
            }
        }
        return sum;
