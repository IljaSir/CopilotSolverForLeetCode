Synthesizing 10/10 solutions

=======

        map<int, int> m;
        for (int i = 0; i < nums.size(); i++) {
            m[nums[i]]++;
        }
        int res = 0;
        for (auto it = m.begin(); it != m.end(); it++) {
            auto it2 = m.find(it->first + 1);
            if (it2 != m.end()) {
                res = max(res, it->second + it2->second);
            }
        }
        return res;

=======

        int n = nums.size();
        unordered_map<int, int> cnt;
        for (int i = 0; i < n; i++) {
            cnt[nums[i]]++;
        }
        int ans = 0;
        for (auto& p: cnt) {
            if (cnt.find(p.first + 1) != cnt.end()) {
                ans = max(ans, p.second + cnt[p.first + 1]);
            }
        }
        return ans;

=======

        unordered_map<int, int> m;
        int res = 0;
        for (int i = 0; i < nums.size(); ++i) {
            m[nums[i]]++;
            if (m.find(nums[i] + 1) != m.end()) {
                res = max(res, m[nums[i]] + m[nums[i] + 1]);
            }
            if (m.find(nums[i] - 1) != m.end()) {
                res = max(res, m[nums[i]] + m[nums[i] - 1]);
            }
        }
        return res;

=======

        map<int, int> m;
        for (auto& n : nums) {
            m[n]++;
        }
        int ans = 0;
        for (auto it = m.begin(); it != m.end(); it++) {
            auto it2 = it;
            it2++;
            if (it2 != m.end() && it->first + 1 == it2->first) {
                ans = max(ans, it->second + it2->second);
            }
        }
        return ans;

=======

        unordered_map<int, int> m;
        int ans = 0;
        for (int n : nums) {
            m[n]++;
        }
        for (auto& [k, v] : m) {
            if (m.count(k + 1)) {
                ans = max(ans, v + m[k + 1]);
            }
        }
        return ans;

=======

        unordered_map<int, int> cnt;
        for (int x: nums) cnt[x]++;
        int res = 0;
        for (auto& [k, v]: cnt) {
            if (cnt.count(k + 1)) {
                res = max(res, v + cnt[k + 1]);
            }
        }
        return res;

=======

        map<int, int> cnt;
        for (auto num : nums) {
            cnt[num] += 1;
        }
        int res = 0;
        for (auto it = cnt.begin(); it != cnt.end(); ++it) {
            auto jt = it;
            ++jt;
            if (jt != cnt.end() && jt->first == it->first + 1) {
                res = max(res, jt->second + it->second);
            }
        }
        return res;

=======

        map<int, int> m;
        for (auto n: nums) m[n]++;
        int res = 0;
        for (auto it = m.begin(); it != m.end(); it++) {
            auto it2 = it; it2++;
            if (it2 != m.end() && it->first + 1 == it2->first) {
                res = max(res, it->second + it2->second);
            }
        }
        return res;

=======

        int res = 0;
        unordered_map<int, int> m;
        for (int n: nums) {
            m[n]++;
        }
        for (auto &p: m) {
            if (m.count(p.first + 1)) {
                res = max(res, p.second + m[p.first + 1]);
            }
        }
        return res;

=======

        int ans = 0;
        unordered_map<int, int> mp;
        for (auto& x: nums) mp[x]++;
        for (auto& x: mp) {
            auto it = mp.find(x.first + 1);
            if (it != mp.end()) ans = max(ans, x.second + it->second);
        }
        return ans;
