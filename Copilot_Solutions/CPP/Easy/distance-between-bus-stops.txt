Synthesizing 10/10 solutions

=======

        int total = accumulate(distance.begin(), distance.end(), 0);
        if (start > destination) {
            swap(start, destination);
        }
        int sum = accumulate(distance.begin() + start, distance.begin() + destination, 0);
        return min(sum, total - sum);

=======

        int sum = 0;
        int n = distance.size();
        for (int i = 0; i < n; i++) {
            sum += distance[i];
        }
        if (start > destination) {
            swap(start, destination);
        }
        int tmp = 0;
        for (int i = start; i < destination; i++) {
            tmp += distance[i];
        }
        return min(tmp, sum - tmp);

=======

        int n = distance.size();
        int dist = 0;
        for (int i = start; i != destination; i = (i + 1) % n) {
            dist += distance[i];
        }
        int total = accumulate(distance.begin(), distance.end(), 0);
        return min(dist, total - dist);

=======

        int sum = 0;
        int i = start;
        while (true) {
            sum += distance[i];
            i = (i + 1) % distance.size();
            if (i == destination) {
                break;
            }
        }
        int sum2 = 0;
        i = start;
        while (true) {
            i = (i - 1 + distance.size()) % distance.size();
            sum2 += distance[i];
            if (i == destination) {
                break;
            }
        }
        return min(sum, sum2);

=======

        int sum = 0;
        for (int i = 0; i < distance.size(); i++) {
            sum += distance[i];
        }
        int sum1 = 0;
        int i = start;
        while (i != destination) {
            sum1 += distance[i];
            i = (i + 1) % distance.size();
        }
        return min(sum1, sum - sum1);

=======

        int n = distance.size();
        if (n == 0) return 0;
        if (start == destination) return 0;
        if (start > destination) swap(start, destination);
        int sum = 0;
        for (int i = 0; i < n; i++) {
            sum += distance[i];
        }
        int total = 0;
        for (int i = start; i < destination; i++) {
            total += distance[i];
        }
        return min(total, sum - total);

=======

        int total = 0;
        for (int d : distance) total += d;
        int dist = 0;
        if (start > destination) swap(start, destination);
        for (int i = start; i < destination; i++) dist += distance[i];
        return min(dist, total - dist);

=======

        int sum = 0;
        for (int i = 0; i < distance.size(); ++i) {
            sum += distance[i];
        }
        int d = 0;
        if (start <= destination) {
            for (int i = start; i < destination; ++i) {
                d += distance[i];
            }
        } else {
            for (int i = destination; i < start; ++i) {
                d += distance[i];
            }
        }
        return min(d, sum - d);

=======

        int n = distance.size();
        int tot = 0;
        for (int i = 0; i < n; i++) {
            tot += distance[i];
        }
        int s = min(start, destination);
        int d = max(start, destination);
        int sum = 0;
        for (int i = s; i < d; i++) {
            sum += distance[i];
        }
        return min(sum, tot - sum);

=======

        int sum = 0;
        for (auto d : distance) {
            sum += d;
        }
        int i = min(start, destination);
        int j = max(start, destination);
        int sum1 = 0;
        for (; i < j; i++) {
            sum1 += distance[i];
        }
        return min(sum1, sum - sum1);
