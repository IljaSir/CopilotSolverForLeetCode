Synthesizing 10/10 solutions

=======

        map<string, int> m1;
        map<string, int> m2;
        for (int i = 0; i < list1.size(); i++) {
            m1[list1[i]] = i;
        }
        for (int i = 0; i < list2.size(); i++) {
            m2[list2[i]] = i;
        }
        vector<string> ret;
        int minIdx = INT_MAX;
        for (auto it = m1.begin(); it != m1.end(); it++) {
            if (m2.find(it->first) != m2.end()) {
                int idx = it->second + m2[it->first];
                if (idx < minIdx) {
                    ret.clear();
                    ret.push_back(it->first);
                    minIdx = idx;
                } else if (idx == minIdx) {
                    ret.push_back(it->first);
                }
            }
        }
        return ret;

=======

        vector<string> res;
        unordered_map<string, int> m;
        int minSum = INT_MAX;
        for (int i = 0; i < list1.size(); i++) {
            m[list1[i]] = i;
        }
        for (int i = 0; i < list2.size(); i++) {
            if (m.find(list2[i]) != m.end()) {
                if (m[list2[i]] + i < minSum) {
                    res.clear();
                    res.push_back(list2[i]);
                    minSum = m[list2[i]] + i;
                } else if (m[list2[i]] + i == minSum) {
                    res.push_back(list2[i]);
                }
            }
        }
        return res;

=======

        vector<string> res;
        unordered_map<string, int> m;
        int minSum = INT_MAX;
        for (int i = 0; i < list1.size(); i++) {
            m[list1[i]] = i;
        }
        for (int i = 0; i < list2.size(); i++) {
            if (m.count(list2[i])) {
                int sum = i + m[list2[i]];
                if (sum < minSum) {
                    minSum = sum;
                    res.clear();
                    res.push_back(list2[i]);
                } else if (sum == minSum) {
                    res.push_back(list2[i]);
                }
            }
        }
        return res;

=======

        map<string, int> m;
        for (int i = 0; i < list1.size(); i++) {
            m[list1[i]] = i;
        }
        vector<string> res;
        int minSum = INT_MAX;
        for (int i = 0; i < list2.size(); i++) {
            auto it = m.find(list2[i]);
            if (it != m.end()) {
                int sum = it->second + i;
                if (minSum > sum) {
                    minSum = sum;
                    res.clear();
                    res.push_back(list2[i]);
                } else if (minSum == sum) {
                    res.push_back(list2[i]);
                }
            }
        }
        return res;

=======

        unordered_map<string, int> m;
        for (int i = 0; i < list1.size(); i++) {
            m[list1[i]] = i;
        }
        vector<string> ans;
        int minIndex = INT_MAX;
        for (int i = 0; i < list2.size(); i++) {
            if (m.find(list2[i]) != m.end()) {
                if (m[list2[i]] + i < minIndex) {
                    minIndex = m[list2[i]] + i;
                    ans.clear();
                    ans.push_back(list2[i]);
                } else if (m[list2[i]] + i == minIndex) {
                    ans.push_back(list2[i]);
                }
            }
        }
        return ans;

=======

        unordered_map<string, int> index;
        for (int i = 0; i < list1.size(); i++) {
            index[list1[i]] = i;
        }
        vector<string> res;
        int minSum = INT_MAX;
        for (int i = 0; i < list2.size(); i++) {
            if (index.count(list2[i])) {
                if (minSum > i + index[list2[i]]) {
                    res.clear();
                    res.push_back(list2[i]);
                    minSum = i + index[list2[i]];
                } else if (minSum == i + index[list2[i]]) {
                    res.push_back(list2[i]);
                }
            }
        }
        return res;

=======

        vector<string> res;
        int minIndex = INT_MAX;
        unordered_map<string, int> map;
        for (int i = 0; i < list1.size(); i++) {
            map[list1[i]] = i;
        }
        for (int i = 0; i < list2.size(); i++) {
            if (map.count(list2[i])) {
                if (map[list2[i]] + i < minIndex) {
                    res.clear();
                    res.push_back(list2[i]);
                    minIndex = map[list2[i]] + i;
                } else if (map[list2[i]] + i == minIndex) {
                    res.push_back(list2[i]);
                }
            }
        }
        return res;

=======

        vector<string> res;
        unordered_map<string, int> m;
        int minIndex = INT_MAX;
        for (int i = 0; i < list1.size(); ++i) {
            m[list1[i]] = i;
        }
        for (int i = 0; i < list2.size(); ++i) {
            if (m.count(list2[i])) {
                if (m[list2[i]] + i < minIndex) {
                    res.clear();
                    res.push_back(list2[i]);
                    minIndex = m[list2[i]] + i;
                } else if (m[list2[i]] + i == minIndex) {
                    res.push_back(list2[i]);
                }
            }
        }
        return res;

=======

        unordered_map<string, int> hashTable;
        for (int i = 0; i < list1.size(); i++) {
            hashTable[list1[i]] = i;
        }
        vector<string> result;
        int minSum = INT_MAX;
        for (int i = 0; i < list2.size(); i++) {
            if (hashTable.find(list2[i]) != hashTable.end()) {
                if (i + hashTable[list2[i]] < minSum) {
                    result.clear();
                    result.push_back(list2[i]);
                    minSum = i + hashTable[list2[i]];
                } else if (i + hashTable[list2[i]] == minSum) {
                    result.push_back(list2[i]);
                }
            }
        }
        return result;

=======

        vector<string> res;
        int min_index = INT_MAX;
        int i = 0, j = 0;
        for (string s1 : list1) {
            j = 0;
            for (string s2 : list2) {
                if (s1 == s2) {
                    if (i + j < min_index) {
                        min_index = i + j;
                        res.clear();
                        res.push_back(s1);
                    } else if (i + j == min_index) {
                        res.push_back(s1);
                    }
                }
                j++;
            }
            i++;
        }
        return res;
