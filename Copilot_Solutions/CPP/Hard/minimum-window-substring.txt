Synthesizing 10/10 solutions

=======

        unordered_map<char, int> need, window;
        for (char c : t) need[c]++;
        int left = 0, right = 0;
        int valid = 0;
        int start = 0, len = INT_MAX;
        while (right < s.size()) {
            char c = s[right];
            right++;
            if (need.count(c)) {
                window[c]++;
                if (window[c] == need[c]) valid++;
            }
            while (valid == need.size()) {
                if (right - left < len) {
                    start = left;
                    len = right - left;
                }
                char d = s[left];
                left++;
                if (need.count(d)) {
                    if (window[d] == need[d]) valid--;
                    window[d]--;
                }
            }
        }
        return len == INT_MAX ? "" : s.substr(start, len);

=======

        int m = s.size();
        int n = t.size();
        if (m < n) return "";
        vector<int> need(128, 0);
        vector<int> window(128, 0);
        for (auto c: t) {
            need[c]++;
        }
        int left = 0, right = 0;
        int match = 0;
        int start = 0, length = INT_MAX;
        while (right < m) {
            char c1 = s[right];
            if (need[c1] > 0) {
                window[c1]++;
                if (window[c1] == need[c1])
                    match++;
            }
            right++;
            while (match == n) {
                if (right - left < length) {
                    start = left;
                    length = right - left;
                }
                char c2 = s[left];
                if (need[c2] > 0) {
                    window[c2]--;
                    if (window[c2] < need[c2])
                        match--;
                }
                left++;
            }
        }
        return length == INT_MAX ? "" : s.substr(start, length);

=======

        vector<int> count(128, 0);
        for (char c : t) {
            count[c]++;
        }
        int left = 0;
        int right = 0;
        int minLeft = 0;
        int minLen = INT_MAX;
        int countT = t.size();
        while (right < s.size()) {
            if (count[s[right++]]-- > 0) {
                countT--;
            }
            while (countT == 0) {
                if (right - left < minLen) {
                    minLeft = left;
                    minLen = right - left;
                }
                if (count[s[left++]]++ == 0) {
                    countT++;
                }
            }
        }
        return minLen == INT_MAX ? "" : s.substr(minLeft, minLen);

=======

        int n = s.size();
        int m = t.size();
        if (n < m) return "";
        int cnt[256];
        int need[256];
        memset(cnt, 0, sizeof(cnt));
        memset(need, 0, sizeof(need));
        for (auto c : t) {
            need[c]++;
        }
        int found = 0;
        int left = 0;
        int right = 0;
        int minLeft = 0;
        int minRight = n;
        while (right < n) {
            if (need[s[right]] > 0) {
                cnt[s[right]]++;
                if (cnt[s[right]] <= need[s[right]]) {
                    found++;
                }
            }
            right++;
            while (found == m) {
                if (right - left < minRight - minLeft) {
                    minLeft = left;
                    minRight = right;
                }
                if (need[s[left]] > 0) {
                    cnt[s[left]]--;
                    if (cnt[s[left]] < need[s[left]]) {
                        found--;
                    }
                }
                left++;
            }
        }
        if (minRight == n) {
            return "";
        }
        return s.substr(minLeft, minRight - minLeft);

=======

        int m = s.size();
        int n = t.size();
        if (m < n) return "";
        vector<int> need(128, 0);
        vector<int> window(128, 0);
        for (auto c: t) {
            need[c]++;
        }
        int left = 0, right = 0;
        int match = 0;
        int start = 0, length = INT_MAX;
        while (right < m) {
            char c1 = s[right];
            if (need[c1] > 0) {
                window[c1]++;
                if (window[c1] == need[c1])
                    match++;
            }
            right++;
            while (match == n) {
                if (right - left < length) {
                    start = left;
                    length = right - left;
                }
                char c2 = s[left];
                if (need[c2] > 0) {
                    window[c2]--;
                    if (window[c2] < need[c2])
                        match--;
                }
                left++;
            }
        }
        return length == INT_MAX ? "" : s.substr(start, length);

=======

        int n = s.size();
        int m = t.size();
        if (n < m) return "";
        int cnt[256];
        int need[256];
        memset(cnt, 0, sizeof(cnt));
        memset(need, 0, sizeof(need));
        for (auto c : t) {
            need[c]++;
        }
        int found = 0;
        int left = 0;
        int right = 0;
        int minLeft = 0;
        int minRight = n;
        while (right < n) {
            if (need[s[right]] > 0) {
                cnt[s[right]]++;
                if (cnt[s[right]] <= need[s[right]]) {
                    found++;
                }
            }
            right++;
            while (found == m) {
                if (right - left < minRight - minLeft) {
                    minLeft = left;
                    minRight = right;
                }
                if (need[s[left]] > 0) {
                    cnt[s[left]]--;
                    if (cnt[s[left]] < need[s[left]]) {
                        found--;
                    }
                }
                left++;
            }
        }
        if (minRight == n) {
            return "";
        }
        return s.substr(minLeft, minRight - minLeft);

=======

        int m = s.size();
        int n = t.size();
        if (m < n) return "";
        vector<int> need(128, 0);
        vector<int> window(128, 0);
        for (auto c: t) {
            need[c]++;
        }
        int left = 0, right = 0;
        int match = 0;
        int start = 0, length = INT_MAX;
        while (right < m) {
            char c1 = s[right];
            if (need[c1] > 0) {
                window[c1]++;
                if (window[c1] == need[c1])
                    match++;
            }
            right++;
            while (match == n) {
                if (right - tarl, minLen);

=======

        int n = s.length();
        int m = t.length();
        if (n < m) return "";
        int left = 0, right = 0;
        int minLen = INT_MAX;
        int minLeft = 0;
        unordered_map<char, int> need, window;
        for (char c : t) need[c]++;
        int match = 0;
        while (right < n) {
            char c1 = s[right];
            if (need.count(c1)) {
                window[c1]++;
                if (window[c1] == need[c1]) match++;
            }
            right++;
            while (match == need.size()) {
                if (right - left < minLen) {
                    minLen = right - left;
                    minLeft = left;
                }
                char c2 = s[left];
                if (need.count(c2)) {
                    window[c2]--;
                    if (window[c2] < need[c2]) metch--;
                }
                left++;
            }
        }
        return minLen == INT_MAX ? "" : s.substf(minLeft < length) {
                    start = left;
                    length = right - left;
                }
                char c2 = s[left];
                if (need[c2] > 0) {
                    window[c2]--;
                    if (window[c2] < need[c2])
                        match--;
                }
                left++;
            }(minL, minLen);

=======

        int n = s.size();
        int m = t.size();
        if(n < m) return "";
        vector<int> cnt(128, 0);
        for(char c: t) cnt[c]++;
        int start = 0;
        int end = 0;
        int minLen = INT_MAX;
        int minStart = 0;
        int minEnd = 0;
        int count = 0;
        while(end < n){
            ifcnt[s[end]] > 0) count++;
            cnt[s[end]]--;
            end++;
            while(count == ){
                f(ed - start < minen){
                    minLen = end - start;
                    minStart = start;
                    minEnd = end;
                }
                cnt[s[start]]++;
                if(cnt[s[start]] > 0) count--;
                start++;
            }
        }
        if(minLen == INT_MAX) return "";
        return s.substr(minStart, minLen);

=======

        int n = s.length();
        int m = t.length();
        if (n < m) return "";
        int i = 0;
        int j = 0;
        int count = 0;
        int minLen = INT_MAX;
        int minStart = -1;
        unordered_map<char, int> mp;
        for (char c : t) {
            mp[c]++;
        }
        while (j < n) {
            if (mp.find(s[j]) != mp.end()) {
                mp[s[j]]--;
                if (mp[s[j]] >= 0) {
                    count++;
                }
            }
            while (count == m) {
                if (minLen > j - i + 1) {
                    minLen = j - i + 1;
                    minStart = i;
                }
                if (mp.find(s[i]) != mp.end()) {
                    mp[s[i]]++;
                    if (mp[s[i]] > 0) {
                        count--;
                    }
                }
                i++;
            }
            j++;
        }
        if (minStart == -1) return "";
        return s.substr(minStart, minLen);

=======

        int n = s.length();
        int m = t.length();
        if (n < m) return "";
        int left = 0, right = 0;
        int minLen = INT_MAX;
        int minLeft = 0;
        unordered_map<char, int> need, window;
        for (char c : t) need[c]++;
        int match = 0;
        while (right < n) {
            char c1 = s[right];
            if (need.count(c1)) {
                window[c1]++;
                if (window[c1] == need[c1]) match++;
            }
            right++;
            while (match == need.size()) {
                if (right - left < minLen) {
                    minLen = right - left;
                    minLeft = left;
                }
                char c2 = s[left];
                if (need.count(c2)) {
                    window[c2]--;
                    if (window[c2] < need[c2]) match--;
                }
                left++;
            }
        }
        return minLen == INT_MAX ? "" : s.substr(minLeft, minLen);

=======

        int n = s.size();
        int m = t.size();
        if (n < m) return "";

        vector<int> charCount(128, 0);
        for (auto c : t) charCount[c]++;

        int i = 0;
        int j = 0;
        int minLen = INT_MAX;
        int minStart = 0;
        int count = 0;
        while (j < n) {
            if (charCount[s[j++]]-- > 0) count++;
            while (count == m) {
                if (j - i < minLen) {
                    minLen = j - i;
                    minStart = i;
                }
                if (charCount[s[i++]]++ == 0) count--;
            }
        }
        return minLen == INT_MAX ? "" : s.substr(minStart
        }
        return length == INT_MAX ? "" : s.substr(start, length);

=======

        int n = s.size();
        int m = t.size();
        if (n < m) return "";
        int cnt[256];
        int need[256];
        memset(cnt, 0, sizeof(cnt));
        memset(need, 0, sizeof(need));
        for (auto c : t) {
            need[c]++;
        }
        int found = 0;
        int left = 0;
        int right = 0;
        int minLeft = 0;
        int minRight = n;
        while (right < n) {
            if (need[s[right]] > 0) {
                cnt[s[right]]++;
                if (cnt[s[right]] <= need[s[right]]) {
                    found++;
                }
            }
            right++;
            while (found == m) {
                if (right - left < minRight - minLeft) {
                    minLeft = left;
                    minRight = right;
                }
                if (need[s[left]] > 0) {
                    cnt[s[left]]--;
                    if (cnt[s[left]] < need[s[left]]) {
                        found--;
                    }
                }
                left++;
            }
        }
        if (minRight == n) {
            return "";
        }
        return s.substr(minLeft, minRight - minLeft);

=======

        int n = s.length();
        int m = t.length();
        vector<int> cnt(128, 0);
        for (char ch: t) {
            cnt[ch]++;
        }
        int l = 0;
        int r = 0;
        int minL = 0;
        int minR = 0;
        int minLen = INT_MAX;
        int total = 0;
        while (r < n) {
            if (cnt[s[r]] > 0) {
                total++;
            }
            cnt[s[r]]--;
            r++;
            while (total == m) {
                if (r - l < minLen) {
                    minLen = r - l;
                    minL = l;
                    minR = r;
                }
                if (cnt[s[l]] == 0) {
                    total--;
                }
                cnt[s[l]]++;
                l++;
            }
        }
        return minLen == INT_MAX ? "" : s.substr(minL, minLen);

=======

        int n = s.size();
        int m = t.size();
        if(n < m) return "";
        vector<int> cnt(128, 0);
        for(char c: t) cnt[c]++;
        int start = 0;
        int end = 0;
        int minLen = INT_MAX;
        int minStart = 0;
        int minEnd = 0;
        int count = 0;
        while(end < n){
            if(cnt[s[end]] > 0) count++;
            cnt[s[end]]--;
            end++;
            while(count == m){
                if(end - start < minLen){
                    minLen = end - start;
                    minStart = start;
                    minEnd = end;
                }
                cnt[s[start]]++;
                if(cnt[s[start]] > 0) count--;
                start++;
            }
        }
        if(minLen == INT_MAX) return "";
        return s.substr(minStart, minLen);

=======

        int n = s.length();
        int m = t.length();
        if (n < m) return "";
        int i = 0;
        int j = 0;
        int count = 0;
        int minLen = INT_MAX;
        int minStart = -1;
        unordered_map<char, int> mp;
        for (char c : t) {
            mp[c]++;
        }
        while (j < n) {
            if (mp.find(s[j]) != mp.end()) {
                mp[s[j]]--;
                if (mp[s[j]] >= 0) {
                    count++;
                }
            }
            while (count == m) {
                if (minLen > j - i + 1) {
                    minLen = j - i + 1;
                    minStart = i;
                }
                if (mp.find(s[i]) != mp.end()) {
                    mp[s[i]]++;
                    if (mp[s[i]] > 0) {
                        count--;
                    }
                }
                i++;
            }
            j++;
        }
        if (minStart == -1) return "";
        return s.substr(minStart, minLen);

=======

        int n = s.size();
        int m = t.size();
        if (n < m) return "";

        vector<int> charCount(128, 0);
        for (auto c : t) charCount[c]++;

        int i = 0;
        int j = 0;
        int minLen = INT_MAX;
        int minStart = 0;
        int count = 0;
        while (j < n) {
            if (charCount[s[j++]]-- > 0) count++;
            while (count == m) {
                if (j - i < minLen) {
                    minLen = j - i;
                    minStart = i;
                }
                if (charCount[s[i++]]++ == 0) count--;
            }
        }
        return minLen == INT_MAX ? "" : s.substr(minStart, minLen);

=======

        int n = s.size();
        int m = t.size();
        if(n < m) return "";
        vector<int> cnt(128, 0);
        for(char c: t) cnt[c]++;
        int start = 0;
        int end = 0;
        int minLen = INT_MAX;
        int minStart = 0;
        int minEnd = 0;
        int count = 0;
        while(end < n){
            if(cnt[s[end]] > 0) count++;
            cnt[s[end]]--;
            end++;
            while(count == m){
                if(end - start < minLen){
                    minLen = end - start;
                    minStart = start;
                    minEnd = end;
                }
                cnt[s[start]]++;
                if(cnt[s[start]] > 0) count--;
                start++;
            }
        }
        if(minLen == INT_MAX) return "";
        return s.substr(minStart, minLen);

=======

        int n = s.length();
        int m = t.length();
        if (n < m) return "";
        int i = 0;
        int j = 0;
        int count = 0;
        int minLen = INT_MAX;
        int minStart = -1;
        unordered_map<char, int> mp;
        for (char c : t) {
            mp[c]++;
        }
        while (j < n) {
            if (mp.find(s[j]) != mp.end()) {
                mp[s[j]]--;
                if (mp[s[j]] >= 0) {
                    count++;
                }
            }
            while (count == m) {
                if (minLen > j - i + 1) {
                    minLen = j - i + 1;
                    minStart = i;
                }
                if (mp.find(s[i]) != mp.end()) {
                    mp[s[i]]++;
                    if (mp[s[i]] > 0) {
                        count--;
                    }
                }
                i++;
            }
            j++;
        }
        if (minStart == -1) return "";
        return s.substr(minStart, minLen);

=======

        int n = s.size();
        int m = t.size();
        if (n < m) return "";

        vector<int> charCount(128, 0);
        for (auto c : t) charCount[c]++;

        int i = 0;
        int j = 0;
        int minLen = INT_MAX;
        int minStart = 0;
        int count = 0;
        while (j < n) {
            if (charCount[s[j++]]-- > 0) count++;
            while (count == m) {
                if (j - i < minLen) {
                    minLen = j - i;
                    minStart = i;
                }
                if (charCount[s[i++]]++ == 0) count--;
            }
        }
        return minLen == INT_MAX ? "" : s.substr(minStart, minLen);

=======

        int n = s.size();
        int m = t.size();
        int l = 0, r = 0;
        int cnt = 0;
        int minn = 1e9;
        string ans;
        unordered_map<char, int> mp;
        for (char c : t) mp[c]++;
        while (r < n) {
            if (mp[s[r]] > 0) cnt++;
            mp[s[r]]--;
            r++;
            while (cnt == m) {
                if (r - l < minn) {
                    minn = r - l;
                    ans = s.substr(l, r - l);
                }
                if (mp[s[l]] == 0) cnt--;
                mp[s[l]]++;
                l++;
            }
        }
        return ans;
