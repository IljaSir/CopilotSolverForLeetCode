Synthesizing 10/10 solutions

=======

        vector<vector<int>> graph(n);
        for (auto& c : connections) {
            graph[c[0]].push_back(c[1]);
            graph[c[1]].push_back(c[0]);
        }
        vector<vector<int>> ans;
        vector<int> rank(n, -1);
        function<int(int,int)> dfs = [&](int u, int p) {
            rank[u] = 0;
            for (auto& v : graph[u]) {
                if (v == p) continue;
                if (rank[v] == -1) {
                    rank[u] = max(rank[u], dfs(v, u) + 1);
                } else {
                    rank[u] = max(rank[u], rank[v] + 1);
                }
            }
            if (rank[u] == 0) ans.push_back({u, p});
            return rank[u];
        };
        dfs(0, -1);
        return ans;

=======

        vector<vector<int>> graph(n);
        for (auto& c : connections) {
            graph[c[0]].push_back(c[1]);
            graph[c[1]].push_back(c[0]);
        }
        vector<int> low(n, -1), dfn(n, -1);
        vector<vector<int>> res;
        int time = 0;
        for (int i = 0; i < n; i++) {
            if (dfn[i] == -1) {
                dfs(i, -1, graph, low, dfn, time, res);
            }
        }
        return res;
    }
    void dfs(int u, int parent, vector<vector<int>>& graph, vector<int>& low, vector<int>& dfn, int& time, vector<vector<int>>& res) {
        low[u] = dfn[u] = time++;
        for (int v : graph[u]) {
            if (v == parent) continue;
            if (dfn[v] == -1) {
                dfs(v, u, graph, low, dfn, time, res);
                low[u] = min(low[u], low[v]);
                if (low[v] > dfn[u]) {
                    res.push_back({u, v});
                }
            } else {
                low[u] = min(low[u], dfn[v]);
            }
        }

=======

        vector<vector<int>> graph(n);
        for (const auto& edge: connections) {
            graph[edge[0]].push_back(edge[1]);
            graph[edge[1]].push_back(edge[0]);
        }
        vector<int> rank(n, -1);
        int r = 0;
        vector<vector<int>> res;
        dfs(0, -1, rank, r, graph, res);
        return res;

=======

        vector<vector<int>> graph(n);
        for (auto& con : connections) {
            graph[con[0]].push_back(con[1]);
            graph[con[1]].push_back(con[0]);
        }
        vector<vector<int>> res;
        vector<int> dfn(n, -1);
        vector<int> low(n, -1);
        int time = 0;
        function<void(int, int)> dfs = [&](int cur, int pre) {
            dfn[cur] = low[cur] = time++;
            for (auto& nxt : graph[cur]) {
                if (nxt == pre) continue;
                if (dfn[nxt] == -1) {
                    dfs(nxt, cur);
                    low[cur] = min(low[cur], low[nxt]);
                    if (low[nxt] > dfn[cur]) {
                        res.push_back({cur, nxt});
                    }
                } else {
                    low[cur] = min(low[cur], dfn[nxt]);
                }
            }
        };
        dfs(0, -1);
        return res;

=======

        vector<vector<int>> edges(n, vector<int>());
        for (auto& c : connections) {
            edges[c[0]].push_back(c[1]);
            edges[c[1]].push_back(c[0]);
        }
        vector<vector<int>> res;
        vector<int> disc(n, 0), low(n, 0);
        vector<bool> visited(n, false);
        dfs(edges, 0, -1, 0, disc, low, visited, res);
        return res;
    }
    
    void dfs(vector<vector<int>>& edges, int u, int parent, int time, vector<int>& disc, vector<int>& low, vector<bool>& visited, vector<vector<int>>& res) {
        visited[u] = true;
        disc[u] = time;
        low[u] = time;
        for (int v : edges[u]) {
            if (v == parent) continue;
            if (!visited[v]) {
                dfs(edges, v, u, time + 1, disc, low, visited, res);
                low[u] = min(low[u], low[v]);
                if (low[v] > disc[u]) {
                    res.push_back({u, v});
                }
            } else {
                low[u] = min(low[u], disc[v]);
            }
        }

=======

        vector<vector<int>> graph(n);
        for (auto& edge : connections) {
            graph[edge[0]].push_back(edge[1]);
            graph[edge[1]].push_back(edge[0]);
        }
        vector<int> low(n, -1);
        vector<int> dfn(n, -1);
        vector<vector<int>> result;
        function<void(int, int, int&)> dfs = [&](int u, int parent, int& time) {
            low[u] = dfn[u] = ++time;
            for (int v : graph[u]) {
                if (v == parent) continue;
                if (dfn[v] == -1) {
                    dfs(v, u, time);
                    low[u] = min(low[u], low[v]);
                    if (low[v] > dfn[u]) {
                        result.push_back({u, v});
                    }
                } else {
                    low[u] = min(low[u], dfn[v]);
                }
            }
        };
        int time = 0;
        dfs(0, 0, time);
        return result;

=======

        vector<vector<int>> graph(n);
        for (auto& e: connections) {
            graph[e[0]].push_back(e[1]);
            graph[e[1]].push_back(e[0]);
        }
        vector<int> rank(n, -1);
        vector<vector<int>> result;
        function<int(int, int)> dfs = [&](int node, int depth) {
            if (rank[node] != -1) {
                return rank[node];
            }
            rank[node] = depth;
            int minRank = depth;
            for (int next: graph[node]) {
                if (rank[next] == depth - 1) {
                    continue;
                }
                int nextRank = dfs(next, depth + 1);
                if (nextRank <= depth) {
                    continue;
                }
                result.push_back({node, next});
            }
            return minRank;
        };
        dfs(0, 0);
        return result;

=======

        vector<vector<int>> graph(n);
        for (auto& edge : connections) {
            graph[edge[0]].push_back(edge[1]);
            graph[edge[1]].push_back(edge[0]);
        }
        vector<int> pre(n, -1), low(n, -1);
        vector<vector<int>> res;
        int time = 0;
        function<void(int, int)> dfs = [&](int cur, int parent) {
            pre[cur] = low[cur] = time++;
            for (int nxt : graph[cur]) {
                if (pre[nxt] == -1) {
                    dfs(nxt, cur);
                    low[cur] = min(low[cur], low[nxt]);
                    if (low[nxt] > pre[cur]) {
                        res.push_back({cur, nxt});
                    }
                } else if (nxt != parent) {
                    low[cur] = min(low[cur], pre[nxt]);
                }
            }
        };
        dfs(0, -1);
        return res;

=======

        vector<vector<int>> ans;
        vector<int> disc(n, -1);
        vector<int> low(n, -1);
        vector<vector<int>> graph(n);
        for (auto& c : connections) {
            graph[c[0]].push_back(c[1]);
            graph[c[1]].push_back(c[0]);
        }
        for (int i = 0; i < n; ++i) {
            if (disc[i] == -1) {
                dfs(i, -1, 0, disc, low, graph, ans);
            }
        }
        return ans;
    }
    void dfs(int u, int p, int time, vector<int>& disc, vector<int>& low, vector<vector<int>>& graph, vector<vector<int>>& ans) {
        disc[u] = low[u] = time;
        for (auto& v : graph[u]) {
            if (v == p) {
                continue;
            }
            if (disc[v] == -1) {
                dfs(v, u, time + 1, disc, low, graph, ans);
                low[u] = min(low[u], low[v]);
                if (low[v] > disc[u]) {
                    ans.push_back({u, v});
                }
            } else {
                low[u] = min(low[u], disc[v]);
            }
        }

=======

		vector<vector<int>> res;
		vector<int> visited(n, -1);
		vector<int> low(n, 0);
		vector<vector<int>> graph(n);
		for (auto& e: connections) {
			graph[e[0]].push_back(e[1]);
			graph[e[1]].push_back(e[0]);
		}
		dfs(0, 0, visited, low, graph, res);
		return res;
