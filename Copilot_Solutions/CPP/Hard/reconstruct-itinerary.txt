Synthesizing 10/10 solutions

=======

        unordered_map<string, multiset<string>> graph;
        for (auto ticket : tickets) {
            graph[ticket[0]].insert(ticket[1]);
        }
        vector<string> res;
        stack<string> st;
        st.push("JFK");
        while (!st.empty()) {
            string cur = st.top();
            if (graph[cur].empty()) {
                res.push_back(cur);
                st.pop();
            } else {
                st.push(*graph[cur].begin());
                graph[cur].erase(graph[cur].begin());
            }
        }
        reverse(res.begin(), res.end());
        return res;

=======

        unordered_map<string, multiset<string>> graph;
        for (auto ticket : tickets) {
            graph[ticket[0]].insert(ticket[1]);
        }
        vector<string> res;
        stack<string> s;
        s.push("JFK");
        while (!s.empty()) {
            string top = s.top();
            if (graph[top].empty()) {
                res.push_back(top);
                s.pop();
            } else {
                s.push(*graph[top].begin());
                graph[top].erase(graph[top].begin());
            }
        }
        reverse(res.begin(), res.end());
        return res;

=======

        vector<string> res;
        unordered_map<string, multiset<string>> m;
        for (auto ticket : tickets) {
            m[ticket[0]].insert(ticket[1]);
        }
        stack<string> s;
        s.push("JFK");
        while (!s.empty()) {
            string t = s.top();
            if (m[t].empty()) {
                res.push_back(t);
                s.pop();
            } else {
                s.push(*m[t].begin());
                m[t].erase(m[t].begin());
            }
        }
        reverse(res.begin(), res.end());
        return res;

=======

        unordered_map<string, multiset<string>> m;
        for (auto& t : tickets) {
            m[t[0]].insert(t[1]);
        }
        vector<string> res;
        stack<string> s;
        s.push("JFK");
        while (!s.empty()) {
            string t = s.top();
            if (m[t].empty()) {
                res.push_back(t);
                s.pop();
            } else {
                s.push(*m[t].begin());
                m[t].erase(m[t].begin());
            }
        }
        return vector<string>(res.rbegin(), res.rend());

=======

        unordered_map<string, multiset<string>> graph;
        for (auto ticket : tickets) {
            graph[ticket[0]].insert(ticket[1]);
        }
        vector<string> ans;
        stack<string> st;
        st.push("JFK");
        while (!st.empty()) {
            string top = st.top();
            if (graph[top].empty()) {
                ans.push_back(top);
                st.pop();
            } else {
                st.push(*graph[top].begin());
                graph[top].erase(graph[top].begin());
            }
        }
        reverse(ans.begin(), ans.end());
        return ans;

=======

        unordered_map<string, multiset<string>> m;
        vector<string> res;
        for (auto& ticket : tickets) {
            m[ticket[0]].insert(ticket[1]);
        }
        stack<string> s;
        s.push("JFK");
        while (!s.empty()) {
            string cur = s.top();
            if (m[cur].empty()) {
                res.push_back(cur);
                s.pop();
            } else {
                s.push(*m[cur].begin());
                m[cur].erase(m[cur].begin());
            }
        }
        reverse(res.begin(), res.end());
        return res;

=======

        vector<string> res;
        unordered_map<string, priority_queue<string, vector<string>, greater<string>>> mp;
        for (auto& ticket : tickets) {
            mp[ticket[0]].push(ticket[1]);
        }
        stack<string> st;
        st.push("JFK");
        while (!st.empty()) {
            string top = st.top();
            if (mp[top].empty()) {
                res.push_back(top);
                st.pop();
            } else {
                st.push(mp[top].top());
                mp[top].pop();
            }
        }
        reverse(res.begin(), res.end());
        return res;

=======

        unordered_map<string, multiset<string>> graph;
        for(auto& ticket : tickets) {
            graph[ticket[0]].insert(ticket[1]);
        }
        vector<string> result;
        dfs(graph, "JFK", result);
        reverse(result.begin(), result.end());
        return result;

=======

        map<string, multiset<string>> adj;
        for (auto& t : tickets) {
            adj[t[0]].insert(t[1]);
        }
        vector<string> res;
        stack<string> stk;
        stk.push("JFK");
        while (!stk.empty()) {
            string t = stk.top();
            if (adj[t].empty()) {
                res.push_back(t);
                stk.pop();
            } else {
                auto it = adj[t].begin();
                stk.push(*it);
                adj[t].erase(it);
            }
        }
        reverse(res.begin(), res.end());
        return res;

=======

        std::unordered_map<std::string, std::multiset<std::string>> um;
        for (const auto& ticket : tickets) {
            um[ticket[0]].insert(ticket[1]);
        }
        std::vector<std::string> result;
        std::function<void(std::string)> dfs = [&](std::string airport) {
            while (um[airport].size()) {
                std::string next = *um[airport].begin();
                um[airport].erase(um[airport].begin());
                dfs(next);
            }
            result.push_back(airport);
        };
        dfs("JFK");
        std::reverse(result.begin(), result.end());
        return result;
