Synthesizing 10/10 solutions

=======

        int n = words.size();
        int m = letters.size();
        vector<int> cnt(26, 0);
        for (int i = 0; i < m; ++i) {
            cnt[letters[i] - 'a']++;
        }
        return dfs(words, cnt, score, 0);
    }
    int dfs(vector<string>& words, vector<int>& cnt, vector<int>& score, int pos) {
        int n = words.size();
        if (pos == n) return 0;
        int maxScore = 0;
        vector<int> cntCopy = cnt;
        bool canForm = true;
        for (char c : words[pos]) {
            if (cnt[c - 'a'] == 0) {
                canForm = false;
                break;
            }
            cnt[c - 'a']--;
        }
        if (canForm) {
            int curScore = 0;
            for (char c : words[pos]) {
                curScore += score[c - 'a'];
            }
            maxScore = max(maxScore, curScore + dfs(words, cnt, score, pos + 1));
        }
        cnt = cntCopy;
        maxScore = max(maxScore, dfs(words, cnt, score, pos + 1));
        return maxScore;

=======

        unordered_map<char, int> m;
        for (int i = 0; i < letters.size(); ++i) {
            m[letters[i]]++;
        }
        return dfs(words, 0, m, score);
    }
    int dfs(vector<string>& words, int pos, unordered_map<char, int> m, vector<int>& score) {
        if (pos == words.size()) return 0;
        int res = dfs(words, pos + 1, m, score);
        string word = words[pos];
        int sum = 0;
        for (int i = 0; i < word.size(); ++i) {
            if (m[word[i]] == 0) {
                for (int j = 0; j < i; ++j) {
                    m[word[j]]++;
                }
                return res;
            }
            m[word[i]]--;
            sum += score[word[i] - 'a'];
        }
        res = max(res, sum + dfs(words, pos + 1, m, score));
        return res;

=======

        unordered_map<char, int> letterCount;
        for (auto c : letters) {
            letterCount[c]++;
        }
        return maxScoreWords(words, 0, letterCount, score);
    }
    int maxScoreWords(vector<string>& words, int idx, unordered_map<char, int> letterCount, vector<int>& score) {
        if (idx == words.size()) {
            return 0;
        }
        int maxScore = 0;
        int wordScore = 0;
        bool canFormWord = true;
        for (auto c : words[idx]) {
            if (letterCount[c] == 0) {
                canFormWord = false;
                break;
            }
            letterCount[c]--;
            wordScore += score[c - 'a'];
        }
        if (canFormWord) {
            maxScore = wordScore + maxScoreWords(words, idx + 1, letterCount, score);
        }
        maxScore = max(maxScore, maxScoreWords(words, idx + 1, letterCount, score));
        return maxScore;

=======

        unordered_map<char, int> mp;
        for (char c: letters) mp[c]++;
        return dfs(words, 0, mp, score);
    }
    int dfs(vector<string>& words, int start, unordered_map<char, int> mp, vector<int>& score) {
        if (start == words.size()) return 0;
        int res = dfs(words, start + 1, mp, score);
        int tmp = 0;
        bool flag = true;
        for (char c: words[start]) {
            if (mp[c] == 0) {
                flag = false;
                break;
            }
            mp[c]--;
            tmp += score[c - 'a'];
        }
        if (flag) {
            res = max(res, tmp + dfs(words, start + 1, mp, score));
        }
        return res;

=======

        vector<int> cnt(26);
        for (char c : letters) ++cnt[c - 'a'];
        int ans = 0;
        dfs(words, 0, cnt, score, ans);
        return ans;
    }
    
    void dfs(vector<string>& words, int i, vector<int>& cnt, vector<int>& score, int& ans) {
        if (i == words.size()) {
            int sum = 0;
            for (int i = 0; i < 26; ++i) {
                if (cnt[i] < 0) return;
                sum += cnt[i] * score[i];
            }
            ans = max(ans, sum);
            return;
        }
        dfs(words, i + 1, cnt, score, ans);
        for (char c : words[i]) --cnt[c - 'a'];
        dfs(words, i + 1, cnt, score, ans);
        for (char c : words[i]) ++cnt[c - 'a'];

=======

        int n = words.size();
        int m = letters.size();
        int res = 0;
        vector<int> cnt(26, 0);
        for (auto ch : letters) {
            cnt[ch - 'a']++;
        }
        for (int i = 0; i < (1 << n); i++) {
            vector<int> tmp_cnt = cnt;
            int tmp_res = 0;
            for (int j = 0; j < n; j++) {
                if (i & (1 << j)) {
                    bool flag = true;
                    for (auto ch : words[j]) {
                        if (tmp_cnt[ch - 'a'] == 0) {
                            flag = false;
                            break;
                        }
                        tmp_cnt[ch - 'a']--;
                    }
                    if (flag) {
                        for (auto ch : words[j]) {
                            tmp_res += score[ch - 'a'];
                        }
                    }
                }
            }
            res = max(res, tmp_res);
        }
        return res;

=======

        unordered_map<char, int> char_map;
        for (auto ch : letters) {
            char_map[ch]++;
        }
        return dfs(words, char_map, score, 0);
    }
    
    int dfs(vector<string>& words, unordered_map<char, int>& char_map, vector<int>& score, int idx) {
        if (idx == words.size()) {
            return 0;
        }
        int res = 0;
        int cur = dfs(words, char_map, score, idx + 1);
        if (isValid(words[idx], char_map)) {
            for (auto ch : words[idx]) {
                char_map[ch]--;
            }
            int score = getScore(words[idx], score);
            res = max(res, score + dfs(words, char_map, score, idx + 1));
            for (auto ch : words[idx]) {
                char_map[ch]++;
            }
        }
        return max(res, cur);
    }
    
    bool isValid(string word, unordered_map<char, int>& char_map) {
        for (auto ch : word) {
            if (char_map[ch] == 0) {
                return false;
            }
        }
        return true;
    }
    
    int getScore(string word, vector<int>& score) {
        int res = 0;
        for (auto ch : word) {
            res += score[ch - 'a'];
        }
        return res;

=======

        map<char, int> letterCount;
        for (auto c : letters) {
            letterCount[c]++;
        }
        return maxScore(words, letterCount, score);
    }
    
    int maxScore(vector<string>& words, map<char, int>& letterCount, vector<int>& score) {
        int maxScore = 0;
        for (int i = 0; i < words.size(); i++) {
            string word = words[i];
            map<char, int> wordCount;
            for (auto c : word) {
                wordCount[c]++;
            }
            bool canForm = true;
            for (auto c : word) {
                if (wordCount[c] > letterCount[c]) {
                    canForm = false;
                    break;
                }
            }
            if (canForm) {
                for (auto c : word) {
                    letterCount[c]--;
                }
                words.erase(words.begin() + i);
                int score = maxScore(words, letterCount, score);
                for (auto c : word) {
                    letterCount[c]++;
                }
                words.insert(words.begin() + i, word);
                maxScore = max(maxScore, score);
            }
        }
        int score = 0;
        for (auto c : letterCount) {
            score += c.second * score[c.first - 'a'];
        }
        return max(maxScore, score);

=======

        int res = 0, n = words.size();
        vector<int> cnt(26, 0);
        for (auto c : letters) cnt[c - 'a']++;
        vector<int> wordScore(n, 0);
        for (int i = 0; i < n; ++i) {
            for (auto c : words[i]) wordScore[i] += score[c - 'a'];
        }
        function<void(int, vector<int>&)> dfs = [&](int i, vector<int>& cnt) {
            if (i == n) return;
            dfs(i + 1, cnt);
            bool isValid = true;
            for (auto c : words[i]) {
                cnt[c - 'a']--;
                if (cnt[c - 'a'] < 0) isValid = false;
            }
            if (isValid) {
                res = max(res, wordScore[i]);
                dfs(i + 1, cnt);
            }
            for (auto c : words[i]) cnt[c - 'a']++;
        };
        dfs(0, cnt);
        return res;

=======

        int ans = 0;
        int n = words.size();
        vector<int> cnt(26, 0);
        for (auto c : letters) {
            cnt[c - 'a']++;
        }
        for (int s = 1; s < (1 << n); s++) {
            int tmp = 0;
            vector<int> cc = cnt;
            for (int i = 0; i < n; i++) {
                if ((s >> i) & 1) {
                    bool ok = true;
                    for (auto c : words[i]) {
                        if (--cc[c - 'a'] < 0) {
                            ok = false;
                            break;
                        }
                    }
                    if (ok) {
                        for (auto c : words[i]) {
                            tmp += score[c - 'a'];
                        }
                    }
                }
            }
            ans = max(ans, tmp);
        }
        return ans;
