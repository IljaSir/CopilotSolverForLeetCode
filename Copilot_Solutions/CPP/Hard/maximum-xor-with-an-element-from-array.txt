Synthesizing 10/10 solutions

=======

        sort(nums.begin(), nums.end());
        vector<pair<int, int>> q;
        for (int i = 0; i < queries.size(); i++) {
            q.push_back(make_pair(queries[i][1], i));
        }
        sort(q.begin(), q.end());
        vector<int> ans(queries.size());
        int j = 0;
        for (int i = 0; i < q.size(); i++) {
            while (j < nums.size() && nums[j] <= q[i].first) j++;
            int m = -1;
            for (int k = 0; k < j; k++) {
                m = max(m, nums[k] ^ q[i].first);
            }
            ans[q[i].second] = m;
        }
        return ans;

=======

        int n = nums.size();
        int m = queries.size();
        vector<int> ans(m);
        vector<int> idx(m);
        iota(idx.begin(), idx.end(), 0);
        sort(nums.begin(), nums.end());
        sort(idx.begin(), idx.end(), [&](int a, int b){
            return queries[a][1] < queries[b][1];
        });
        int j = 0;
        set<int> s;
        for (int i = 0; i < m; ++i) {
            while (j < n && nums[j] <= queries[idx[i]][1]) {
                s.insert(nums[j]);
                ++j;
            }
            if (s.empty()) ans[idx[i]] = -1;
            else {
                int x = queries[idx[i]][0];
                auto it = s.lower_bound(x);
                if (it != s.end()) ans[idx[i]] = *it ^ x;
                else {
                    --it;
                    ans[idx[i]] = *it ^ x;
                }
            }
        }
        return ans;

=======

        sort(nums.begin(), nums.end());
        int n = nums.size();
        int q = queries.size();
        vector<int> res(q, -1);
        for (int i = 0; i < q; i++) {
            queries[i].push_back(i);
        }
        sort(queries.begin(), queries.end(), [](const vector<int>& a, const vector<int>& b) {
            return a[1] < b[1];
        });
        int j = 0;
        for (int i = 0; i < q; i++) {
            while (j < n && nums[j] <= queries[i][1]) {
                j++;
            }
            if (j == 0) {
                continue;
            }
            int cur = 0;
            for (int k = 30; k >= 0; k--) {
                int bit = (queries[i][0] >> k) & 1;
                if (bit == 0) {
                    if (cur * 2 + 1 < j && nums[cur * 2 + 1] <= queries[i][1]) {
                        cur = cur * 2 + 1;
                    } else if (cur * 2 + 2 < j && nums[cur * 2 + 2] <= queries[i][1]) {
                        cur = cur * 2 + 2;
                    } else {
                        break;
                    }
                } else {
                    if (cur * 2 + 2 < j && nums[cur * 2 + 2] <= queries[i][1]) {
                        cur = cur * 2 + 2;
                    } else if (cur * 2 + 1 < j && nums[cur * 2 + 1] <= queries[i][1]) {
                        cur = cur * 2 + 1;
                    } else {
                        break;
                    }
                }
            }
            res[queries[i][2]] = nums[cur] ^ queries[i][0];
        }
        return res;

=======

        int n = nums.size();
        int m = queries.size();
        vector<int> ans(m);
        vector<pair<int, int>> q(m);
        for (int i = 0; i < m; i++) {
            q[i] = {queries[i][1], i};
        }
        sort(q.begin(), q.end());
        sort(nums.begin(), nums.end());
        int j = 0;
        for (auto& p : q) {
            int x = p.first;
            int idx = p.second;
            int max_xor = -1;
            for (; j < n; j++) {
                if (nums[j] > x) break;
                max_xor = max(max_xor, nums[j] ^ queries[idx][0]);
            }
            ans[idx] = max_xor;
        }
        return ans;

=======

        int n = nums.size();
        int q = queries.size();
        vector<int> ans(q);
        vector<int> idx(q);
        for (int i = 0; i < q; ++i) {
            idx[i] = i;
        }
        sort(begin(nums), end(nums));
        sort(begin(idx), end(idx), [&](int i, int j) {
            return queries[i][1] < queries[j][1];
        });
        int i = 0;
        Trie trie;
        for (int j = 0; j < q; ++j) {
            while (i < n && nums[i] <= queries[idx[j]][1]) {
                trie.insert(nums[i]);
                ++i;
            }
            ans[idx[j]] = trie.search(queries[idx[j]][0]);
        }
        return ans;

=======

        vector<int> res;
        sort(nums.begin(), nums.end());
        for (auto& q : queries) {
            int x = q[0], m = q[1];
            int idx = upper_bound(nums.begin(), nums.end(), m) - nums.begin();
            int max_xor = -1;
            for (int i = 0; i < idx; ++i) {
                max_xor = max(max_xor, x ^ nums[i]);
            }
            res.push_back(max_xor);
        }
        return res;

=======

        int n = nums.size();
        int q = queries.size();
        sort(nums.begin(), nums.end());
        vector<int> res(q);
        vector<int> idx(q);
        for (int i = 0; i < q; ++i) {
            idx[i] = i;
        }
        sort(idx.begin(), idx.end(), [&](int i, int j) {
            return queries[i][1] < queries[j][1];
        });
        int j = 0;
        for (int i = 0; i < q; ++i) {
            int x = queries[idx[i]][0];
            int m = queries[idx[i]][1];
            while (j < n && nums[j] <= m) {
                ++j;
            }
            if (j == 0) {
                res[idx[i]] = -1;
            } else {
                int max = 0;
                for (int k = 0; k < j; ++k) {
                    max = std::max(max, x ^ nums[k]);
                }
                res[idx[i]] = max;
            }
        }
        return res;

=======

        sort(nums.begin(), nums.end());
        int n = nums.size();
        vector<int> res;
        for (auto q : queries) {
            int x = q[0], m = q[1];
            int idx = upper_bound(nums.begin(), nums.end(), m) - nums.begin();
            int ans = -1;
            for (int i = 0; i < idx; i++) {
                ans = max(ans, x ^ nums[i]);
            }
            res.push_back(ans);
        }
        return res;

=======

        int n = nums.size();
        int m = queries.size();
        vector<int> answer(m);
        vector<int> idx(m);
        iota(idx.begin(), idx.end(), 0);
        sort(idx.begin(), idx.end(), [&queries](int i, int j){
            return queries[i][1] < queries[j][1];
        });
        sort(nums.begin(), nums.end());
        vector<bool> used(n);
        int j = 0;
        for (int i = 0; i < m; i++) {
            while (j < n && nums[j] <= queries[idx[i]][1]) {
                used[j] = true;
                j++;
            }
            if (j == 0) {
                answer[idx[i]] = -1;
                continue;
            }
            int cur = 0;
            for (int k = 30; k >= 0; k--) {
                int bit = (queries[idx[i]][0] >> k) & 1;
                int next = cur | (bit ^ 1);
                bool found = false;
                for (int l = 0; l < j; l++) {
                    if (used[l] && ((nums[l] >> k) & 1) == next) {
                        found = true;
                        break;
                    }
                }
                if (found) {
                    cur = next;
                } else {
                    cur = next ^ 1;
                }
            }
            answer[idx[i]] = queries[idx[i]][0] ^ cur;
        }
        return answer;

=======

        int n = nums.size();
        sort(nums.begin(), nums.end());
        vector<int> ans;
        for (auto& q : queries) {
            int x = q[0], m = q[1], y = -1;
            for (int i = 31; i >= 0; --i) {
                int t = y | (1 << i);
                if (t <= m) {
                    auto it = lower_bound(nums.begin(), nums.end(), t);
                    if (it != nums.end() && *it <= m && (*it ^ x) > y) {
                        y = *it ^ x;
                    }
                }
            }
            ans.push_back(y);
        }
        return ans;
