Synthesizing 10/10 solutions (Duplicates hidden)

=======

        int m = grid.size(), n = grid[0].size(), keys = 0;
        int sx, sy;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == '@') {
                    sx = i;
                    sy = j;
                } else if (islower(grid[i][j])) {
                    keys++;
                }
            }
        }
        queue<tuple<int, int, int>> q;
        q.push({sx, sy, 0});
        unordered_set<string> seen;
        seen.insert(to_string(sx) + "#" + to_string(sy) + "#" + to_string(0));
        int res = 0;
        vector<vector<int>> dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        while (!q.empty()) {
            for (int i = q.size(); i > 0; --i) {
                auto [x, y, k] = q.front();
                q.pop();
                if (k == (1 << keys) - 1) {
                    return res;
                }
                for (auto& dir : dirs) {
                    int nx = x + dir[0], ny = y + dir[1], nk = k;
                    if (nx < 0 || nx >= m || ny < 0 || ny >= n || grid[nx][ny] == '#') {
                        continue;
                    }
                    if (isupper(grid[nx][ny]) && !(nk & (1 << (grid[nx][ny] - 'A')))) {
                        continue;
                    }
                    if (islower(grid[nx][ny])) {
                        nk |= 1 << (grid[nx][ny] - 'a');
                    }
                    string state = to_string(nx) + "#" + to_string(ny) + "#" + to_string(nk);
                    if (seen.count(state)) {
                        continue;
                    }
                    seen.insert(state);
                    q.push({nx, ny, nk});
                }
            }
            ++res;
        }
        return -1;

=======

        int m = grid.size(), n = grid[0].size();
        int sx = 0, sy = 0, all = 0;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == '@') {
                    sx = i; sy = j;
                } else if (grid[i][j] >= 'a' && grid[i][j] <= 'f') {
                    all |= (1 << (grid[i][j] - 'a'));
                }
            }
        }
        queue<pair<int, int>> q;
        q.push({sx * n + sy, 0});
        int step = 0;
        vector<vector<int>> vis(m, vector<int>(n, 0));
        vis[sx][sy] = 1;
        vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        while (!q.empty()) {
            int size = q.size();
            while (size--) {
                auto [cur, curKeys] = q.front(); q.pop();
                int x = cur / n, y = cur % n;
                if (curKeys == all) {
                    return step;
                }
                for (auto& dir : dirs) {
                    int nx = x + dir[0], ny = y + dir[1];
                    if (nx < 0 || nx >= m || ny < 0 || ny >= n || grid[nx][ny] == '#') {
                        continue;
                    }
                    if (vis[nx][ny] & (1 << curKeys)) {
                        continue;
                    }
                    vis[nx][ny] |= (1 << curKeys);
                    int nextKeys = curKeys;
                    if (grid[nx][ny] >= 'a' && grid[nx][ny] <= 'f') {
                        nextKeys |= (1 << (grid[nx][ny] - 'a'));
                    } else if (grid[nx][ny] >= 'A' && grid[nx][ny] <= 'F') {
                        if (!(curKeys & (1 << (grid[nx][ny] - 'A')))) {
                            continue;
                        }
                    }
                    q.push({nx *

=======

        int m = grid.size(), n = grid[0].size();
        int si, sj;
        int k = 0;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == '@') {
                    si = i;
                    sj = j;
                } else if (grid[i][j] >= 'a' && grid[i][j] <= 'f') {
                    ++k;
                }
            }
        }
        vector<vector<vector<int>>> visited(m, vector<vector<int>>(n, vector<int>(1 << k)));
        queue<vector<int>> q;
        q.push({si, sj, 0});
        visited[si][sj][0] = 1;
        vector<vector<int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int step = 0;
        while (!q.empty()) {
            int size = q.size();
            for (int i = 0; i < size; ++i) {
                vector<int> cur = q.front();
                q.pop();
                if (cur[2] == (1 << k) - 1) {
                    return step;
                }
                for (auto& dir : dirs) {
                    int x = cur[0] + dir[0];
                    int y = cur[1] + dir[1];
                    if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == '#') {
                        continue;
                    }
                    int status = cur[2];
                    if (grid[x][y] >= 'a' && grid[x][y] <= 'f') {
                        status |= (1 << (grid[x][y] - 'a'));
                    }
                    if (grid[x][y] >= 'A' && grid[x][y] <= 'F' && !(status & (1 << (grid[x][y] - 'A')))) {
                        continue;
                    }
                    if (!visited[x][y][status]) {
                        visited[x][y][status] = 1;
                        q.push({x, y, status});
                    }
                }
            }
            ++step;
        }
        return -1;

=======

        int m = grid.size(), n = grid[0].size();
        int sx, sy, all = 0;
        vector<vector<vector<int>>> dist(m, vector<vector<int>>(n, vector<int>(1 << 6, -1)));
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == '@') {
                    sx = i; sy = j;
                } else if (islower(grid[i][j])) {
                    all |= 1 << (grid[i][j] - 'a');
                }
            }
        }
        queue<pair<int, int>> q;
        q.push({sx * n + sy, 0});
        dist[sx][sy][0] = 0;
        while (!q.empty()) {
            int x = q.front().first / n, y = q.front().first % n, s = q.front().second;
            q.pop();
            if (s == all) {
                return dist[x][y][s];
            }
            for (int i = -1; i <= 1; ++i) {
                for (int j = -1; j <= 1; ++j) {
                    if (abs(i) + abs(j) != 1) {
                        continue;
                    }
                    int nx = x + i, ny = y + j, ns = s;
                    if (nx < 0 || nx >= m || ny < 0 || ny >= n || grid[nx][ny] == '#') {
                        continue;
                    }
                    if (islower(grid[nx][ny])) {
                        ns |= 1 << (grid[nx][ny] - 'a');
                    }
                    if (isupper(grid[nx][ny]) && !(ns >> (grid[nx][ny] - 'A') & 1)) {
                        continue;
                    }
                    if (dist[nx][ny][ns] == -1) {
                        dist[nx][ny][ns] = dist[x][y][s] + 1;
                        q.push({nx * n + ny, ns});
                    }
                }
            }
        }
        return -1;

=======

        int m = grid.size();
        int n = grid[0].size();
        int start_i = -1;
        int start_j = -1;
        int key_cnt = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '@') {
                    start_i = i;
                    start_j = j;
                }
                if (grid[i][j] >= 'a' && grid[i][j] <= 'f') {
                    key_cnt++;
                }
            }
        }
        vector<vector<vector<int>>> visited(m, vector<vector<int>>(n, vector<int>(1 << 6, 0)));
        visited[start_i][start_j][0] = 1;
        queue<vector<int>> q;
        q.push({start_i, start_j, 0});
        int step = 1;
        while (!q.empty()) {
            int q_size = q.size();
            for (int i = 0; i < q_size; i++) {
                auto pos = q.front();
                q.pop();
                int i = pos[0];
                int j = pos[1];
                int keys = pos[2];
                for (int k = 0; k < 4; k++) {
                    int ni = i + dirs[k][0];
                    int nj = j + dirs[k][1];
                    if (ni < 0 || ni >= m || nj < 0 || nj >= n) {
                        continue;
                    }
                    if (grid[ni][nj] == '#') {
                        continue;
                    }
                    int nkeys = keys;
                    if (grid[ni][nj] >= 'a' && grid[ni][nj] <= 'f') {
                        nkeys = keys | (1 << (grid[ni][nj] - 'a'));
                    }
                    if (grid[ni][nj] >= 'A' && grid[ni][nj] <= 'F') {
                        if ((keys & (1 << (grid[ni][nj] - 'A'))) == 0) {
                            continue;
                        }
                    }
                    if (visited[ni][nj][nkeys] == 0) {
                        visited[ni][nj][nkeys] = 1;
                        q.push({ni, nj,

=======

        int m = grid.size(), n = grid[0].size();
        int startx, starty;
        int totalKeys = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '@') {
                    startx = i;
                    starty = j;
                } else if (grid[i][j] >= 'a' && grid[i][j] <= 'f') {
                    totalKeys++;
                }
            }
        }
        queue<vector<int>> q;
        q.push({startx, starty, 0});
        vector<vector<vector<int>>> visited(m, vector<vector<int>>(n, vector<int>(1 << 6, 0)));
        visited[startx][starty][0] = 1;
        int step = 0;
        vector<int> dx = {-1, 1, 0, 0};
        vector<int> dy = {0, 0, -1, 1};
        while (!q.empty()) {
            int size = q.size();
            while (size--) {
                auto cur = q.front();
                q.pop();
                int x = cur[0], y = cur[1], keys = cur[2];
                if (keys == (1 << totalKeys) - 1) {
                    return step;
                }
                for (int i = 0; i < 4; i++) {
                    int nx = x + dx[i], ny = y + dy[i];
                    if (nx < 0 || nx >= m || ny < 0 || ny >= n || grid[nx][ny] == '#') {
                        continue;
                    }
                    int nkeys = keys;
                    if (grid[nx][ny] >= 'a' && grid[nx][ny] <= 'f') {
                        nkeys |= (1 << (grid[nx][ny] - 'a'));
                    }
                    if (grid[nx][ny] >= 'A' && grid[nx][ny] <= 'F' && ((nkeys >> (grid[nx][ny] - 'A')) & 1) == 0) {
                        continue;
                    }
                    if (visited[nx][ny][nkeys] == 0) {
                        visited[nx][ny][nkeys

=======

        int m = grid.size(), n = grid[0].size();
        int keys = 0;
        int start_x = 0, start_y = 0;
        vector<vector<vector<int>>> visited(m, vector<vector<int>>(n, vector<int>(64, 0)));
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (isalpha(grid[i][j])) {
                    keys |= (1 << (grid[i][j] - 'a'));
                }
                if (grid[i][j] == '@') {
                    start_x = i;
                    start_y = j;
                }
            }
        }
        int dirs[] = {0, 1, 0, -1, 0};
        queue<vector<int>> q;
        q.push({start_x, start_y, 0, 0});
        visited[start_x][start_y][0] = 1;
        while (!q.empty()) {
            auto node = q.front();
            q.pop();
            int x = node[0], y = node[1], k = node[2], step = node[3];
            if (k == keys) {
                return step;
            }
            for (int i = 0; i < 4; i++) {
                int nx = x + dirs[i], ny = y + dirs[i + 1];
                if (nx < 0 || nx >= m || ny < 0 || ny >= n || grid[nx][ny] == '#') {
                    continue;
                }
                int nk = k;
                if (islower(grid[nx][ny])) {
                    nk |= (1 << (grid[nx][ny] - 'a'));
                }
                if (isupper(grid[nx][ny]) && !(nk & (1 << (grid[nx][ny] - 'A')))) {
                    continue;
                }
                if (!visited[nx][ny][nk]) {
                    visited[nx][ny][nk] = 1;
                    q.push({nx, ny, nk, step + 1});
                }
            }
        }
        return -1;

=======

        int m = grid.size();
        int n = grid[0].size();
        int sx, sy;
        int total = 0;
        vector<vector<int>> dist(m, vector<int>(n, 0));
        vector<vector<vector<int>>> dp(m, vector<vector<int>>(n, vector<int>(64, INT_MAX)));
        queue<pair<int, int>> q;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                char c = grid[i][j];
                if (c == '@') {
                    sx = i;
                    sy = j;
                } else if (c >= 'a' && c <= 'f') {
                    total |= (1 << (c - 'a'));
                }
            }
        }
        q.push({sx, sy});
        dp[sx][sy][0] = 0;
        while (!q.empty()) {
            auto [x, y] = q.front();
            q.pop();
            for (int k = 0; k < 4; k++) {
                int nx = x + dx[k];
                int ny = y + dy[k];
                if (nx < 0 || nx >= m || ny < 0 || ny >= n) {
                    continue;
                }
                char c = grid[nx][ny];
                if (c == '#') {
                    continue;
                }
                int keys = 0;
                if (c >= 'A' && c <= 'F') {
                    keys = (1 << (c - 'A'));
                }
                if (c >= 'a' && c <= 'f') {
                    keys = (1 << (c - 'a'));
                }
                if ((dp[x][y][keys] + 1) < dp[nx][ny][keys | dp[x][y][0]]) {
                    dp[nx][ny][keys | dp[x][y][0]] = dp[x][y][keys] + 1;
                    q.push({nx, ny});
                }
            }
        }
        int ans = INT_MAX;
        for (int i = 0; i < 64; i++) {
            if ((i | total) == total) {
                ans = min(ans, dp[sx][sy][i]);
            }
        }
        return ans == INT_MAX ? -

=======

        int N = grid.size(), M = grid[0].size();
        int sx, sy, totalKeys = 0;
        vector<vector<int>> keys(N, vector<int>(M));
        vector<vector<int>> locks(N, vector<int>(M));
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                if (grid[i][j] == '@') {
                    sx = i, sy = j;
                } else if (grid[i][j] >= 'a' && grid[i][j] <= 'f') {
                    keys[i][j] = 1 << (grid[i][j] - 'a');
                    totalKeys |= keys[i][j];
                } else if (grid[i][j] >= 'A' && grid[i][j] <= 'F') {
                    locks[i][j] = 1 << (grid[i][j] - 'A');
                }
            }
        }
        queue<tuple<int, int, int>> q;
        q.emplace(sx, sy, 0);
        vector<vector<int>> visited(N, vector<int>(M, 0));
        visited[sx][sy] = 1;
        int res = 0;
        while (!q.empty()) {
            int sz = q.size();
            for (int i = 0; i < sz; i++) {
                auto [x, y, k] = q.front();
                q.pop();
                if (k == totalKeys) {
                    return res;
                }
                for (int dx : {1, 0, -1, 0}) {
                    for (int dy : {0, 1, 0, -1}) {
                        int nx = x + dx, ny = y + dy;
                        if (nx < 0 || nx >= N || ny < 0 || ny >= M || grid[nx][ny] == '#') {
                            continue;
                        }
                        int nk = k;
                        if (keys[nx][ny]) {
                            nk |= keys[nx][ny];
                        }
                        if (locks[nx][ny] && !(k & locks[nx][ny])) {
                            continue;
                        }
                        if (visited[nx][ny] & (1 << nk)) {
                            continue;
                        }
                        visited[nx][ny] |=
