Synthesizing 10/10 solutions

=======

        int n = grid.size();
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(2, INT_MAX)));
        dp[0][0][0] = 0;
        dp[0][1][1] = 0;
        int res = INT_MAX;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == 1) {
                    dp[i][j][0] = dp[i][j][1] = INT_MAX;
                }
                if (i > 0) {
                    dp[i][j][0] = min(dp[i][j][0], dp[i - 1][j][0] + 1);
                    dp[i][j][1] = min(dp[i][j][1], dp[i - 1][j][1] + 1);
                }
                if (j > 0) {
                    dp[i][j][0] = min(dp[i][j][0], dp[i][j - 1][0] + 1);
                    dp[i][j][1] = min(dp[i][j][1], dp[i][j - 1][1] + 1);
                }
                if (i > 0 && j > 0) {
                    if (grid[i - 1][j] == 0 && grid[i][j - 1] == 0) {
                        dp[i][j][0] = min(dp[i][j][0], dp[i - 1][j - 1][1] + 1);
                        dp[i][j][1] = min(dp[i][j][1], dp[i - 1][j - 1][0] + 1);
                    }
                }
                if (i == n - 1 && j == n - 2) {
                    res = min(res, dp[i][j][0]);
                }
                if (i == n - 2 && j == n - 1) {
                    res = min(res, dp[i][j][1]);
                }
            }
        }
        return res == INT_MAX ? -1 : res;

=======

        int n = grid.size();
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(2, INT_MAX)));
        dp[0][0][0] = 0;
        dp[0][1][0] = 0;
        dp[0][0][1] = 1;
        dp[0][1][1] = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i + 1 < n && grid[i][j] == 0 && grid[i+1][j] == 0) {
                    dp[i+1][j][0] = min(dp[i+1][j][0], dp[i][j][0] + 1);
                    dp[i+1][j][0] = min(dp[i+1][j][0], dp[i][j][1] + 1);
                    dp[i][j+1][1] = min(dp[i][j+1][1], dp[i][j][0] + 1);
                    dp[i][j+1][1] = min(dp[i][j+1][1], dp[i][j][1] + 1);
                }
                if (j + 1 < n && grid[i][j] == 0 && grid[i][j+1] == 0) {
                    dp[i][j+1][1] = min(dp[i][j+1][1], dp[i][j][1] + 1);
                    dp[i][j+1][1] = min(dp[i][j+1][1], dp[i][j][0] + 1);
                    dp[i+1][j][0] = min(dp[i+1][j][0], dp[i][j][0] + 1);
                    dp[i+1][j][0] = min(dp[i+1][j][0], dp[i][j][1] + 1);
                }
            }
        }
        return min(dp[n-1][n-1][0], dp[n-1][n-1][1]) == INT_MAX ? -1 : min(dp[n-1][n-1][0], dp[n-1][n-1][1]);

=======

        int n = grid.size();
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(2, INT_MAX)));
        dp[0][0][0] = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (i - 1 >= 0 && grid[i - 1][j] == 0) {
                    dp[i][j][0] = min(dp[i][j][0], dp[i - 1][j][0]);
                    dp[i][j][1] = min(dp[i][j][1], dp[i - 1][j][1]);
                }
                if (j - 1 >= 0 && grid[i][j - 1] == 0) {
                    dp[i][j][0] = min(dp[i][j][0], dp[i][j - 1][0]);
                    dp[i][j][1] = min(dp[i][j][1], dp[i][j - 1][1]);
                }
                if (i - 1 >= 0 && j - 1 >= 0 && grid[i - 1][j] == 0 && grid[i][j - 1] == 0 && grid[i - 1][j - 1] == 0) {
                    dp[i][j][0] = min(dp[i][j][0], dp[i - 1][j - 1][1]);
                    dp[i][j][1] = min(dp[i][j][1], dp[i - 1][j - 1][0]);
                }
                if (grid[i][j] == 0) {
                    if (i + 1 < n && grid[i + 1][j] == 0) {
                        dp[i + 1][j][0] = min(dp[i + 1][j][0], dp[i][j][0] + 1);
                        dp[i + 1][j][1] = min(dp[i + 1][j][1], dp[i][j][1] + 1);
                    }
                    if (j + 1 < n && grid[i][j + 1] == 0) {
                        dp[i][j + 1][0] =

=======

        int n = grid.size();
        queue<vector<int>> q;
        q.push({0, 0, 0});
        vector<vector<vector<int>>> visited(n, vector<vector<int>>(n, vector<int>(2, 0)));
        visited[0][0][0] = 1;
        int ans = 0;
        while (!q.empty()) {
            int size = q.size();
            while (size--) {
                auto cur = q.front();
                q.pop();
                int x = cur[0], y = cur[1], dir = cur[2];
                if (x == n - 1 && y == n - 2 && dir == 0) return ans;
                if (dir == 0) {
                    if (x + 1 < n && grid[x + 1][y] == 0 && grid[x + 1][y + 1] == 0) {
                        if (x + 2 == n - 1 && y == n - 1) return ans + 1;
                        if (x + 2 < n && grid[x + 2][y] == 0 && grid[x + 2][y + 1] == 0 && !visited[x + 1][y][1]) {
                            visited[x + 1][y][1] = 1;
                            q.push({x + 1, y, 1});
                        }
                    }
                    if (y + 2 < n && grid[x][y + 2] == 0 && grid[x + 1][y + 2] == 0 && !visited[x][y + 1][0]) {
                        visited[x][y + 1][0] = 1;
                        q.push({x, y + 1, 0});
                    }
                }
                else {
                    if (y + 1 < n && grid[x][y + 1] == 0 && grid[x + 1][y + 1] == 0) {
                        if (x == n - 1 && y + 2 == n - 1) return ans + 1;
                        if (y + 2 < n && grid[x][y + 2] == 0 && grid[x + 1][y + 2] == 0 && !visited[x][y + 1][0]) {

=======

        int n = grid.size();
        queue<vector<int>> q;
        q.push({0, 0, 0, 0});
        vector<vector<vector<int>>> visited(n, vector<vector<int>>(n, vector<int>(2, 0)));
        visited[0][0][0] = 1;
        int steps = 0;
        while (!q.empty()) {
            int size = q.size();
            while (size--) {
                auto cur = q.front(); q.pop();
                int x = cur[0], y = cur[1], d = cur[2], s = cur[3];
                if (x == n - 1 && y == n - 2 && d == 0) {
                    return s;
                }
                if (x < n - 1 && grid[x + 1][y] == 0 && grid[x + 1][y + 1] == 0 && visited[x + 1][y][d] == 0) {
                    visited[x + 1][y][d] = 1;
                    q.push({x + 1, y, d, s + 1});
                }
                if (y < n - 1 && grid[x][y + 1] == 0 && grid[x + 1][y + 1] == 0 && visited[x][y + 1][d] == 0) {
                    visited[x][y + 1][d] = 1;
                    q.push({x, y + 1, d, s + 1});
                }
                if (d == 0 && x < n - 1 && grid[x + 1][y] == 0 && grid[x + 1][y + 1] == 0 && visited[x][y][1] == 0) {
                    visited[x][y][1] = 1;
                    q.push({x, y, 1, s + 1});
                }
                if (d == 1 && y < n - 1 && grid[x][y + 1] == 0 && grid[x + 1][y + 1] == 0 && visited[x][y][0] == 0) {
                    visited[x][y][0] = 1;
                    q.push({x, y, 0, s + 1});
                }

=======

        int n = grid.size();
        vector<vector<int>> dp(n, vector<int>(n, n*n));
        dp[0][0] = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (i + 1 < n && grid[i][j] == 0 && grid[i+1][j] == 0) {
                    dp[i+1][j] = min(dp[i+1][j], dp[i][j] + 1);
                    if (j + 1 < n && grid[i+1][j+1] == 0) {
                        dp[i+1][j+1] = min(dp[i+1][j+1], dp[i][j] + 1);
                        if (i - 1 >= 0 && grid[i-1][j] == 0) {
                            dp[i][j+1] = min(dp[i][j+1], dp[i][j] + 1);
                        }
                    }
                }
                if (j + 1 < n && grid[i][j] == 0 && grid[i][j+1] == 0) {
                    dp[i][j+1] = min(dp[i][j+1], dp[i][j] + 1);
                    if (i + 1 < n && grid[i+1][j+1] == 0) {
                        dp[i+1][j+1] = min(dp[i+1][j+1], dp[i][j] + 1);
                        if (j - 1 >= 0 && grid[i][j-1] == 0) {
                            dp[i+1][j] = min(dp[i+1][j], dp[i][j] + 1);
                        }
                    }
                }
            }
        }
        return dp[n-1][n-1] == n*n ? -1 : dp[n-1][n-1];

=======

        int n = grid.size();
        queue<pair<int, int>> q;
        q.push({0, 0});
        int steps = 0;
        while (!q.empty()) {
            int size = q.size();
            while (size--) {
                auto [x, y] = q.front(); q.pop();
                if (x == n - 1 && y == n - 2) return steps;
                if (x + 1 < n && grid[x + 1][y] == 0) {
                    grid[x + 1][y] = 1;
                    q.push({x + 1, y});
                }
                if (y + 1 < n && grid[x][y + 1] == 0) {
                    grid[x][y + 1] = 1;
                    q.push({x, y + 1});
                }
                if (x + 1 < n && y + 1 < n && grid[x][y + 1] == 0 && grid[x + 1][y + 1] == 0 && grid[x + 1][y] == 0) {
                    grid[x + 1][y + 1] = 1;
                    q.push({x, y + 1});
                }
                if (x + 1 < n && y + 1 < n && grid[x + 1][y] == 0 && grid[x + 1][y + 1] == 0 && grid[x][y + 1] == 0) {
                    grid[x + 1][y + 1] = 1;
                    q.push({x + 1, y});
                }
            }
            steps++;
        }
        return -1;

=======

        int n = grid.size();
        queue<pair<int, int>> q;
        unordered_set<string> visited;
        q.push({0, 0});
        visited.insert("0,0");
        int steps = 0;
        while (!q.empty()) {
            int size = q.size();
            for (int i = 0; i < size; i++) {
                auto p = q.front();
                q.pop();
                int x = p.first;
                int y = p.second;
                if (x == n - 1 && y == n - 2) return steps;
                if (x + 1 < n && grid[x + 1][y] == 0) {
                    int nextX = x + 1;
                    int nextY = y;
                    if (visited.count(to_string(nextX) + "," + to_string(nextY))) continue;
                    q.push({nextX, nextY});
                    visited.insert(to_string(nextX) + "," + to_string(nextY));
                }
                if (y + 1 < n && grid[x][y + 1] == 0) {
                    int nextX = x;
                    int nextY = y + 1;
                    if (visited.count(to_string(nextX) + "," + to_string(nextY))) continue;
                    q.push({nextX, nextY});
                    visited.insert(to_string(nextX) + "," + to_string(nextY));
                }
                if (x + 1 < n && y + 1 < n && grid[x][y + 1] == 0 && grid[x + 1][y] == 0 && grid[x + 1][y + 1] == 0) {
                    int nextX = x;
                    int nextY = y + 1;
                    if (visited.count(to_string(nextX) + "," + to_string(nextY))) continue;
                    q.push({nextX, nextY});
                    visited.insert(to_string(nextX) + "," + to_string(nextY));
                }
                if (y + 1 < n && grid[x][y + 1] == 0 && grid[x + 1][y + 1] == 0) {
                    int nextX = x + 1;
                    int nextY = y;
                    if (visited.count(to_string(nextX) + "," + to_string(nextY))) continue;
                    q.push({

=======

        int n = grid.size();
        if (n == 1)
            return 0;
        queue<pair<pair<int, int>, pair<int, int>>> q;
        q.push({{0, 1}, {0, 0}});
        vector<vector<vector<int>>> visited(n, vector<vector<int>>(n, vector<int>(2, 0)));
        visited[0][0][0] = 1;
        visited[0][1][1] = 1;
        int level = 0;
        while (!q.empty()) {
            level++;
            int size = q.size();
            for (int i = 0; i < size; i++) {
                auto p = q.front();
                q.pop();
                int x1 = p.first.first;
                int y1 = p.first.second;
                int x2 = p.second.first;
                int y2 = p.second.second;
                if (x1 == n - 1 && y1 == n - 2)
                    return level - 1;
                if (x2 == n - 1 && y2 == n - 1)
                    return level - 1;
                // move right
                if (y1 + 1 < n && y2 + 1 < n && grid[x1][y1 + 1] == 0 && grid[x2][y2 + 1] == 0) {
                    int x3 = x1;
                    int y3 = y1 + 1;
                    int x4 = x2;
                    int y4 = y2 + 1;
                    if (visited[x3][y3][0] == 0) {
                        visited[x3][y3][0] = 1;
                        q.push({{x3, y3}, {x4, y4}});
                    }
                }
                // move down
                if (x1 + 1 < n && x2 + 1 < n && grid[x1 + 1][y1] == 0 && grid[x2 + 1][y2] == 0) {
                    int x3 = x1 + 1;
                    int y3 = y1;
                    int x4 = x2 + 1;
                    int y4 = y2;
                    if (visited[x3][y3][1] == 0) {
                        visited[x3][y3][

=======

        int n = grid.size();
        if (n == 0) return 0;
        int moves = 0;
        int dir = 0;
        int r = 0, c = 0;
        while (r != n - 1 || c != n - 1) {
            if (dir == 0) {
                if (c + 1 < n && grid[r][c + 1] == 0) {
                    c++;
                } else if (r + 1 < n && grid[r + 1][c] == 0) {
                    dir = 1;
                    r++;
                } else if (c + 1 < n && r + 1 < n && grid[r + 1][c] == 0 && grid[r + 1][c + 1] == 0) {
                    dir = 2;
                    r++;
                } else {
                    return -1;
                }
            } else if (dir == 1) {
                if (r + 1 < n && grid[r + 1][c] == 0) {
                    r++;
                } else if (c + 1 < n && grid[r][c + 1] == 0) {
                    dir = 0;
                    c++;
                } else if (c + 1 < n && r + 1 < n && grid[r][c + 1] == 0 && grid[r + 1][c + 1] == 0) {
                    dir = 3;
                    c++;
                } else {
                    return -1;
                }
            } else if (dir == 2) {
                if (c + 1 < n && grid[r][c + 1] == 0) {
                    dir = 0;
                    c++;
                } else if (r + 1 < n && grid[r + 1][c] == 0) {
                    r++;
                } else {
                    return -1;
                }
            } else if (dir == 3) {
                if (r + 1 < n && grid[r + 1][c] == 0) {
                    dir = 1;
                    r++;
                } else if (c + 1 < n && grid[r][c + 1] == 0) {
                    c++;
                } else {
                    return -1;
