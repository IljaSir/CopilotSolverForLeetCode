Synthesizing 3/10 solutions

=======

        string ans(n, '0');
        unordered_set<string> seen;
        seen.insert(ans);
        int total = pow(k, n);
        for (int i = 0; i < total; i++) {
            string prev = ans.substr(ans.size() - n + 1);
            for (int j = k - 1; j >= 0; j--) {
                string next = prev + to_string(j);
                if (!seen.count(next)) {
                    seen.insert(next);
                    ans += to_string(j);
                    break;
                }
            }
        }
        return ans;

=======

        string res(n, '0');
        if (n == 1) {
            for (int i = 1; i < k; ++i) {
                res += to_string(i);
            }
            return res;
        }
        int total = pow(k, n);
        unordered_set<string> visited;
        visited.insert(res);
        dfs(res, total, visited, k, n);
        return res;
    }
    
    bool dfs(string& res, int total, unordered_set<string>& visited, int k, int n) {
        if (visited.size() == total) {
            return true;
        }
        string prev = res.substr(res.size() - n + 1, n - 1);
        for (int i = 0; i < k; ++i) {
            string next = prev + to_string(i);
            if (visited.find(next) != visited.end()) {
                continue;
            }
            visited.insert(next);
            res += to_string(i);
            if (dfs(res, total, visited, k, n)) {
                return true;
            }
            visited.erase(next);
            res.pop_back();
        }
        return false;

=======

        int total = pow(k, n);
        string password(n, '0');
        unordered_set<string> visited;
        visited.insert(password);
        dfs(password, visited, total, n, k);
        return password;
