Synthesizing 2/10 solutions

=======

        int n = boxes.size();
        vector<int> next(n);
        int right = 0, weight = 0;
        for (int left = 0; left < n; ++left) {
            while (right < n && (right == left || boxes[right][0] == boxes[right - 1][0] || weight + boxes[right][1] <= maxWeight)) {
                weight += boxes[right][1];
                ++right;
            }
            next[left] = right;
            weight -= boxes[left][1];
        }

        vector<int> dp(n + 1, INT_MAX / 2);
        dp[0] = 0;
        for (int i = 0; i < n; ++i) {
            dp[next[i]] = min(dp[next[i]], dp[i] + 2);
            dp[next[i] - 1] = min(dp[next[i] - 1], dp[i] + 1);
        }
        return dp[n] - 1;

=======

        int n = boxes.size();
        vector<int> dp(n + 1, INT_MAX / 2);
        dp[0] = 0;
        int i = 0, j = 0;
        int weight = 0;
        int count = 0;
        while (i < n) {
            while (j < n && j - i < maxBoxes && weight + boxes[j][1] <= maxWeight) {
                weight += boxes[j][1];
                if (j == 0 || boxes[j][0] != boxes[j - 1][0]) {
                    count++;
                }
                j++;
            }
            int t = dp[i] + count + 2;
            for (int k = i; k < j; k++) {
                if (k == n - 1 || boxes[k][0] != boxes[k + 1][0]) {
                    t--;
                }
                dp[k + 1] = min(dp[k + 1], t);
            }
            weight -= boxes[i][1];
            if (i == j - 1 || boxes[i][0] != boxes[i + 1][0]) {
                count--;
            }
            i++;
        }
        return dp[n];
