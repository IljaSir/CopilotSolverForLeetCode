Synthesizing 7/10 solutions

=======

        int n = cost.size(), m = cost[0].size();
        vector<vector<int>> dp(n + 1, vector<int>(1 << m, 1e9));
        dp[0][0] = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                for (int k = 0; k < (1 << m); ++k) {
                    dp[i + 1][k | (1 << j)] = min(dp[i + 1][k | (1 << j)], dp[i][k] + cost[i][j]);
                }
            }
        }
        int ans = 1e9;
        for (int i = 0; i < (1 << m); ++i) {
            int cur = dp[n][i];
            for (int j = 0; j < m; ++j) {
                if (!(i & (1 << j))) {
                    cur += *min_element(cost.begin(), cost.end(), [j](auto& a, auto& b) { return a[j] < b[j]; })[j];
                }
            }
            ans = min(ans, cur);
        }
        return ans;

=======

        int n = cost.size(), m = cost[0].size();
        vector<vector<int>> dp(n+1, vector<int>(1<<m, 1e9));
        dp[0][0] = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < (1<<m); j++) {
                for (int k = 0; k < m; k++) {
                    dp[i+1][j|(1<<k)] = min(dp[i+1][j|(1<<k)], dp[i][j] + cost[i][k]);
                }
            }
        }
        vector<vector<int>> dp2(1<<m, vector<int>(1<<m, 1e9));
        for (int i = 0; i < (1<<m); i++) {
            for (int j = 0; j < (1<<m); j++) {
                for (int k = 0; k < m; k++) {
                    if ((i&(1<<k)) == 0 && (j&(1<<k)) == 0) {
                        dp2[i][j|(1<<k)] = min(dp2[i][j|(1<<k)], dp2[i][j] + cost[n-1][k]);
                    }
                }
            }
        }
        int ans = 1e9;
        for (int i = 0; i < (1<<m); i++) {
            ans = min(ans, dp2[i][(1<<m)-1] + dp[n][i]);
        }
        return ans;

=======

        int n = cost.size(), m = cost[0].size();
        vector<vector<int>> dp(n, vector<int>(1 << m, INT_MAX / 2));
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                dp[i][1 << j] = cost[i][j];
            }
        }
        for (int i = 1; i < (1 << m); ++i) {
            int cnt = __builtin_popcount(i);
            if (cnt > n) continue;
            for (int j = 0; j < n; ++j) {
                for (int k = 0; k < m; ++k) {
                    if ((i >> k) & 1) {
                        dp[j][i] = min(dp[j][i], dp[j][i ^ (1 << k)] + cost[j][k]);
                    }
                }
            }
        }
        vector<vector<int>> f(n + 1, vector<int>(1 << m, INT_MAX / 2));
        f[0][0] = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < (1 << m); ++j) {
                f[i + 1][j] = min(f[i + 1][j], f[i][j]);
                for (int k = 0; k < m; ++k) {
                    f[i + 1][j | (1 << k)] = min(f[i + 1][j | (1 << k)], f[i][j] + cost[i][k]);
                }
            }
        }
        int ans = INT_MAX;
        for (int i = 0; i < (1 << m); ++i) {
            ans = min(ans, f[n][i] + dp[n - 1][((1 << m) - 1) ^ i]);
        }
        return ans;

=======

        int n = cost.size(), m = cost[0].size();
        vector<int> dp(1 << m, 1e9);
        dp[0] = 0;
        for (int i = 0; i < n; i++) {
            vector<int> t(1 << m, 1e9);
            for (int j = 0; j < (1 << m); j++) {
                for (int k = 0; k < m; k++) {
                    if (j & (1 << k)) {
                        t[j] = min(t[j], dp[j ^ (1 << k)] + cost[i][k]);
                    }
                }
            }
            dp = t;
        }
        vector<int> sum(1 << m);
        for (int i = 0; i < (1 << m); i++) {
            for (int j = 0; j < m; j++) {
                if (i & (1 << j)) {
                    sum[i] += cost[n - 1][j];
                }
            }
        }
        for (int i = 0; i < (1 << m); i++) {
            for (int j = 0; j < (1 << m); j++) {
                dp[i | j] = min(dp[i | j], dp[i] + sum[j]);
            }
        }
        return dp[(1 << m) - 1];

=======

        int n = cost.size(), m = cost[0].size();
        vector<int> dp(1 << m, 0x3f3f3f3f);
        dp[0] = 0;
        for (int i = 0; i < n; i++) {
            vector<int> t(1 << m, 0x3f3f3f3f);
            for (int j = 0; j < (1 << m); j++) {
                for (int k = 0; k < m; k++) {
                    if ((j >> k) & 1) {
                        t[j] = min(t[j], dp[j ^ (1 << k)] + cost[i][k]);
                    } else {
                        t[j] = min(t[j], dp[j] + cost[i][k]);
                    }
                }
            }
            dp = t;
        }
        return dp[(1 << m) - 1];

=======

        int m = cost.size(), n = cost[0].size();
        int dp[1 << m][n];
        memset(dp, 0x3f, sizeof(dp));
        for (int j = 0; j < n; j++) {
            for (int i = 0; i < m; i++) {
                dp[1 << i][j] = cost[i][j];
            }
        }
        for (int s = 1; s < (1 << m); s++) {
            int cnt = __builtin_popcount(s);
            for (int j = 0; j < n; j++) {
                for (int i = 0; i < m; i++) {
                    if (s >> i & 1) {
                        dp[s][j] = min(dp[s][j], dp[s ^ (1 << i)][j] + cost[i][j]);
                    }
                }
            }
            for (int j = 0; j < n; j++) {
                for (int i = 0; i < m; i++) {
                    if (!(s >> i & 1)) {
                        dp[s | (1 << i)][j] = min(dp[s | (1 << i)][j], dp[s][j]);
                    }
                }
            }
        }
        int ans = 0x3f3f3f3f;
        for (int s = 0; s < (1 << m); s++) {
            int sum = 0;
            for (int i = 0; i < m; i++) {
                if (s >> i & 1) {
                    sum += *min_element(cost[i].begin(), cost[i].end());
                }
            }
            for (int j = 0; j < n; j++) {
                ans = min(ans, sum + dp[s][j]);
            }
        }
        return ans;

=======

        int row = cost.size();
        int col = cost[0].size();
        int res = INT_MAX;
        for(int i = 0; i < (1 << col); i++) {
            int tmp = 0;
            for(int j = 0; j < row; j++) {
                int min_val = INT_MAX;
                for(int k = 0; k < col; k++) {
                    int bit = 1 << k;
                    if(i & bit) {
                        min_val = min(min_val, cost[j][k]);
                    }
                }
                tmp += min_val;
            }
            res = min(res, tmp + dfs(cost, i, row, col));
        }
        return res;
    }
    
    int dfs(vector<vector<int>>& cost, int state, int row, int col) {
        if(row == cost.size()) return 0;
        int res = INT_MAX;
        for(int i = 0; i < (1 << col); i++) {
            int tmp = 0;
            for(int j = 0; j < col; j++) {
                int bit = 1 << j;
                if(i & bit) {
                    if(!(state & bit)) {
                        tmp += cost[row][j];
                    }
                }
            }
            res = min(res, tmp + dfs(cost, state | i, row + 1, col));
        }
        return res;
