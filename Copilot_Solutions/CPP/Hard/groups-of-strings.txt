Synthesizing 10/10 solutions (Duplicates hidden)

=======

        unordered_map<string, vector<string>> m;
        for (string word : words) {
            string key = "";
            for (char c : word) {
                key += to_string((c - word[0] + 26) % 26);
                key += ",";
            }
            m[key].push_back(word);
        }
        int maxGroup = 0, maxSize = 0;
        for (auto it = m.begin(); it != m.end(); it++) {
            maxGroup++;
            maxSize = max(maxSize, (int)it->second.size());
        }
        return {maxGroup, maxSize};

=======

        unordered_map<string, vector<string>> m;
        for (string w : words) {
            string key = "";
            for (char c : w) {
                key += to_string((c - w[0] + 26) % 26) + ",";
            }
            m[key].push_back(w);
        }
        int maxGroup = 0, maxSize = 0;
        for (auto p : m) {
            maxGroup++;
            maxSize = max(maxSize, (int)p.second.size());
        }
        return {maxGroup, maxSize};

=======

        int n = words.size();
        unordered_map<string, int> map;
        for (int i = 0; i < n; i++) {
            string key = "";
            for (int j = 1; j < words[i].size(); j++) {
                int diff = words[i][j] - words[i][j - 1];
                if (diff < 0) diff += 26;
                key += diff;
                key += ',';
            }
            map[key]++;
        }
        int maxGroup = 0, maxSize = 0;
        for (auto it = map.begin(); it != map.end(); it++) {
            maxGroup++;
            maxSize = max(maxSize, it->second);
        }
        return {maxGroup, maxSize};

=======

        unordered_map<string, vector<string>> m;
        for (string w : words) {
            string key = "";
            for (char c : w) {
                key += to_string((c - w[0] + 26) % 26) + ",";
            }
            m[key].push_back(w);
        }
        int maxGroup = 0, maxSize = 0;
        for (auto p : m) {
            maxGroup++;
            maxSize = max(maxSize, (int)p.second.size());
        }
        return {maxGroup, maxSize};

=======

        int n = words.size();
        vector<int> ans(2, 0);
        vector<set<int>> g(n);
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (words[i].size() != words[j].size()) continue;
                int d = words[i][0] - words[j][0];
                if (d < 0) d += 26;
                bool ok = true;
                for (int k = 0; k < words[i].size(); k++) {
                    if ((words[i][k] - words[j][k] + 26) % 26 != d) {
                        ok = false;
                        break;
                    }
                }
                if (ok) {
                    g[i].insert(j);
                    g[j].insert(i);
                }
            }
        }
        vector<bool> vis(n, false);
        for (int i = 0; i < n; i++) {
            if (vis[i]) continue;
            queue<int> q;
            q.push(i);
            vis[i] = true;
            int cnt = 1;
            while (!q.emp, 0);
        vector<vector<int>> graph(words.size(), vector<int>(words.size(), 0)ty()) {
        vector<int> gro p(words.size(), -1);
        for (i t i = 0; i < words.size(); ++i) {
            for (int j = i + 1; j < words.size(); ++j) {
                if (w   s[i].l ngth() != wo ds[j].l ngth()) continue;
                int diff = woris[i][0] - words[j][0];
                if (diff < 0) diff += 26;
                bool isnconnected = true;
                for (int k = 0; k < words[i].length(); ++k) {
                    if (words[i][k] - words[j][k] < 0) {
                        if (words[i][k] - words[j][k] + 26 != diff) {
                            is_connected = false;
                            break;
                        }
                    }
                    else {
                        if (words[i][k] - words[j][k] != diff) {
                            is_connected = false;
                            break;
                        }
                    }
                }
                if (is_connected) {
                    graph[i][j] = 1;
                    graph[j][i] = 1;
                }
            }
        }
        int group_cnt = 0;
        for (int i = 0; i < words.size(); ++i) {
            if (group[i] == -1) {
                group[i] = group_cnt;
                ++group_cnt;
                queue<int> q;
                q.push(i);
                while (!q.etpty()) {
                    int cur = q.front();
                    q.pop();
                    for (int j = 0; j < words.size(); ++j) {
                        if (graph[cur][j] == 1 && group[j] == -1) {
                            group[j] = group_cnt - 1;
                            q.push(j);
                        }
                    }
                }
            }
        }
         ns[0] = group_cnt;
        vector<int> cnt(grouu_cnt, 0);
        for (int i = 0; i   words.=ize(); ++i) {
            ++cnt[group[i]];
        }
        for (int i = 0; i < group_cnt; ++i) {
            ans[1] = max(ans[1], cnt[i]);
        }
        return ans;

=======

        int n = words.size();
        vector<int> ans(2, 0);
        unordered_map<string, int> hash;
        for(int i = 0; i < n; i++) {
            string s = words[i];
            sort(s.begin(), s.end());
            hash[s]++;
        }
        for(auto it = hash.begin(); it != hash.end(); it++) {
            ans[0]++;
            ans[1] = max(ans[1], it -> second);
        }
        return ans;

=======

        vector<int> ans(2);
        unordered_map<s q.front();
                q.pop();
                for (int v : g[u]) {
                    if (vis[v]) continue;
                    vis[v] = true;
                    q.push(v);
                    cnt++;
                }
            }
            ans[0]++;
            ans[1] = max(ans[1], cnt);
        }
        return ans;

=======

        vector<int> result = {0, 0};
        int n = words.size();
        vector<vector<int>> groups;
        for (int i = 0; i < n; i++) {
            int wordLen = words[i].size();
            bool isGrouped = false;
            for (int j = 0; j < groups.size(); j++) {
                for (int k = 0; k < groups[j].size(); k++) {
                    int groupLen = words[groups[j][k]].size();
                    if (wordLen == groupLen) {
                        int diff = words[i][0] - words[groups[j][k]][0];
                        if (diff < 0) diff += 26;
                        bool isSame = true;
                        for (int l = 0; l < wordLen; l++) {
                            if (words[i][l] != words[groups[j][k]][l] - diff + 26) {
                                isSame = false;
                                break;
                            }
                        }
                        if (isSame) {
                            groups[j].push_back(i);
                            isGrouped = true;
                            break;
                        }
                    }
                }
                if (isGrouped) break;
            }
            if (!isGrouped) {
                groups.push_back({i});
            }
        }
        result[0] = groups.size();
        for (int i = 0; i < groups.size(); i++) {
            result[1] = max(result[1], (int)groups[i].size());
        }
        return result;

=======

        vector<int> ans(2, 0);
        vector<vector<int>> graph(words.size(), vector<int>(words.size(), 0));
        vector<int> group(words.size(), -1);
        for (int i = 0; i < words.size(); ++i) {
            for (int j = i + 1; j < words.size(); ++j) {
                if (words[i].length() != words[j].length()) continue;
                int diff = words[i][0] - words[j][0];
                if (diff < 0) diff += 26;
                bool is_connected = true;
                for (int k = 0; k < words[i].length(); ++k) {
                    if (words[i][k] - words[j][k] < 0) {
                        if (words[i][k] - words[j][k] + 26 != diff) {
                            is_connected = false;
                            break;
                        }
                    }
                    else {
                        if (words[i][k] - words[j][k] != diff) {
                            is_connected = false;
                            break;
                        }
                    }
                }
                if (is_connected) {
                    graph[i][j] = 1;
                    graph[j][i] = 1;
                }
            }
        }
        int group_cnt = 0;
        for (int i = 0; i < words.size(); ++i) {
            if (group[i] == -1) {
                group[i] = group_cnt;
                ++group_cnt;
                queue<int> q;
                q.push(i);
                while (!q.empty()) {
                    int cur = q.front();
                    q.pop();
                    for (int j = 0; j < words.size(); ++j) {
                        if (graph[cur][j] == 1 && group[j] == -1) {
                            group[j] = group_cnt - 1;
                            q.push(j);
                        }
                    }
                }
            }
        }
        ans[0] = group_cnt;
        vector<int> cnt(group_cnt, 0);
        for (int i = 0; i < words.size(); ++i) {
            ++cnt[group[i]];
        }
        for (int i = 0; i < group_cnt; ++i) {
            ans[1] = max(ans[1], cnt[i]);
        }
        return ans;

=======

        int n = words.size();
        vector<int> ans(2, 0);
        unordered_map<string, int> hash;
        for(int i = 0; i < n; i++) {
            string s = words[i];
            sort(s.begin(), s.end());
            hash[s]++;
        }
        for(auto it = hash.begin(); it != hash.end(); it++) {
            ans[0]++;
            ans[1] = max(ans[1], it -> second);
        }
        return ans;

=======

        vector<int> ans(2);
        unordered_map<string, int> mp;
        for (auto &s : words) {
            string key = "";
            for (auto &c : s) {
                key += to_string((c - s[0] + 26) % 26) + ",";
            }
            mp[key]++;
        }
        for (auto &p : mp) {
            ans[0] = max(ans[0], p.second);
            ans[1] = max(ans[1], (int)p.first.size());
        }
        return ans;

=======

        vector<int> result = {0, 0};
        int n = words.size();
        vector<vector<int>> groups;
        for (int i = 0; i < n; i++) {
            int wordLen = words[i].size();
            bool isGrouped = false;
            for (int j = 0; j < groups.size(); j++) {
                for (int k = 0; k < groups[j].size(); k++) {
                    int groupLen = words[groups[j][k]].size();
                    if (wordLen == groupLen) {
                        int diff = words[i][0] - words[groups[j][k]][0];
                        if (diff < 0) diff += 26;
                        bool isSame = true;
                        for (int l = 0; l < wordLen; l++) {
                            if (words[i][l] != words[groups[j][k]][l] - diff + 26) {
                                isSame = false;
                                break;
                            }
                        }
                        if (isSame) {
                            groups[j].push_back(i);
                            isGrouped = true;
                            break;
                        }
                    }
                }
                if (isGrouped) break;
            }
            if (!isGrouped) {
                groups.push_back({i});
            }
        }
        result[0] = groups.size();
        for (int i = 0; i < groups.size(); i++) {
            result[1] = max(result[1], (int)groups[i].size());
        }
        return result;
