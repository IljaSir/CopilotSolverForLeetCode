Synthesizing 10/10 solutions (Duplicates hidden)

=======

        int n = nums.size();
        priority_queue<int> pq;
        for (int i = 0; i < n; i++) {
            if (nums[i] % 2 == 1) {
                nums[i] *= 2;
            }
            pq.push(nums[i]);
        }
        int ans = pq.top() - pq.top() / 2;
        while (pq.top() % 2 == 0) {
            int x = pq.top();
            pq.pop();
            pq.push(x / 2);
            ans = min(ans, pq.top() - pq.top() / 2);
        }
        return ans;

=======

        int n = nums.size();
        set<int> s;
        for (int i = 0; i < n; i++) {
            if (nums[i] % 2 == 1) {
                nums[i] *= 2;
            }
            s.insert(nums[i]);
        }
        int res = *s.rbegin() - *s.begin();
        while (*s.rbegin() % 2 == 0) {
            int x = *s.rbegin();
            s.erase(x);
            x /= 2;
            s.insert(x);
            res = min(res, *s.rbegin() - *s.begin());
        }
        return res;

=======

        multiset<int> s;
        for (int x : nums) {
            if (x % 2) x *= 2;
            s.insert(x);
        }
        int ans = *s.rbegin() - *s.begin();
        while (*s.rbegin() % 2 == 0) {
            int x = *s.rbegin();
            s.erase(s.find(x));
            s.insert(x / 2);
            ans = min(ans, *s.rbegin() - *s.begin());
        }
        return ans;

=======

        priority_queue<int> pq;
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            if (nums[i] % 2 == 1) {
                nums[i] *= 2;
            }
            pq.push(nums[i]);
        }
        int ans = pq.top() - pq.top() / 2;
        while (pq.top() % 2 == 0) {
            int top = pq.top();
            pq.pop();
            pq.push(top / 2);
            ans = min(ans, pq.top() - pq.top() / 2);
        }
        return ans;

=======

        set<int> s;
        for (int num : nums) {
            num = num % 2 == 0 ? num : num * 2;
            s.insert(num);
        }
        int res = *s.rbegin() - *s.begin();
        while (*s.rbegin() % 2 == 0) {
            s.insert(*s.rbegin() / 2);
            s.erase(*s.rbegin());
            res = min(res, *s.rbegin() - *s.begin());
        }
        return res;

=======

        int n = nums.size();
        vector<int> v(n);
        for (int i = 0; i < n; ++i) {
            if (nums[i] % 2 == 1) {
                v[i] = nums[i] * 2;
            } else {
                v[i] = nums[i];
            }
        }
        sort(v.begin(), v.end());
        int ans = v.back() - v.front();
        for (int i = 0; i < n; ++i) {
            while (v[i] % 2 == 0 && v[i] > v.front()) {
                v[i] /= 2;
                sort(v.begin(), v.end());
                ans = min(ans, v.back() - v.front());
            }
        }
        return ans;

=======

        int n = nums.size();
        priority_queue<int, vector<int>, greater<int>> pq;
        for (int i = 0; i < n; i++) {
            pq.push(nums[i] % 2 == 1 ? nums[i] * 2 : nums[i]);
        }
        int res = pq.top() - pq.top() % 2;
        while (pq.top() % 2 == 0) {
            int x = pq.top();
            pq.pop();
            pq.push(x / 2);
            res = min(res, pq.top() - pq.top() % 2);
        }
        return res;

=======

        int n = nums.size();
        priority_queue<int> pq;
        int mn = INT_MAX;
        for (int i = 0; i < n; i++) {
            int x = nums[i] % 2 == 0 ? nums[i] : nums[i] * 2;
            mn = min(mn, x);
            pq.push(x);
        }
        int ans = INT_MAX;
        while (!pq.empty()) {
            int x = pq.top();
            pq.pop();
            ans = min(ans, x - mn);
            if (x % 2 == 0) {
                x /= 2;
                mn = min(mn, x);
                pq.push(x);
            } else {
                break;
            }
        }
        return ans;

=======

        multiset<int> s;
        for(int i:nums) {
            if(i%2==0) s.insert(i);
            else s.insert(i*2);
        }
        int res = *s.rbegin() - *s.begin();
        while(*s.rbegin()%2==0) {
            int n = *s.rbegin();
            s.erase(--s.end());
            s.insert(n/2);
            res = min(res, *s.rbegin() - *s.begin());
        }
        return res;
