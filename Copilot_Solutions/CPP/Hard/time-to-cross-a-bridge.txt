Synthesizing 10/10 solutions (Duplicates hidden)

=======

        vector<int> leftToRight(k);
        vector<int> pickOld(k);
        vector<int> rightToLeft(k);
        vector<int> putNew(k);
        for (int i = 0; i < k; ++i) {
            leftToRight[i] = time[i][0];
            pickOld[i] = time[i][1];
            rightToLeft[i] = time[i][2];
            putNew[i] = time[i][3];
        }
        vector<int> worker(k);
        vector<int> box(k);
        int left = 0;
        int right = 0;
        int cur = 0;
        int res = 0;
        while (left < k || right < k || cur > 0) {
            int next = INT_MAX;
            for (int i = 0; i < k; ++i) {
                if (box[i] < n) {
                    next = min(next, leftToRight[i] + rightToLeft[i]);
                }
            }
            for (int i = 0; i < k; ++i) {
                if (box[i] < n) {
                    if (leftToRight[i] + rightToLeft[i] == next) {
                        next = min(next, leftToRight[i] + rightToLeft[i] + pickOld[i]);
                        break;
                    }
                }
            }
            for (int i = 0; i < k; ++i) {
                if (box[i] < n) {
                    if (leftToRight[i] + rightToLeft[i] == next) {
                        if (worker[i] == 0) {
                            worker[i] = 1;
                            ++cur;
                            next = min(next, leftToRight[i] + rightToLeft[i] + pickOld[i]);
                            break;
                        }
                    }
                }
            }
            for (int i = 0; i < k; ++i) {
                if (box[i] < n) {
                    if (leftToRight[i] + rightToLeft[i] + pickOld[i] == next) {
                        next = min(next, leftToRight[i] + rightToLeft[i] + pickOld[i] + putNew[i]);
                        break;
                    }
                }
            }
            for (int i = 0; i < k; ++i) {
                if (box[i] < n) {
                    if (leftTo

=======

        // leftToRighti + rightToLefti > leftToRightj + rightToLeftj
        // leftToRighti + rightToLefti == leftToRightj + rightToLeftj and i > j
        vector<vector<int>> workers;
        for (int i = 0; i < k; ++i) {
            workers.push_back({time[i][0] + time[i][2], i});
        }
        sort(workers.begin(), workers.end());
        int left = 0, right = 0;
        int oldWarehouse = n, newWarehouse = 0;
        int res = 0;
        while (oldWarehouse > 0) {
            if (left < k) {
                int worker = workers[left][1];
                res = max(res, time[worker][0]);
                res += time[worker][1];
                oldWarehouse--;
                newWarehouse++;
                left++;
                right++;
            } else {
                int worker = workers[right][1];
                res += time[worker][2];
                res += time[worker][3];
                oldWarehouse--;
                newWarehouse++;
                right++;
            }
        }
        return res;

=======

        vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= k; ++j) {
                dp[i][j] = dp[i][j - 1] + time[j - 1][0] + time[j - 1][1] + time[j - 1][2] + time[j - 1][3];
                for (int l = 1; l <= j - 1; ++l) {
                    dp[i][j] = min(dp[i][j], max(dp[i][l], dp[0][j] + time[j - 1][0] + time[j - 1][1] + time[j - 1][2] + time[j - 1][3]));
                }
                for (int l = 1; l <= j - 1; ++l) {
                    dp[i][j] = min(dp[i][j], max(dp[i - 1][l], dp[0][j] + time[j - 1][0] + time[j - 1][1] + time[j - 1][2]));
                }
            }
        }
        return dp[n][k];

=======

        int left = 0;
        int right = 1e6;
        while (left < right) {
            int mid = (left + right) >> 1;
            if (canCross(n, k, time, mid)) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;

=======

        vector<int> bridges(k, 0);
        vector<int> oldWarehouse(k, 0);
        vector<int> newWarehouse(k, 0);
        for (int i = 0; i < k; ++i) {
            bridges[i] = time[i][0] + time[i][2];
            oldWarehouse[i] = time[i][1];
            newWarehouse[i] = time[i][3];
        }
        vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j < k; ++j) {
                if (i - 1 >= 0) {
                    dp[i] = min(dp[i], dp[i - 1] + oldWarehouse[j]);
                }
                if (i >= 2) {
                    dp[i] = min(dp[i], dp[i - 2] + bridges[j] + newWarehouse[j]);
                }
            }
        }
        return dp[n];
    }
    int solve(int n, int k, vector<vector<int>>& time) {
        vector<int> bridges(k, 0);
        vector<int> oldWarehouse(k, 0);
        vector<int> newWarehouse(k, 0);
        for (int i = 0; i < k; ++i) {
            bridges[i] = time[i][0] + time[i][2];
            oldWarehouse[i] = time[i][1];
            newWarehouse[i] = time[i][3];
        }
        vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j < k; ++j) {
                if (i - 1 >= 0) {
                    dp[i] = min(dp[i], dp[i - 1] + oldWarehouse[j]);
                }
                if (i >= 2) {
                    dp[i] = min(dp[i], dp[i - 2] + bridges[j] + newWarehouse[j]);
                }
            }
        }
        return dp[n];

=======

        int ans = 0;
        int bridge = 0;
        int left = 0;
        int right = 0;
        int leftToRight = 0;
        int rightToLeft = 0;
        while (n) {
            if (bridge == 0) {
                if (right) {
                    ans += time[rightToLeft][2];
                    --right;
                    ++left;
                    bridge = 1;
                } else if (left) {
                    ans += time[leftToRight][0];
                    --left;
                    ++right;
                    bridge = 1;
                } else {
                    ans += time[leftToRight][0];
                    --left;
                    ++right;
                    bridge = 1;
                }
            } else {
                if (right) {
                    ans += time[rightToLeft][3];
                    --right;
                    --n;
                    bridge = 0;
                } else {
                    ans += time[leftToRight][1];
                    --left;
                    ++right;
                    bridge = 0;
                }
            }
            if (bridge == 0) {
                leftToRight = 0;
                rightToLeft = 0;
                for (int i = 1; i < k; ++i) {
                    if (leftToRight == 0 || time[i][0] + time[i][2] < time[leftToRight][0] + time[leftToRight][2] ||
                        (time[i][0] + time[i][2] == time[leftToRight][0] + time[leftToRight][2] && i < leftToRight)) {
                        leftToRight = i;
                    }
                    if (rightToLeft == 0 || time[i][2] + time[i][0] < time[rightToLeft][2] + time[rightToLeft][0] ||
                        (time[i][2] + time[i][0] == time[rightToLeft][2] + time[rightToLeft][0] && i < rightToLeft)) {
                        rightToLeft = i;
                    }
                }
            }
        }
        return ans;

=======

        int ans = 0;
        vector<int> t(k, 0);
        vector<int> pos(k, 0); // 0: left, 1: right
        vector<int> box(k, 0);
        while (n > 0) {
            for (int i = 0; i < k; ++i) {
                if (pos[i] == 0 && box[i] == 0) {
                    // move to right
                    pos[i] = 1;
                    t[i] += time[i][0];
                } else if (pos[i] == 1 && box[i] == 0) {
                    // pick up a box
                    box[i] = 1;
                    t[i] += time[i][1];
                    --n;
                } else if (pos[i] == 1 && box[i] == 1) {
                    // move to left
                    pos[i] = 0;
                    t[i] += time[i][2];
                } else if (pos[i] == 0 && box[i] == 1) {
                    // put down a box
                    box[i] = 0;
                    t[i] += time[i][3];
                }
            }
            // find the next worker to move
            int minTime = INT_MAX;
            int minWorker = -1;
            for (int i = 0; i < k; ++i) {
                if (t[i] < minTime) {
                    minTime = t[i];
                    minWorker = i;
                }
            }
            // update other workers' time
            for (int i = 0; i < k; ++i) {
                if (i != minWorker) {
                    t[i] = minTime;
                }
            }
            ans = max(ans, minTime);
        }
        return ans;
    }
    int minimumTimeRequired(vector<int>& jobs, int k) {
        int n = jobs.size();
        if (n == 0) {
            return 0;
        }
        if (k == 1) {
            return accumulate(jobs.begin(), jobs.end(), 0);
        }
        vector<vector<int>> time(k, vector<int>(4, 0));
        int ans = INT_MAX;
        for (int i = 0; i < (1 << n); ++i) {
            if (__builtin

=======

        vector<int> cur(k, 0);
        vector<int> last(k, 0);
        vector<int> next(k, 0);
        vector<int> nextLast(k, 0);
        vector<int> waiting(k, 0);
        vector<int> waitingLast(k, 0);
        vector<int> waitingNext(k, 0);
        vector<int> waitingNextLast(k, 0);
        vector<int> lastLeft(k, 0);
        vector<int> nextLeft(k, 0);
        vector<int> lastRight(k, 0);
        vector<int> nextRight(k, 0);
        vector<int> lastLeftWaiting(k, 0);
        vector<int> nextLeftWaiting(k, 0);
        vector<int> lastRightWaiting(k, 0);
        vector<int> nextRightWaiting(k, 0);
        vector<int> lastLeftWaitingLast(k, 0);
        vector<int> nextLeftWaitingLast(k, 0);
        vector<int> lastRightWaitingLast(k, 0);
        vector<int> nextRightWaitingLast(k, 0);
        vector<int> lastLeftWaitingNext(k, 0);
        vector<int> nextLeftWaitingNext(k, 0);
        vector<int> lastRightWaitingNext(k, 0);
        vector<int> nextRightWaitingNext(k, 0);
        vector<int> lastLeftWaitingNextLast(k, 0);
        vector<int> nextLeftWaitingNextLast(k, 0);
        vector<int> lastRightWaitingNextLast(k, 0);
        vector<int> nextRightWaitingNextLast(k, 0);
        for (int i = 0; i < k; ++i) {
            last[i] = time[i][0];
            lastLeft[i] = time[i][0];
            lastRight[i] = time[i][2];
            lastLeftWaitingLast[i] = time[i][0];
            lastRightWaitingLast[i] = time[i][2];
        }
        for (int i = 1; i < n; ++i) {
            for (int j = 0; j < k; ++j) {
                next[j] = 1000000000;
                nextLeft[j] = 1000000000;
                nextRight[j] = 1000000000;
                nextLeftWaiting[j] = 1000000000;
                nextRight

=======

        // TODO
