Synthesizing 10/10 solutions (Duplicates hidden)

=======

        multiset<int> window(nums.begin(), nums.begin() + k);
        auto mid = next(window.begin(), k / 2);
        vector<double> medians;
        for (int i = k;; i++) {
            medians.push_back((double(*mid) + *next(mid, k % 2 - 1)) / 2);
            if (i == nums.size()) return medians;
            window.insert(nums[i]);
            if (nums[i] < *mid) mid--;
            if (nums[i - k] <= *mid) mid++;
            window.erase(window.lower_bound(nums[i - k]));
        }

=======

        multiset<int> window(nums.begin(), nums.begin() + k);
        auto mid = next(window.begin(), k / 2);
        vector<double> medians;
        for (int i = k;; i++) {
            medians.push_back((double(*mid) + *prev(mid, 1 - k % 2)) / 2);
            if (i == nums.size())
                return medians;
            window.insert(nums[i]);
            if (nums[i] < *mid)
                mid--;
            if (nums[i - k] <= *mid)
                mid++;
            window.erase(window.lower_bound(nums[i - k]));
        }

=======

        multiset<int> window(nums.begin(), nums.begin() + k);
        auto mid = next(window.begin(), k / 2);
        vector<double> medians;
        for (int i = k; ; i++) {
            // Push the current median.
            medians.push_back((double(*mid) + *prev(mid, 1 - k % 2)) / 2);
            // If all done, return.
            if (i == nums.size())
                return medians;
            // Insert nums[i].
            window.insert(nums[i]);
            if (nums[i] < *mid)
                mid--;
            // Erase nums[i-k].
            if (nums[i-k] <= *mid)
                mid++;
            window.erase(window.lower_bound(nums[i-k]));
        }

=======

        multiset<int> window(nums.begin(), nums.begin() + k);
        auto mid = next(window.begin(), k / 2);
        vector<double> medians;
        for (int i = k; ; i++) {
            // Push the current median.
            medians.push_back(((double) *mid + *prev(mid, 1 - k % 2)) / 2);

            // If all done, return.
            if (i == nums.size())
                return medians;

            // Insert nums[i].
            window.insert(nums[i]);
            if (nums[i] < *mid)
                mid--;

            // Erase nums[i-k].
            if (nums[i-k] <= *mid)
                mid++;
            window.erase(window.lower_bound(nums[i-k]));
        }

=======

        vector<double> res;
        multiset<int> window(nums.begin(), nums.begin() + k);
        auto mid = next(window.begin(), k / 2);
        for (int i = k; ; i++) {
            res.push_back((double(*mid) + *prev(mid, 1 - k % 2)) / 2);
            if (i == nums.size()) return res;
            window.insert(nums[i]);
            if (nums[i] < *mid) mid--;
            if (nums[i - k] <= *mid) mid++;
            window.erase(window.lower_bound(nums[i - k]));
        }

=======

        vector<double> ans;
        multiset<int> win(nums.begin(), nums.begin() + k);
        auto mid = next(win.begin(), k / 2);
        for (int i = k; ; i++) {
            ans.push_back((double(*mid) + *prev(mid, 1 - k % 2)) / 2);
            if (i == nums.size()) return ans;
            win.insert(nums[i]);
            if (nums[i] < *mid) mid--;
            if (nums[i - k] <= *mid) mid++;
            win.erase(win.lower_bound(nums[i - k]));
        }

=======

        multiset<int> s;
        vector<double> ans;
        for (int i = 0; i < nums.size(); i++) {
            if (i >= k) {
                s.erase(s.find(nums[i - k]));
            }
            s.insert(nums[i]);
            if (i >= k - 1) {
                auto it = s.begin();
                advance(it, k / 2);
                if (k % 2) {
                    ans.push_back(*it);
                } else {
                    ans.push_back(((double)*it + *prev(it)) / 2);
                }
            }
        }
        return ans;

=======

        vector<double> ans;
        multiset<int> s;
        int n = nums.size();
        for (int i = 0; i < n; ++i) {
            if (i >= k) {
                s.erase(s.find(nums[i - k]));
            }
            s.insert(nums[i]);
            if (i >= k - 1) {
                auto it = next(s.begin(), k / 2);
                ans.push_back((double(*it) + *prev(it, 1 - k % 2)) / 2);
            }
        }
        return ans;

=======

        vector<double> res;
        int n = nums.size();
        multiset<int> s(begin(nums), begin(nums) + k);
        auto mid = next(begin(s), k / 2);
        for (int i = k; ; i++) {
            res.push_back((double(*mid) + *prev(mid, 1 - k % 2)) / 2);
            if (i == n) return res;
            s.insert(nums[i]);
            if (nums[i] < *mid) mid--;
            if (nums[i - k] <= *mid) mid++;
            s.erase(s.lower_bound(nums[i - k]));
        }
