Synthesizing 9/10 solutions (Duplicates hidden)

=======

        int m = isInfected.size(), n = isInfected[0].size();
        vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        int res = 0;
        while (true) {
            vector<vector<int>> walls(m, vector<int>(n, 0));
            vector<vector<bool>> visited(m, vector<bool>(n, false));
            vector<int> area;
            int cnt = 0;
            for (int i = 0; i < m; ++i) {
                for (int j = 0; j < n; ++j) {
                    if (isInfected[i][j] == 1 && !visited[i][j]) {
                        int a = 0;
                        queue<pair<int, int>> q;
                        q.push({i, j});
                        visited[i][j] = true;
                        while (!q.empty()) {
                            auto [x, y] = q.front();
                            q.pop();
                            ++a;
                            for (auto& dir : dirs) {
                                int nx = x + dir[0], ny = y + dir[1];
                                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {
                                    if (isInfected[nx][ny] == 0) {
                                        ++walls[nx][ny];
                                        cnt = max(cnt, walls[nx][ny]);
                                    } else if (isInfected[nx][ny] == 1 && !visited[nx][ny]) {
                                        visited[nx][ny] = true;
                                        q.push({nx, ny});
                                    }
                                }
                            }
                        }
                        area.push_back(a);
                    }
                }
            }
            if (cnt == 0) break;
            res += cnt;
            for (int i = 0; i < m; ++i) {
                for (int j = 0; j < n; ++j) {
                    if (walls[i][j] == cnt) {
                        isInfected[i][j] = -1;
                    }
                }
            }
        }
        return res;

=======

        int m = isInfected.size();
        int n = isInfected[0].size();
        int res = 0;
        vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        while (true) {
            vector<vector<int>> visited(m, vector<int>(n, 0));
            vector<vector<int>> wall(m, vector<int>(n, 0));
            vector<int> area;
            vector<int> perim;
            int maxArea = 0;
            int maxAreaIdx = -1;
            int maxPerim = 0;
            int maxPerimIdx = -1;
            int idx = 0;
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    if (isInfected[i][j] == 1 && visited[i][j] == 0) {
                        int a = 0;
                        int p = 0;
                        dfs(isInfected, visited, wall, dirs, a, p, i, j);
                        area.push_back(a);
                        perim.push_back(p);
                        if (a > maxArea) {
                            maxArea = a;
                            maxAreaIdx = idx;
                        }
                        if (p > maxPerim) {
                            maxPerim = p;
                            maxPerimIdx = idx;
                        }
                        idx++;
                    }
                }
            }
            if (maxAreaIdx == -1) {
                break;
            }
            res += maxPerim;
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    if (wall[i][j] == 1) {
                        isInfected[i][j] = 1;
                    }
                }
            }
            for (int i = 0; i < area.size(); i++) {
                if (i != maxAreaIdx) {
                    res += area[i];
                }
            }
        }
        return res;

=======

        int m = isInfected.size();
        int n = isInfected[0].size();
        int total = 0;
        while (true) {
            vector<vector<bool>> visited(m, vector<bool>(n, false));
            vector<vector<int>> infected(m, vector<int>(n, 0));
            vector<vector<int>> walls(m, vector<int>(n, 0));
            vector<vector<int>> queue;
            int maxInfected = 0;
            int maxInfectedI = -1;
            int maxInfectedJ = -1;
            int maxWalls = 0;
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    if (isInfected[i][j] == 1 && !visited[i][j]) {
                        int infectedCount = 0;
                        int wallsCount = 0;
                        queue.clear();
                        queue.push_back({i, j});
                        visited[i][j] = true;
                        while (!queue.empty()) {
                            auto& node = queue.back();
                            queue.pop_back();
                            int x = node[0];
                            int y = node[1];
                            if (isInfected[x][y] == 1) {
                                infectedCount++;
                                if (x > 0 && !visited[x - 1][y]) {
                                    queue.push_back({x - 1, y});
                                    visited[x - 1][y] = true;
                                }
                                if (x < m - 1 && !visited[x + 1][y]) {
                                    queue.push_back({x + 1, y});
                                    visited[x + 1][y] = true;
                                }
                                if (y > 0 && !visited[x][y - 1]) {
                                    queue.push_back({x, y - 1});
                                    visited[x][y - 1] = true;
                                }
                                if (y < n - 1 && !visited[x][y + 1]) {
                                    queue.push_back({x, y + 1});
                                    visited[x][y + 1] = true;
                                }
                            } else {
                                wallsCount++;
                                if (x > 0 && isInfected[x - 1][y] == 0 && !visited[x - 1][y]) {
                                    queue.push_back({x -

=======

        int m = isInfected.size(), n = isInfected[0].size();
        int ans = 0;
        while (true) {
            vector<vector<int>> walls(m, vector<int>(n));
            vector<vector<int>> areas;
            vector<vector<int>> fronts;
            vector<int> perimeters;
            int area = 0;
            for (int i = 0; i < m; ++i) {
                for (int j = 0; j < n; ++j) {
                    if (isInfected[i][j] == 1) {
                        isInfected[i][j] = 2;
                        vector<int> front = {i, j};
                        fronts.push_back(front);
                        int perimeter = 0;
                        while (!front.empty()) {
                            vector<int> next;
                            for (auto& f : front) {
                                int x = f / n, y = f % n;
                                for (int k = 0; k < 4; ++k) {
                                    int nx = x + dx[k], ny = y + dy[k];
                                    if (nx >= 0 && nx < m && ny >= 0 && ny < n) {
                                        if (isInfected[nx][ny] == 0) {
                                            ++perimeter;
                                            isInfected[nx][ny] = -1;
                                        }
                                        else if (isInfected[nx][ny] == 1) {
                                            isInfected[nx][ny] = 2;
                                            next.push_back(nx * n + ny);
                                        }
                                    }
                                }
                            }
                            swap(front, next);
                        }
                        areas.push_back(front);
                        perimeters.push_back(perimeter);
                        area += front.size();
                    }
                }
            }
            if (area == 0) {
                break;
            }
            int best = 0;
            for (int i = 1; i < areas.size(); ++i) {
                if (perimeters[i] > perimeters[best]) {
                    best = i;
                }
            }
            ans += perimeters[best];
            for (int i = 0; i < areas.size(); ++i) {
                if (i != best) {
                    ans += areas[i].size();
                }
                else {
                    for (auto& idx : areas[i]) {
                        int x = idx / n, y =

=======

        int m = isInfected.size();
        int n = isInfected[0].size();
        int ans = 0;
        vector<vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        while (true) {
            int maxWalls = 0;
            int maxRegion = 0;
            vector<vector<int>> walls(m, vector<int>(n, 0));
            vector<vector<int>> visited(m, vector<int>(n, 0));
            for (int i = 0; i < m; ++i) {
                for (int j = 0; j < n; ++j) {
                    if (isInfected[i][j] == 1 && !visited[i][j]) {
                        queue<vector<int>> q;
                        q.push({i, j});
                        visited[i][j] = 1;
                        int region = 0;
                        int walls = 0;
                        while (!q.empty()) {
                            auto cur = q.front();
                            q.pop();
                            ++region;
                            for (auto d : dir) {
                                int x = cur[0] + d[0];
                                int y = cur[1] + d[1];
                                if (x < 0 || x >= m || y < 0 || y >= n) {
                                    ++walls;
                                    continue;
                                }
                                if (isInfected[x][y] == 0) {
                                    ++walls;
                                    continue;
                                }
                                if (visited[x][y]) {
                                    continue;
                                }
                                q.push({x, y});
                                visited[x][y] = 1;
                            }
                        }
                        if (region > maxRegion) {
                            maxRegion = region;
                            maxWalls = walls;
                            walls = vector<vector<int>>(m, vector<int>(n, 0));
                            for (int i = 0; i < m; ++i) {
                                for (int j = 0; j < n; ++j) {
                                    if (visited[i][j] && isInfected[i][j] == 0) {
                                        walls[i][j] = 1;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (maxRegion == 0) {
                break;
            }
            ans += maxWalls;
            for (

=======

        int m = isInfected.size(), n = isInfected[0].size();
        int res = 0;
        vector<vector<int>> dir = {{-1,0},{1,0},{0,-1},{0,1}};
        while(true){
            vector<vector<int>> visited(m, vector<int>(n, 0));
            vector<vector<int>> wall(m, vector<int>(n, 0));
            vector<vector<int>> area(m, vector<int>(n, 0));
            vector<int> w;
            vector<int> a;
            int maxArea = 0;
            for(int i = 0; i < m; i++){
                for(int j = 0; j < n; j++){
                    if(isInfected[i][j] == 1 && !visited[i][j]){
                        int walls = 0, areas = 0;
                        queue<vector<int>> q;
                        q.push({i,j});
                        visited[i][j] = 1;
                        while(!q.empty()){
                            vector<int> cur = q.front();
                            q.pop();
                            areas++;
                            for(int k = 0; k < 4; k++){
                                int x = cur[0] + dir[k][0];
                                int y = cur[1] + dir[k][1];
                                if(x >= 0 && x < m && y >= 0 && y < n){
                                    if(isInfected[x][y] == 0 && !visited[x][y]){
                                        walls++;
                                        visited[x][y] = 1;
                                    }
                                    if(isInfected[x][y] == 1 && !visited[x][y]){
                                        q.push({x,y});
                                        visited[x][y] = 1;
                                    }
                                }
                            }
                        }
                        w.push_back(walls);
                        a.push_back(areas);
                        if(areas > maxArea){
                            maxArea = areas;
                        }
                    }
                }
            }
            if(maxArea == 0){
                break;
            }
            for(int i = 0; i < w.size(); i++){
                if(a[i] == maxArea){
                    res += w[i];
                }
                else{
                    res += w[i] + 1;
                }
            }
            for(int i = 0; i < m; i++){
                for(int j = 0; j < n; j++){
                    if(isInf

=======

        int m = isInfected.size();
        int n = isInfected[0].size();
        int res = 0;
        while (true) {
            vector<vector<int>> borders;
            vector<int> areas;
            vector<vector<int>> fronts;
            vector<int> front_areas;
            vector<vector<int>> visited(m, vector<int>(n, 0));
            for (int i = 0; i < m; ++i) {
                for (int j = 0; j < n; ++j) {
                    if (isInfected[i][j] == 1 && visited[i][j] == 0) {
                        vector<int> border;
                        int area = 0;
                        vector<int> front;
                        int front_area = 0;
                        queue<pair<int, int>> q;
                        q.push({i, j});
                        visited[i][j] = 1;
                        while (!q.empty()) {
                            auto [x, y] = q.front();
                            q.pop();
                            ++area;
                            int cnt = 0;
                            for (int k = 0; k < 4; ++k) {
                                int nx = x + dx[k];
                                int ny = y + dy[k];
                                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {
                                    if (isInfected[nx][ny] == 0) {
                                        ++cnt;
                                        if (visited[nx][ny] == 0) {
                                            visited[nx][ny] = 1;
                                            q.push({nx, ny});
                                        }
                                    }
                                    else if (isInfected[nx][ny] == 1 && visited[nx][ny] == 0) {
                                        visited[nx][ny] = 1;
                                        q.push({nx, ny});
                                    }
                                }
                            }
                            if (cnt > 0) {
                                ++front_area;
                                front.push_back(x * n + y);
                                if (cnt == 1) {
                                    border.push_back(x * n + y);
                                }
                            }
                        }
                        borders.push_back(border);
                        areas.push_back(area);
                        fronts.push_back(front);
                        front_areas.push_back(front_area);
                    }
                }
            }
            if (borders.empty()) {
                break;
            }
            int max_area = 0;
            int max_idx = 0;

=======

        int m = isInfected.size();
        int n = isInfected[0].size();
        int res = 0;
        while (true) {
            int maxArea = 0;
            int maxAreaI = -1;
            int maxAreaJ = -1;
            vector<vector<bool>> visited(m, vector<bool>(n, false));
            vector<vector<int>> area(m, vector<int>(n, 0));
            vector<vector<int>> wall(m, vector<int>(n, 0));
            vector<vector<int>> neighbor(m, vector<int>(n, 0));
            for (int i = 0; i < m; ++i) {
                for (int j = 0; j < n; ++j) {
                    if (isInfected[i][j] == 1 && !visited[i][j]) {
                        int tmpArea = 0;
                        dfs(isInfected, visited, area, wall, neighbor, i, j, tmpArea);
                        if (tmpArea > maxArea) {
                            maxArea = tmpArea;
                            maxAreaI = i;
                            maxAreaJ = j;
                        }
                    }
                }
            }
            if (maxArea == 0) {
                break;
            }
            res += wall[maxAreaI][maxAreaJ];
            for (int i = 0; i < m; ++i) {
                for (int j = 0; j < n; ++j) {
                    if (isInfected[i][j] == 1 && area[i][j] == 0) {
                        isInfected[i][j] = 2;
                    }
                }
            }
            for (int i = 0; i < m; ++i) {
                for (int j = 0; j < n; ++j) {
                    if (isInfected[i][j] == 2) {
                        if (i > 0 && isInfected[i - 1][j] == 0) {
                            isInfected[i - 1][j] = 1;
                        }
                        if (i < m - 1 && isInfected[i + 1][j] == 0) {
                            isInfected[i + 1][j] = 1;
                        }
                        if (j > 0 && isInfected[i][j - 1] ==
