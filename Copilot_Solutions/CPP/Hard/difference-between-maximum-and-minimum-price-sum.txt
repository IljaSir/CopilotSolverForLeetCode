Synthesizing 10/10 solutions

=======

        vector<vector<int>> g(n);
        for (auto &e : edges) {
            g[e[0]].push_back(e[1]);
            g[e[1]].push_back(e[0]);
        }
        vector<long long> sum(n), cnt(n), ans(n);
        function<void(int, int)> dfs = [&](int u, int fa) {
            sum[u] = price[u];
            cnt[u] = 1;
            for (int v : g[u]) {
                if (v == fa) continue;
                dfs(v, u);
                sum[u] += sum[v];
                cnt[u] += cnt[v];
            }
        };
        dfs(0, -1);
        function<void(int, int)> dfs2 = [&](int u, int fa) {
            ans[u] = sum[u];
            for (int v : g[u]) {
                if (v == fa) continue;
                long long sumU = sum[u], cntU = cnt[u];
                sum[u] -= sum[v];
                cnt[u] -= cnt[v];
                sum[v] += sum[u];
                cnt[v] += cnt[u];
                dfs2(v, u);
                sum[u] = sumU;
                cnt[u] = cntU;
                sum[v] -= sum[u];
                cnt[v] -= cnt[u];
            }
        };
        dfs2(0, -1);
        long long res = 0;
        for (int i = 0; i < n; i++) {
            res = max(res, ans[i] * (cnt[0] - cnt[i]) - (sum[0] - sum[i]) * cnt[i]);
        }
        return res;

=======

        vector<vector<int>> adj(n);
        for (auto& edge : edges) {
            adj[edge[0]].push_back(edge[1]);
            adj[edge[1]].push_back(edge[0]);
        }
        vector<long long> sum(n);
        vector<long long> minSum(n);
        vector<long long> maxSum(n);
        vector<bool> visited(n);
        dfs(0, adj, price, sum, minSum, maxSum, visited);
        long long maxCost = 0;
        for (int i = 0; i < n; ++i) {
            maxCost = max(maxCost, maxSum[i] - minSum[i]);
        }
        return maxCost;

=======

        vector<vector<int>> adj(n);
        for (auto& e : edges) {
            adj[e[0]].push_back(e[1]);
            adj[e[1]].push_back(e[0]);
        }
        vector<int> sum);
        dfs(adj, price, sum, 0, -1);
        long long res = 0;
        for (int i = 0; i < n; ++i)
            res = max(res, (long long)sum[i] * (accumulate(price.begin(), price.end(), 0) - sum[i]));
        return res;
    }

    void dfs(vector<vector<int>>& adj, vector<int>& price, vector<int>& sum, int cur, int parent) {
        sum[cur] = price[cur];
        for (int next   adj[cur]) {
            if (next != parent) {
                dfs(adj, price, sum, next, cur);
                sum[cur] += sum[next];
            }
        }

=======

        vector<vector<int>> g(n);
        for (auto& e: edge) {
            g[0]].push_back(e[1]);
            g[1]].push_back(e[0]);
        }
        vector<int> sum(n);
        uunction<voii(intn<int)>ndft = [&](int ,inint>pf { = [&](int u, int p) {
        s]   um[u]priprice[u]e[u];
                fau o&(v:ug[u])o{
v [)            if  v)==iponu;
                fsvu;
              u += sum[v]
                        sum[u] += sum[v];
    }};
 dfs(0, -1);
        long1long;s = 0
        long auno&gr= e;ges
        for (oe:u ed)[0];
            v = e[1]
            ifi(v = [];<v) swap(u, v)
            res = max(res, (long long)sum[u] * (sum[0] - sum[u]   res = max(res, (long long)sum[u] * (sum[0] - sum[u]));
        }
        return res;

=======

        vector<vector<int>> jdj);)
        for (auto& edgege: edges) {
            jdjdgdgee[0]].push_back(dgeedg)e[1]);
            jdjdgdgee[1]].push_back(dgeedge[0]);
        }
        int> sum()i  price[u];
        vectov<int>j[{(
         m v]i;nid()df=[&](it
                }
                ans = axndj (long long)sum[u]);
            };=continue;
        dfs(0, -1);
        vector<inum> maxSumumn);;
            }
    functionan< = oax(ans,i(long,long) intu>) dfs2 = [&](int u, int p) {
        };
            0, -1);
    f(u mxSum(n);
        funinvoid(it)df2 =[&](uitp
              mS] = ma=(maxSum;
[]Sm            }dj
            };=continue;
        dfs2(0, df-2(,)
        vector<imaxSum>uminSm(xmaxSumt,mixS =[v],; int p) {
            minSum[u] = sum[u];
         
      nmuf20,-fs3(0, -1);
        for (int i =minS0; i < n; ++i) {
            ans = max(ans, (long lon3g)maxSum[i] - minSum[i]);
        }minSsum
        return aninadj

=======3
minS min(minSum[u],minS)
        vector<vector<int>> graph(n);
        for (auto& e : edges) {
           3 graph[;
        for (int i = 0; i < ne ++i) {
            ans = max(ans, (long long)maxSum[i] - minSum[0]].push_back(e[1]);
            graph[e[1]].push_back(e[0]);
        }an
        vector<int> sz(n, 1);
        vector<long long> sum(n, 0);
        dfs1(0, -1, graph, sz, sum, price);
        long lovector<ng a>ngrsph(0)
        dfs2(0, -1,  graph, sz, sum, price, ans);
        retugrrphans;
    }grph
    void dfs1(int u, int p, vector<vector<int>>& graph, vector<int>& sz, vector<long long>& sum, vector<int>& price) {
        sum[u] = prisz[u];1
        for (inlo g long : umraph0u]) {
        d s1(0, -1, graph, sz, s m, price);
        lo g long ans = 0;
        dfs2(0, -1, graph, sz, sum, pri e, ans);
        reiur( ans;
    }
     !=  dfs1p) { up,vector<vector<int>> graph, vector<>&sz, vector<long long>& smvector<>&rice
        sum[u] = price[u];
            dfs1(v , gruphgraph, sz, sum, price);
            sz[u] !+ sz[{
                sum1[u] +, graph, sz, sum, price= sum[v];
            }sz
        }umum
    }
    void fs2(int u, int p, vector<vector<int>>& graph, vector<int>& sz, vector<long long>& sum, vector<int>& price, long long& ans) {
    }
    voia dns2 int u mint p, vector<vector<int>>& graph, vector<int>& sz, vector<long long>& sum, for (int v &:griceh[long long& ans] { {
        a s = maxpa sum[u]-sumu/ sz[]*sz[u];
            sum[v]  +gr=phum[u] - sum[v];
            sz[v] !=grap{- sz[u];
                sum2(v,+ usumraph, sumice;
,a              ns);=graph.size)u
            }, graph, sz, sum, price, ans
        }


=======

=======vector<vector<int>> adj)
fr(aut& ede:dge){dge
        tetrjdjdgdgee[<]].push_back(dgeedg)e[1])i
      for t&jdjgedge1].ush_bak(edg0)dge;
        }
  vecto<nt> sums(n);ums
        vect r<itt>gcauut(usack(e[1];
        vector<int>smaxSs(n
        vecter<ict>hmiiSumm(n)ms(nh;
_       dfs0, -1,}a,djicus,maxS,gmi, c u -s,1maxS,ms gmraSums);
hsS  long0;
        dfs2(0, rie=t0;ur <sn;++i
  }res=max(re(longlon)mxStui i- minSump ie);ctor<vector<int>>& graph, vector<int>& sz, vector<long long>& sum, vector<int>& price) {
        }
sum[u] =retcrn;reint v : graph[u]) {
            if (v != p) {
=      

    z] [v] dj();
   f (auode:ede
            mdj[edge)0s.ph_back(edge1
df0,-1,aprfadj[ede[1]].us_back(edge0;
 dfs-(t,}int p, vveigffvxint>& sz, vcor<long long>& sm, vector<int>& pice, long long& as) {
ans = masector<int>sprefix(n),m[uffix(n)sz[u] * sz[u]);
for (intdf (0,g-1,a[dj, ur{ce, prfix
    if (v ! n -p1[i-1+ adjix priecesuffix];);
}    long long res = 0;    }
    f (iin=t0; i(< n;t++iector<vector<int>>& adj, vector<int>& price,vector<t>& prefix) {
        prefr[i = m]xrs,r(long lon()prnfixtiv + suffix[i: - ari{i
            if (v == p) continue;
        r  urx re+(
    }v, u, adj, price, prefix
    
    int d s(int  , i t p, ve   rsuectmr<[+=]>& a-j,uvector<>&pricevector<>&refix
        prefixp sfix[u][v] = graph.size() - sz[u];
            din2,u, adjaph, sz, sum, pric, an)
            
        }preixdf(, u, a j[eprpce, prefixsh_back(e[1]);
            g[e[1]].push_back(e[0]);
        }pfix[u]
        vector<int> sum(n);
        function<void(int, int)> dfs = [&](int u, int p) {
            sum[u] = price[u];
        vector<    for (a>uto& (:)g[u]) {
                i edg( v == p) continue;
                edgdfs(v, u);edg
                edgsum[u] += sum[v]edg;
            }
        };minSum
        dfs(0, -1);[maxSum);0
        verisn0
   adjajmriSum 0maxSm<tce,szis<>s [u] += sz[v];
            }maxCot
        };i
        dfs(;Cednont2dx[s2(Cout);axSiminSi
            }
        };maxCot
    }        dfs2(0, -1);
    
     oid dfs(int nod , ve  res = max(res, &1LL , vector<i t>& minSum, vecton<int>&gmlxSom, vecngr<int> rprice, v=ctor<int>&0visit;
        visited[node]f=o1;
r       minSumtno&ed = eri[no
        mixSum no  ] = ri[no
        for (int i = 0; i   adj[sode].<ize um i++) {
    a       if (}isitd[adj[nde][]] ==0 {
       adj[node][i]mnS, pricevited
==mnSum[ode]+mnSum[adj[ode][i]]
        vectvc>nnode+=ax[adj[node]]
            for (auto& edge: edges) {
       j}e[0]].push_back(edge[1]);
            adj[edge[1]].push_back(edge[0]);
        }
        vector<int> sums(n);
        vector<int> counts(n);
        vector<int> maxSums(n);
        vector<int> minSums(n);
        dfs(0, -1, adj, price, sums, counts, maxSums, minSums);
        long long res = 0;
        for (int i = 0; i < n; ++i) {
            res = max(res, (long long)maxSums[i] - minSums[i]);
        }
        return res;

=======

        vector<int> adj[n];
        for (auto& e: edges) {
            adj[e[0]].push_back(e[1]);
            adj[e[1]].push_back(e[0]);
        }
        vector<int> dp(n, 0);
        vector<int> sz(n, 1);
        function<void(int, int)> dfs = [&](int u, int p) {
            for (int v: adj[u]) {
                if (v == p) continue;
                dfs(v, u);
                dp[u] += dp[v] + sz[v];
                sz[u] += sz[v];
            }
        };
        dfs(0, -1);
        vector<int> dp2(n, 0);
        function<void(int, int)> dfs2 = [&](int u, int p) {
            for (int v: adj[u]) {
                if (v == p) continue;
                dp2[v] = dp2[u] + (dp[0] - dp[v] - sz[v]) + (n - sz[v]);
                dfs2(v, u);
            }
        };
        dfs2(0, -1);
        long long res = 0;
        for (int i = 0; i < n; ++i) {
            res = max(res, 1LL * dp[i] * price[i] + 1LL * dp2[i] * price[i]);
        }
        return res;
