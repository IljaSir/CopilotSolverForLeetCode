Synthesizing 10/10 solutions (Duplicates hidden)

=======

        int n = tasks.size();
        vector<int> dp(1 << n, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i < (1 << n); ++i) {
            int maxEnd = 0;
            for (int j = 0; j < n; ++j) {
                if (i & (1 << j)) {
                    maxEnd = max(maxEnd, tasks[j][1]);
                }
            }
            for (int j = 0; j < n; ++j) {
                if (!(i & (1 << j)) && tasks[j][0] >= maxEnd) {
                    dp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + tasks[j][2]);
                }
            }
        }
        return dp[(1 << n) - 1];

=======

        int n = tasks.size();
        vector<int> dp(1 << n, INT_MAX);
        dp[0] = 0;
        for (int i = 1; i < (1 << n); ++i) {
            int last = 0;
            for (int j = 0; j < n; ++j) {
                if (i & (1 << j)) {
                    last = max(last, tasks[j][1]);
                }
            }
            for (int j = 0; j < n; ++j) {
                if (i & (1 << j)) {
                    int prev = i - (1 << j);
                    dp[i] = min(dp[i], dp[prev] + max(0, tasks[j][0] - last) + tasks[j][2]);
                }
            }
        }
        return dp[(1 << n) - 1];

=======

        int n = tasks.size();
        vector<int> dp(2001, 0);
        for (int i = 0; i < n; ++i) {
            int start = tasks[i][0], end = tasks[i][1], duration = tasks[i][2];
            dp[start] += duration;
            dp[end + 1] -= duration;
        }
        int ans = 0, cur = 0;
        for (int i = 1; i <= 2000; ++i) {
            cur += dp[i];
            ans = max(ans, cur);
        }
        return ans;

=======

        int n = tasks.size();
        vector<vector<int>> dp(1 << n, vector<int>(n, INT_MAX));
        for (int i = 0; i < n; ++i) {
            dp[1 << i][i] = tasks[i][2];
        }
        for (int mask = 1; mask < (1 << n); ++mask) {
            for (int i = 0; i < n; ++i) {
                if (!(mask & (1 << i))) continue;
                for (int j = 0; j < n; ++j) {
                    if (mask & (1 << j)) continue;
                    if (tasks[j][0] <= tasks[i][1] && tasks[j][1] >= tasks[i][1]) {
                        dp[mask | (1 << j)][j] = min(dp[mask | (1 << j)][j], dp[mask][i] + tasks[j][2]);
                    } else {
                        dp[mask | (1 << j)][j] = min(dp[mask | (1 << j)][j], dp[mask][i] + tasks[j][2] + tasks[i][1] - tasks[j][0]);
                    }
                }
            }
        }
        int ans = INT_MAX;
        for (int i = 0; i < n; ++i) {
            ans = min(ans, dp[(1 << n) - 1][i]);
        }
        return ans;

=======

        int n = tasks.size();
        vector<vector<int>> dp(n+1, vector<int>(n+1, 0));
        for (int i = 1; i <= n; ++i) {
            dp[i][i] = tasks[i-1][2];
        }
        for (int len = 2; len <= n; ++len) {
            for (int i = 1; i <= n-len+1; ++i) {
                int j = i+len-1;
                dp[i][j] = dp[i+1][j] + tasks[i-1][2];
                for (int k = i+1; k <= j; ++k) {
                    if (tasks[k-1][1] < tasks[i-1][0]) {
                        dp[i][j] = min(dp[i][j], dp[i][k-1] + dp[k][j]);
                    }
                }
            }
        }
        return dp[1][n];

=======

        if (tasks.empty()) return 0;
        sort(tasks.begin(), tasks.end(), [](const auto& a, const auto& b) {
            return a[0] < b[0];
        });
        
        int n = tasks.size();
        vector<int> dp(n, 0);
        dp[0] = tasks[0][2];
        for (int i = 1; i < n; ++i) {
            int end = tasks[i][0] - 1;
            int j = i - 1;
            while (j >= 0 && tasks[j][1] > end) {
                --j;
            }
            dp[i] = tasks[i][2] + (j < 0 ? 0 : dp[j]);
            if (i > 0) dp[i] = min(dp[i], dp[i - 1]);
        }
        return dp[n - 1];

=======

        vector<vector<int>> dp(2001, vector<int>(2001, 0));
        for (int i = 1; i <= 2000; ++i) {
            dp[i][i] = 1;
        }
        for (int len = 2; len <= 2000; ++len) {
            for (int i = 1; i + len - 1 <= 2000; ++i) {
                int j = i + len - 1;
                dp[i][j] = j - i + 1;
                for (int k = i; k < j; ++k) {
                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]);
                }
                for (auto& task: tasks) {
                    if (i == task[0] && j == task[1]) {
                        dp[i][j] = min(dp[i][j], task[2]);
                    }
                }
            }
        }
        return dp[1][2000];

=======

        int n = tasks.size();
        vector<int> dp(1<<n, 0);
        for (int i = 1; i < (1<<n); ++i) {
            int x = __builtin_ctz(i);
            int mask = i ^ (1<<x);
            dp[i] = dp[mask] + tasks[x][2];
            for (int y = 0; y < n; ++y) {
                if (i & (1<<y) && tasks[y][0] <= tasks[x][1]) {
                    dp[i] = max(dp[i], dp[mask | (1<<y)] + tasks[x][2]);
                }
            }
            for (int y = x + 1; y < n; ++y) {
                if (i & (1<<y) && tasks[y][0] <= tasks[x][1]) {
                    dp[i] = max(dp[i], dp[mask | (1<<y)] + tasks[x][2]);
                }
            }
        }
        
        return *max_element(dp.begin(), dp.end());

=======

        vector<pair<int, int>> time;
        for (auto& task : tasks) {
            time.push_back(make_pair(task[1], task[2]));
            time.push_back(make_pair(task[0] - 1, -task[2]));
        }
        sort(time.begin(), time.end());
        int ans = 0, cur = 0;
        for (auto& t : time) {
            cur += t.second;
            ans = max(ans, cur);
        }
        return ans;
