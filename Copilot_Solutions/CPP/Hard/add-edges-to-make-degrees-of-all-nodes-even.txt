Synthesizing 10/10 solutions

=======

        vector<vector<int>> g(n);
        for (auto& e : edges) {
            g[e[0] - 1].push_back(e[1] - 1);
            g[e[1] - 1].push_back(e[0] - 1);
        }
        vector<int> d(n);
        for (int i = 0; i < n; ++i) {
            d[i] = g[i].size();
        }
        vector<int> vis(n);
        function<void(int)> dfs = [&](int u) {
            vis[u] = 1;
            for (auto& v : g[u]) {
                if (!vis[v]) {
                    dfs(v);
                }
            }
        };
        int cnt = 0;
        for (int i = 0; i < n; ++i) {
            if (!vis[i]) {
                ++cnt;
                dfs(i);
            }
        }
        if (cnt > 1) {
            return false;
        }
        int odd = 0;
        for (int i = 0; i < n; ++i) {
            if (d[i] % 2) {
                ++odd;
            }
        }
        if (odd == 0) {
            return true;
        }
        if (odd != 2) {
            return false;
        }
        for (int i = 0; i < n; ++i) {
            if (d[i] % 2) {
                for (auto& v : g[i]) {
                    if (d[v] % 2) {
                        return true;
                    }
                }
            }
        }
        return false;

=======

        vector<vector<int>> graph(n);
        for (auto& e : edges) {
            graph[e[0] - 1].push_back(e[1] - 1);
            graph[e[1] - 1].push_back(e[0] - 1);
        }
        vector<int> degrees(n);
        for (int i = 0; i < n; ++i) {
            degrees[i] = graph[i].size();
        }
        vector<int> colors(n);
        int color = 1;
        for (int i = 0; i < n; ++i) {
            if (colors[i] == 0) {
                if (!dfs(graph, colors, color, i)) {
                    return false;
                }
                color++;
            }
        }
        int oddDegree = 0;
        for (int i = 0; i < n; ++i) {
            if (degrees[i] % 2 == 1) {
                oddDegree++;
            }
        }
        return oddDegree <= 2;
    }
    bool dfs(vector<vector<int>>& graph, vector<int>& colors, int color, int node) {
        colors[node] = color;
        for (int i = 0; i < graph[node].size(); ++i) {
            int neighbor = graph[node][i];
            if (colors[neighbor] == color) {
                return false;
            }
            if (colors[neighbor] == 0 && !dfs(graph, colors, color, neighbor)) {
                return false;
            }
        }
        return true;

=======

        vector<vector<int>> g(n);
        for (auto& e: edges) {
            g[e[0]-1].push_back(e[1]-1);
            g[e[1]-1].push_back(e[0]-1);
        }
        vector<int> d(n, 0);
        for (int i = 0; i < n; ++i) {
            d[i] = g[i].size();
        }
        vector<bool> vis(n, false);
        int odd = 0;
        for (int i = 0; i < n; ++i) {
            if (d[i] % 2 == 1) {
                ++odd;
            }
        }
        if (odd == 0) {
            return true;
        }
        if (odd % 2 == 1) {
            return false;
        }
        queue<int> q;
        for (int i = 0; i < n; ++i) {
            if (d[i] % 2 == 1) {
                q.push(i);
                vis[i] = true;
                break;
            }
        }
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            for (int v: g[u]) {
                if (vis[v]) {
                    continue;
                }
                if (d[v] % 2 == 1) {
                    vis[v] = true;
                    q.push(v);
                }
            }
        }
        for (int i = 0; i < n; ++i) {
            if (!vis[i] && d[i] % 2 == 1) {
                return false;
            }
        }
        return true;

=======

        vector<vector<int>> g(n + 1);
        vector<int> deg(n + 1);
        for (auto& e : edges) {
            g[e[0]].push_back(e[1]);
            g[e[1]].push_back(e[0]);
            ++deg[e[0]];
            ++deg[e[1]];
        }
        for (int i = 1; i <= n; ++i) {
            if (deg[i] % 2 != 0) {
                g[0].push_back(i);
                g[i].push_back(0);
                ++deg[0];
            }
        }
        queue<int> q;
        q.push(0);
        vector<bool> visited(n + 1);
        visited[0] = true;
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            for (int v : g[u]) {
                if (!visited[v]) {
                    visited[v] = true;
                    q.push(v);
                }
            }
        }
        for (int i = 0; i <= n; ++i) {
            if (!visited[i]) {
                return false;
            }
        }
        return true;

=======

        vector<vector<int>> adj(n);
        vector<int> degree(n);
        for (auto& e : edges) {
            adj[e[0] - 1].push_back(e[1] - 1);
            adj[e[1] - 1].push_back(e[0] - 1);
            degree[e[0] - 1]++;
            degree[e[1] - 1]++;
        }
        vector<int> odd;
        for (int i = 0; i < n; i++) {
            if (degree[i] % 2 == 1) {
                odd.push_back(i);
            }
        }
        if (odd.size() == 0) {
            return true;
        }
        if (odd.size() % 2 == 1) {
            return false;
        }
        for (int i = 0; i < odd.size(); i += 2) {
            bool found = false;
            for (int j = 0; j < adj[odd[i]].size(); j++) {
                if (degree[adj[odd[i]][j]] % 2 == 1) {
                    edges.push_back({odd[i] + 1, adj[odd[i]][j] + 1});
                    found = true;
                    break;
                }
            }
            if (!found) {
                return false;
            }
        }
        return isPossible(n, edges);

=======

        vector<vector<int>> graph(n+1);
        vector<int> degree(n+1);
        for (auto& edge: edges) {
            graph[edge[0]].push_back(edge[1]);
            graph[edge[1]].push_back(edge[0]);
            degree[edge[0]]++;
            degree[edge[1]]++;
        }
        queue<int> q;
        for (int i = 1; i <= n; ++i) {
            if (degree[i] % 2 == 1) {
                q.push(i);
            }
        }
        while (!q.empty()) {
            int node = q.front();
            q.pop();
            for (int neighbor: graph[node]) {
                degree[neighbor]--;
                if (degree[neighbor] % 2 == 1) {
                    q.push(neighbor);
                }
            }
        }
        for (int i = 1; i <= n; ++i) {
            if (degree[i] % 2 == 1) {
                return false;
            }
        }
        return true;

=======

        vector<int> deg(n + 1, 0);
        for (auto& e : edges) {
            deg[e[0]]++;
            deg[e[1]]++;
        }
        int odd = 0;
        for (int i = 1; i <= n; i++) {
            if (deg[i] % 2 == 1) {
                odd++;
            }
        }
        if (odd == 0) {
            return true;
        }
        if (odd % 2 == 1) {
            return false;
        }
        vector<unordered_set<int>> g(n + 1);
        for (auto& e : edges) {
            g[e[0]].insert(e[1]);
            g[e[1]].insert(e[0]);
        }
        vector<bool> vis(n + 1, false);
        for (int i = 1; i <= n; i++) {
            if (vis[i] || deg[i] % 2 == 0) {
                continue;
            }
            queue<int> q;
            q.push(i);
            vis[i] = true;
            while (!q.empty()) {
                int u = q.front();
                q.pop();
                for (int v : g[u]) {
                    if (vis[v] || deg[v] % 2 == 0) {
                        continue;
                    }
                    vis[v] = true;
                    q.push(v);
                }
            }
            int cnt = 0;
            for (int j = 1; j <= n; j++) {
                if (vis[j]) {
                    cnt++;
                }
            }
            if (cnt % 2 == 1) {
                return false;
            }
        }
        return true;

=======

        vector<int> degree(n + 1, 0);
        vector<vector<int>> graph(n + 1, vector<int>());
        for (const auto &edge : edges) {
            graph[edge[0]].push_back(edge[1]);
            graph[edge[1]].push_back(edge[0]);
            degree[edge[0]]++;
            degree[edge[1]]++;
        }
        vector<int> odd;
        for (int i = 1; i <= n; i++) {
            if (degree[i] % 2) {
                odd.push_back(i);
            }
        }
        if (odd.size() == 0) {
            return true;
        }
        if (odd.size() % 2) {
            return false;
        }
        vector<int> visited(n + 1, 0);
        for (int i = 0; i < odd.size(); i += 2) {
            if (!dfs(odd[i], odd[i + 1], graph, visited)) {
                return false;
            }
        }
        return true;

=======

        if (n == 1) return true;
        if (n == 2) return false;
        if (edges.size() < n - 1) return false;
        vector<int> degree(n + 1, 0);
        vector<vector<int>> adj(n + 1, vector<int>());
        for (auto edge : edges) {
            adj[edge[0]].push_back(edge[1]);
            adj[edge[1]].push_back(edge[0]);
            degree[edge[0]]++;
            degree[edge[1]]++;
        }
        queue<int> q;
        for (int i = 1; i <= n; i++) {
            if (degree[i] % 2) q.push(i);
        }
        while (!q.empty()) {
            int u = q.front(); q.pop();
            if (degree[u] % 2) {
                int v = adj[u][0];
                adj[u].erase(adj[u].begin());
                adj[v].erase(find(adj[v].begin(), adj[v].end(), u));
                degree[u]--;
                degree[v]--;
                if (degree[v] % 2) q.push(v);
            }
        }
        for (int i = 1; i <= n; i++) {
            if (degree[i] % 2) return false;
        }
        return true;

=======

        // 1. Count the degree of each node
        vector<int> degree(n + 1, 0);
        for (auto& edge : edges) {
            degree[edge[0]]++;
            degree[edge[1]]++;
        }
        
        // 2. Count the number of nodes with odd degree
        int oddDegreeNodes = 0;
        for (int i = 1; i <= n; i++) {
            if (degree[i] % 2 == 1) {
                oddDegreeNodes++;
            }
        }
        
        // 3. If there are more than 2 odd degree nodes, then it is not possible to make the degree of each node in the graph even
        if (oddDegreeNodes > 2) {
            return false;
        }
        
        // 4. If there are 2 odd degree nodes, then we need to find a path between them, otherwise we can add 2 edges to make the degree of each node in the graph even
        if (oddDegreeNodes == 2) {
            // 4.1. Build the graph
            vector<vector<int>> graph(n + 1, vector<int>());
            for (auto& edge : edges) {
                graph[edge[0]].push_back(edge[1]);
                graph[edge[1]].push_back(edge[0]);
            }
            
            // 4.2. Find the first odd degree node
            int start = 0;
            for (int i = 1; i <= n; i++) {
                if (degree[i] % 2 == 1) {
                    start = i;
                    break;
                }
            }
            
            // 4.3. Find a path between the first odd degree node and the second odd degree node
            vector<bool> visited(n + 1, false);
            return dfs(graph, start, visited);
        }
        
        return true;
