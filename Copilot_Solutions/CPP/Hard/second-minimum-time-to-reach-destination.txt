Synthesizing 9/10 solutions (Duplicates hidden)

=======

        vector<vector<int>> graph(n);
        for (auto& e : edges) {
            graph[e[0] - 1].push_back(e[1] - 1);
            graph[e[1] - 1].push_back(e[0] - 1);
        }
        vector<int> dist(n, INT_MAX);
        dist[0] = 0;
        queue<int> q;
        q.push(0);
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            for (int v : graph[u]) {
                if (dist[v] == INT_MAX) {
                    dist[v] = dist[u] + time;
                    q.push(v);
                } else if (dist[v] > dist[u] + time) {
                    int prev = dist[v];
                    dist[v] = dist[u] + time;
                    if ((dist[v] / change) % 2 == (dist[u] / change) % 2) {
                        dist[v] = (dist[v] / change + 1) * change;
                    }
                    if (dist[v] < prev) {
                        q.push(v);
                    }
                }
            }
        }
        return dist[n - 1];

=======

        vector<vector<int>> graph(n);
        for (auto& edge : edges) {
            graph[edge[0] - 1].push_back(edge[1] - 1);
            graph[edge[1] - 1].push_back(edge[0] - 1);
        }
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        pq.push({0, 0});
        vector<int> dist(n, INT_MAX);
        dist[0] = 0;
        while (!pq.empty()) {
            auto [t, u] = pq.top();
            pq.pop();
            if (t > dist[u]) continue;
            for (auto v : graph[u]) {
                int wait = (t / change + 1) * change - t;
                int cost = t + wait + time;
                if (cost < dist[v]) {
                    dist[v] = cost;
                    pq.push({cost, v});
                }
            }
        }
        return dist[n - 1];

=======

        vector<vector<int>> g(n);
        for (auto& e: edges) {
            g[e[0] - 1].push_back(e[1] - 1);
            g[e[1] - 1].push_back(e[0] - 1);
        }
        vector<int> dist(n, INT_MAX);
        queue<int> q;
        q.push(0);
        dist[0] = 0;
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            for (int v: g[u]) {
                int t = dist[u] + time;
                t += change - t % change;
                if (dist[v] > t) {
                    dist[v] = t;
                    q.push(v);
                }
            }
        }
        int minTime = dist[n - 1];
        int secondMinTime = INT_MAX;
        for (int i = 0; i < n; i++) {
            if (dist[i] == minTime) {
                for (int j: g[i]) {
                    if (dist[j] != minTime) {
                        secondMinTime = min(secondMinTime, dist[j]);
                    }
                }
            }
        }
        return secondMinTime;

=======

        vector<vector<int>> adj(n);
        for (auto& e : edges) {
            adj[e[0] - 1].push_back(e[1] - 1);
            adj[e[1] - 1].push_back(e[0] - 1);
        }
        vector<int> dist(n, INT_MAX);
        vector<int> cycle(n, INT_MAX);
        dist[0] = 0;
        cycle[0] = 0;
        queue<int> q;
        q.push(0);
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (int v : adj[u]) {
                int t = dist[u] + time;
                int c = (t / change) * change;
                if (t % change != 0) c += change;
                if (c < cycle[v]) {
                    cycle[v] = c;
                    dist[v] = c + time;
                    q.push(v);
                } else if (c == cycle[v] && dist[v] > t + time) {
                    dist[v] = t + time;
                    q.push(v);
                }
            }
        }
        return dist[n - 1];

=======

        vector<vector<pair<int, int>>> graph(n + 1);
        for (auto &e : edges) {
            graph[e[0]].push_back({e[1], time});
            graph[e[1]].push_back({e[0], time});
        }
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        vector<int> dist(n + 1, INT_MAX);
        pq.push({0, 1});
        dist[1] = 0;
        while (!pq.empty()) {
            auto [d, u] = pq.top();
            pq.pop();
            if (d > dist[u]) {
                continue;
            }
            for (auto &[v, w] : graph[u]) {
                int t = d + w + (d + w) / change * change;
                if (t < dist[v]) {
                    dist[v] = t;
                    pq.push({t, v});
                }
            }
        }
        return dist[n];

=======

        vector<vector<int>> g(n+1);
        for (auto& e: edges) {
            g[e[0]].push_back(e[1]);
            g[e[1]].push_back(e[0]);
        }
        vector<int> dist(n+1, INT_MAX);
        queue<int> q;
        q.push(1);
        dist[1] = 0;
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (auto& v: g[u]) {
                int w = dist[u] + time;
                if (dist[u] % change < change - 1) {
                    w += change - 1 - dist[u] % change;
                }
                if (w < dist[v]) {
                    dist[v] = w;
                    q.push(v);
                }
            }
        }
        int ans = INT_MAX;
        for (int i = 1; i <= n; ++i) {
            if (i != 1 && dist[i] < ans) {
                ans = dist[i];
            }
        }
        return ans;

=======

        vector<vector<pair<int, int>>> adj(n + 1);
        for (auto& edge : edges) {
            adj[edge[0]].push_back({edge[1], time});
            adj[edge[1]].push_back({edge[0], time});
        }
        vector<int> dist(n + 1, INT_MAX);
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        pq.push({0, 1});
        while (!pq.empty()) {
            auto [d, u] = pq.top();
            pq.pop();
            if (d >= dist[u]) continue;
            dist[u] = d;
            for (auto& [v, t] : adj[u]) {
                int cycle = (d + t) / change;
                int next = cycle * change + change;
                pq.push({next, v});
            }
        }
        return dist[n];

=======

        vector<vector<pair<int, int>>> graph(n + 1);
        for (const auto& edge : edges) {
            int u = edge[0], v = edge[1];
            graph[u].emplace_back(v, 0);
            graph[v].emplace_back(u, 0);
        }
        for (int i = 1; i <= n; ++i) {
            int cycle = i * change;
            int k = (time - 1) / cycle;
            int remain = time - k * cycle;
            int t = remain > 0 ? remain : time;
            for (auto& p : graph[i]) {
                p.second = t;
            }
        }
        vector<int> dist(n + 1, INT_MAX);
        dist[1] = 0;
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        pq.emplace(0, 1);
        while (!pq.empty()) {
            auto [d, u] = pq.top();
            pq.pop();
            if (d > dist[u]) {
                continue;
            }
            for (const auto& [v, t] : graph[u]) {
                int d2 = d + t;
                if (d2 < dist[v]) {
                    dist[v] = d2;
                    pq.emplace(d2, v);
                }
            }
        }
        return dist[n];
