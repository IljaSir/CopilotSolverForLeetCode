Synthesizing 9/10 solutions (Duplicates hidden)

=======

        int n = nums.size();
        int sum = accumulate(nums.begin(), nums.end(), 0);
        vector<vector<bool>> dp(n + 1, vector<bool>(sum + 1, false));
        dp[0][0] = true;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= sum; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j >= nums[i - 1]) {
                    dp[i][j] = dp[i][j] || dp[i - 1][j - nums[i - 1]];
                }
            }
        }
        for (int i = 1; i < n; i++) {
            if (sum * i % n == 0 && dp[i][sum * i / n]) {
                return true;
            }
        }
        return false;

=======

        int n = nums.size();
        int sum = accumulate(nums.begin(), nums.end(), 0);
        vector<vector<bool>> dp(n + 1, vector<bool>(sum + 1, false));
        dp[0][0] = true;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= sum; j++) {
                if (j >= nums[i - 1]) {
                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        for (int i = 1; i < n; i++) {
            if (sum * i % n == 0 && dp[i][sum * i / n]) {
                return true;
            }
        }
        return false;

=======

        int n = nums.size();
        int sum = accumulate(nums.begin(), nums.end(), 0);
        vector<vector<bool>> dp(n + 1, vector<bool>(sum + 1, false));
        dp[0][0] = true;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= sum; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j >= nums[i - 1]) {
                    dp[i][j] |= dp[i - 1][j - nums[i - 1]];
                }
            }
        }
        for (int i = 1; i < n; i++) {
            if (sum * i % n == 0 && dp[i][sum * i / n]) {
                return true;
            }
        }
        return false;

=======

        int n = nums.size();
        vector<int> sum(1 << n, 0);
        for (int i = 0; i < (1 << n); ++i) {
            for (int j = 0; j < n; ++j) {
                if (i & (1 << j)) {
                    sum[i] = sum[i ^ (1 << j)] + nums[j];
                }
            }
        }
        
        for (int i = 1; i < (1 << n) - 1; ++i) {
            int j = (1 << n) - 1 - i;
            if (sum[i] * n == sum[j] * __builtin_popcount(i) || sum[j] * n == sum[i] * __builtin_popcount(j)) {
                return true;
            }
        }
        
        return false;

=======

        int n = nums.size();
        int sum = accumulate(nums.begin(), nums.end(), 0);
        vector<vector<bool>> dp(n + 1, vector<bool>(n * 500 + 1, false));
        dp[0][0] = true;
        for (int i = 0; i < n; ++i) {
            for (int j = i; j >= 0; --j) {
                for (int k = n * 500; k >= nums[i]; --k) {
                    dp[j + 1][k] |= dp[j][k - nums[i]];
                }
            }
        }
        for (int i = 1; i < n; ++i) {
            if (sum * i % n == 0 && dp[i][sum * i / n]) {
                return true;
            }
        }
        return false;

=======

        int n = nums.size();
        int sum = 0;
        for (auto num : nums)
            sum += num;
        vector<vector<bool>> dp(n + 1, vector<bool>(sum + 1, false));
        dp[0][0] = true;
        for (int i = 0; i < n; ++i) {
            for (int j = i; j >= 0; --j) {
                for (int k = sum; k >= nums[i]; --k) {
                    dp[j + 1][k] = dp[j + 1][k] || dp[j][k - nums[i]];
                }
            }
        }
        for (int i = 1; i < n; ++i) {
            if (sum * i % n == 0 && dp[i][sum * i / n])
                return true;
        }
        return false;

=======

        int sum = accumulate(nums.begin(), nums.end(), 0);
        int n = nums.size();
        int half = n / 2;
        bool possible = false;
        for (int i = 1; i <= half; ++i) {
            if (sum * i % n == 0) {
                possible = true;
                break;
            }
        }
        if (!possible) return false;
        vector<vector<bool>> dp(n + 1, vector<bool>(sum + 1, false));
        dp[0][0] = true;
        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j <= sum; ++j) {
                dp[i][j] = dp[i - 1][j];
                if (j >= nums[i - 1]) {
                    dp[i][j] = dp[i][j] || dp[i - 1][j - nums[i - 1]];
                }
            }
        }
        for (int i = 1; i <= half; ++i) {
            if (sum * i % n == 0 && dp[n][sum * i / n]) return true;
        }
        return false;

=======

        int n = nums.size();
        int sum = accumulate(nums.begin(), nums.end(), 0);
        int maxLen = n/2;
        vector<vector<bool>> dp(maxLen+1, vector<bool>(sum+1, false));
        for (int i = 0; i < n; i++) {
            for (int j = maxLen; j >= 1; j--) {
                for (int k = sum; k >= nums[i]; k--) {
                    if (j == 1 && k == nums[i]) {
                        dp[j][k] = true;
                    } else if (j > 1 && dp[j-1][k-nums[i]]) {
                        dp[j][k] = true;
                    }
                }
            }
        }
        for (int i = 1; i <= maxLen; i++) {
            if (sum*i%n == 0 && dp[i][sum*i/n]) {
                return true;
            }
        }
        return false;
