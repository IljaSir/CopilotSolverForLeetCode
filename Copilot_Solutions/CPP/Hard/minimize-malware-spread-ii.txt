Synthesizing 9/10 solutions (Duplicates hidden)

=======

        int n = graph.size();
        vector<int> color(n, -1);
        int c = 0;
        for (int i = 0; i < n; ++i) {
            if (color[i] == -1) {
                dfs(graph, color, i, c++);
            }
        }
        vector<int> size(c, 0);
        for (int i = 0; i < n; ++i) {
            ++size[color[i]];
        }
        vector<int> malware(c, 0);
        for (int i : initial) {
            ++malware[color[i]];
        }
        int ans = INT_MAX;
        for (int i : initial) {
            int c = color[i];
            if (malware[c] == 1) {
                if (ans == INT_MAX) {
                    ans = i;
                } else if (size[c] > size[color[ans]]) {
                    ans = i;
                } else if (size[c] == size[color[ans]] && i < ans) {
                    ans = i;
                }
            }
        }
        if (ans == INT_MAX) {
            for (int i : initial) {
                ans = min(ans, i);
            }
        }
        return ans;

=======

        int n = graph.size();
        vector<int> colors(n, -1);
        int c = 0;
        for (int i = 0; i < n; ++i) {
            if (colors[i] == -1) {
                dfs(graph, colors, i, c++);
            }
        }
        vector<int> colorSize(c);
        for (int color : colors) {
            colorSize[color]++;
        }
        vector<int> colorInitial(c);
        for (int node : initial) {
            colorInitial[colors[node]]++;
        }
        int ans = INT_MAX;
        for (int node : initial) {
            int color = colors[node];
            if (colorInitial[color] == 1) {
                if (ans == INT_MAX) {
                    ans = node;
                }
                else if (colorSize[color] > colorSize[colors[ans]]) {
                    ans = node;
                }
                else if (colorSize[color] == colorSize[colors[ans]] && node < ans) {
                    ans = node;
                }
            }
        }
        if (ans == INT_MAX) {
            for (int node : initial) {
                ans = min(ans, node);
            }
        }
        return ans;
    }
    void dfs(vector<vector<int>>& graph, vector<int>& colors, int node, int color) {
        colors[node] = color;
        for (int nei = 0; nei < graph.size(); ++nei) {
            if (graph[node][nei] == 1 && colors[nei] == -1) {
                dfs(graph, colors, nei, color);
            }
        }

=======

        int n = graph.size();
        vector<int> color(n, -1);
        for (int c = 0, i = 0; i < n; ++i) {
            if (color[i] < 0) {
                dfs(graph, color, i, c++);
            }
        }
        vector<int> colorSize(c, 0);
        for (int i = 0; i < n; ++i) {
            colorSize[color[i]]++;
        }
        vector<int> infected(c, 0);
        for (int i : initial) {
            infected[color[i]]++;
        }
        int ans = initial[0], ansSize = -1;
        for (int i : initial) {
            int c = color[i];
            if (infected[c] == 1) {
                if (ansSize < colorSize[c]) {
                    ansSize = colorSize[c];
                    ans = i;
                }
            }
        }
        if (ansSize == -1) {
            for (int i : initial) {
                ans = min(ans, i);
            }
        }
        return ans;
    }
    void dfs(const vector<vector<int>>& graph, vector<int>& color, int node, int c) {
        color[node] = c;
        for (int i = 0; i < graph.size(); ++i) {
            if (graph[node][i] == 1 && color[i] < 0) {
                dfs(graph, color, i, c);
            }
        }

=======

        int n = graph.size();
        vector<int> group(n, -1);
        for (int i = 0; i < n; ++i) {
            if (group[i] == -1) {
                dfs(graph, group, i, i);
            }
        }
        vector<int> groupSize(n, 0);
        for (int i = 0; i < n; ++i) {
            groupSize[group[i]]++;
        }
        vector<int> infected(n, 0);
        for (int i : initial) {
            infected[group[i]]++;
        }
        int ans = *min_element(initial.begin(), initial.end());
        int ansSize = -1;
        for (int i : initial) {
            int g = group[i];
            if (infected[g] == 1) {
                if (groupSize[g] > ansSize) {
                    ans = i;
                    ansSize = groupSize[g];
                }
            }
        }
        return ans;

=======

        int n = graph.size();
        vector<int> infected(n, 0);
        for (int i: initial) {
            infected[i] = 1;
        }
        vector<int> parent(n, -1);
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (graph[i][j] == 1 && infected[i] && infected[j]) {
                    if (parent[i] == -1) {
                        parent[i] = i;
                    }
                    if (parent[j] == -1) {
                        parent[j] = i;
                    }
                    parent[j] = i;
                }
            }
        }
        vector<int> count(n, 0);
        for (int i = 0; i < n; ++i) {
            if (parent[i] == -1) {
                continue;
            }
            count[parent[i]] += infected[i];
        }
        int ans = -1, maxCount = 0;
        for (int i: initial) {
            if (ans == -1 || (count[parent[i]] > maxCount) || (count[parent[i]] == maxCount && parent[i] < parent[ans])) {
                ans = i;
                maxCount = count[parent[i]];
            }
        }
        return ans;

=======

        int n = graph.size();
        vector<int> colors(n);
        int c = 0;
        for (int i=0; i < n; i++) {
            if (colors[i] == 0) {
                c++;
                dfs(graph, colors, i, c);
            }
        }
        vector<int> colorSize(c+1);
        vector<int> colorInitial(c+1);
        for (int i=0; i < n; i++) {
            colorSize[colors[i]]++;
        }
        for (auto i: initial) {
            colorInitial[colors[i]]++;
        }
        int ans = INT_MAX;
        for (auto i: initial) {
            int c = colors[i];
            if (colorInitial[c] == 1) {
                if (ans == INT_MAX) {
                    ans = i;
                } else if (colorSize[c] > colorSize[colors[ans]]) {
                    ans = i;
                } else if (colorSize[c] == colorSize[colors[ans]] && i < ans) {
                    ans = i;
                }
            }
        }
        if (ans == INT_MAX) {
            for (auto i: initial) {
                ans = min(ans, i);
            }
        }
        return ans;
    }
    
    void dfs(vector<vector<int>>& graph, vector<int>& colors, int node, int c) {
        colors[node] = c;
        for (int i=0; i < graph.size(); i++) {
            if (graph[node][i] == 1 && colors[i] == 0) {
                dfs(graph, colors, i, c);
            }
        }

=======

        // 1. find the connected components
        // 2. find the number of nodes in each connected component
        // 3. find the number of initial nodes in each connected component
        // 4. find the maximum number of initial nodes in a connected component
        // 5. find the connected component with the maximum number of initial nodes
        // 6. find the node with the smallest index in the connected component
        int n = graph.size();
        vector<int> component(n, 0);
        vector<int> size(n, 0);
        vector<int> initial_nodes(n, 0);
        int max_initial_nodes = 0;
        int max_initial_nodes_component = 0;
        int max_initial_nodes_component_node = 0;
        int component_count = 0;
        for (int i = 0; i < n; i++) {
            if (component[i] == 0) {
                component_count++;
                size[component_count] = 1;
                component[i] = component_count;
                dfs(i, graph, component, component_count, size);
            }
        }
        for (int i = 0; i < initial.size(); i++) {
            initial_nodes[component[initial[i]]]++;
        }
        for (int i = 1; i <= component_count; i++) {
            if (initial_nodes[i] > max_initial_nodes) {
                max_initial_nodes = initial_nodes[i];
                max_initial_nodes_component = i;
                max_initial_nodes_component_node = -1;
            } else if (initial_nodes[i] == max_initial_nodes) {
                for (int j = 0; j < n; j++) {
                    if (component[j] == i) {
                        if (max_initial_nodes_component_node == -1 || j < max_initial_nodes_component_node) {
                            max_initial_nodes_component_node = j;
                        }
                    }
                }
            }
        }
        if (max_initial_nodes == 1) {
            for (int i = 0; i < initial.size(); i++) {
                if (component[initial[i]] == max_initial_nodes_component) {
                    return initial[i];
                }
            }
        }
        return max_initial_nodes_component_node;
