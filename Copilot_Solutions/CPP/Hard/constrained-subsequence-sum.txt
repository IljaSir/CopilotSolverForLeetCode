Synthesizing 9/10 solutions

=======

        int n = nums.size();
        vector<int> dp(n);
        deque<int> q;
        dp[0] = nums[0];
        q.push_back(0);
        for (int i = 1; i < n; ++i) {
            dp[i] = nums[i] + max(0, dp[q.front()]);
            while (!q.empty() && dp[q.back()] <= dp[i]) q.pop_back();
            q.push_back(i);
            if (i - q.front() >= k) q.pop_front();
        }
        return *max_element(dp.begin(), dp.end());

=======

        int n = nums.size();
        vector<int> dp(n);
        deque<int> q;
        for (int i = 0; i < n; ++i) {
            dp[i] = nums[i] + (q.empty() ? 0 : q.front());
            while (!q.empty() && q.back() < dp[i]) {
                q.pop_back();
            }
            q.push_back(dp[i]);
            if (i >= k && q.front() == dp[i - k]) {
                q.pop_front();
            }
        }
        return *max_element(dp.begin(), dp.end());

=======

        int n = nums.size();
        deque<int> dq;
        int res = nums[0];
        for (int i = 0; i < n; ++i) {
            if (!dq.empty()) {
                nums[i] = max(nums[i], nums[dq.front()] + nums[i]);
            }
            res = max(res, nums[i]);
            while (!dq.empty() && nums[dq.back()] <= nums[i]) {
                dq.pop_back();
            }
            dq.push_back(i);
            if (dq.front() == i - k) {
                dq.pop_front();
            }
        }
        return res;

=======

        int n = nums.size();
        vector<int> dp(n, 0);
        int res = INT_MIN;
        deque<int> q;
        for (int i = 0; i < n; i++) {
            dp[i] = nums[i] + (q.empty() ? 0 : q.front());
            res = max(res, dp[i]);
            while (!q.empty() && q.back() < dp[i]) {
                q.pop_back();
            }
            if (dp[i] > 0) {
                q.push_back(dp[i]);
            }
            if (i >= k && !q.empty() && q.front() == dp[i - k]) {
                q.pop_front();
            }
        }
        return res;

=======

        int n = nums.size();
        deque<int> q;
        int res = INT_MIN;
        for (int i = 0; i < n; ++i) {
            if (!q.empty()) {
                nums[i] = max(nums[i], nums[q.front()] + nums[i]);
            }
            while (!q.empty() && nums[q.back()] <= nums[i]) {
                q.pop_back();
            }
            q.push_back(i);
            if (q.front() == i - k) {
                q.pop_front();
            }
            res = max(res, nums[i]);
        }
        return res;

=======

        int n = nums.size();
        vector<int> dp(n);
        int ans = nums[0];
        deque<int> q;
        for (int i = 0; i < n; ++i) {
            if (!q.empty()) {
                dp[i] = nums[i] + max(0, dp[q.front()]);
            } else {
                dp[i] = nums[i];
            }
            while (!q.empty() && dp[q.back()] <= dp[i]) {
                q.pop_back();
            }
            q.push_back(i);
            if (q.front() == i - k) {
                q.pop_front();
            }
            ans = max(ans, dp[i]);
        }
        return ans;

=======

        int n = nums.size();
        deque<int> dq;
        int ans = INT_MIN;
        for (int i = 0; i < n; ++i) {
            if (dq.size() && i - dq.front() > k) {
                dq.pop_front();
            }
            if (dq.size()) {
                nums[i] += nums[dq.front()];
            }
            while (dq.size() && nums[dq.back()] <= nums[i]) {
                dq.pop_back();
            }
            dq.push_back(i);
            ans = max(ans, nums[i]);
        }
        return ans;

=======

        int n = nums.size();
        deque<int> q;
        int res = INT_MIN;
        for (int i = 0; i < n; ++i) {
            if (!q.empty()) {
                nums[i] = max(nums[i], nums[q.front()] + nums[i]);
            }
            while (!q.empty() && nums[q.back()] <= nums[i]) {
                q.pop_back();
            }
            q.push_back(i);
            if (q.front() == i - k) {
                q.pop_front();
            }
            res = max(res, nums[i]);
        }
        return res;

        return mx;

=======

======  int n = nums.size();
=      int ans = INT_MIN;
        deque<int> q;
        fo(int i = 0; i < n; i++) {
            if(!q.mpy()) {
                nms[i] = nums[i] + q.fot();
           }
            ans = a(ans, nums[i]);
            while(!q.empty() && q.back() < nums[i]) {
                q.pop_back();
            }
            q.push_back(nums[i]);
            if(i >= k && q.front() == nums[i - k]) {
                q.pop_front();
            }
        }
        return ans

        int n = nums.size();
        vector<int> dp(n);
        int ans = nums[0];
        deque<int> q;
        for (int i = 0; i < n; ++i) {
            if (!q.empty()) {
                dp[i] = nums[i] + max(0, dp[q.front()]);
            } else {
                dp[i] = nums[i];
            }
            while (!q.empty() && dp[q.back()] <= dp[i]) {
                q.pop_back();
            }
            q.push_back(i);
            if (q.front() == i - k) {
                q.pop_front();
            }
            ans = max(ans, dp[i]);
        }
        return ans;

=======

        int n = nums.size();
        deque<int> dq;
        int ans = INT_MIN;
        for (int i = 0; i < n; ++i) {
            if (dq.size() && i - dq.front() > k) {
                dq.pop_front();
            }
            if (dq.size()) {
                nums[i] += nums[dq.front()];
            }
            while (dq.size() && nums[dq.back()] <= nums[i]) {
                dq.pop_back();
            }
            dq.push_back(i);
            ans = max(ans, nums[i]);
        }
        return ans;

=======

        int n = nums.size();
        int dp[n];
        int mx = INT_MIN;
        deque<int> dq;
        for (int i = 0; i < n; i++) {
            dp[i] = nums[i];
            if (!dq.empty()) {
                dp[i] = max(dp[i], nums[i] + dp[dq.front()]);
            }
            while (!dq.empty() && dp[dq.back()] < dp[i]) {
                dq.pop_back();
            }
            dq.push_back(i);
            if (dq.front() == i - k) {
                dq.pop_front();
            }
            mx = max(mx, dp[i]);
        }
        return mx;

=======

        int n = nums.size();
        int ans = INT_MIN;
        deque<int> q;
        for(int i = 0; i < n; i++) {
            if(!q.empty()) {
                nums[i] = nums[i] + q.front();
            }
            ans = max(ans, nums[i]);
            while(!q.empty() && q.back() < nums[i]) {
                q.pop_back();
            }
            q.push_back(nums[i]);
            if(i >= k && q.front() == nums[i - k]) {
                q.pop_front();
            }
        }
        return ans;
