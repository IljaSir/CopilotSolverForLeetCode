Synthesizing 10/10 solutions

=======

        sort(nums.begin(), nums.end());
        int left = 0, right = nums.back() - nums[0];
        while (left < right) {
            int mid = left + (right - left) / 2;
            int count = 0, start = 0;
            for (int end = 0; end < nums.size(); ++end) {
                while (nums[end] - nums[start] > mid) {
                    ++start;
                }
                count += end - start;
            }
            if (count < k) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;

=======

        sort(nums.begin(), nums.end());
        int n = nums.size();
        int l = 0, r = nums[n - 1] - nums[0];
        while (l < r) {
            int mid = l + r >> 1;
            int cnt = 0, i = 0;
            for (int j = 0; j < n; j ++) {
                while (i < n && nums[j] - nums[i] > mid) i ++;
                cnt += j - i;
            }
            if (cnt < k) l = mid + 1;
            else r = mid;
        }
        return l;

=======

        sort(nums.begin(), nums.end());
        int n = nums.size();
        int l = 0, r = nums[n - 1] - nums[0];
        while (l < r) {
            int mid = l + (r - l) / 2;
            int cnt = 0;
            for (int i = 0; i < n; ++i) {
                auto it = upper_bound(nums.begin(), nums.end(), nums[i] + mid);
                cnt += it - nums.begin() - i - 1;
            }
            if (cnt < k) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        return l;

=======

        sort(nums.begin(), nums.end());
        int n = nums.size();
        int left = 0, right = nums[n - 1] - nums[0];
        while (left < right) {
            int mid = left + (right - left) / 2;
            int count = 0, start = 0;
            for (int end = 0; end < n; end++) {
                while (nums[end] - nums[start] > mid) {
                    start++;
                }
                count += end - start;
            }
            if (count < k) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;

=======

        int n = nums.size();
        sort(nums.begin(), nums.end());
        int l = 0, r = nums[n - 1] - nums[0];
        while (l < r) {
            int mid = l + r >> 1;
            int cnt = 0, j = 0;
            for (int i = 0; i < n; i++) {
                while (j < n && nums[j] - nums[i] <= mid) j++;
                cnt += j - i - 1;
            }
            if (cnt >= k) r = mid;
            else l = mid + 1;
        }
        return l;

=======

        sort(nums.begin(), nums.end());
        int n = nums.size();
        int left = 0;
        int right = nums[n - 1] - nums[0];
        while (left < right) {
            int mid = left + (right - left) / 2;
            int cnt = 0;
            int j = 0;
            for (int i = 0; i < n; ++i) {
                while (j < n && nums[j] - nums[i] <= mid) {
                    ++j;
                }
                cnt += j - i - 1;
            }
            if (cnt < k) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;

=======

        sort(nums.begin(), nums.end());
        int n = nums.size();
        int l = 0, r = nums[n - 1] - nums[0];
        while (l < r) {
            int m = l + (r - l) / 2;
            int count = 0, left = 0;
            for (int right = 0; right < n; right++) {
                while (nums[right] - nums[left] > m) {
                    left++;
                }
                count += right - left;
            }
            if (count >= k) {
                r = m;
            } else {
                l = m + 1;
            }
        }
        return l;

=======

        sort(nums.begin(), nums.end());
        int l = 0, r = nums.back() - nums.front();
        while (l < r) {
            int mid = l + (r - l) / 2;
            int cnt = 0, start = 0;
            for (int i = 0; i < nums.size(); ++i) {
                while (nums[i] - nums[start] > mid) ++start;
                cnt += i - start;
            }
            if (cnt < k) l = mid + 1;
            else r = mid;
        }
        return l;

=======

        sort(nums.begin(), nums.end());
        int n = nums.size();
        int l = 0, r = nums[n-1] - nums[0];
        while (l < r) {
            int mid = (l + r) / 2;
            int count = 0, left = 0;
            for (int right = 0; right < n; ++right) {
                while (nums[right] - nums[left] > mid) {
                    ++left;
                }
                count += right - left;
            }
            if (count < k) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        return l;

=======

        int n = nums.size();
        sort(nums.begin(), nums.end());
        int low = 0, high = nums[n-1] - nums[0];
        while (low < high) {
            int mid = (low + high) / 2;
            int count = 0;
            for (int i = 0; i < n; ++i) {
                count += upper_bound(nums.begin(), nums.end(), nums[i] + mid) - nums.begin() - i - 1;
            }
            if (count < k) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
