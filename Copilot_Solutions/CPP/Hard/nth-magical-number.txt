Synthesizing 10/10 solutions

=======

        int mod = 1e9 + 7;
        int l = 0, r = 1e15;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (mid / a + mid / b - mid / (a * b / __gcd(a, b)) < n) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        return l % mod;

=======

        int c = a * b / gcd(a, b);
        long long l = 0, r = 1e15;
        while (l < r) {
            long long mid = (l + r) >> 1;
            if (mid / a + mid / b - mid / c >= n) r = mid;
            else l = mid + 1;
        }
        return l % (int)(1e9 + 7);

=======

        if (a > b) swap(a, b);
        int64_t l = 0, r = 1e15;
        while (l < r) {
            int64_t m = (l + r) / 2;
            if (m / a + m / b - m / lcm(a, b) < n) l = m + 1;
            else r = m;
        }
        return l % (int)(1e9 + 7);
    }
    int64_t gcd(int64_t a, int64_t b) {
        return b == 0 ? a : gcd(b, a % b);

=======

        int MOD = 1000000007;
        int lcm = a * b / gcd(a, b);
        long lo = 0, hi = (long)1e15;
        while (lo < hi) {
            long mi = lo + (hi - lo) / 2;
            if (mi / a + mi / b - mi / lcm < n)
                lo = mi + 1;
            else
                hi = mi;
        }
        return lo % MOD;

=======

        int64_t mod = 1e9 + 7;
        int64_t l = 1, r = 1e15;
        int64_t ans = 0;
        while (l <= r) {
            int64_t m = l + (r - l) / 2;
            int64_t cnt = m / a + m / b - m / lcm(a, b);
            if (cnt >= n) {
                ans = m;
                r = m - 1;
            } else {
                l = m + 1;
            }
        }
        return ans % mod;
    }
    int64_t gcd(int64_t a, int64_t b) {
        if (b == 0) return a;
        return gcd(b, a % b);
    }
    int64_t lcm(int64_t a, int64_t b) {
        return a / gcd(a, b) * b;

=======

        // a * b = gcd(a, b) * lcm(a, b)
        int mod = 1e9 + 7;
        int gcd = __gcd(a, b);
        int lcm = a * b / gcd;
        int k = lcm / a + lcm / b - 1;
        int q = n / k;
        int r = n % k;
        int ans = q * lcm % mod;
        int c = 0;
        for (int i = 1; i <= r; ++i) {
            if (i % a == 0 && i % b == 0) {
                c = i;
                break;
            }
        }
        ans = (ans + c) % mod;
        return ans;

=======

        long long int l = 1, r = 1e15;
        long long int c = a * b / __gcd(a, b);
        while (l < r) {
            long long int m = l + (r - l) / 2;
            if (m / a + m / b - m / c < n) l = m + 1;
            else r = m;
        }
        return l % (int) (1e9 + 7);

=======

        int mod = 1000000007;
        int l = 2;
        int r = 1e9;
        int mid;
        while (l < r) {
            mid = l + (r - l) / 2;
            if (mid / a + mid / b - mid / lcm(a, b) < n) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        return l % mod;
    }
    
    int lcm(int a, int b) {
        return a * b / gcd(a, b);

=======

        int MOD = 1e9 + 7;
        long long lcm = a * (long long)b / __gcd(a, b);
        long long lo = 1, hi = 1e15, mid;
        while (lo < hi) {
            mid = (lo + hi) / 2;
            if (mid / a + mid / b - mid / lcm < n) lo = mid + 1;
            else hi = mid;
        }
        return lo % MOD;

=======

        int l = 0, r = 1e15;
        int mod = 1e9+7;
        long long ab = a * b / __gcd(a, b);
        while (l < r) {
            int m = l + (r - l) / 2;
            int cnt = m / a + m / b - m / ab;
            if (cnt < n) l = m + 1;
            else r = m;
        }
        return l % mod;
