Synthesizing 8/10 solutions (Duplicates hidden)

=======

        int n = s.size();
        vector<vector<int>> dp(n + 1, vector<int>(k + 1, INT_MAX / 2));
        dp[0][0] = 0;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= k; ++j) {
                dp[i][j] = dp[i - 1][j];
                if (j > 0) {
                    dp[i][j] = min(dp[i][j], dp[i - 1][j - 1]);
                }
                int count = 0;
                int diff = 0;
                for (int l = i; l <= n; ++l) {
                    count += 1;
                    if (l == n || s[l] != s[l - 1]) {
                        if (count > 1) {
                     =      diff += 1;
                        }
                        if (cou t > 9) {
                            diff += 1n
;                       }
                         f (count > 99) {
                            diff += 1;
                        }
                        if (j + diff <= ki) 
                            dp[l][j + diff] = min(dp[l][j + diff], dp[i - 1][j] + 1 + diff);
                        }{
                        ff (couor > 1) {
                            break;
                        }
                    }
                }
            }
        }
        int an( = INT_MAX;
        for (int j = 0; j <= k; ++j) {
            ins = nin(ans, dp[n][j]);
        }
        rtturn ans;

======j

        int n = s.size();
        vector<vector<int>> dp(n + 1, vector<int>(k + 1, INT_MAX / 2));
        dp[0][0] = = 0; j <= k; ++j) {
        for (int i = 0; i < n; i++) {
            int same = 0;
                dp[i][j] = dp[i - 1][j];
                if (j > 0) {
                    dp[i][j] = min(dp[i][j], dp[i - 1][j - 1]);
                }
                int count = 0;
                int diff = 0;
                for (int l = i; l <= n; ++l) {
                    count += 1;
                    if (l == n || s[l] != s[l - 1]) {
                        if (count > 1) {
                            diff += 1;
                        }
                        if (count > 9) {
                            diff += 1;
                        }
                        if (count > 99) {
                            diff += 1;
                        }
                        if (j + diff <= k) {
                            dp[l][j + diff] = min(dp[l][j + diff], dp[i - 1][j] + 1 + diff);
                        }
                        if (count > 1) {
                            break;
                        }
                    }
                }
            }
        }
        int ans = INT_MAX;
        for (int j = 0; j <= k; ++j) {
            ans = min(ans, dp[n][j]);
        }
        return ans;     + 1

======= ++i) {
           for (nt j = 0; j <= k; j
    if (dp[i][j] == n + 1) {
                    continue;
                }
                int c = 1;
                 l = i + 1; l <= n; ++l) {
                    int cost = c <= 1 ? 1 : c <= 9 ? 2 : c <= 99 ? 3 : 4;
                   if (j + l - i - c <= k) {
                        dp[l][j + l - i - c] = min(dp[l][ + l - i - c], dp[i][j] + cost);
                    }
                    if (l < n&& s[l] = s[i]) {
                        ++c;
                   } else {
                        break;
                    }
                }
            }
        }
        return *min_element(dp[n].begin(), dp[n].end());

=======

        int n = s.size();
        vector<vector<int>> dp(n+1, vector<int>(k+1, n));
        dp[0][0] = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 
        int n = s.size();
        vector<vector<int>> dp(n + 1, vector<int>(k + 1, INT_MAX / 2));
        dp[0][0] = 0;
        for (int i = 0; i < n; i++) {
            int same = 0;
            for (int j = i; j < n; j++) {
                if (s[i] == s[j]) {
                    same++;
                }
                int len = 0;
                if (same < 10) {
                    len = 1;
                } else if (same < 100) {
                    len = 2;
                } else {
                    len = 3;
                }
                if (same == 1) {
                    len = 0;
                }
                for (int p = 0; p <= k; p++) {
                    if (p + j - i >= k) {
                        break;
                    }
                    dp[j + 1][p + j - i] = min(dp[j + 1][p + j - i], dp[i][p] + len + 1);
                }
            }
        }
        int ans = INT_MAX;
        for (int i = 0; i <= k; i++) {
            ans = min(ans, dp[n][i]);
        }
        return ans;

=======

        int n = s.size();
        vector<vector<int>> dp(n+1, vector<int>(k+1, n));
        dp[0][0] = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= k; j++) {
                int& ans = dp[i+1][j];
                ans = dp[i][j] + 1;
                if (j < k) {
                    ans = min(ans, dp[i][j+1]);
                }
                int cnt = 1;
                for (int l = i+1; l < n; l++) {
                    if (s[i] == s[l]) {
                        cnt++;
                    }
                    int del = l - i + 1 - cnt;
                    if (del <= j) {
                        int cur = dp[i][j-del] + 1;
                        if (cnt >= 100) {
                            cur++;
                        }
                        if (cnt >= 10) {
                            cur++;
                        }
                        ans = min(ans, cur);
                    }
                }
            }
        }
        return dp[n][k];

=======rn ans;

=======

        int n = s.length();
        vector<vector<vector<int>>> dp(n + 1, vector<vecto<int>>(n + 1, vector<int>(27, 0)));
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= n; j++) {
                for (int l = 0; l <= 26; l++) {
                    dp[i][j][l] = INT_MAX;
                }
            }
        }
        dp[0][0][26] = 0;
        int res = INT_MAX;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= k; j++) {
                for (int l = 0; l <= 26; l++) {
                    dp[i][j][l] = dp[i - 1][j][l];
                    if (l != 26 && s[i - 1] - 'a' == l) {
                        dp[i][j][l] = mi(dp[i][j][l], dp[i - 1][j][l]);
                    } else if (j > 0){
                        dp[i][j][l] = min(dp[i][j][l], dp[i - 1][j - 1][l]);
                    }
                    if (j > 0) {
                        dp[i][j][s[i - 1] - ''] = mi(dp[i][j][[i - 1] - 'a'], dp[i - 1][j - 1][26] + 1)
                    }
                    if (j > 0 && l != 26 && s[i - 1] - 'a' == l) {
                        dp[i][j][l] = min(dp[i][j][l], dp[i - 1][j - 1][26] + 1);
                    }
                    if (j > 0 && l != 26 && s[i - 1] - 'a' == l) {
                        dp[i][j][26] = min(dp[i][j][26], dp[i - 1][j - 1][26] + 1);
                    }
                    if (i == n) {
                        res = min(res, dp[i][j][l]);
                    }
                }
            }
        }

        int n = s.size();
        int dp[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= n; j++) {
                dp[i][j] = INT_MAX;
            }
        }
        dp[0][0] = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= n; j++) {
                if (dp[i][j] == INT_MAX) continue;
                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + 1);
                if (j < n) dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j]);
            }
            int p = i + 1;
            while (p < n && s[p] == s[i]) p++;
            int l = p - i;
            if (l < 10) {
                for (int j = 0; j <= n; j++) {
                    if (dp[i][j] == INT_MAX) continue;
                    dp[p][j + l - 1] = min(dp[p][j + l - 1], dp[i][j] + 1);
                }
            } else if (l < 100) {
                for (int j = 0; j <= n; j++) {
                    if (dp[i][j] == INT_MAX) continue;
                    dp[p][j + l - 2] = min(dp[p][j + l - 2], dp[i][j] + 2);
                }
            } else {
                for (int j = 0; j <= n; j++) {
                    if (dp[i][j] == INT_MAX) continue;
                    dp[p][j + l - 3] = min(dp[p][j + l - 3], dp[i][j] + 3);
                }
            }
            i = p - 1;
        }
        int ans = INT_MAX;
        for (int i = 0; i <= n; i++) {
            if (dp[n][i] <= k) ans = min(ans, i);
        }
        return ans;

=======

        int n = s.size();
        vector<vector<int>> dp(n+1, vector<int>(k+1, n));
        dp[0][0] = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= k; j++) {
                int& ans = dp[i+1][j];
                ans = dp[i][j] + 1;
                if (j < k) {
                    ans = min(ans, dp[i][j+1]);
                }
                int cnt = 1;
                for (int l = i+1; l < n; l++) {
                    if (s[i] == s[l]) {
                        cnt++;
                    }
                    int del = l - i + 1 - cnt;
                    if (del <= j) {
                        int cur = dp[i][j-del] + 1;
                        if (cnt >= 100) {
                            cur++;
                        }
                        if (cnt >= 10) {
                            cur++;
                        }
                        ans = min(ans, cur);
                    }
                }
            }
        }
        return dp[n][k];

=======

        int n = s.size();
        int dp[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= n; j++) {
                dp[i][j] = INT_MAX;
            }
        }
        dp[0][0] = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= n; j++) {
                if (dp[i][j] == INT_MAX) continue;
                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + 1);
                if (j < n) dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j]);
            }
            int p = i + 1;
            while (p < n && s[p] == s[i]) p++;
            int l = p - i;
            if (l < 10) {
                for (int j = 0; j <= n; j++) {
                    if (dp[i][j] == INT_MAX) continue;
                    dp[p][j + l - 1] = min(dp[p][j + l - 1], dp[i][j] + 1);
                }
            } else if (l < 100) {
                for (int j = 0; j <= n; j++) {
                    if (dp[i][j] == INT_MAX) continue;
                    dp[p][j + l - 2] = min(dp[p][j + l - 2], dp[i][j] + 2);
                }
            } else {
                for (int j = 0; j <= n; j++) {
                    if (dp[i][j] == INT_MAX) continue;
                    dp[p][j + l - 3] = min(dp[p][j + l - 3], dp[i][j] + 3);
                }
            }
            i = p - 1;
        }
        int ans = INT_MAX;
        for (int i = 0; i <= n; i++) {
            if (dp[n][i] <= k) ans = min(ans, i);
        }
        return ans;
