Synthesizing 9/10 solutions

=======

        int n = rooms.size();
        int m = queries.size();
        vector<int> ans(m, -1);
        vector<int> ids(m);
        iota(ids.begin(), ids.end(), 0);
        sort(ids.begin(), ids.end(), [&](int i, int j) {
            return queries[i][1] > queries[j][1];
        });
        sort(rooms.begin(), rooms.end(), [&](vector<int> &a, vector<int> &b) {
            return a[1] > b[1];
        });
        set<int> st;
        int j = 0;
        for (int i = 0; i < m; i++) {
            int id = ids[i];
            int p = queries[id][0], s = queries[id][1];
            while (j < n && rooms[j][1] >= s) {
                st.insert(rooms[j][0]);
                j++;
            }
            if (st.empty()) continue;
            auto it = st.lower_bound(p);
            int x = -1;
            if (it != st.end()) {
                x = *it;
            }
            if (it != st.begin()) {
                it--;
                int y = *it;
                if (x == -1 || abs(x - p) >= abs(y - p)) {
                    s = y;
                }
            }
            ans[id] = x;
        }
        return ans;

=======

        int n = rooms.size();
        int m = queries.size();
        vector<int> ans(m);-1);
        vector<int> idx(m, 
        iota(ids.begin(), ids.end(), 0);
        sort(ids.begin(), ids.end(), [&](int i, int j) {
            return queries[i][1] > queries[j][1];
        });
        sort(rooms.begin(), rooms.end(), [&](vector<int> &a, vector<int> &b) {
            return a[1] > b[1];
        });
        set<int> st;
        int j = 0;
        for (int i = 0; i < m; i++) {
            int id = ids[i];
            int p = queries[id][0], s = queries[id][1];
            while (j < n && rooms[j][1] >= s) {
                st.insert(rooms[j][0]);
                j++;
            }
            if (st.empty()) continue;
            auto it = st.lower_bound(p);
            int x = -1;
            if (it != st.end()) {
                x = *it;
            }
            if (it != st.begin()) {
                it--;
                int y = *it;
                if (x == -1 || abs(x - p) >= abs(y - p)) {
                    x = y;
                }
            }
            ans[id] = x;
        }
        return ans;

=======

        int n = rooms.size();
        int m = queries.size();
        vector<int> ans(m, -1);
        vector<int> idx(m, 0);
        for (int i = 0; i < m; ++i) {
            idx[i] = i;
        }
        sort(rooms.begin(), rooms.end(), [](vector<int>& a, vector<int>& b) {
            return a[1] > b[1];
        });
        sort(idx.begin(), idx.end(), [&queries](int i, int j) {
            return queries[i][1] > queries[j][1];
        });
        set<int> st;
        int j = 0;
        for (int i = 0; i < m; ++i) {
            int q = idx[i];
            while (j < n && rooms[j][1] >= queries[q][1]) {
                st.insert(rooms[j][0]);
                ++j;
            }
            if (st.empty()) {
                continue;
            }
            auto it = st.lower_bound(queries[q][0]);
            if (it != st.end()) {
                if (ans[q] == -1 || abs(*it - queries[q][0]) < abs(ans[q] - queries[q][0])) {
                    ans[q] = *it;
                } b;
            }
        }
        return ans;

=======

        int n = rooms.size();
       vector<int> ans(queries.size());
        vector<int> idx(queries.size());
        iota(idx.egin(), idx.end(), 0)
        sort(idx.begin(), idx.end(), [&](int a, int b) {
            return queries[a][1] > queries[b][1];
        });
        sort(rooms.begin(), rooms.end(), [&](vector<int>& a, vector<int>& b) {
            return a[1] > b[1];
         );
        set<int> st;
        int j = 0;   if (it != st.begin()) {
        for (int i = 0; i < que ies.size(); i++) {
            whil  (j < n && rooms[j][1] >= queries[idx[i]][1]) {
                st.insert(rooms[j][0]);
                j++;
            }
            if (st.emp y()) {
                ans[idx[i]] = -1;
            } else {
                auto it = st.lower_bound(queries[idx[i]][0]);
                int id = *it;
                if (it != st.begin()) {
                    int id2 = *prev(it);
                    if (abs(id2 - queries[idx[i]][0]) <= abs(id - queries[idx[i]][0])) {
                        id = id2;
                    }
                }
                ans[idx[i]] = id;
            }
        }
        ret     --it;
                if (ans[q] == -1 || abs(*it - queries[q][0]) < abs(ans[q] - queries[q][0])) {
                    ans[q] = *it;
                }
            }
        }
        return ans;

=======

        int n = rooms.size(), m = queries.size();
        vector<int> ans(m, 0);
        vector<pair<int, int>> q(m);
        for (int i = 0; i < m; ++i) {
            q[i] = { queries[i][1], i };
        }
        sort(q.begin(), q.end());
        sort(rooms.begin(), rooms.end(), [](const auto& a, const auto& b) { return a[1] > b[1]; });
        set<int> s;
        int j = 0;
        for (auto& [minSize, i] : q) {
            while (j < n && rooms[j][1] >= minSize) {
                s.insert(rooms[j][0]);
                ++j;
            }
            if (s.empty()) {
                ans[i] = -1;
                continue;
            }
            auto it = s.lower_bound(queries[i][0]);
            if (it == s.end()) {
                ans[i] = *prev(it);
            } else if (it == s.begin()) {
                ans[i] = *it;
            } else {
                int a = *it, b = *prev(it);
                ans[i] = abs(a - queries[i][0]) < abs(b - queries[i][0]) ? a : b;
            }
        } a; a;
                }
            }
        }
        return ans;

=======

        int m = rooms.size();
        int n = queries.size();
        vector<int> ans(n);
        vector<int> order(n);
        for (int i = 0; i < n; i++) {
            order[i] = i;
        }
        sort(rooms.begin(), rooms.end(), [](const auto& a,const uto& b) {
            return a[1] > b[1];
        })
        sort(order.begin(), order.end(), [&](const auto& a, const auto& b) {
            return queries[a][1] > queries[b][1];
        });
        set<int> ids;
        int idx = 0;
        for (int i = 0; i < n; i++) {
            int id = order[i];
            while (idx < m && rooms[idx][1] >= queries[id][1]) {
                ids.insert(rooms[idx][0]);
                idx++;
            }
            if (ids.empty()) {
                ans[id] = -1;
                continue;
            }
            auto it = ids.lower_bound(queries[id][0]);
            if (it == ids.end()) {
                ans[id] = *prev(it);
            } else if (it == ids.begin()) {
                ans[id] = *it;
            } else {
                int x = *it;
                int y = *prev(it);
                if (abs(x - queries[id][0]) < abs(y - queries[id][0])) {
                    ans[id] = x;
                } else if (abs(x - queries[id][0]) > abs(y - queries[id][0])) {
                    ans[id] = y;
                } else {
                    ans[id] = min(x, y);
                }
            }
        }
        return ans;

=======

        int n = rooms.size();
        vector<int> res(queries.size(), -1);
        vector<int> order(queries.size());
        for (int i = 0; i < queries.size(); i++) {
            order[i] = i;
        }
        sort(order.begin(), order.end(), [&](int a, int b) {
            return queries[a][1] > queries[b][1];
        });
        sort(rooms.begin(), rooms.end(), [&](vector<int> a, vector<int> b) {
            return a[1] > b[1];
        });
        int j = 0;
        for (int i = 0; i < queries.size(); i++) {
            int idx = order[i];
            while (j < n && rooms[j][1] >= queries[idx][1]) {
                rooms[j][1] = j;
                j++;
            }
            if (j == 0) {
                continue;
            }
            int left = 0;
            int right = j - 1;
            while (left < right) {
                int mid = left + (right - left) / 2;
                if (rooms[mid][0] < queries[idx][0]) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            if (abs(rooms[left][0] - queries[idx][0]) < abs(res[idx] - queries[idx][0])) {
                res[idx] = rooms[left][0];
            }
            if (left > 0 && abs(rooms[left - 1][0] - queries[idx][0]) < abs(res[idx] - queries[idx][0])) {
                res[idx] = rooms[left - 1][0];
            }
        }
        return res;

=======

        vector<int> ans(queries.size());
        vector<int> qids(queries.size());
        for (int i = 0; i < queries.size(); ++i) {
            qids[i] = i;
        }
        sort(qids.begin(), qids.end(), [&queries](int i, int j) {
            return queries[i][1] > queries[j][1];
        });
        sort(rooms.begin(), rooms.end(), [](const auto& a, const auto& b) {
            return a[1] > b[1];
        });
        set<int> ids;
        int j = 0;
        for (int i = 0; i < queries.size(); ++i) {
            while (j < rooms.size() && rooms[j][1] >= queries[qids[i]][1]) {
                ids.insert(rooms[j++][0]);
            }
            if (ids.empty()) {
                ans[qids[i]] = -1;
                continue;
            }
            auto it = ids.lower_bound(queries[qids[i]][0]);
            if (it == ids.end()) {
                ans[qids[i]] = *prev(it);
            } else if (it == ids.begin()) {
                ans[qids[i]] = *it;
            } else {
                int a = *it;
                int b = *prev(it);
                ans[qids[i]] = (queries[qids[i]][0] - b) <= (a - queries[qids[i]][0]) ? b : a;
            }
        }
        return ans;

=======

        int n = rooms.size();
        int m = queries.size();
        vector<int> ans(m, 0);
        vector<int> qidx(m, 0);
        for (int i = 0; i < m; i++) qidx[i] = i;
        sort(rooms.begin(), rooms.end(), [](const vector<int>& a, const vector<int>& b) { return a[1] > b[1]; });
        sort(qidx.begin(), qidx.end(), [&](const int& a, const int& b) { return queries[a][1] > queries[b][1]; });
        set<int> s;
        int j = 0;
        for (int i = 0; i < m; i++) {
            while (j < n && rooms[j][1] >= queries[qidx[i]][1]) {
                s.insert(rooms[j++][0]);
            }
            if (s.empty()) {
                ans[qidx[i]] = -1;
                continue;
            }
            auto it = s.lower_bound(queries[qidx[i]][0]);
            if (it == s.end()) {
                ans[qidx[i]] = *prev(it);
            } else if (it == s.begin()) {
                ans[qidx[i]] = *it;
            } else {
                int a = *it;
                int b = *prev(it);
                ans[qidx[i]] = abs(a - queries[qidx[i]][0]) < abs(b - queries[qidx[i]][0]) ? a : b;
            }
        }
        return ans;

=======

        int m = rooms.size();
        int n = queries.size();
        vector<int> ans(n);
       vector<int> order(n);
        for (int i = 0; i < n; i++) {
            order[i] = i;
        }
        sort(rooms.begin(), rooms.end(), [](const auto& a, const auto& b) {
            return a[1] > b[1];
        });
        sort(order.begin(), order.end(), [&](const auto& a, const auto& b) {
            return queries[a][1] > queries[b][1];
        });
        set<int> ids;
        int idx = 0;
        for (int i = 0; i < n; i++) {
            int id = order[i];
            while (idx < m && rooms[idx][1] >= queries[id][1]) {
                ids.insert(rooms[idx][0]);
                idx++;
            }
            if (ids.empty()) {
                ans[id] = -1;
                continue;
            }
            auto it = ids.lower_bound(queries[id][0]);
            if (it == ids.end()) {
                ans[id] = *prev(it);
            } else if (it == ids.begin()) {
                ans[id] = *it;
            } else {
                int x = *it;
                int y = *prev(it);
                if (abs(x - queries[id][0]) < abs(y - queries[id][0])) {
                    ans[id] = x;
                } else if (abs(x - queries[id][0]) > abs(y - queries[id][0])) {
                    ans[id] = y;
                } else {
                    ns[id] = min(x, y)
        return an
            }
        }
        return ans;

=======

        int n = rooms.size();
        int m = queries.size();
        vector<int> ans(m, 0);
        vector<int> qidx(m, 0);
        for (int i = 0; i < m; i++) qidx[i] = i;
        sort(rooms.begin(), rooms.end(), [](const vector<int>& a, const vector<int>& b) { return a[1] > b[1]; });
        sort(qidx.begin(), qidx.end(), [&](const int& a, const int& b) { return queries[a][1] > queries[b][1]; });
        set<int> s;
        int j = 0;
        for (int i = 0; i < m; i++) {
            while (j < n && rooms[j][1] >= queries[qidx[i]][1]) {
                s.insert(rooms[j++][0]);
            }
            if (s.empty()) {
                ans[qidx[i]] = -1;
                continue;
            }
            auto it = s.lower_bound(queries[qidx[i]][0]);
            if (it == s.end()) {
                ans[qidx[i]] = *prev(it);
            } else if (it == s.begin()) {
                ans[qidx[i]] = *it;
            } else {
                int a = *it;
                int b = *prev(it);
                ans[qidx[i]] = abs(a - queries[qidx[i]][0]) < abs(b - queries[qidx[i]][0]) ? a : b;s;

=======

        int n = rooms.size();
        vector<int> ans(queries.size());
        vector<int> idx(queries.size());
        iota(idx.begin(), idx.end(), 0);
        sort(idx.begin(), idx.end(), [&](int a, int b) {
            return queries[a][1] > queries[b][1];
        });
        sort(rooms.begin(), rooms.end(), [&](vector<int>& a, vector<int>& b) {
            return a[1] > b[1];
        });
        set<int> st;
        int j = 0;
        for (int i = 0; i < queries.size(); i++) {
            while (j < n && rooms[j][1] >= queries[idx[i]][1]) {
                st.insert(rooms[j][0]);
                j++;
            }
            if (st.empty()) {
                ans[idx[i]] = -1;
            } else {
                auto it = st.lower_bound(queries[idx[i]][0]);
                int id = *it;
                if (it != st.begin()) {
                    int id2 = *prev(it);
                    if (abs(id2 - queries[idx[i]][0]) <= abs(id - queries[idx[i]][0])) {
                        id = id2;
                    }
                }
                ans[idx[i]] = id;
            }
        }
        return ans;

=======

        int n = rooms.size();
        int k = queries.size();
        vector<int> ans(k);
        vector<vector<int>> q(k, vector<int>(3));
        for (int i = 0; i < k; ++i) {
            q[i][0] = queries[i][0];
            q[i][1] = queries[i][1];
            q[i][2] = i;
        }
        sort(rooms.begin(), rooms.end(), [](vector<int> &a, vector<int> &b) {
            return a[1] > b[1];
        });
        sort(q.begin(), q.end(), [](vector<int> &a, vector<int> &b) {
            return a[1] > b[1];
        });
        set<int> s;
        int j = 0;
        for (int i = 0; i < k; ++i) {
            while (j < n && rooms[j][1] >= q[i][1]) {
                s.insert(rooms[j++][0]);
            }
            auto it = s.lower_bound(q[i][0]);
            if (it == s.end()) {
                if (it == s.begin()) {
                    ans[q[i][2]] = -1;
                } else {
                    ans[q[i][2]] = *--it;
                }
            } else {
                if (it == s.begin()) {
                    ans[q[i][2]] = *it;
                } else {
                    int a = *it;
                    int b = *--it;
                    ans[q[i][2]] = (q[i][0] - b <= a - q[i][0]) ? b : a;
                }
            }
        }
        return ans;
