Synthesizing 10/10 solutions (Duplicates hidden)

=======

        int n = grid.size();
        vector<vector<int>> dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
        vector<vector<bool>> visited(n, vector<bool>(n, false));
        vector<int> area;
        area.push_back(0);
        int res = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (!visited[i][j] && grid[i][j] == 1) {
                    int cnt = 0;
                    queue<pair<int, int>> q;
                    q.push({i, j});
                    visited[i][j] = true;
                    while (!q.empty()) {
                        auto [r, c] = q.front(); q.pop();
                        cnt++;
                        for (auto [dr, dc]: dir) {
                            int nr = r + dr, nc = c + dc;
                            if (nr < 0 || nr >= n || nc < 0 || nc >= n || visited[nr][nc] || grid[nr][nc] == 0) continue;
                            visited[nr][nc] = true;
                            q.push({nr, nc});
                        }
                    }
                    area.push_back(cnt);
                    res = max(res, cnt);
                }
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) {
                    int cnt = 1;
                    unordered_set<int> s;
                    for (auto [dr, dc]: dir) {
                        int nr = i + dr, nc = j + dc;
                        if (nr < 0 || nr >= n || nc < 0 || nc >= n || grid[nr][nc] == 0) continue;
                        if (s.find(grid[nr][nc]) == s.end()) {
                            cnt += area[grid[nr][nc]];
                            s.insert(grid[nr][nc]);
                        }
                    }
                    res = max(res, cnt);
                }
            }
        }
        return res;

=======

        int n = grid.size();
        vector<int> area(n*n+2, 0);
        int id = 2;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    area[id] = dfs(grid, i, j, id);
                    id++;
                }
            }
        }
        int res = *max_element(area.begin(), area.end());
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) {
                    int cur = 1;
                    unordered_set<int> seen;
                    for (auto d : dirs) {
                        int x = i + d[0];
                        int y = j + d[1];
                        if (x < 0 || x >= n || y < 0 || y >= n || grid[x][y] == 0) continue;
                        int idx = grid[x][y];
                        if (seen.count(idx)) continue;
                        seen.insert(idx);
                        cur += area[idx];
                    }
                    res = max(res, cur);
                }
            }
        }
        return res;

=======

        int N = grid.size();
        int id = 2;
        unordered_map<int, int> area;
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                if(grid[i][j] == 1) {
                    area[id] = dfs(grid, i, j, id);
                    id++;
                }
            }
        }
        int ans = area[2];
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                if(grid[i][j] == 0) {
                    unordered_set<int> seen;
                    int cur = 1;
                    for(int k = 0; k < 4; k++) {
                        int x = i + dirs[k][0];
                        int y = j + dirs[k][1];
                        if(x < 0 || x >= N || y < 0 || y >= N || grid[x][y] == 0) continue;
                        int idx = grid[x][y];
                        if(seen.count(idx)) continue;
                        seen.insert(idx);
                        cur += area[idx];
                    }
                    ans = max(ans, cur);
                }
            }
        }
        return ans;

=======

        int n = grid.size();
        vector<int> sizes(n * n + 2, 0);
        vector<vector<int>> dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        int color = 2;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] != 1) continue;
                int size = 0;
                queue<pair<int, int>> q;
                q.push({i, j});
                grid[i][j] = color;
                while (!q.empty()) {
                    auto [x, y] = q.front(); q.pop();
                    size++;
                    for (auto& dir : dirs) {
                        int nx = x + dir[0], ny = y + dir[1];
                        if (nx < 0 || nx >= n || ny < 0 || ny >= n || grid[nx][ny] != 1) continue;
                        grid[nx][ny] = color;
                        q.push({nx, ny});
                    }
                }
                sizes[color] = size;
                color++;
            }
        }
        int res = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] != 0) continue;
                unordered_set<int> seen;
                int size = 1;
                for (auto& dir : dirs) {
                    int x = i + dir[0], y = j + dir[1];
                    if (x < 0 || x >= n || y < 0 || y >= n || seen.count(grid[x][y]) || grid[x][y] == 0) continue;
                    seen.insert(grid[x][y]);
                    size += sizes[grid[x][y]];
                }
                res = max(res, size);
            }
        }
        return res == 0 ? n * n : res;

=======

        int n = grid.size();
        vector<int> parent(n * n, -1);
        vector<int> size(n * n, 0);
        int maxSize = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == 1) {
                    int id = i * n + j;
                    parent[id] = id;
                    size[id] = 1;
                    if (i > 0 && grid[i - 1][j] == 1) {
                        unionSet(id, (i - 1) * n + j, parent, size);
                    }
                    if (j > 0 && grid[i][j - 1] == 1) {
                        unionSet(id, i * n + j - 1, parent, size);
                    }
                    maxSize = max(maxSize, size[find(id, parent)]);
                }
            }
        }
        int res = maxSize;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == 0) {
                    int id = i * n + j;
                    set<int> s;
                    if (i > 0 && grid[i - 1][j] == 1) {
                        s.insert(find((i - 1) * n + j, parent));
                    }
                    if (i < n - 1 && grid[i + 1][j] == 1) {
                        s.insert(find((i + 1) * n + j, parent));
                    }
                    if (j > 0 && grid[i][j - 1] == 1) {
                        s.insert(find(i * n + j - 1, parent));
                    }
                    if (j < n - 1 && grid[i][j + 1] == 1) {
                        s.insert(find(i * n + j + 1, parent));
                    }
                    int newSize = 1;
                    for (auto it = s.begin(); it != s.end(); ++it) {
                        newSize += size[*it];
                    }
                    res = max(res, newSize);
                }
            }
        }
        return res;

=======

        int n = grid.size();
        int m = grid[0].size();
        vector<vector<int>> visited(n, vector<int>(m, 0));
        vector<int> islandSize;
        islandSize.push_back(0);
        int islandCount = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (grid[i][j] == 1 && visited[i][j] == 0) {
                    ++islandCount;
                    int size = 0;
                    dfs(grid, visited, i, j, size);
                    islandSize.push_back(size);
                }
            }
        }
        int maxArea = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (grid[i][j] == 0) {
                    int area = 1;
                    unordered_set<int> adjIsland;
                    if (i > 0 && grid[i-1][j] == 1) {
                        adjIsland.insert(visited[i-1][j]);
                    }
                    if (j > 0 && grid[i][j-1] == 1) {
                        adjIsland.insert(visited[i][j-1]);
                    }
                    if (i < n-1 && grid[i+1][j] == 1) {
                        adjIsland.insert(visited[i+1][j]);
                    }
                    if (j < m-1 && grid[i][j+1] == 1) {
                        adjIsland.insert(visited[i][j+1]);
                    }
                    for (auto island : adjIsland) {
                        area += islandSize[island];
                    }
                    maxArea = max(maxArea, area);
                }
            }
        }
        if (maxArea == 0) {
            return n * m;
        } else {
            return maxArea;
        }

=======

        int n = grid.size();
        vector<int> parent(n * n, -1);
        vector<int> sz(n * n, 0);
        vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        int ans = 0;
        auto find = [&](int x) {
            if (parent[x] == -1) return x;
            return parent[x] = find(parent[x]);
        };
        auto unionSet = [&](int x, int y) {
            int px = find(x);
            int py = find(y);
            if (px == py) return;
            if (sz[px] > sz[py]) swap(px, py);
            parent[px] = py;
            sz[py] += sz[px];
        };
        auto getRoot = [&](int x) {
            while (parent[x] != -1) x = parent[x];
            return x;
        };
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (!grid[i][j]) continue;
                int id = i * n + j;
                sz[id] = 1;
                for (auto& dir : dirs) {
                    int ni = i + dir[0];
                    int nj = j + dir[1];
                    if (ni < 0 || ni >= n || nj < 0 || nj >= n || !grid[ni][nj]) continue;
                    unionSet(id, ni * n + nj);
                }
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j]) continue;
                int id = i * n + j;
                unordered_set<int> roots;
                for (auto& dir : dirs) {
                    int ni = i + dir[0];
                    int nj = j + dir[1];
                    if (ni < 0 || ni >= n || nj < 0 || nj >= n || !grid[ni][nj]) continue;
                    roots.insert(getRoot(ni * n + nj));
                }
                int cur = 1;
                for (auto& r : roots) cur += sz[r];

=======

        int n = grid.size();
        vector<vector<int>> id(n, vector<int>(n, -1));
        vector<int> area;
        int cur = 0;
        int ans = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1 && id[i][j] == -1) {
                    area.push_back(0);
                    dfs(grid, id, i, j, cur, area);
                    ans = max(ans, area[cur]);
                    cur++;
                }
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) {
                    int cur = 1;
                    set<int> seen;
                    for (int k = 0; k < 4; k++) {
                        int ni = i + dx[k];
                        int nj = j + dy[k];
                        if (ni >= 0 && ni < n && nj >= 0 && nj < n && grid[ni][nj] == 1) {
                            if (seen.find(id[ni][nj]) == seen.end()) {
                                seen.insert(id[ni][nj]);
                                cur += area[id[ni][nj]];
                            }
                        }
                    }
                    ans = max(ans, cur);
                }
            }
        }
        return ans;

=======

        int n = grid.size();
        vector<int> id(n*n);
        vector<int> area(n*n);
        int curId = 2;
        int ans = 0;
        int dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    grid[i][j] = curId;
                    int curArea = 1;
                    queue<pair<int, int>> q;
                    q.push({i, j});
                    while (!q.empty()) {
                        auto [x, y] = q.front();
                        q.pop();
                        for (auto& dir : dirs) {
                            int nx = x + dir[0];
                            int ny = y + dir[1];
                            if (nx < 0 || nx >= n || ny < 0 || ny >= n) {
                                continue;
                            }
                            if (grid[nx][ny] == 1) {
                                grid[nx][ny] = curId;
                                q.push({nx, ny});
                                curArea++;
                            }
                        }
                    }
                    ans = max(ans, curArea);
                    area[curId] = curArea;
                    curId++;
                }
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) {
                    unordered_set<int> ids;
                    for (auto& dir : dirs) {
                        int nx = i + dir[0];
                        int ny = j + dir[1];
                        if (nx < 0 || nx >= n || ny < 0 || ny >= n) {
                            continue;
                        }
                        ids.insert(grid[nx][ny]);
                    }
                    int curArea = 1;
                    for (auto& id : ids) {
                        curArea += area[id];
                    }
                    ans = max(ans, curArea);
                }
            }
        }
        return ans;
