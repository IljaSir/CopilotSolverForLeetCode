Synthesizing 10/10 solutions

=======

        int n = coins.size();
        vector<vector<int>> adj(n);
        for (auto& e : edges) {
            adj[e[0]].push_back(e[1]);
            adj[e[1]].push_back(e[0]);
        }
        vector<int> cost(n, 0);
        vector<int> visited(n, 0);
        dfs(0, adj, coins, cost, visited);
        return cost[0];
    }
    void dfs(int u, vector<vector<int>>& adj, vector<int>& coins, vector<int>& cost, vector<int>& visited) {
        visited[u] = 1;
        for (int v : adj[u]) {
            if (visited[v]) continue;
            dfs(v, adj, coins, cost, visited);
            cost[u] += cost[v] + coins[v];
        }

=======

        int n = coins.size();
        vector<vector<int>> adj(n);
        for (auto& e: edges) {
            adj[e[0]].push_back(e[1]);
            adj[e[1]].push_back(e[0]);
        }
        vector<int> dp(n);
        dfs(0, -1, coins, adj, dp);
        return dp[0];
    }
    void dfs(int u, int p, vector<int>& coins, vector<vector<int>>& adj, vector<int>& dp) {
        dp[u] = coins[u];
        for (int v : adj[u]) {
            if (v == p) continue;
            dfs(v, u, coins, adj, dp);
            dp[u] += min(dp[v], 2);
        }

=======

        int n = coins.size();
        vector<vector<int>> graph(n);
        for (auto& edge : edges) {
            graph[edge[0]].push_back(edge[1]);
            graph[edge[1]].push_back(edge[0]);
        }
        vector<int> dp(n, 0);
        dfs(graph, coins, dp, 0, -1);
        return dp[0];
    }
    
    void dfs(vector<vector<int>>& graph, vector<int>& coins, vector<int>& dp, int u, int parent) {
        dp[u] = coins[u];
        for (int v : graph[u]) {
            if (v != parent) {
                dfs(graph, coins, dp, v, u);
                dp[u] += dp[v];
            }
        }
        if (dp[u] == 0) {
            dp[u] = -1;
        } else if (dp[u] == 1) {
            dp[u] = 1;
        } else {
            dp[u] = 2;
        }

=======

        int n = coins.size();
        vector<vector<int>> tree(n);
        for (auto& e : edges) {
            tree[e[0]].push_back(e[1]);
            tree[e[1]].push_back(e[0]);
        }
        vector<int> dp(n);
        function<void(int, int)> dfs = [&](int u, int p) {
            dp[u] = coins[u];
            for (auto v : tree[u]) {
                if (v == p) continue;
                dfs(v, u);
                dp[u] += dp[v];
            }
        };
        dfs(0, -1);
        int res = 0;
        for (int i = 0; i < n; ++i) {
            if (dp[i] == 0) continue;
            res += 2;
            for (auto j : tree[i]) {
                if (dp[j] > 0) {
                    res -= 2;
                    break;
                }
            }
        }
        return res;

=======

        int n = coins.size();
        vector<vector<int>> graph(n);
        for (auto &e : edges) {
            graph[e[0]].push_back(e[1]);
            graph[e[1]].push_back(e[0]);
        }
        vector<int> dp(n);
        vector<vector<int>> dp1(n);
        for (auto &d : dp1) d.resize(n);
        vector<vector<int>> dp2(n);
        for (auto &d : dp2) d.resize(n);
        function<void(int, int)> dfs = [&](int u, int p) {
            for (auto v : graph[u]) {
                if (v == p) continue;
                dfs(v, u);
            }
            dp[u] = coins[u];
            for (auto v : graph[u]) {
                if (v == p) continue;
                dp[u] += dp[v];
            }
            for (auto v : graph[u]) {
                if (v == p) continue;
                dp1[u][v] = dp[v];
            }
            for (auto v : graph[u]) {
                if (v == p) continue;
                for (auto w : graph[u]) {
                    if (w == p || w == v) continue;
                    dp1[u][v] = max(dp1[u][v], dp1[u][w] + dp[v]);
                }
            }
            for (auto v : graph[u]) {
                if (v == p) continue;
                dp2[u][v] = dp[u] - dp[v];
            }
            for (auto v : graph[u]) {
                if (v == p) continue;
                for (auto w : graph[u]) {
                    if (w == p || w == v) continue;
                    dp2[u][v] = max(dp2[u][v], dp2[u][w] + dp[v]);
                }
            }
        };
        dfs(0, -1);
        int ans = 0;
        for (auto v : graph[0]) {
            ans = max(ans, dp1[0][v] + dp2[0][v]);
        }
        return dp[0] - ans;

=======

        int n = coins.size();
        vector<vector<int>> tree(n);
        for (auto edge: edges) {
            tree[edge[0]].push_back(edge[1]);
            tree[edge[1]].push_back(edge[0]);
        }
        vector<int> dp(n, 0);
        dfs(tree, dp, 0, -1);
        return dp[0];
    }
    void dfs(vector<vector<int>>& tree, vector<int>& dp, int root, int parent) {
        dp[root] = coins[root];
        for (auto child: tree[root]) {
            if (child == parent) continue;
            dfs(tree, dp, child, root);
            dp[root] += dp[child];
        }
        dp[root] -= 1;

=======

        vector<vector<int>> tree(coins.size());
        for (auto& e : edges) {
            tree[e[0]].push_back(e[1]);
            tree[e[1]].push_back(e[0]);
        }
        vector<int> dp(coins.size(), 0);
        int res = 0;
        dfs(tree, coins, dp, 0, -1, res);
        return res;

=======

        vector<vector<int>> adjList(coins.size());
        for (auto edge : edges) {
            adjList[edge[0]].push_back(edge[1]);
            adjList[edge[1]].push_back(edge[0]);
        }
        int res = 0;
        vector<int> dp(coins.size(), 0);
        function<void(int, int)> dfs = [&](int node, int parent) {
            for (auto adj : adjList[node]) {
                if (adj == parent) continue;
                dfs(adj, node);
                dp[node] += dp[adj];
            }
            dp[node] += coins[node];
            res += abs(dp[node]);
        };
        dfs(0, -1);
        return res;

=======

        vector<vector<int>> G(coins.size());
        for (auto& e: edges) {
            G[e[0]].push_back(e[1]);
            G[e[1]].push_back(e[0]);
        }
        vector<int> dp(coins.size());
        function<void(int, int)> dfs = [&](int u, int p) {
            for (auto v: G[u]) {
                if (v == p) continue;
                dfs(v, u);
                dp[u] += dp[v];
            }
            dp[u] += coins[u];
        };
        dfs(0, -1);
        int ans = 0;
        for (int i = 0; i < coins.size(); ++i) {
            if (dp[i] == 0) continue;
            ans += 2 * (dp[i] - 1);
            if (i == 0) {
                ans += 2;
            } else {
                ans += 1;
            }
        }
        return ans;

=======

        int n = coins.size();
        vector<int> g[n];
        for(auto e : edges){
            g[e[0]].push_back(e[1]);
            g[e[1]].push_back(e[0]);
        }
        vector<int> dp(n, 0);
        vector<int> visited(n, 0);
        dfs(0, g, coins, dp, visited);
        return dp[0];
    }
    void dfs(int v, vector<int> g[], vector<int>& coins, vector<int>& dp, vector<int>& visited){
        visited[v] = 1;
        for(auto u : g[v]){
            if(!visited[u]){
                dfs(u, g, coins, dp, visited);
                dp[v] += dp[u] + coins[u];
            }
        }
