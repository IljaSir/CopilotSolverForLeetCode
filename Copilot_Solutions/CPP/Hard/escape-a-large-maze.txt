Synthesizing 6/10 solutions (Duplicates hidden)

=======

        unordered_set<int> block;
        for (auto& b : blocked) {
            block.insert(b[0] * 1000000 + b[1]);
        }
        return bfs(block, source, target) && bfs(block, target, source);
    }
    bool bfs(unordered_set<int>& block, vector<int>& source, vector<int>& target) {
        int sx = source[0], sy = source[1], tx = target[0], ty = target[1];
        queue<vector<int>> q;
        q.push({sx, sy});
        unordered_set<int> visited;
        visited.insert(sx * 1000000 + sy);
        int directions[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        while (!q.empty()) {
            int x = q.front()[0], y = q.front()[1];
            q.pop();
            if (x == tx && y == ty) return true;
            if (visited.size() >= 20000) return true;
            for (int i = 0; i < 4; i++) {
                int nx = x + directions[i][0], ny = y + directions[i][1];
                int key = nx * 1000000 + ny;
                if (nx < 0 || nx >= 1000000 || ny < 0 || ny >= 1000000 || block.count(key) || visited.count(key)) continue;
                q.push({nx, ny});
                visited.insert(key);
            }
        }
        return false;

=======

        unordered_set<int> blockedSet;
        for (auto& b : blocked) {
            blockedSet.insert(b[0] * 1000000 + b[1]);
        }
        return bfs(blockedSet, source, target) && bfs(blockedSet, target, source);
    }
    
    bool bfs(unordered_set<int>& blockedSet, vector<int>& source, vector<int>& target) {
        int dir[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        queue<pair<int, int>> q;
        unordered_set<int> visited;
        q.push({source[0], source[1]});
        visited.insert(source[0] * 1000000 + source[1]);
        while (!q.empty()) {
            int size = q.size();
            for (int i = 0; i < size; i++) {
                auto cur = q.front();
                q.pop();
                if (cur.first == target[0] && cur.second == target[1]) return true;
                for (int j = 0; j < 4; j++) {
                    int x = cur.first + dir[j][0];
                    int y = cur.second + dir[j][1];
                    int key = x * 1000000 + y;
                    if (x < 0 || x >= 1000000 || y < 0 || y >= 1000000 || blockedSet.count(key) || visited.count(key)) continue;
                    visited.insert(key);
                    q.push({x, y});
                }
            }
            if (visited.size() >= 20000) return true;
        }
        return false;

=======

        unordered_set<int> block;
        for (auto& b: blocked) {
            block.insert(b[0] * 1000000 + b[1]);
        }
        return bfs(block, source, target) && bfs(block, target, source);
    }
    
    bool bfs(unordered_set<int>& block, vector<int>& source, vector<int>& target) {
        queue<vector<int>> q;
        q.push(source);
        unordered_set<int> visited;
        visited.insert(source[0] * 1000000 + source[1]);
        int cnt = 0;
        while (!q.empty()) {
            auto cur = q.front();
            q.pop();
            ++cnt;
            if (cur[0] == target[0] && cur[1] == target[1]) return true;
            if (cnt >= 20000) return true;
            for (auto& d: dirs) {
                int nx = cur[0] + d[0], ny = cur[1] + d[1];
                if (nx < 0 || nx >= 1000000 || ny < 0 || ny >= 1000000 || block.count(nx * 1000000 + ny) || visited.count(nx * 1000000 + ny)) continue;
                visited.insert(nx * 1000000 + ny);
                q.push({nx, ny});
            }
        }
        return false;

=======

        unordered_set<int> block;
        for (auto& p : blocked) {
            block.insert(p[0] * 1000000 + p[1]);
        }
        return bfs(block, source, target) && bfs(block, target, source);
    }
    
    bool bfs(unordered_set<int>& block, vector<int>& source, vector<int>& target) {
        int m = 1000000;
        queue<vector<int>> q;
        q.push(source);
        unordered_set<int> visited;
        visited.insert(source[0] * m + source[1]);
        int cnt = 0;
        while (!q.empty()) {
            vector<int> p = q.front(); q.pop();
            cnt++;
            if (cnt > 20000) return true;
            if (p[0] == target[0] && p[1] == target[1]) return true;
            int dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
            for (int i = 0; i < 4; i++) {
                int x = p[0] + dirs[i][0];
                int y = p[1] + dirs[i][1];
                if (x < 0 || x >= m || y < 0 || y >= m) continue;
                if (visited.count(x * m + y)) continue;
                if (block.count(x * m + y)) continue;
                visited.insert(x * m + y);
                q.push({x, y});
            }
        }
        return false;
