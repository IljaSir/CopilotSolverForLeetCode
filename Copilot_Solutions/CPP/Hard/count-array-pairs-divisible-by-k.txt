Synthesizing 10/10 solutions

=======

        long long ans = 0;
        unordered_map<int, int> m;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] % k == 0) {
                ans += m[0];
            }
            ans += m[k - nums[i] % k];
            m[nums[i] % k]++;
        }
        return ans;

=======

        unordered_map<int, long long> m;
        long long ans = 0;
        for (int i = 0; i < nums.size(); i++) {
            ans += m[(k - nums[i] % k) % k];
            m[nums[i] % k]++;
        }
        return ans;

=======

        int n = nums.size();
        long long ans = 0;
        unordered_map<int, int> cnt;
        for (int x : nums) {
            int y = x % k;
            if (y < 0) y += k;
            int z = (k - y) % k;
            ans += cnt[z];
            cnt[y]++;
        }
        return ans;

=======

        unordered_map<int, int> m;
        long long res = 0;
        for (int num : nums) {
            res += m[k - num % k] % 1000000007;
            m[num % k]++;
        }
        return res % 1000000007;

=======

        long long ans = 0;
        unordered_map<int, int> mp;
        for (int x : nums) {
            int y = x % k;
            if (y < 0) y += k;
            ans += mp[(k - y) % k];
            mp[y]++;
        }
        return ans;

=======

        map<int, int> m;
        for (auto n : nums) {
            m[n]++;
        }
        long long res = 0;
        for (auto it = m.begin(); it != m.end(); ++it) {
            if (k == 1) {
                res += (long long)it->second * (it->second - 1) / 2;
            } else {
                auto it2 = m.find(k - it->first);
                if (it2 != m.end()) {
                    res += (long long)it->second * it2->second;
                }
            }
        }
        return res;

=======

        unordered_map<int, int> mp;
        long long ans = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (k == 1) {
                if (mp.find(nums[i]) != mp.end())
                    ans += mp[nums[i]];
            } else {
                if (mp.find(k - nums[i] % k) != mp.end())
                    ans += mp[k - nums[i] % k];
            }
            mp[nums[i] % k]++;
        }
        return ans;

=======

        int n = nums.size();
        vector<int> cnt(k);
        long long res = 0;
        for (auto x : nums) {
            int y = x % k;
            if (y == 0) {
                res += cnt[0];
            } else {
                res += cnt[k - y];
            }
            cnt[y]++;
        }
        return res;

=======

        long long res = 0;
        unordered_map<int, int> mp;
        for (int num : nums) {
            int mod = num % k;
            if (mod < 0) mod += k;
            int t = (k - mod) % k;
            if (mp.count(t)) res += mp[t];
            ++mp[mod];
        }
        return res;

=======

        long long ans = 0;
        unordered_map<int, int> m;
        for (const auto& num : nums) {
            int r = num % k;
            int t = (k - r) % k;
            ans += m[t];
            m[r]++;
        }
        return ans;
