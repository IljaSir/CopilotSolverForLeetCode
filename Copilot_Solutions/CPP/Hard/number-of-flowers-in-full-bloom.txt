Synthesizing 8/10 solutions (Duplicates hidden)

=======

        vector<int> ans(people.size(), 0);
        sort(flowers.begin(), flowers.end(), [](vector<int>& a, vector<int>& b) {return a[1] < b[1];});
        sort(people.begin(), people.end());
        int i = 0, j = 0;
        while (i < people.size() && j < flowers.size()) {
            if (people[i] <= flowers[j][1]) {
                int count = 0;
                for (int k = j; k >= 0 && flowers[k][1] >= people[i]; k--) {
                    if (flowers[k][0] <= people[i]) {
                        count++;
                    }
                }
                ans[i] = count;
                i++;
            } else {
                j++;
            }
        }
        return ans;

=======

        vector<int> res;
        int n = people.size();
        int m = flowers.size();
        sort(flowers.begin(), flowers.end(), [](auto& a, auto& b) {
            return a[0] < b[0];
        });
        for (int i = 0; i < n; ++i) {
            int cnt = 0;
            for (int j = 0; j < m; ++j) {
                if (people[i] > flowers[j][1]) continue;
                if (people[i] >= flowers[j][0]) ++cnt;
            }
            res.push_back(cnt);
        }
        return res;

=======

        int n = flowers.size();
        int m = people.size();
        vector<int> ans(m, 0);
        vector<vector<int>> f(n, vector<int>(2, 0));
        for (int i = 0; i < n; ++i) {
            f[i][0] = flowers[i][0];
            f[i][1] = flowers[i][1];
        }
        sort(f.begin(), f.end(), [](vector<int>& a, vector<int>& b) {
            if (a[0] == b[0]) return a[1] < b[1];
            return a[0] < b[0];
        });
        int idx = 0;
        int maxRight = 0;
        for (int i = 0; i < m; ++i) {
            while (idx < n && f[idx][0] <= people[i]) {
                maxRight = max(maxRight, f[idx][1]);
                ++idx;
            }
            ans[i] = idx;
            if (people[i] <= maxRight) --ans[i];
        }
        return ans;

=======

        vector<int> res;
        int n = flowers.size();
        int m = people.size();
        int i = 0, j = 0;
        int cnt = 0;
        sort(flowers.begin(), flowers.end());
        sort(people.begin(), people.end());
        while (i < n && j < m) {
            if (people[j] < flowers[i][0]) {
                res.push_back(cnt);
                j++;
            } else if (people[j] <= flowers[i][1]) {
                cnt++;
                j++;
            } else {
                i++;
                cnt--;
            }
        }
        while (j < m) {
            res.push_back(cnt);
            j++;
        }
        return res;

=======

        vector<int> answer;
        int n = flowers.size();
        int m = people.size();
        int i = 0;
        int j = 0;
        while (i < m && j < n) {
            if (people[i] >= flowers[j][0] && people[i] <= flowers[j][1]) {
                answer.push_back(1);
                i++;
            } else if (people[i] > flowers[j][1]) {
                j++;
            } else {
                answer.push_back(0);
                i++;
            }
        }
        while (i < m) {
            answer.push_back(0);
            i++;
        }
        return answer;

=======

        vector<int> result;
        int flowerCount = flowers.size();
        for (auto person : people) {
            int count = 0;
            for (int i = 0; i < flowerCount; i++) {
                if (person >= flowers[i][0] && person <= flowers[i][1]) {
                    count++;
                }
            }
            result.push_back(count);
        }
        return result;

=======

        int n = flowers.size();
        int m = people.size();
        vector<int> res(m, 0);
        int f = 0;
        int p = 0;
        set<vector<int>> s;
        while (p < m) {
            while (f < n && flowers[f][0] <= people[p]) {
                s.insert({flowers[f][1], f});
                ++f;
            }
            while (!s.empty() && s.begin()->at(0) <= people[p]) {
                ++res[p];
                s.erase(s.begin());
            }
            ++p;
        }
        return res;
