Synthesizing 10/10 solutions

=======

        int n = nums.size();
        vector<int> ones;
        for (int i = 0; i < n; i++) {
            if (nums[i] == 1) {
                ones.push_back(i);
            }
        }
        int m = ones.size();
        vector<int> prefix_sum(m+1, 0);
        for (int i = 1; i <= m; i++) {
            prefix_sum[i] = prefix_sum[i-1] + ones[i-1];
        }
        int ans = INT_MAX;
        for (int i = 0; i + k - 1 < m; i++) {
            int mid = i + k / 2;
            int left = ones[mid] * k - (prefix_sum[mid+1] - prefix_sum[i]);
            int right = (prefix_sum[i+k] - prefix_sum[mid+1]) - ones[mid] * k;
            ans = min(ans, left + right);
        }
        return ans;

=======

        int n = nums.size();
        vector<int> ones;
        for (int i = 0; i < n; ++i) {
            if (nums[i] == 1) {
                ones.push_back(i);
            }
        }
        int m = ones.size();
        vector<int> presum(m + 1, 0);
        for (int i = 1; i <= m; ++i) {
            presum[i] = presum[i - 1] + ones[i - 1];
        }
        int ans = INT_MAX;
        for (int i = 0; i <= m - k; ++i) {
            int j = i + k - 1;
            int mid = (i + j) / 2;
            int cur = presum[mid + 1] - presum[i] - (presum[j + 1] - presum[mid + 1]) + (mid - i + 1) * ones[mid] - (j - mid) * ones[mid];
            ans = min(ans, cur);
        }
        return ans;

=======

        int n = nums.size();
        vector<int> ones;
        for (int i = 0; i < n; ++i) {
            if (nums[i]) {
                ones.push_back(i);
            }
        }
        int m = ones.size();
        int ans = INT_MAX;
        int sum = 0;
        for (int i = 0; i < k; ++i) {
            sum += ones[i];
        }
        ans = sum - ones[k / 2] * (k - k / 2);
        for (int i = k; i < m; ++i) {
            sum += ones[i] - ones[i - k];
            ans = min(ans, sum - ones[i - k / 2] * (k - k / 2));
        }
        return ans;

=======

        vector<int> ones;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 1) {
                ones.push_back(i);
            }
        }
        int res = INT_MAX;
        int n = ones.size();
        int mid = n / 2;
        for (int i = 0; i < n - k + 1; i++) {
            int j = i + k - 1;
            int left = ones[i + mid - i];
            int right = ones[j - mid + j];
            res = min(res, (right - left) - (j - i) + (mid - i));
        }
        return res;

=======

        int n = nums.size();
        vector<int> pos;
        for (int i = 0; i < n; ++i) {
            if (nums[i] == 1) pos.push_back(i);
        }
        vector<int> prefix = {0};
        for (int i = 0; i < pos.size(); ++i) {
            prefix.push_back(prefix.back() + pos[i]);
        }
        int res = 0x3f3f3f3f;
        for (int i = 0; i + k - 1 < pos.size(); ++i) {
            int mid = (i + i + k - 1) / 2;
            int cur = (pos[mid] * (mid - i) - (prefix[mid] - prefix[i])) + (prefix[i + k] - prefix[mid + 1] - pos[mid] * (i + k - mid - 1));
            res = min(res, cur);
        }
        return res;

=======

        vector<int> ones;
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] == 1) ones.push_back(i);
        }
        int res = INT_MAX;
        int n = ones.size();
        int l = 0, r = k - 1;
        int sum = 0;
        for (int i = l; i <= r; ++i) {
            sum += ones[i];
        }
        int mid = (k - 1) / 2;
        int median = ones[mid];
        res = min(res, sum - median * (k - 1 - mid) - median * mid);
        while (r < n - 1) {
            sum += ones[++r] - ones[++l - 1];
            median = ones[l + mid];
            res = min(res, sum - median * (k - 1 - mid) - median * mid);
        }
        return res;

=======

        vector<int> onePos;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 1) {
                onePos.push_back(i);
            }
        }
        int n = onePos.size();
        vector<int> onePosSum(n + 1);
        for (int i = 1; i <= n; i++) {
            onePosSum[i] = onePosSum[i - 1] + onePos[i - 1];
        }
        int res = INT_MAX;
        for (int i = 0; i < n - k + 1; i++) {
            int j = i + k - 1;
            int mid = i + (j - i) / 2;
            int leftSum = onePosSum[mid + 1] - onePosSum[i];
            int rightSum = onePosSum[j + 1] - onePosSum[mid + 1];
            res = min(res, (mid - i + 1) * onePos[mid] - leftSum + rightSum - (j - mid) * onePos[mid]);
        }
        return res;

=======

        vector<int> onePos;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 1) {
                onePos.push_back(i);
            }
        }
        int ans = INT_MAX;
        for (int i = 0; i < onePos.size() - k + 1; i++) {
            int mid = onePos[i + k / 2];
            int cost = 0;
            for (int j = i; j < i + k; j++) {
                cost += abs(onePos[j] - mid) - abs(j - i - k / 2);
            }
            ans = min(ans, cost);
        }
        return ans;

=======

        vector<int> onePos;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 1) {
                onePos.push_back(i);
            }
        }
        int n = onePos.size();
        vector<int> onePosSum(n + 1);
        for (int i = 1; i <= n; i++) {
            onePosSum[i] = onePosSum[i - 1] + onePos[i - 1];
        }
        int res = INT_MAX;
        for (int i = 0; i < n - k + 1; i++) {
            int j = i + k - 1;
            int mid = i + (j - i) / 2;
            int leftSum = onePosSum[mid + 1] - onePosSum[i];
            int rightSum = onePosSum[j + 1] - onePosSum[mid + 1];
            res = min(res, (mid - i + 1) * onePos[mid] - leftSum + rightSum - (j - mid) * onePos[mid]);
        }
        return res;

=======

        vector<int> onePos;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 1) {
                onePos.push_back(i);
            }
        }
        int ans = INT_MAX;
        for (int i = 0; i < onePos.size() - k + 1; i++) {
            int mid = onePos[i + k / 2];
            int cost = 0;
            for (int j = i; j < i + k; j++) {
                cost += abs(onePos[j] - mid) - abs(j - i - k / 2);
            }
            ans = min(ans, cost);
        }
        return ans;

=======

        vector<int> v;
        for(int i = 0; i < nums.size(); i++) {
            if(nums[i] == 1) {
                v.push_back(i);
            }
        }
        int n = v.size();
        int res = INT_MAX;
        for(int i = 0; i < n - k + 1; i++) {
            int mid = i + (k - 1) / 2;
            int l = v[i];
            int r = v[i + k - 1];
            int m = v[mid];
            int val = 0;
            for(int j = i; j < i + k; j++) {
                val += abs(v[j] - m);
            }
            res = min(res, val);
        }
        return res;

=======

        int n = nums.size();
        vector<int> ones;
        for (int i = 0; i < n; ++i) {
            if (nums[i]) {
                ones.push_back(i);
            }
        }
        int m = ones.size();
        int ans = INT_MAX;
        int sum = 0;
        for (int i = 0; i < k; ++i) {
            sum += ones[i];
        }
        ans = sum - ones[k / 2] * (k - k / 2);
        for (int i = k; i < m; ++i) {
            sum += ones[i] - ones[i - k];
            ans = min(ans, sum - ones[i - k / 2] * (k - k / 2));
        }
        return ans;

=======

        vector<int> ones;
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] == 1) ones.push_back(i);
        }
        int res = INT_MAX;
        int n = ones.size();
        int l = 0, r = k - 1;
        int sum = 0;
        for (int i = l; i <= r; ++i) {
            sum += ones[i];
        }
        int mid = (k - 1) / 2;
        int median = ones[mid];
        res = min(res, sum - median * (k - 1 - mid) - median * mid);
        while (r < n - 1) {
            sum += ones[++r] - ones[++l - 1];
            median = ones[l + mid];
            res = min(res, sum - median * (k - 1 - mid) - median * mid);
        }
        return res;

=======

        vector<int> v;
        for(int i = 0; i < nums.size(); i++) {
            if(nums[i] == 1) {
                v.push_back(i);
            }
        }
        int n = v.size();
        int res = INT_MAX;
        for(int i = 0; i < n - k + 1; i++) {
            int mid = i + (k - 1) / 2;
            int l = v[i];
            int r = v[i + k - 1];
            int m = v[mid];
            int val = 0;
            for(int j = i; j < i + k; j++) {
                val += abs(v[j] - m);
            }
            res = min(res, val);
        }
        return res;

=======

        vector<int> ones;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 1) {
                ones.push_back(i);
            }
        }
        long long ans = INT_MAX;
        for (int i = 0; i < ones.size() - k + 1; i++) {
            int mid = ones[i + k / 2 - 1];
            long long cost = 0;
            for (int j = i; j < i + k; j++) {
                cost += abs(mid - ones[j]);
            }
            ans = min(ans, cost);
        }
        return ans;
