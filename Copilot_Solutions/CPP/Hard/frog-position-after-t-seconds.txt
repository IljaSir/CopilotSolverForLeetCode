Synthesizing 10/10 solutions (Duplicates hidden)

=======

        vector<vector<int>> adj(n + 1);
        for (auto& e : edges) {
            adj[e[0]].push_back(e[1]);
            adj[e[1]].push_back(e[0]);
        }
        vector<double> prob(n + 1, 0);
        prob[1] = 1.0;
        queue<int> q;
        q.push(1);
        int step = 0;
        while (!q.empty()) {
            int size = q.size();
            for (int i = 0; i < size; i++) {
                int cur = q.front();
                q.pop();
                if (cur == target && step == t) {
                    return prob[cur];
                }
                int count = 0;
                for (int next : adj[cur]) {
                    if (prob[next] == 0) {
                        count++;
                    }
                }
                for (int next : adj[cur]) {
                    if (prob[next] == 0) {
                        prob[next] = prob[cur] / count;
                        q.push(next);
                    }
                }
            }
            step++;
        }
        return 0;

=======

        vector<vector<int>> adj(n + 1);
        for (auto& e : edges) {
            adj[e[0]].push_back(e[1]);
            adj[e[1]].push_back(e[0]);
        }
        vector<int> visited(n + 1);
        return dfs(adj, visited, 1, t, target);
    }
    double dfs(vector<vector<int>>& adj, vector<int>& visited, int node, int t, int target) {
        if (t < 0) return 0;
        if (node == target) {
            if (t == 0) return 1;
            for (int i = 0; i < adj[node].size(); i++) {
                if (!visited[adj[node][i]]) return 0;
            }
            return 1;
        }
        visited[node] = 1;
        double res = 0;
        int cnt = 0;
        for (int i = 0; i < adj[node].size(); i++) {
            if (!visited[adj[node][i]]) {
                cnt++;
            }
        }
        for (int i = 0; i < adj[node].size(); i++) {
            if (!visited[adj[node][i]]) {
                res += dfs(adj, visited, adj[node][i], t - 1, target) / cnt;
            }
        }
        return res;

=======

        vector<vector<int>> graph(n + 1);
        for (auto edge : edges) {
            graph[edge[0]].push_back(edge[1]);
            graph[edge[1]].push_back(edge[0]);
        }
        vector<bool> visited(n + 1, false);
        queue<int> q;
        q.push(1);
        visited[1] = true;
        int level = 0;
        while (!q.empty()) {
            int size = q.size();
            for (int i = 0; i < size; i++) {
                int node = q.front();
                q.pop();
                if (node == target) {
                    if (level == t || graph[node].size() == 1) {
                        return 1.0;
                    }
                    return 0.0;
                }
                int count = 0;
                for (int j = 0; j < graph[node].size(); j++) {
                    if (!visited[graph[node][j]]) {
                        count++;
                    }
                }
                for (int j = 0; j < graph[node].size(); j++) {
                    if (!visited[graph[node][j]]) {
                        q.push(graph[node][j]);
                        visited[graph[node][j]] = true;
                    }
                }
            }
            level++;
        }
        return 0.0;

=======

        vector<vector<int>> adj(n);
        for (auto e : edges) {
            adj[e[0] - 1].push_back(e[1] - 1);
            adj[e[1] - 1].push_back(e[0] - 1);
        }
        vector<bool> visited(n);
        return dfs(adj, visited, target - 1, 0, t, 1);

=======

        vector<vector<int>> graph(n + 1);
        for (auto e : edges) {
            graph[e[0]].push_back(e[1]);
            graph[e[1]].push_back(e[0]);
        }
        vector<bool> visited(n + 1);
        return dfs(graph, visited, 1, t, target);
    }
    
    double dfs(vector<vector<int>>& graph, vector<bool>& visited, int node, int t, int target) {
        if (visited[node]) {
            return 0;
        }
        if (t == 0) {
            return node == target ? 1 : 0;
        }
        visited[node] = true;
        int n = graph[node].size();
        for (int i = 0; i < graph[node].size(); i++) {
            if (visited[graph[node][i]]) {
                n--;
            }
        }
        double res = 0;
        for (int i = 0; i < graph[node].size(); i++) {
            if (!visited[graph[node][i]]) {
                res += dfs(graph, visited, graph[node][i], t - 1, target) / n;
            }
        }
        visited[node] = false;
        return res;

=======

        vector<vector<int>> graph(n+1, vector<int>());
        for (auto& edge: edges) {
            graph[edge[0]].push_back(edge[1]);
            graph[edge[1]].push_back(edge[0]);
        }
        vector<int> visited(n+1, 0);
        visited[1] = 1;
        return dfs(graph, visited, 1, t, target);
    }
    double dfs(vector<vector<int>>& graph, vector<int>& visited, int cur, int t, int target) {
        if (t == 0) {
            return cur == target ? 1 : 0;
        }
        int count = 0;
        for (auto next: graph[cur]) {
            if (visited[next] == 0) {
                count++;
            }
        }
        if (count == 0) {
            return cur == target ? 1 : 0;
        }
        double prob = 0;
        for (auto next: graph[cur]) {
            if (visited[next] == 0) {
                visited[next] = 1;
                prob += dfs(graph, visited, next, t-1, target) / count;
                visited[next] = 0;
            }
        }
        return prob;

=======

        vector<vector<int>> g(n+1);
        for(auto &e:edges){
            g[e[0]].push_back(e[1]);
            g[e[1]].push_back(e[0]);
        }
        vector<int> vis(n+1);
        vis[1] = 1;
        queue<int> q;
        q.push(1);
        double res = 1;
        int step = 0;
        while(!q.empty()){
            int sz = q.size();
            for(int i = 0; i < sz; i++){
                int cur = q.front(); q.pop();
                if(cur == target && step == t) return res;
                int cnt = 0;
                for(int j = 0; j < g[cur].size(); j++){
                    if(vis[g[cur][j]] == 0) cnt++;
                }
                for(int j = 0; j < g[cur].size(); j++){
                    if(vis[g[cur][j]] == 0){
                        vis[g[cur][j]] = 1;
                        q.push(g[cur][j]);
                        if(cnt > 0) res /= cnt;
                    }
                }
            }
            step++;
            if(step > t) return 0;
        }
        return 0;

=======

        // 1. construct graph
        vector<vector<int>> graph(n+1);
        for (auto edge : edges) {
            graph[edge[0]].push_back(edge[1]);
            graph[edge[1]].push_back(edge[0]);
        }
        
        // 2. bfs
        vector<int> visited(n+1, 0);
        queue<int> q;
        q.push(1);
        visited[1] = 1;
        int time = 0;
        while (!q.empty()) {
            int size = q.size();
            for (int i = 0; i < size; i++) {
                int curr = q.front();
                q.pop();
                if (time == t) {
                    return curr == target ? 1.0 : 0.0;
                }
                int count = 0;
                for (int next : graph[curr]) {
                    if (visited[next] == 0) {
                        count++;
                    }
                }
                for (int next : graph[curr]) {
                    if (visited[next] == 0) {
                        if (count == 1) {
                            visited[next] = 1;
                            q.push(next);
                        } else {
                            visited[next] = 2;
                            q.push(next);
                        }
                    }
                }
            }
            time++;
        }
        return 0.0;

=======

        int i, j, k, u, v, w, x, y, z;
        int m = edges.size();
        vector<vector<int>> g(n + 1);
        for (i = 0; i < m; i++) {
            u = edges[i][0];
            v = edges[i][1];
            g[u].push_back(v);
            g[v].push_back(u);
        }
        vector<int> visited(n + 1);
        vector<int> q;
        q.push_back(1);
        visited[1] = 1;
        double ans = 1.0;
        for (i = 0; i < t; i++) {
            vector<int> next;
            for (j = 0; j < q.size(); j++) {
                x = q[j];
                y = 0;
                for (k = 0; k < g[x].size(); k++) {
                    if (visited[g[x][k]]) {
                        y++;
                    }
                }
                for (k = 0; k < g[x].size(); k++) {
                    if (!visited[g[x][k]]) {
                        visited[g[x][k]] = 1;
                        next.push_back(g[x][k]);
                        ans = ans * 1.0 / (g[x].size() - y);
                    }
                }
            }
            q = next;
        }
        for (i = 0; i < q.size(); i++) {
            if (q[i] == target) {
                return ans;
            }
        }
        return 0.0;
