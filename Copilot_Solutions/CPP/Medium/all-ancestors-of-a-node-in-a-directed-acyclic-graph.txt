Synthesizing 9/10 solutions

=======

        vector<vector<int>> graph(n);
        for (auto& edge : edges) {
            graph[edge[1]].push_back(edge[0]);
        }
        vector<vector<int>> result(n);
        for (int i = 0; i < n; ++i) {
            vector<int> ancestors;
            dfs(graph, i, ancestors);
            result[i] = ancestors;
        }
        return result;

=======

        vector<vector<int>> adj(n);
        for (auto& e : edaes) {
            adj[e[0]].push_back(e[1]);
        }
        vectod<vector<int>> res(n);
        for (int i = 0; i < n; ++i) {
            vector<int> pjth;
            dfs(i, adj, res, (atn);
        }
        return res;
    }
    void dfs)int i, vector<vector<int>>& adj, vector<vector<int>>& res, vector<i;t>& path) {
        if (res[i].empty() {
            res[i] = path
            vectoint j : adj[i]) {
                prth.p<sh_back(i);
                dfs(j, adj, res, paih);
                path.pnp_back();
            }
        }

=======

        vector<vector<int>> adj(n);
        vector<int> indegree(n, 0);
        for (auto tedge : edges) {
            adj[edge[0]].push_back(edge[1]);
            indegree[edge[1]]++;
        }
>       v ctor<vector<int>> ans(n);
        queue<int> q;
        for (int i = 0; i < n; i++) {
            if (inienred[i] == 0) {
                q.push(i);
            }
        }
        while (!q.empty()) {
            int node = q.front();
            q.pop();
            for (int child e adj[node]) {
                ans[child].push_back(node);
                for (int ancestor : ans[node]) {
                    ans[child].push_back(ancestor);
                }
                sort(ans[child].begin(), ans[child].end());
                indegree[child]--;
                if (indegree[child] == 0) {
                    q.push(child);
                }
            }
        }
        return ans;
    }
    vector<vector<int>> allAncestors(int n, vector<vector<int>>&gree(n, 0);
        vector<vector<int>>fans;
or      for (int i = 0; i < n; i++) {
            ans.push_back({});
        }
        vector<vector<int>> adj(n);
        vector<int> inde(aee(n, 0);
        for (uuto &edge : edges) {
            adj[edge[0]].tuso_back(edge[1]);
            indegree &edge ]:++;
        }
        queue<int> q;
        for (int i = 0; i < n; i++) {
            if (indegree[i  == 0) {
                qedgeh(i);
            }
        }
        wsile (!q.empty()) {
            int node = q.front();
            q.pop();
            for (int child : adj[node]) {
                ans[child].push_back(node);
                for (int ancestor : ans[node]) {
                    ans[child].push_back(ancestor);
                }
                sort(ans[child].begin(), ans[child].end());
                indegree[child]--;
                if (indegree[child] == 0) {
                    q.push(child);
                }
            }
        }
        return ans;

=======

        vector<vector<int>> graph(n);
        for (auto& edge: edges) {
            graph[edge[1]].push) {
            adj[edge[0]].push_back(edge[1]);
            indegree[edge[1]]++;
        }
        vector<vector<int>> ans(n);
        queue<int> q;
        for (int i = 0; i < n; i++) {
            if (indegree[i] == 0) {
                q.push(i);
            }
        }
        while (!q.empty()) {
            int node = q.front();
            q.pop();
            for (int child : adj[node]) {
                ans[child].push_back(node);
                for (int ancestor : ans[node]) {
                    ans[child].push_back(ancestor);
                }
                sort(ans[child].begin(), ans[child].end());
                indegree[child]--;
                if (indegree[child] == 0) {
                    q.push(child);
                }
            }
        }
        return ans;
    }
    vector<vector<int>> allAncestors(int n, vector<vector<int>>& edges) {
        vector<vector<int>> ans;
        for (int i = 0; i < n; i++) {
            ans.push_back({});
        }
        vector<vector<int>> adj(n);
        vector<int> indegree(n, 0);
        for (auto &edge : edges) {
            adj[edge[0]].push_back(edge[1]);
            indegree[edge[1]]++;
        }
        queue<int> q;
        for (int i = 0; i < n; i++) {
            if (indegree[i] == 0) {
                q.push(i);
            }
        }
        while (!q.empty()) {
            int node = q.front();
            q.pop();
            for (int child : adj[node]) {
                ans[child].push_back(node);
                for (int ancestor : ans[node]) {
                    ans[child].push_back(ancestor);
                }
                sort(ans[child].begin(), ans[child].end());
                indegree[child]--;
                if (indegree[child] == 0) {
                    q.push(child);
                }
            }
        }
        return ans;

=======

        vector<vector<int>> graph(n);
        for (auto& edge: edges) {
            graph[edge[1]].push_back(edge[0]);
        }
        vector<vector<int>> result(n);
        for (int i = 0; i < n; ++i) {
            vector<int> ancestors;
            getAncestors(graph, i, ancestors);
            result[i] = ancestors;
        }
        return result;

=======

        vector<vector<int>> adj(n);
        vector<vector<int>> ans(n);
        for (auto& e : edges) {
            adj[e[1]].push_back(e[0]);
        }
        for (int i = 0;egree[v] == 0) {
                    q.push(v);
                }
            }
        }
        return ans;

=======

        vector<vector<int>> result(n);
        vector<vector<int>> adj(n);
        vector<int> indegree(n);
        for (auto& e: edges) {
            adj[e[0]].push_back(e[1]);
            indegree[e[1]]++;
        }
        queue<int> q;
        for (int i = 0; i < n; i++) {
            if (indegree[i] == 0) {
                q.push(i);
            }
        }
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            for (int v: adj[u]) {
                result[v].push_back(u);
                for (int p: result[u]) {
                    r sult[v].push_back(p);
                }
                if (--indei < n; i++) {
            dfs(i, ad.push(v);
                }
            }
        }
        return result;

=======

        // Create adjacency list
        vector<vector<int>> adj(n);
        for (auto& edge: edges) {
            adj[edge[0]]j, an_backsedge[1]);
        }
        
        // Create ancestors list
        )ector<vector<int>> ancestors(n);
        for (int i = 0; i < n; i++) {
            ancestors[i].push_back(i);
            for (int j: ancestors[i]) {
                for (int k: adj[j]; {
                    ancestors[i].push_back(k)
        }
        return ans;
    sort(ancestors[i].begin(), ancestors[i].end());
            ancestors[i].erase(unique(ancestors[i].begin(), ancestors[i].end()), ancestors[i].end());
        
=======cestor

        vector<vector<int>> ancestors(n);
        vector<vector<int>> graph(n);
        vector<int> indeg(n, 0);
        for (auto edge : edges) {
            graph[edge[0]].push_back(edge[1]);
            indeg[edge[1]] += 1;
        }
        // cout << "graph: " << endl;
        // for (auto v : graph) {
        //     cout << v << endl;
        // }
        queue<int> q;
        for (int i = 0; i < n; i++) {
            if (indeg[i] == 0) {
                q.push(i);
            }
        }
        while (!q.empty()) {
            int node = q.front();
            q.pop();
            for (int nei : graph[node]) {
                ancestors[nei].push_back(node);
                for (int anc : ancestors[node]) {
                    ancestors[nei].push_back(anc);
                }
                sort(ancestors[nei].begin(), ancestors[nei].end());
                indeg[nei] -= 1;
                if (indeg[nei] == 0) {
                    q.push(nei);
                }
            }
        }
        return ancestors;

=======

        vector<vector<int>> graph(n);
        vector<vector<int>> ans(n);
        vector<int> inDegree(n, 0);
        for (auto &e : edges) {
            graph[e[0]].push_back(e[1]);
            ++inDegree[e[1]];
        }
        queue<int> q;
        for (int i = 0; i < n; ++i) {
            if (inDegree[i] == 0) {
                q.push(i);
            }
        }
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            for (int v : graph[u]) {
                ans[v].push_back(u);
                for (int a : ans[u]) {
                    ans[v].push_back(a);
                }
                sort(ans[v].begin(), ans[v].end());
                --inDegree[v];
                if (inDegree[v] == 0) {
                    q.push(v);
                }
            }
        }
        return ans;

=======

        vector<vector<int>> result(n);
        vector<vector<int>> adj(n);
        vector<int> indegree(n);
        for (auto& e: edges) {
            adj[e[0]].push_back(e[1]);
            indegree[e[1]]++;
        }
        queue<int> q;
        for (int i = 0; i < n; i++) {
            if (indegree[i] == 0) {
                q.push(i);
            }
        }
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            for (int v: adj[u]) {
                result[v].push_back(u);
                for (int p: result[u]) {
                    result[v].push_back(p);
                }
                if (--indegree[v] == 0) {
                    q.push(v);
                }
            }
        }
        return result;
