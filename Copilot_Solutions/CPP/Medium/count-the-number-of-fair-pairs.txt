Synthesizing 10/10 solutions (Duplicates hidden)

=======

        int n = nums.size();
        vector<int> sum(n + 1, 0);
        for (int i = 0; i < n; i++) {
            sum[i + 1] = sum[i] + nums[i];
        }
        long long res = 0;
        for (int i = 0; i < n; i++) {
            int l = i + 1, r = n;
            while (l < r) {
                int mid = (l + r) / 2;
                if (sum[mid + 1] - sum[i] >= lower) {
                    r = mid;
                } else {
                    l = mid + 1;
                }
            }
            int left = l;
            l = i + 1, r = n;
            while (l < r) {
                int mid = (l + r) / 2;
                if (sum[mid + 1] - sum[i] <= upper) {
                    l = mid + 1;
                } else {
                    r = mid;
                }
            }
            int right = l;
            res += right - left;
        }
        return res;

=======

        int n = nums.size();
        vector<int> pre(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            pre[i] = pre[i - 1] + nums[i - 1];
        }
        long long res = 0;
        for (int i = 0; i < n; i++) {
            int l = i + 1, r = n;
            while (l < r) {
                int mid = l + r + 1 >> 1;
                if (pre[mid] - pre[i] >= lower) r = mid - 1;
                else l = mid;
            }
            int left = l;
            l = i + 1, r = n;
            while (l < r) {
                int mid = l + r >> 1;
                if (pre[mid] - pre[i] <= upper) l = mid + 1;
                else r = mid;
            }
            int right = l;
            res += right - left;
        }
        return res;

=======

        long long ans = 0;
        sort(nums.begin(), nums.end());
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            int l = i + 1, r = n - 1;
            while (l < r) {
                int sum = nums[i] + nums[l];
                if (sum > upper) {
                    r--;
                } else if (sum < lower) {
                    l++;
                } else {
                    int j = r;
                    while (j > l && nums[i] + nums[j] >= lower) {
                        j--;
                    }
                    ans += r - j;
                    l++;
                }
            }
        }
        return ans;

=======

        long long ans = 0;
        int n = nums.size();
        vector<int> pre(n + 1);
        for (int i = 1; i <= n; ++i) {
            pre[i] = pre[i - 1] + nums[i - 1];
        }
        map<int, int> cnt;
        for (int i = 0; i <= n; ++i) {
            ++cnt[pre[i]];
            ans += cnt[pre[i] - lower] + cnt[pre[i] - upper - 1] - cnt[pre[i] - upper];
        }
        return ans;

=======

        int n = nums.size();
        vector<int> prefix(n+1, 0);
        for (int i = 0; i < n; i++)
            prefix[i+1] = prefix[i] + nums[i];
        long long ans = 0;
        for (int i = 0; i < n; i++) {
            int l = lower - prefix[i];
            int r = upper - prefix[i];
            int p = lower_bound(prefix.begin()+i+1, prefix.end(), l) - prefix.begin();
            int q = upper_bound(prefix.begin()+i+1, prefix.end(), r) - prefix.begin();
            ans += q - p;
        }
        return ans;

=======

        long long result = 0;
        int n = nums.size();
        sort(nums.begin(), nums.end());
        for (int i = 0; i < n; ++i) {
            int l = i + 1, r = n - 1;
            while (l < r) {
                int m = l + (r - l) / 2;
                if (nums[i] + nums[m] < lower) {
                    l = m + 1;
                } else {
                    r = m;
                }
            }
            int left = l;
            l = i + 1, r = n - 1;
            while (l < r) {
                int m = l + (r - l + 1) / 2;
                if (nums[i] + nums[m] > upper) {
                    r = m - 1;
                } else {
                    l = m;
                }
            }
            int right = r;
            if (left <= right) {
                result += right - left + 1;
            }
        }
        return result;

=======

        long long count = 0;
        int n = nums.size();
        vector<int> sorted(n);
        sort(nums.begin(), nums.end());
        for (int i = 0; i < n; ++i) {
            int low = lower - nums[i];
            int up = upper - nums[i];
            int l = lower_bound(nums.begin(), nums.begin() + i, low) - nums.begin();
            int u = upper_bound(nums.begin(), nums.begin() + i, up) - nums.begin();
            count += u - l;
        }
        return count;

=======

        int n = nums.size();
        int l = 0;
        int r = 0;
        long long sum = 0;
        long long res = 0;
        long long cnt = 0;
        for (int i = 0; i < n; i++) {
            while (l < n && sum < lower) {
                sum += nums[l];
                l++;
            }
            if (l == n) break;
            while (r < n && sum <= upper) {
                sum += nums[r];
                r++;
            }
            if (sum > upper) {
                sum -= nums[r-1];
                r--;
            }
            if (l < r) {
                cnt = r - l;
                res += (cnt * (cnt - 1)) / 2;
            }
            sum -= nums[i];
        }
        return res;

=======

        long long result = 0;
        vector<int> count(upper + 1, 0);
        for (int i = 0; i < nums.size(); i++) {
            int left = max(0, lower - nums[i]);
            int right = min(upper, upper - nums[i]);
            for (int j = left; j <= right; j++) {
                result += count[j];
            }
            count[nums[i]]++;
        }
        return result;
