Synthesizing 10/10 solutions

=======

        unordered_map<int, int> m;
        int res = 0;
        for (int n : nums) {
            if (m[k - n] > 0) {
                --m[k - n];
                ++res;
            } else {
                ++m[n];
            }
        }
        return res;

=======

        int res = 0;
        unordered_map<int, int> m;
        for (int i = 0; i < nums.size(); i++) {
            if (m.find(k - nums[i]) != m.end() && m[k - nums[i]] > 0) {
                m[k - nums[i]]--;
                res++;
            } else {
                m[nums[i]]++;
            }
        }
        return res;

=======

        int res = 0;
        unordered_map<int, int> m;
        for (auto n : nums) {
            if (m.find(k - n) != m.end() && m[k - n] > 0) {
                res++;
                m[k - n]--;
            } else {
                m[n]++;
            }
        }
        return res;

=======

        int n = nums.size();
        if (n == 0) return 0;
        sort(nums.begin(), nums.end());
        int l = 0, r = n - 1;
        int res = 0;
        while (l < r) {
            if (nums[l] + nums[r] == k) {
                ++res;
                ++l;
                --r;
            } else if (nums[l] + nums[r] < k) {
                ++l;
            } else {
                --r;
            }
        }
        return res;

=======

        unordered_map<int, int> m;
        int cnt = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (m.count(k - nums[i])) {
                if (m[k - nums[i]] > 0) {
                    m[k - nums[i]]--;
                    cnt++;
                }
            } else {
                m[nums[i]]++;
            }
        }
        return cnt;

=======

        unordered_map<int, int> m;
        int ans = 0;
        for (auto &n : nums) {
            if (m[k - n] > 0) {
                m[k - n]--;
                ans++;
            } else {
                m[n]++;
            }
        }
        return ans;

=======

        int ans = 0;
        unordered_map<int, int> m;
        for (int i : nums) {
            if (m.count(k - i) && m[k - i] > 0) {
                ans++;
                m[k - i]--;
            } else {
                m[i]++;
            }
        }
        return ans;

=======

        int ret = 0;
        unordered_map<int, int> m;
        for (auto i : nums) {
            if (m[k - i] > 0) {
                m[k - i]--;
                ret++;
            } else {
                m[i]++;
            }
        }
        return ret;

=======

        int result = 0;
        unordered_map<int, int> m;
        for (auto n : nums) {
            if (m.count(k - n) && m[k - n] > 0) {
                m[k - n]--;
                result++;
            } else {
                m[n]++;
            }
        }
        return result;

=======

        unordered_map<int, int> count;
        for (auto n: nums) {
            ++count[n];
        }
        int res = 0;
        for (auto p: count) {
            if (p.first * 2 == k) {
                res += p.second / 2;
            } else if (p.first < k) {
                if (count.find(k - p.first) != count.end()) {
                    res += min(p.second, count[k - p.first]);
                }
            }
        }
        return res;
