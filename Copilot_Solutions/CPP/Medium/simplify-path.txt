Synthesizing 8/10 solutions

=======

        stack<string> s;
        int i = 0;
        int n = path.size();
        while (i < n) {
            while (i < n && path[i] == '/') {
                i++;
            }
            if (i == n) {
                break;
            }
            int j = i;
            while (j < n && path[j] != '/') {
                j++;
            }
            string dir = path.substr(i, j - i);
            if (dir == "..") {
                if (!s.empty()) {
                    s.pop();
                }
            }
            else if (dir != ".") {
                s.push(dir);
            }
            i = j;
        }
        if (s.empty()) {
            return "/";
        }
        string ans;
        while (!s.empty()) {
            ans = "/" + s.top() + ans;
            s.pop();
        }
        return ans;

=======

        int n = path.size();
        if (n == 0) return "";
        vector<string> stack;
        int i = 0;
        while (i < n) {
            while (i < n && path[i] == '/') ++i;
            if (i == n) break;
            int start = i;
            while (i < n && path[i] != '/') ++i;
            int end = i;
            string dir = path.substr(start, end - start);
            if (dir == ".") continue;
            if (dir == "..") {
                if (!stack.empty()) stack.pop_back();
            } else {
                stack.push_back(dir);
            }
        }
        string ans = "";
        for (string dir: stack) {
            ans += "/" + dir;
        }
        if (ans == "") ans = "/";
        return ans;

=======

        stack<string> st;
        string res;
        for (int i = 0; i < path.size(); i++) {
            if (path[i] == '/') {
                continue;
            } else if (path[i] == '.') {
                if (i + 1 < path.size() && path[i + 1] == '.') {
                    if (!st.empty()) {
                        st.pop();
                    }
                    i++;
                }
            } else {
                string cur;
                while (i < path.size() && path[i] != '/') {
                    cur += path[i];
                    i++;
                }
                st.push(cur);
                i--;
            }
        }
        if (st.empty()) {
            return "/";
        }
        while (!st.empty()) {
            res = "/" + st.top() + res;
            st.pop();
        }
        return res;

=======

        vector<string> v;
        string res;
        int i = 0;
        while (i < path.size()) {
            while (i < path.size() && path[i] == '/') i++;
            if (i == path.size()) break;
            string s;
            while (i < path.size() && path[i] != '/') s += path[i++];
            if (s == "..") {
                if (!v.empty()) v.pop_back();
            } else if (s != ".") {
                v.push_back(s);
            }
        }
        for (auto &s : v) {
            res += "/" + s;
        }
        return res.empty() ? "/" : res;

=======

        if (path.empty()) return "";
        vector<string> stk;
        int i = 0;
        while (i < path.size()) {
            if (path[i] == '/') {
                ++i;
                continue;
            }
            int j = i + 1;
            while (j < path.size() && path[j] != '/') ++j;
            string s = path.substr(i, j - i);
            if (s == "..") {
                if (!stk.empty()) stk.pop_back();
            } else if (s != ".") {
                stk.push_back(s);
            }
            i = j;
        }
        string ret = "";
        for (const string& s : stk) {
            ret += "/" + s;
        }
        if (ret.empty()) ret = "/";
        return ret;

=======

        int n = path.size();
        vector<string> stack;
        int i = 0;
        while (i < n) {
            if (path[i] == '/') {
                i++;
                continue;
            }
            string s;
            while (i < n && path[i] != '/') {
                s.push_back(path[i++]);
            }
            if (s == ".") {
                continue;
            }
            if (s == "..") {
                if (!stack.empty()) {
                    stack.pop_back();
                }
            } else {
                stack.push_back(s);
            }
        }
        string ans;
        for (auto s : stack) {
            ans += "/";
            ans += s;
        }
        if (ans.empty()) {
            ans = "/";
        }
        return ans;

=======

        vector<string> v;
        string res = "";
        int i = 0;
        while (i < path.size()) {
            if (path[i] == '/') {
                i++;
                continue;
            }
            string tmp = "";
            while (i < path.size() && path[i] != '/') {
                tmp += path[i];
                i++;
            }
            if (tmp == "..") {
                if (!v.empty()) {
                    v.pop_back();
                }
            } else if (tmp != ".") {
                v.push_back(tmp);
            }
        }
        for (string s : v) {
            res += "/" + s;
        }
        return res.empty() ? "/" : res;

=======

        int i, j, k;
        i = 0;
        vector<string> stk;
        while (i < path.size()) {
            if (path[i] == '/') {
                i++;
                continue;
            }
            j = i;
            while (j < path.size() && path[j] != '/') j++;
            string s = path.substr(i, j - i);
            if (s == ".") {
                i = j;
                continue;
            }
            if (s == "..") {
                if (!stk.empty()) stk.pop_back();
            } else {
                stk.push_back(s);
            }
            i = j;
        }
        string ans;
        for (auto &s : stk) {
            ans += "/" + s;
        }
        if (ans.empty()) ans = "/";
        return ans;
