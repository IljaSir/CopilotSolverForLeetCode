Synthesizing 10/10 solutions

=======

        int n = capacity.size();
        vector<int> diff(n);
        for (int i = 0; i < n; ++i) {
            diff[i] = capacity[i] - rocks[i];
        }
        sort(diff.begin(), diff.end());
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            if (additionalRocks >= diff[i]) {
                additionalRocks -= diff[i];
                ++ans;
            }
        }
        return ans;

=======

        int n = capacity.size();
        vector<int> diff(n);
        for (int i = 0; i < n; ++i) {
            diff[i] = capacity[i] - rocks[i];
        }
        sort(diff.begin(), diff.end());
        int res = 0;
        for (int i = 0; i < n; ++i) {
            if (additionalRocks >= diff[i]) {
                ++res;
                additionalRocks -= diff[i];
            } else {
                break;
            }
        }
        return res;

=======

        int n = capacity.size();
        vector<int> diff(n);
        for (int i = 0; i < n; i++) {
            diff[i] = capacity[i] - rocks[i];
        }
        sort(diff.begin(), diff.end());
        int res = 0;
        for (int i = 0; i < n; i++) {
            if (additionalRocks >= diff[i]) {
                res++;
                additionalRocks -= diff[i];
            } else {
                break;
            }
        }
        return res;

=======

        int n = capacity.size();
        vector<int> diff(n);
        for (int i = 0; i < n; i++) {
            diff[i] = capacity[i] - rocks[i];
        }
        sort(diff.begin(), diff.end());
        for (int i = 0; i < n; i++) {
            if (additionalRocks >= diff[i]) {
                additionalRocks -= diff[i];
            } else {
                return i;
            }
        }
        return n;

=======

        int n = capacity.size();
        vector<int> v(n);
        for (int i = 0; i < n; i++) {
            v[i] = capacity[i] - rocks[i];
        }
        sort(v.begin(), v.end());
        int res = 0;
        for (int i = 0; i < n; i++) {
            if (additionalRocks >= v[i]) {
                additionalRocks -= v[i];
                res++;
            } else {
                break;
            }
        }
        return res;

=======

        int n = capacity.size();
        vector<int> v(n);
        for (int i = 0; i < n; i++) {
            v[i] = capacity[i] - rocks[i];
        }
        sort(v.begin(), v.end());
        int ans = 0;
        for (int i = 0; i < n; i++) {
            if (additionalRocks >= v[i]) {
                additionalRocks -= v[i];
                ans++;
            }
        }
        return ans;

=======

        priority_queue<int> pq;
        int n = capacity.size();
        for (int i = 0; i < n; ++i) {
            pq.push(capacity[i] - rocks[i]);
        }
        while (additionalRocks > 0) {
            int x = pq.top();
            pq.pop();
            if (x == 0) {
                pq.push(0);
                break;
            }
            pq.push(x - 1);
            --additionalRocks;
        }
        int ans = 0;
        while (!pq.empty()) {
            if (pq.top() == 0) {
                ++ans;
            }
            pq.pop();
        }
        return ans;

=======

        int n = capacity.size();
        int l = 0, r = n;
        int ans = 0;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (check(capacity, rocks, additionalRocks, mid)) {
                ans = max(ans, mid);
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return ans;
    }
    
    bool check(vector<int>& capacity, vector<int>& rocks, int additionalRocks, int mid) {
        int n = capacity.size();
        vector<int> diff(n);
        for (int i = 0; i < n; ++i) {
            diff[i] = capacity[i] - rocks[i];
        }
        sort(diff.begin(), diff.end(), greater<int>());
        int sum = 0;
        for (int i = 0; i < mid; ++i) {
            sum += diff[i];
        }
        return sum <= additionalRocks;

=======

        int n = capacity.size();
        int l = 0, r = 1e9;
        while (l < r) {
            int m = (l + r + 1) >> 1;
            int cnt = 0;
            for (int i = 0; i < n; ++i) {
                cnt += max(0, capacity[i] - rocks[i]) / m;
            }
            if (cnt <= additionalRocks) {
                r = m - 1;
            } else {
                l = m;
            }
        }
        return l;

=======

        auto n = capacity.size();
        auto low = 0;
        auto high = n;
        while (low < high) {
            auto mid = low + (high - low + 1) / 2;
            if (check(mid, capacity, rocks, additionalRocks)) {
                low = mid;
            } else {
                high = mid - 1;
            }
        }
        return low;
    }
    bool check(int mid, vector<int>& capacity, vector<int>& rocks, int additionalRocks) {
        auto n = capacity.size();
        auto sum = 0;
        for (auto i = 0; i < n; ++i) {
            if (capacity[i] - rocks[i] >= mid) {
                sum += capacity[i] - rocks[i] - mid;
            }
        }
        return sum <= additionalRocks;
