Synthesizing 10/10 solutions

=======

        int minIndex = 0;
        int maxIndex = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] < nums[minIndex]) {
                minIndex = i;
            }
            if (nums[i] > nums[maxIndex]) {
                maxIndex = i;
            }
        }
        int left = 0;
        int right = nums.size() - 1;
        int count = 0;
        while (left < minIndex && right > maxIndex) {
            left++;
            right--;
            count++;
        }
        while (left < minIndex) {
            left++;
            count++;
        }
        while (right > maxIndex) {
            right--;
            count++;
        }
        return count;

=======

        int min = nums[0];
        int max = nums[0];
        int minIndex = 0;
        int maxIndex = 0;
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] < min) {
                min = nums[i];
                minIndex = i;
            }
            if (nums[i] > max) {
                max = nums[i];
                maxIndex = i;
            }
        }
        int minDelete = minIndex;
        int maxDelete = nums.size() - maxIndex - 1;
        if (minIndex > maxIndex) {
            return minDelete + maxDelete - 1;
        } else {
            return minDelete + maxDelete;
        }

=======

        int n = nums.size();
        vector<int> left(n);
        vector<int> right(n);
        left[0] = nums[0];
        for(int i = 1; i < n; i++) {
            left[i] = min(left[i-1], nums[i]);
        }
        right[n-1] = nums[n-1];
        for(int i = n-2; i >= 0; i--) {
            right[i] = max(right[i+1], nums[i]);
        }
        int res = n;
        for(int i = 0; i < n; i++) {
            if(i == 0) {
                res = min(res, n - (upper_bound(right.begin()+i+1, right.end(), left[i]) - right.begin()));
            } else if(i == n-1) {
                res = min(res, n - (lower_bound(left.begin(), left.begin()+i, right[i]) - left.begin()));
            } else {
                int l = lower_bound(left.begin(), left.begin()+i, right[i]) - left.begin();
                int r = upper_bound(right.begin()+i+1, right.end(), left[i]) - right.begin();
                res = min(res, n - (i - l + r - i - 1));
            }
        }
        return res;

=======

        int n = nums.size();
        vector<int> min(n, INT_MAX);
        vector<int> max(n, INT_MIN);
        min[0] = nums[0];
        max[n-1] = nums[n-1];
        for(int i = 1; i < n; i++)
            min[i] = min(min[i-1], nums[i]);
        for(int i = n-2; i >= 0; i--)
            max[i] = max(max[i+1], nums[i]);
        int ans = INT_MAX;
        for(int i = 0; i < n; i++){
            int left = i;
            int right = n - i - 1;
            int l = left == 0 ? INT_MIN : min[left-1];
            int r = right == 0 ? INT_MAX : max[i+1];
            if(l < nums[i] && nums[i] < r)
                ans = min(ans, left + right);
        }
        return ans;

=======

        int n = nums.size();
        int left[n], right[n];
        left[0] = nums[0];
        for(int i = 1; i < n; i++){
            left[i] = min(left[i-1], nums[i]);
        }
        right[n-1] = nums[n-1];
        for(int i = n-2; i >= 0; i--){
            right[i] = max(right[i+1], nums[i]);
        }
        int ans = INT_MAX;
        for(int i = 0; i < n-1; i++){
            ans = min(ans, n-2-i + (left[i] < right[i+1]));
        }
        return min(ans, n-1);

=======

        int n = nums.size();
        vector<int> min(n);
        vector<int> max(n);
        min[0] = nums[0];
        max[n-1] = nums[n-1];
        
        for(int i=1; i<n; i++) {
            min[i] = min(min[i-1], nums[i]);
        }
        
        for(int i=n-2; i>=0; i--) {
            max[i] = max(max[i+1], nums[i]);
        }
        
        int ans = INT_MAX;
        for(int i=0; i<n; i++) {
            int curr = 0;
            if(i > 0) {
                curr += i - (lower_bound(min.begin(), min.begin() + i, nums[i]) - min.begin());
            }
            if(i < n - 1) {
                curr += n - i - 1 - (lower_bound(max.begin() + i + 1, max.end(), nums[i]) - max.begin());
            }
            ans = min(ans, curr);
        }
        return ans;

=======

        int n = nums.size();
        int min = 0;
        int max = 0;
        for (int i = 0; i < n; i++) {
            if (nums[i] < nums[min]) {
                min = i;
            }
            if (nums[i] > nums[max]) {
                max = i;
            }
        }
        int ans = min + n - max - 1;
        if (min > max) {
            ans--;
        }
        return ans;

=======

        int mx = *max_element(nums.begin(), nums.end());
        int mn = *min_element(nums.begin(), nums.end());
        return nums.size() - (find(nums.begin(), nums.end(), mx) - nums.begin() + 1) - (find(nums.rbegin(), nums.rend(), mn) - nums.rbegin() + 1);

=======

        int n = nums.size();
        vector<int> left(n, 0);
        vector<int> right(n, 0);
        for(int i = 1; i < n; i++) {
            if(nums[i] > nums[i - 1]) {
                left[i] = left[i - 1] + 1;
            }
        }
        for(int i = n - 2; i >= 0; i--) {
            if(nums[i] < nums[i + 1]) {
                right[i] = right[i + 1] + 1;
            }
        }
        int ans = n - 1;
        for(int i = 0; i < n; i++) {
            ans = min(ans, left[i] + right[i]);
        }
        return ans;

=======

        int n = nums.size();
        int res = n;
        int l = 0, r = n-1;
        int mn = nums[0], mx = nums[n-1];
        while (l < n && nums[l] == mn) l++;
        while (r >= 0 && nums[r] == mx) r--;
        if (l > r) return 0;
        if (l == r) return 1;
        res = min(res, l + n-1-r);
        while (l < r) {
            if (nums[l] < nums[r]) {
                mn = nums[l];
                while (l < n && nums[l] == mn) l++;
                res = min(res, l + n-1-r);
            } else {
                mx = nums[r];
                while (r >= 0 && nums[r] == mx) r--;
                res = min(res, l + n-1-r);
            }
        }
        return res;
