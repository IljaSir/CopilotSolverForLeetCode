Synthesizing 10/10 solutions

=======

        int n = prizePositions.size();
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            int j = upper_bound(prizePositions.begin(), prizePositions.end(), prizePositions[i] + k) - prizePositions.begin() - 1;
            ans = max(ans, j - i + 1);
        }
        return ans;

=======

        int i = 0, j = 0, n = prizePositions.size();
        int res = 0;
        while (j < n) {
            while (j < n && prizePositions[j] - prizePositions[i] <= k) {
                ++j;
            }
            res = max(res, j - i);
            ++i;
        }
        return res;

=======

        int n = prizePositions.size();
        int i = 0;
        int j = 0;
        int res = 0;
        while (j < n) {
            while (j < n && prizePositions[j] - prizePositions[i] <= k) {
                j++;
            }
            res = max(res, j - i);
            i++;
        }
        return res;

=======

        int n = prizePositions.size();
        int ans = 0;
        for (int i = 0; i < n; i++) {
            int l = i, r = n;
            while (l < r) {
                int m = (l + r + 1) / 2;
                if (prizePositions[m] - prizePositions[i] <= k) {
                    l = m;
                } else {
                    r = m - 1;
                }
            }
            int right = l;
            l = -1, r = i;
            while (l < r) {
                int m = (l + r + 1) / 2;
                if (prizePositions[i] - prizePositions[m] <= k) {
                    l = m;
                } else {
                    r = m - 1;
                }
            }
            int left = l;
            ans = max(ans, right - left);
        }
        return ans;

=======

        int n = prizePositions.size();
        int i = 0, j = 0;
        int count = 0;
        while (j < n) {
            while (j < n && prizePositions[j] - prizePositions[i] <= k) {
                j++;
            }
            count = max(count, j - i);
            i++;
        }
        return count;

=======

        int n = prizePositions.size();
        int res = 0;
        for(int i = 0; i < n; i++){
            int j = i;
            while(j < n && prizePositions[j] - prizePositions[i] <= k) j++;
            res = max(res, j - i);
        }
        return res;

=======

        int n = prizePositions.size();
        int ret = 0;
        for (int i = 0; i < n; i++) {
            int left = prizePositions[i] - k;
            int right = prizePositions[i] + k;
            int j = i;
            while (j < n && prizePositions[j] <= right) {
                j++;
            }
            ret = max(ret, j - i);
        }
        return ret;

=======

        int len = prizePositions.size();
        int left = 0;
        int right = 0;
        int res = 0;
        while (left < len && right < len) {
            while (right < len && prizePositions[right] - prizePositions[left] <= k) {
                right++;
            }
            res = max(res, right - left);
            left++;
        }
        return res;

=======

        int n = prizePositions.size();
        int res = 0;
        for(int i = 0; i < n; ++i){
            int l = i, r = n - 1;
            while(l < r){
                int mid = l + (r - l + 1)/2;
                if(prizePositions[mid] - prizePositions[i] <= k) l = mid;
                else r = mid - 1;
            }
            res = max(res, l - i + 1);
        }
        return res;

=======

        int n = prizePositions.size();
        vector<int> pre(n, 0);
        int res = 0;
        for(int i = 0; i < n; i++){
            if(i == 0) pre[i] = 1;
            else if(prizePositions[i] - prizePositions[i-1] <= k) pre[i] = pre[i-1] + 1;
            else pre[i] = 1;
            res = max(res, pre[i]);
        }
        for(int i = n-1; i >= 0; i--){
            if(i == n-1) pre[i] = 1;
            else if(prizePositions[i+1] - prizePositions[i] <= k) pre[i] = pre[i+1] + 1;
            else pre[i] = 1;
            res = max(res, pre[i]);
        }
        for(int i = 1; i < n-1; i++){
            if(prizePositions[i+1] - prizePositions[i-1] <= k) res = max(res, pre[i-1] + pre[i+1] + 1);
        }
        return res;
