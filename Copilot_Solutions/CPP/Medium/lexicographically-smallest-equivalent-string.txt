Synthesizing 5/10 solutions

=======

        vector<int> parent(26);
        for (int i = 0; i < 26; i++) {
            parent[i] = i;
        }
        for (int i = 0; i < s1.size(); i++) {
            int p1 = find(parent, s1[i] - 'a');
            int p2 = find(parent, s2[i] - 'a');
            parent[p1] = min(p1, p2);
            parent[p2] = min(p1, p2);
        }
        for (int i = 0; i < baseStr.size(); i++) {
            baseStr[i] = 'a' + find(parent, baseStr[i] - 'a');
        }
        return baseStr;
    }
    int find(vector<int>& parent, int x) {
        if (parent[x] == x) {
            return x;
        }
        return parent[x] = find(parent, parent[x]);

=======

        vector<int> parent(26);
        for (int i = 0; i < 26; ++i) {
            parent[i] = i;
        }
        for (int i = 0; i < s1.length(); ++i) {
            unionSet(parent, s1[i] - 'a', s2[i] - 'a');
        }
        for (int i = 0; i < baseStr.length(); ++i) {
            baseStr[i] = find(parent, baseStr[i] - 'a') + 'a';
        }
        return baseStr;

=======

        int p[26];
        for (int i = 0; i < 26; ++i) p[i] = i;
        for (int i = 0; i < s1.size(); ++i) {
            int x = s1[i] - 'a', y = s2[i] - 'a';
            int px = find(p, x), py = find(p, y);
            if (px < py) p[py] = px;
            else p[px] = py;
        }
        for (int i = 0; i < baseStr.size(); ++i) {
            baseStr[i] = 'a' + find(p, baseStr[i] - 'a');
        }
        return baseStr;

=======

        vector<int> parent(26);
        iota(parent.begin(), parent.end(), 0);
        function<int(int)> find = [&](int x) {
            return parent[x] == x ? x : parent[x] = find(parent[x]);
        };
        for (int i = 0; i < s1.size(); ++i) {
            parent[find(s1[i] - 'a')] = find(s2[i] - 'a');
        }
        for (int i = 0; i < baseStr.size(); ++i) {
            baseStr[i] = find(baseStr[i] - 'a') + 'a';
        }
        return baseStr;

=======

        int n = s1.size();
        vector<int> parent(26);
        iota(parent.begin(), parent.end(), 0);
        for (int i = 0; i < n; ++i) {
            int x = s1[i] - 'a', y = s2[i] - 'a';
            int px = find(parent, x), py = find(parent, y);
            if (px < py) parent[py] = px;
            else parent[px] = py;
        }
        for (auto& c : baseStr) {
            c = 'a' + find(parent, c - 'a');
        }
        return baseStr;
