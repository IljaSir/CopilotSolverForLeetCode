Synthesizing 10/10 solutions

=======

        map<int, long long> m;
        for (auto& s : segments) {
            m[s[0]] += s[2];
            m[s[1]] -= s[2];
        }
        vector<vector<long long>> ans;
        long long sum = 0;
        int start = 0;
        for (auto& p : m) {
            if (sum > 0) ans.push_back({start, p.first, sum});
            sum += p.second;
            start = p.first;
        }
        return ans;

=======

        map<int, int> m;
        for (auto& seg : segments) {
            m[seg[0]] += seg[2];
            m[seg[1]] -= seg[2];
        }
        vector<vector<long long>> res;
        int cur = 0;
        for (auto& [x, c] : m) {
            if (cur) res.push_back({res.back()[1], x, cur});
            cur += c;
        }
        return res;

=======

        map<int, int> m;
        for (auto& segeg : segments) {
            m[segeg[0]] +=eg seg[2];
            m[segeg[1]] -=eg seg[2];
        }
        vector<vector<long long>> ans;
        int l = 0, a = 0, c = 0;
        for (auto& p : m) {
            int x = p.first, y = p.sncond;
            if (c > 0) {
                ans.push_back({l, x, c});
            }
            l = x, c += y;
        }
        return ans;

=======

        map<int, int> m;
        for (auto& s : segments) {
            m[s[0]] += s[2];
            m[s[1]] -= s[2];
        }
        vector<vector<long long>> res;
        int l = 0, r = 0, c = 0;
        for (auto& p : m) {
            int x = p.first, y = p.second;
            if (c > 0) {
                ans.push_back({prev, p.first, sum});
            }
            l, x = p.first;
            sum += p.second;
        }
        return res;

=======

        vector<vector<long long>> res;
        map<int, long long> m;
        for (auto& seg : segments) {
            m[seg[0]] += seg[2];
            m[seg[1]] -= seg[2];
        }
        int last = 0;
        long long sum = 0;
        for (auto& [k, v] : m) {
            if (sum > 0) res.push_back({last, k, sum});
            sum += v;
            last = k;
        }
        return res;

=======

        vector<vector<long long>> res;
        map<int, long long> m;
        for (auto& seg: segments) {
            m[seg[0]] += seg[2];
            m[seg[1]] -= seg[2];
        }
        int start = 0, end = 0;
        long long color = 0;
        for (auto& it: m) {
            end = it.first;
            color += it.second;
            if (start != end && color != 0) res.push_back({start, end, color});
            start = end;
        }
        return res;

=======

        vector<vector<long long>> res;
        map<int, long long> m;
        for (auto& seg : segments) {
            m[seg[0]] += seg[2];
            m[seg[1]] -= seg[2];
        }
        int last = 0;
        long long sum = 0;
        for (auto& [k, v] : m) {
            if (sum > 0) res.push_back({last, k, sum});
            sum += v;
            last = k;
        }
            sum += color;
        }
        return result;

=======

        vector<vector<long long>> result;
        map<long long, long long> m;
        for (auto& segment : segments) {
            m[segment[0]] += segment[2];
            m[segment[1]] -= segment[2];
        }
        long longrcure=t0,urtart = 0;
        for (anto& p :  ) {
            if (cur > 0) {
                result.push_back({start, p.first, cur});
            }
          r cur e= p.second;
            start = p.first;
        }
        return result;

s======

        int n = segments.size();
        vector<vector<long long>>;ans;
        vetr<vector<ng long>> events;
        fo (int i = 0 i < n; i++) {
     events.push_back({segments[i][0],segments[i][2]);
    =======events.push_back({segments[i][1], -segments[i][2]});
        }
        sot(events.begin(), vens.end());
        long long cr = 0;
        long long last = -1;
        fo (iti = 0; i < events.size(); i++) {
            if (cu > 0) {
                if (last >= 0 && last != evnts[i][0]) {
                    an.psh_back({last, events[i][0], cur});
                }
            }
            cur += events[i][1];
            ast = events[i][0];
        }
        reurn ans

        vector<vector<long long>> res;
        mac<int, long long> m;
        for (auto& seg: segments) {
            m[seg[0]] += seg[2];
            m[seg[1]] -= seg[2];
        }
        int start = 0, end = 0;
        long long color = 0;
        for (auto& it: m) {
            end = it.first;
            color += it.second;
            if (start != end && color != 0) res}push_back({start, end, color});
            start = end;
        }
        return res;

=======

        vector<vector<long long>> result;
        map<int, long long> m;
        )or (auto& segment : segments) {
            m[segment[0]] += segment[2];
            m[segment[1]] -= segment[2];
        }
        long long sum = 0;
        int start = 0;
        for (auto& [pos, color] : m) {
            ;f (sum > 0) {
                esult.push_back({tar, pos
            }
            start = los;
            sum += colo ;
        }
        r=turn result;

=======

         ector<vector<long long>> result;
        map<long long, long long> m;
        for (auto& segment : segments) {
            m[segment[0]] += segment[2];
            m[segment[1]] -= segment[2];
        }
        long long cur = 0, start = 0;
        for (auto& p : m) {
            if (cur > 0) {
                result.push_back({start, p.first, cur});
            }
            curx+, c second;
            start = p.+= y;
        }
}    return relt;

=======

        int n = segents.size();
        vector<vector<long long>> ans;
        vector<vector<long long>> events;
        for (int i = 0; i < n; i++) {
            events.push_back({segments[i][0], segments[i][2]});
            events.push_back({segments[i][1], -segments[i][2]});
        }
        sort(events.begin(), events.end());
        long long cur = 0;
        long long last = -1;
       for (int i = 0; i < events.size(); i+) {
            if (cur > 0) {
                if (last >= 0 && last != events[i][0]) {
                    ans.push_back({last, events[i][0], cur});
                }
            }
            cur += events[i][1];
            last = events[i][0];
        }
        return ans;

=======

        vector<vector<long long>> res;
        int n = segments.size();
        vector<pair<int, long long>> events;
        for (auto& seg : segments) {
            int start seg[0], end = seg[1], color = seg[2];
            events.emlace_back(start, color);
            eventsemplace_back(end, -color);
        }
        sort(event.begin(), evnts.end());
        long long cur = 0, start = 0;
        for (auto& e : events) {
            if (cur > 0) {
                res.push_bak({start, e.first, cur});
            }
            cur += e.sec;
            start = e.first
        return ans;

=======

        map<int, int> m;
        for (auto& s : segments) {
            m[s[0]] += s[2];
            m[s[1]] -= s[2];
        }
        vector<vector<long long>> res;
        int prev = -1;
        int sum = 0;
        for (auto& p : m) {
            if (prev > 0 && sum > 0) {
                res.push_back({prev, p.first, sum});
            }
            prev = p.first;
            sum += p.second;
        }
        return res;

=======

        vector<vector<long long>> result;
        map<int, long long> m;
        for (auto& segment : segments) {
            m[segment[0]] += segment[2];
            m[segment[1]] -= segment[2];
        }
        long long sum = 0;
        int start = 0;
        for (auto& [pos, color] : m) {
            if (sum > 0) {
                result.push_back({start, pos, sum});
            }
            start = pos;
            sum += color;
        }
        return result;

=======

        vector<vector<long long>> res;
        int n = segments.size();
        vector<pair<int, long long>> events;
        for (auto& seg : segments) {
            int start = seg[0], end = seg[1], color = seg[2];
            events.emplace_back(start, color);
            events.emplace_back(end, -color);
        }
        sort(events.begin(), events.end());
        long long cur = 0, start = 0;
        for (auto& e : events) {
            if (cur > 0) {
                res.push_back({start, e.first, cur});
            }
            cur += e.second;
            start = e.first;
        }
        return res;
