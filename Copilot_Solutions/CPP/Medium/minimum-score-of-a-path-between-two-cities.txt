Synthesizing 10/10 solutions

=======

        vector<vector<pair<int, int>>> graph(n + 1);
        for (auto& road : roads) {
            graph[road[0]].push_back({road[1], road[2]});
            graph[road[1]].push_back({road[0], road[2]});
        }
        vector<int> dist(n + 1, INT_MAX);
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        pq.push({0, 1});
        while (!pq.empty()) {
            auto [d, u] = pq.top();
            pq.pop();
            if (dist[u] < d) continue;
            for (auto& [v, w] : graph[u]) {
                if (dist[v] > max(d, w)) {
                    dist[v] = max(d, w);
                    pq.push({dist[v], v});
                }
            }
        }
        return dist[n];

=======

        vector<vector<pair<int, int>>> graph(n + 1);
        for (auto& road : roads) {
            graph[road[0]].push_back({road[1], road[2]});
            graph[road[1]].push_back({road[0], road[2]});
        }

        vector<int> dist(n + 1, INT_MAX);
        dist[1] = 0;
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        pq.push({0, 1});
        while (!pq.empty()) {
            auto [d, node] = pq.top();
            pq.pop();
            if (d > dist[node]) continue;
            for (auto& [to, cost] : graph[node]) {
                if (dist[node] + cost < dist[to]) {
                    dist[to] = dist[node] + cost;
                    pq.push({dist[to], to});
                }
            }
        }
        return dist[n];

=======

        vector<vector<pair<int, int>>> graph(n + 1);
        for (auto r : roads) {
            graph[r[0]].push_back({r[1], r[2]});
            graph[r[1]].push_back({r[0], r[2]});
        }
        vector<int> dist(n + 1, INT_MAX);
        vector<int> visited(n + 1, 0);
        dist[1] = 0;
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        pq.push({0, 1});
        while (!pq.empty()) {
            auto [d, u] = pq.top();
            pq.pop();
            if (visited[u]) continue;
            visited[u] = 1;
            for (auto [v, w] : graph[u]) {
                if (dist[v] > max(d, w)) {
                    dist[v] = max(d, w);
                    pq.push({dist[v], v});
                }
            }
        }
        return dist[n];

=======

        vector<vector<pair<int, int>>> g(n);
        for (auto& r: roads) {
            g[r[0]-1].push_back({r[1]-1, r[2]});
            g[r[1]-1].push_back({r[0]-1, r[2]});
        }
        vector<int> dist(n, INT_MAX);
        dist[0] = 0;
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        pq.push({0, 0});
        while (!pq.empty()) {
            auto p = pq.top();
            pq.pop();
            if (p.first != dist[p.second]) continue;
            for (auto& e: g[p.second]) {
                if (dist[e.first] > max(dist[p.second], e.second)) {
                    dist[e.first] = max(dist[p.second], e.second);
                    pq.push({dist[e.first], e.first});
                }
            }
        }
        return dist[n-1];

=======

        vector<vector<pair<int, int>>> g(n);
        for (auto& road: roads) {
            g[road[0] - 1].push_back({road[1] - 1, road[2]});
            g[road[1] - 1].push_back({road[0] - 1, road[2]});
        }
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        pq.push({0, 0});
        vector<int> dist(n, INT_MAX);
        dist[0] = 0;
        while (!pq.empty()) {
            auto [d, u] = pq.top();
            pq.pop();
            if (d > dist[u]) continue;
            for (auto& [v, w]: g[u]) {
                if (dist[v] > max(dist[u], w)) {
                    dist[v] = max(dist[u], w);
                    pq.push({dist[v], v});
                }
            }
        }
        return dist[n - 1];

=======

        vector<vector<int>> g(n + 1, vector<int>(n + 1, 0));
        for (auto& r : roads) {
            g[r[0]][r[1]] = g[r[1]][r[0]] = r[2];
        }
        vector<int> dist(n + 1, 0x3f3f3f3f);
        vector<bool> vis(n + 1, false);
        dist[1] = 0;
        for (int i = 1; i <= n; ++i) {
            int u = -1;
            for (int j = 1; j <= n; ++j) {
                if (!vis[j] && (u == -1 || dist[j] < dist[u])) {
                    u = j;
                }
            }
            vis[u] = true;
            for (int v = 1; v <= n; ++v) {
                if (g[u][v]) {
                    dist[v] = min(dist[v], max(dist[u], g[u][v]));
                }
            }
        }
        return dist[n];

=======

        vector<vector<pair<int,int>>> adj(n);
        for (auto r: roads) {
            adj[r[0]-1].push_back({r[1]-1,r[2]});
            adj[r[1]-1].push_back({r[0]-1,r[2]});
        }
        vector<int> dist(n, INT_MAX);
        vector<bool> visited(n, false);
        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
        pq.push({0,0});
        while (!pq.empty()) {
            auto [d, u] = pq.top();
            pq.pop();
            if (visited[u]) continue;
            visited[u] = true;
            dist[u] = d;
            for (auto [v, w]: adj[u]) {
                if (visited[v]) continue;
                pq.push({max(d,w),v});
            }
        }
        return dist[n-1];

=======

        const int INF = 0x3f3f3f3f;
        vector<vector<int>> dist(n, vector<int>(n, INF));
        for (int i = 0; i < n; i++) {
            dist[i][i] = 0;
        }
        for (auto e : roads) {
            int u = e[0] - 1, v = e[1] - 1, w = e[2];
            dist[u][v] = dist[v][u] = w;
        }
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    dist[i][j] = min(dist[i][j], max(dist[i][k], dist[k][j]));
                }
            }
        }
        return dist[0][n - 1];

=======

        vector<vector<int>> dp(n+1, vector<int>(n+1, INT_MAX));
        for (auto &r: roads) {
            dp[r[0]][r[1]] = min(dp[r[0]][r[1]], r[2]);
            dp[r[1]][r[0]] = min(dp[r[1]][r[0]], r[2]);
        }
        for (int i = 1; i <= n; ++i) dp[i][i] = 0;
        for (int k = 1; k <= n; ++k) {
            for (int i = 1; i <= n; ++i) {
                for (int j = 1; j <= n; ++j) {
                    dp[i][j] = min(dp[i][j], max(dp[i][k], dp[k][j]));
                }
            }
        }
        return dp[1][n];

=======

        vector<vector<int>> adj(n + 1, vector<int>(n + 1, 0));
        for (auto r : roads) {
            if (adj[r[0]][r[1]] == 0 || adj[r[0]][r[1]] > r[2]) {
                adj[r[0]][r[1]] = r[2];
                adj[r[1]][r[0]] = r[2];
            }
        }
        vector<int> dist(n + 1, INT_MAX);
        vector<bool> visited(n + 1, false);
        dist[1] = 0;
        for (int i = 1; i <= n; i++) {
            int minDist = INT_MAX;
            int minIdx = -1;
            for (int j = 1; j <= n; j++) {
                if (!visited[j] && dist[j] < minDist) {
                    minIdx = j;
                    minDist = dist[j];
                }
            }
            if (minIdx == -1) {
                break;
            }
            visited[minIdx] = true;
            for (int j = 1; j <= n; j++) {
                if (adj[minIdx][j] != 0 && !visited[j] && dist[j] > adj[minIdx][j]) {
                    dist[j] = adj[minIdx][j];
                }
            }
        }
        return dist[n];
