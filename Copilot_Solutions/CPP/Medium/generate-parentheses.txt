Synthesizing 10/10 solutions

=======

        vector<string> res;
        if (n == 0) {
            res.push_back("");
            return res;
        }
        for (int i = 0; i < n; ++i) {
            vector<string> left = generateParenthesis(i);
            vector<string> right = generateParenthesis(n - i - 1);
            for (auto l : left) {
                for (auto r : right) {
                    res.push_back("(" + l + ")" + r);
                }
            }
        }
        return res;

=======

        vector<string> res;
        string cur;
        dfs(res, cur, 0, 0, n);
        return res;
    }
    void dfs(vector<string> &res, string &cur, int left, int right, int n) {
        if (left == n && right == n) {
            res.push_back(cur);
            return;
        }
        if (left < n) {
            cur.push_back('(');
            dfs(res, cur, left + 1, right, n);
            cur.pop_back();
        }
        if (right < left) {
            cur.push_back(')');
            dfs(res, cur, left, right + 1, n);
            cur.pop_back();
        }

=======

        vector<string> result;
        generateParenthesis(result, "", 0, 0, n);
        return result;
    }
    void generateParenthesis(vector<string>& result, string str, int open, int close, int max) {
        if (str.length() == max * 2) {
            result.push_back(str);
            return;
        }
        if (open < max) {
            generateParenthesis(result, str + "(", open + 1, close, max);
        }
        if (close < open) {
            generateParenthesis(result, str + ")", open, close + 1, max);
        }

=======

        vector<string> res;
        string s;
        helper(n, 0, 0, s, res);
        return res;
    }
    void helper(int n, int left, int right, string s, vector<string>& res) {
        if (left == n && right == n) {
            res.push_back(s);
            return;
        }
        if (left < n) {
            helper(n, left + 1, right, s + "(", res);
        }
        if (right < left) {
            helper(n, left, right + 1, s + ")", res);
        }

=======

        vector<string> res;
        string s;
        dfs(res, s, n, n);
        return res;
    }
    void dfs(vector<string>& res, string s, int l, int r) {
        if (l == 0 && r == 0) {
            res.push_back(s);
            return;
        }
        if (l > r) return;
        if (l > 0) dfs(res, s + '(', l - 1, r);
        if (r > 0) dfs(res, s + ')', l, r - 1);

=======

        vector<string> ret;
        string s;
        dfs(ret, s, 0, 0, n);
        return ret;
    }

    void dfs(vector<string> &ret, string &s, int l, int r, int n) {
        if (l == n && r == n) {
            ret.push_back(s);
            return;
        }
        if (l < n) {
            s.push_back('(');
            dfs(ret, s, l + 1, r, n);
            s.pop_back();
        }
        if (r < l) {
            s.push_back(')');
            dfs(ret, s, l, r + 1, n);
            s.pop_back();
        }

=======

        vector<string> res;
        string s = "";
        helper(n, n, s, res);
        return res;
    }
    void helper(int left, int right, string& s, vector<string>& res) {
        if (left == 0 && right == 0) {
            res.push_back(s);
            return;
        }
        if (left > 0) {
            s.push_back('(');
            helper(left - 1, right, s, res);
            s.pop_back();
        }
        if (right > 0 && right > left) {
            s.push_back(')');
            helper(left, right - 1, s, res);
            s.pop_back();
        }

=======

        vector<string> result;
        if (n == 0) {
            return result;
        }
        dfs(n, n, "", result);
        return result;

=======

        vector<string> result;
        string str;
        generateParenthesisHelper(n, n, str, result);
        return result;
    }
    
    void generateParenthesisHelper(int left, int right, string str, vector<string>& result) {
        if (left == 0 && right == 0) {
            result.push_back(str);
            return;
        }
        if (left > 0) {
            generateParenthesisHelper(left - 1, right, str + "(", result);
        }
        if (right > left) {
            generateParenthesisHelper(left, right - 1, str + ")", result);
        }

=======

        vector<string> result;
        if (n <= 0) return result;
        string temp;
        generateParenthesisCore(n, 0, 0, temp, result);
        return result;
    }
    void generateParenthesisCore(int n, int left, int right, string& temp, vector<string>& result) {
        if (left == n && right == n) {
            result.push_back(temp);
            return;
        }
        if (left < n) {
            temp.push_back('(');
            generateParenthesisCore(n, left + 1, right, temp, result);
            temp.pop_back();
        }
        if (right < left) {
            temp.push_back(')');
            generateParenthesisCore(n, left, right + 1, temp, result);
            temp.pop_back();
        }
