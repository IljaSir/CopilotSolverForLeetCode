Synthesizing 10/10 solutions

=======

        int n = skill.size();
        sort(skill.begin(), skill.end());
        long long res = 0;
        for (int i = 0; i < n / 2; ++i) {
            res += (long long)skill[i] * skill[n - i - 1];
        }
        return res;
    }
    int maxSumOfTwoSubsets(vector<int>& skill) {
        int n = skill.size();
        int sum = accumulate(skill.begin(), skill.end(), 0);
        long long res = 0;
        for (int i = 1; i < (1 << n); ++i) {
            int cnt = 0;
            int s = 0;
            for (int j = 0; j < n; ++j) {
                if (i & (1 << j)) {
                    ++cnt;
                    s += skill[j];
                }
            }
            if (cnt == n / 2) {
                res = max(res, dividePlayers(skill) + s * (sum - s));
            }
        }
        return res % 1000000007;

=======

        int n = skill.size();
        sort(skill.begin(), skill.end());
        long long res = 0;
        for (int i = 0; i < n / 2; i++) {
            res += (long long)skill[i] * skill[n - i - 1];
        }
        return res;
    }
    int maxEqualSum(vector<int>& skill) {
        long long sum = accumulate(skill.begin(), skill.end(), 0LL);
        int n = skill.size();
        long long res = 0;
        for (int i = 0; i < n / 2; i++) {
            res = max(res, dividePlayers(skill));
            swap(skill[i], skill[n - i - 1]);
            res = max(res, dividePlayers(skill));
            swap(skill[i], skill[n - i - 1]);
        }
        return res;

=======

        int n = skill.size();
        sort(skill.begin(), skill.end());
        long long sum = 0;
        for (int i = 0; i < n / 2; ++i) {
            sum += (long long)skill[i] * skill[n - i - 1];
        }
        return sum;
    }
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        int max1 = 0, max2 = 0;
        for (int i = 0; i < n; ++i) {
            if (nums[i] > max1) {
                max2 = max1;
                max1 = nums[i];
            } else if (nums[i] > max2) {
                max2 = nums[i];
            }
        }
        return (max1 - 1) * (max2 - 1);
    }
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        int max1 = 0, max2 = 0;
        for (int i = 0; i < n; ++i) {
            if (nums[i] > max1) {
                max2 = max1;
                max1 = nums[i];
            } else if (nums[i] > max2) {
                max2 = nums[i];
            }
        }
        return (max1 - 1) * (max2 - 1);
    }
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        int max1 = 0, max2 = 0;
        for (int i = 0; i < n; ++i) {
            if (nums[i] > max1) {
                max2 = max1;
                max1 = nums[i];
            } else if (nums[i] > max2) {
                max2 = nums[i];
            }
        }
        return (max1 - 1) * (max2 - 1);

=======

        sort(skill.begin(), skill.end());
        long long res = 0;
        for (int i = 0; i < skill.size() / 2; i++) {
            res += (long long)skill[i] * skill[skill.size() - i - 1];
        }
        return res;

=======

        sort(skill.begin(), skill.end());
        long long res = 0;
        for (int i = 0; i < skill.size() / 2; i++) {
            res += skill[i] * skill[skill.size() - i - 1];
        }
        return res;
    }
    int maxEqualSum(vector<int>& nums) {
        int sum = 0;
        for (int num : nums) sum += num;
        int res = 0;
        for (int i = 0; i < nums.size() - 1; i++) {
            sum -= nums[i];
            if (sum == nums[i]) res = max(res, sum);
        }
        return res;
    }
    int maxEqualSum2(vector<int>& nums) {
        unordered_map<int, int> mp;
        int sum = 0;
        int res = 0;
        for (int i = 0; i < nums.size(); i++) {
            sum += nums[i];
            if (sum == 0) res = max(res, i + 1);
            if (mp.count(sum)) res = max(res, i - mp[sum]);
            else mp[sum] = i;
        }
        return res;
    }
    int maxEqualSum3(vector<int>& nums) {
        unordered_map<int, int> mp;
        int sum = 0;
        int res = 0;
        mp[0] = -1;
        for (int i = 0; i < nums.size(); i++) {
            sum += nums[i];
            if (mp.count(sum)) res = max(res, i - mp[sum]);
            else mp[sum] = i;
        }
        return res;
    }
    int maxEqualSum4(vector<int>& nums) {
        unordered_map<int, int> mp;
        int sum = 0;
        int res = 0;
        mp[0] = -1;
        for (int i = 0; i < nums.size(); i++) {
            sum += nums[i];
            if (mp.count(sum)) res = max(res, i - mp[sum]);
            mp[sum] = i;
        }
        return res;

=======

        sort(skill.begin(), skill.end());
        long long sum = 0;
        for (int i = 0; i < skill.size(); i += 2) {
            sum += (long long)skill[i] * skill[i + 1];
        }
        return sum;

=======

        sort(skill.begin(), skill.end());
        long long ans = 0;
        for (int i = 0; i < skill.size()/2; i++) {
            ans += (long long)skill[i] * skill[skill.size()-i-1];
        }
        return ans;
    }
    int maxmiumScore(vector<int>& skill, int k) {
        int n = skill.size();
        vector<int> pre(n+1);
        for (int i = 0; i < n; i++) {
            pre[i+1] = pre[i] + skill[i];
        }
        vector<vector<int>> dp(n, vector<int>(k+1, -1));
        for (int i = 0; i < n; i++) {
            dp[i][1] = pre[i+1];
        }
        for (int i = 0; i < n; i++) {
            for (int j = 2; j <= k; j++) {
                for (int p = 1; p <= i; p++) {
                    if (dp[i-p][j-1] != -1) {
                        dp[i][j] = max(dp[i][j], dp[i-p][j-1] + pre[p] * pre[i-p+1]);
                    }
                }
            }
        }
        return dp[n-1][k];
    }
    int maxmiumScore2(vector<int>& skill, int k) {
        int n = skill.size();
        vector<int> pre(n+1);
        for (int i = 0; i < n; i++) {
            pre[i+1] = pre[i] + skill[i];
        }
        vector<vector<int>> dp(n, vector<int>(k+1, -1));
        for (int i = 0; i < n; i++) {
            dp[i][1] = pre[i+1];
        }
        for (int i = 0; i < n; i++) {
            for (int j = 2; j <= k; j++) {
                for (int p = 1; p <= i; p++) {
                    if (dp[i-p][j-1] != -1) {
                        dp[i][j] = max(dp[i][j], dp[i-p][j-1] + pre[p] * pre[i-p+1]);
                    }
                }

=======

        long long ans = 0;
        int n = skill.size();
        sort(skill.begin(), skill.end());
        for (int i = 0; i < n; i += 2) {
            ans += (long long) skill[i] * skill[i + 1];
        }
        return ans;
    }
    long long dividePlayers2(vector<int>& skill) {
        long long ans = 0;
        int n = skill.size();
        sort(skill.begin(), skill.end());
        for (int i = 0; i < n; i += 2) {
            ans += (long long) skill[i] * skill[i + 1];
        }
        return ans;

=======

        long long res = 0;
        sort(skill.begin(), skill.end());
        for (int i = 0, j = skill.size() - 1; i < j; ++i, --j)
            res += (long long)skill[i] * skill[j];
        return res;

=======

        int n = skill.size();
        int sum = accumulate(skill.begin(), skill.end(), 0);
        if (sum % (n / 2) != 0) return -1;
        int target = sum / (n / 2);
        sort(skill.begin(), skill.end());
        long long ans = 0;
        for (int i = 0; i < n; i += 2) {
            ans += 1ll * skill[i] * skill[i + 1];
        }
        return ans;
