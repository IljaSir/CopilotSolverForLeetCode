Synthesizing 10/10 solutions

=======

        if (connections.size() < n - 1) return -1;
        vector<int> parent(n, 0);
        for (int i = 0; i < n; ++i) parent[i] = i;
        for (auto& c : connections) {
            int p1 = find(parent, c[0]);
            int p2 = find(parent, c[1]);
            if (p1 != p2) {
                parent[p2] = p1;
                --n;
            }
        }
        return n - 1;

=======

        if (connections.size() < n - 1) return -1;
        vector<int> parent(n);
        for (int i = 0; i < n; ++i) parent[i] = i;
        for (auto& c : connections) {
            int r1 = find(parent, c[0]);
            int r2 = find(parent, c[1]);
            if (r1 != r2) parent[r1] = r2;
        }
        int res = 0;
        for (int i = 0; i < n; ++i) {
            if (parent[i] == i) ++res;
        }
        return res - 1;

=======

        if (connections.size() < n - 1) return -1;
        vector<int> parent(n, 0);
        for (int i = 0; i < n; i++) parent[i] = i;
        for (auto &c : connections) {
            int x = find(parent, c[0]);
            int y = find(parent, c[1]);
            parent[x] = y;
        }
        unordered_set<int> s;
        for (int i = 0; i < n; i++) s.insert(find(parent, i));
        return s.size() - 1;

=======

        if (connections.size() < n - 1) return -1;
        vector<int> parents(n);
        for (int i = 0; i < n; ++i) {
            parents[i] = i;
        }
        for (auto& connection : connections) {
            int p1 = find(parents, connection[0]);
            int p2 = find(parents, connection[1]);
            if (p1 != p2) {
                parents[p1] = p2;
            }
        }
        int count = 0;
        for (int i = 0; i < n; ++i) {
            if (parents[i] == i) {
                ++count;
            }
        }
        return count - 1;

=======

        if (connections.size() < n - 1) return -1;
        vector<int> parent(n);
        for (int i = 0; i < n; i++) parent[i] = i;
        for (auto& c : connections) {
            int x = c[0], y = c[1];
            int px = find(parent, x);
            int py = find(parent, y);
            if (px != py) {
                parent[py] = px;
                n--;
            }
        }
        return n - 1;
    }
    int find(vector<int>& parent, int x) {
        if (parent[x] != x) {
            parent[x] = find(parent, parent[x]);
        }
        return parent[x];

=======

        int m = connections.size();
        if (m < n - 1) {
            return -1;
        }
        vector<int> parent(n);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
        for (auto &c : connections) {
            int a = c[0], b = c[1];
            if (find(a, parent) != find(b, parent)) {
                parent[find(a, parent)] = find(b, parent);
            }
        }
        int cnt = 0;
        for (int i = 0; i < n; i++) {
            if (parent[i] == i) {
                cnt++;
            }
        }
        return cnt - 1;
    }
    int find(int x, vector<int> &parent) {
        if (parent[x] == x) {
            return x;
        }
        return parent[x] = find(parent[x], parent);

=======

        if (connections.size() < n - 1) return -1;
        vector<int> parent(n);
        for (int i = 0; i < n; i++) parent[i] = i;
        int cnt = n;
        for (auto& c : connections) {
            int x = find(parent, c[0]);
            int y = find(parent, c[1]);
            if (x != y) {
                parent[y] = x;
                cnt--;
            }
        }
        return cnt - 1;

=======

        if (connections.size() < n - 1) return -1;
        vector<int> p(n);
        iota(p.begin(), p.end(), 0);
        for (auto& c : connections) {
            int x = find(p, c[0]), y = find(p, c[1]);
            if (x != y) p[x] = y;
        }
        unordered_set<int> s;
        for (int i = 0; i < n; ++i) s.insert(find(p, i));
        return s.size() - 1;

=======

        if (connections.size() < n - 1) return -1;
        vector<int> parent(n);
        iota(parent.begin(), parent.end(), 0);
        for (auto& c: connections) {
            int x = find(parent, c[0]);
            int y = find(parent, c[1]);
            parent[x] = y;
        }
        unordered_set<int> s;
        for (int i = 0; i < n; ++i) {
            s.insert(find(parent, i));
        }
        return s.size() - 1;
    }
    int find(vector<int>& parent, int x) {
        if (parent[x] != x) {
            parent[x] = find(parent, parent[x]);
        }
        return parent[x];

=======

        if (connections.size() < n - 1) return -1;
        vector<int> parent(n);
        iota(parent.begin(), parent.end(), 0);
        int res = n;
        for (auto& c : connections) {
            int p1 = find(parent, c[0]);
            int p2 = find(parent, c[1]);
            if (p1 != p2) {
                parent[p1] = p2;
                --res;
            }
        }
        return res - 1;
