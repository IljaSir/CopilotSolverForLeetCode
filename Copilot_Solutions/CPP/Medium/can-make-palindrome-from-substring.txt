Synthesizing 10/10 solutions (Duplicates hidden)

=======

        int n = s.size();
        vector<vector<int>> dp(n + 1, vector<int>(26, 0));
        for (int i = 0; i < n; ++i) {
            dp[i + 1] = dp[i];
            ++dp[i + 1][s[i] - 'a'];
        }
        vector<bool> ans;
        for (auto &q : queries) {
            int oddCnt = 0;
            for (int i = 0; i < 26; ++i) {
                oddCnt += (dp[q[1] + 1][i] - dp[q[0]][i]) & 1;
            }
            ans.push_back(oddCnt / 2 <= q[2]);
        }
        return ans;

=======

        int n = s.size();
        vector<vector<int>> count(n + 1, vector<int>(26, 0));
        for (int i = 0; i < n; i++) {
            count[i + 1] = count[i];
            count[i + 1][s[i] - 'a']++;
        }
        vector<bool> res;
        for (auto& q: queries) {
            int odd = 0;
            for (int i = 0; i < 26; i++) {
                odd += (count[q[1] + 1][i] - count[q[0]][i]) % 2;
            }
            res.push_back(odd / 2 <= q[2]);
        }
        return res;

=======

        int n = s.size();
        vector<vector<int>> cnt(n + 1, vector<int>(26, 0));
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < 26; ++j) {
                cnt[i + 1][j] = cnt[i][j];
            }
            cnt[i + 1][s[i] - 'a']++;
        }
        vector<bool> ans;
        for (auto q: queries) {
            int odd = 0;
            for (int i = 0; i < 26; ++i) {
                odd += (cnt[q[1] + 1][i] - cnt[q[0]][i]) & 1;
            }
            ans.push_back(odd / 2 <= q[2]);
        }
        return ans;

=======

        int n = s.size();
        vector<int> dp(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            dp[i] = dp[i - 1] ^ (1 << (s[i - 1] - 'a'));
        }
        vector<bool> ans;
        for (auto& q : queries) {
            int diff = dp[q[1] + 1] ^ dp[q[0]];
            int cnt = 0;
            for (int i = 0; i < 26; i++) {
                if (diff & (1 << i)) cnt++;
            }
            ans.push_back(cnt / 2 <= q[2]);
        }
        return ans;

=======

        int n = s.size();
        vector<vector<int>> count(n + 1, vector<int>(26, 0));
        for (int i = 0; i < n; i++) {
            count[i + 1] = count[i];
            count[i + 1][s[i] - 'a']++;
        }
        vector<bool> res;
        for (auto& q: queries) {
            int odd = 0;
            for (int i = 0; i < 26; i++) {
                odd += (count[q[1] + 1][i] - count[q[0]][i]) % 2;
            }
            res.push_back(odd / 2 <= q[2]);
        }
        return res;

=======ns;

=======

        vector<bool> res;
        vector<int> dp(s.length() + 1, 0);
        for (int i = 0; i < s.legth(); i++) {
            dp[i + 1] = dp[i] ^ (1 << (s[i] - 'a'));
        }
        for (auto &q : queries) {
            int cnt = __builtin_popcount(dp[q[1] + 1] ^ dp[q[0]]);
            res.push_back(cnt / 2 <= q[2]);
        }
        return res;

=======

        vector<bool> res;
        int n = s.length();
        vector<vector<int>> preSum(n + 1, vector<int>(26, 0));
        for (int i = 0; i < n; ++i) {
            preSum[i + 1] = preSum[i];
            preSum[i + 1][s[i] - 'a']++;
        }
        for (auto& q : queries) {
            int odd = 0;
            for (int i = 0; i < 26; ++i) {
                odd += (preSum[q[1] + 1][i] - preSum[q[0]][i]) % 2;
            }
            res.push_back(odd / 2 <= q[2]);
        }
        return re

        int n = s.size();
        vector<vector<int>> cnt(n + 1, vector<int>(26, 0));
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < 26; ++j) {
                cnt[i + 1][j] = cnt[i][j];
            }
            cnt[i + 1][s[i] - 'a']++;
        }
        vector<bool> ans;
        for (auto q: queries) {
            int odd = 0;
            for (int i = 0; i < 26; ++i) {
                odd += (cnt[q[1] + 1][i] - cnt[q[0]][i]) & 1;
            }
            ans.push_back(odd / 2 <= q[2]);
        }
        return ans;

=======

        vector<bool> ans;
        int n = s.size();
        vector<vector<int>> dp(n + 1, vector<int>(26, 0));
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < 26; ++j) {
                dp[i + 1][j] = dp[i][j];
            }
            dp[i + 1][s[i] - 'a']++;
        }
        for (auto &q : queries) {
            int odd = 0;
            for (int i = 0; i < 26; ++i) {
                odd += (dp[q[1] + 1][i] - dp[q[0]][i]) % 2;
            }
            ans.push_back(odd / 2 <= q[2]);
        }
        return ans;

=======

        vector<bool> ans;
        for(auto q: queries){
            int l = q[0], r = q[1], k = q[2];
            string sub = s.substr(l, r-l+1);
            int n = sub.length();
            int cnt = 0;
            unordered_map<char, int> m;
            for(int i = 0; i < n; i++){
                m[sub[i]]++;
            }
            for(auto it = m.begin(); it != m.end(); it++){
                if(it->second%2 != 0) cnt++;
            }
            if(cnt/2 <= k) ans.push_back(true);
            else ans.push_back(false);
        }
        return ans;
