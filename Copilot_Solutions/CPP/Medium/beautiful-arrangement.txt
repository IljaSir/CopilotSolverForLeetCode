Synthesizing 10/10 solutions

=======

        vector<int> nums(n);
        for (int i = 0; i < n; ++i) {
            nums[i] = i + 1;
        }
        int ans = 0;
        dfs(nums, 0, ans);
        return ans;

=======

        vector<int> nums(n);
        for (int i = 0; i < n; i++) {
            nums[i] = i + 1;
        }
        int ans = 0;
        dfs(nums, 0, ans);
        return ans;
    }
    
    void dfs(vector<int>& nums, int start, int& ans) {
        if (start == nums.size()) {
            ans++;
            return;
        }
        for (int i = start; i < nums.size(); i++) {
            swap(nums[start], nums[i]);
            if (nums[start] % (start + 1) == 0 || (start + 1) % nums[start] == 0) {
                dfs(nums, start + 1, ans);
            }
            swap(nums[start], nums[i]);
        }

=======

        vector<bool> used(n + 1, false);
        int ans = 0;
        function<void(int)> dfs = [&](int index) {
            if (index == n + 1) {
                ans++;
                return;
            }
            for (int i = 1; i <= n; i++) {
                if (!used[i] && (i % index == 0 || index % i == 0)) {
                    used[i] = true;
                    dfs(index + 1);
                    used[i] = false;
                }
            }
        };
        dfs(1);
        return ans;

=======

        vector<int> nums;
        for (int i = 1; i <= n; i++) {
            nums.push_back(i);
        }
        return countArrangement(nums, 0);
    }
    int countArrangement(vector<int>& nums, int start) {
        if (start == nums.size()) {
            return 1;
        }
        int count = 0;
        for (int i = start; i < nums.size(); i++) {
            if (nums[i] % (start + 1) == 0 || (start + 1) % nums[i] == 0) {
                swap(nums[i], nums[start]);
                count += countArrangement(nums, start + 1);
                swap(nums[i], nums[start]);
            }
        }
        return count;

=======

        int res = 0;
        vector<bool> visited(n+1, false);
        dfs(n, 1, visited, res);
        return res;
    }
    void dfs(int n, int pos, vector<bool>& visited, int& res) {
        if (pos > n) {
            res++;
            return;
        }
        for (int i = 1; i <= n; i++) {
            if (!visited[i] && (pos % i == 0 || i % pos == 0)) {
                visited[i] = true;
                dfs(n, pos+1, visited, res);
                visited[i] = false;
            }
        }

=======

        vector<int> nums(n);
        for (int i = 0; i < n; ++i) nums[i] = i + 1;
        int ans = 0;
        do {
            bool ok = true;
            for (int i = 0; i < n; ++i) {
                if ((nums[i] % (i + 1) != 0) && ((i + 1) % nums[i] != 0)) {
                    ok = false;
                    break;
                }
            }
            if (ok) ans++;
        } while (next_permutation(nums.begin(), nums.end()));
        return ans;

=======

        int ans = 0;
        vector<int> nums(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            nums[i] = i;
        }
        dfs(nums, 1, ans);
        return ans;
    }
    void dfs(vector<int>& nums, int idx, int& ans) {
        if (idx == nums.size()) {
            ++ans;
            return;
        }
        for (int i = idx; i < nums.size(); ++i) {
            swap(nums[idx], nums[i]);
            if (nums[idx] % idx == 0 || idx % nums[idx] == 0) {
                dfs(nums, idx + 1, ans);
            }
            swap(nums[idx], nums[i]);
        }

=======

        vector<int> nums(n);
        iota(nums.begin(), nums.end(), 1);
        return countArrangement(nums, 0);
    }
    int countArrangement(vector<int>& nums, int i) {
        if (i == nums.size()) {
            return 1;
        }
        int res = 0;
        for (int j = i; j < nums.size(); ++j) {
            if (nums[j] % (i + 1) == 0 || (i + 1) % nums[j] == 0) {
                swap(nums[i], nums[j]);
                res += countArrangement(nums, i + 1);
                swap(nums[i], nums[j]);
            }
        }
        return res;

=======

        vector<bool> used(n+1, false);
        int res = 0;
        backtrack(n, 1, res, used);
        return res;
    }
    
    void backtrack(int n, int pos, int& res, vector<bool>& used) {
        if (pos > n) {
            ++res;
            return;
        }
        for (int i = 1; i <= n; ++i) {
            if (used[i]) continue;
            if (i % pos == 0 || pos % i == 0) {
                used[i] = true;
                backtrack(n, pos+1, res, used);
                used[i] = false;
            }
        }

=======

        vector<int> nums(n);
        for(int i = 0; i < n; i++) nums[i] = i + 1;
        return countArrangement(nums, 0);
    }
    int countArrangement(vector<int>& nums, int start) {
        if(start == nums.size()) return 1;
        int res = 0;
        for(int i = start; i < nums.size(); i++) {
            if(nums[i] % (start + 1) == 0 || (start + 1) % nums[i] == 0) {
                swap(nums[i], nums[start]);
                res += countArrangement(nums, start + 1);
                swap(nums[i], nums[start]);
            }
        }
        return res;
