Synthesizing 10/10 solutions

=======

        sort(deck.begin(), deck.end());
        deque<int> dq;
        dq.push_back(deck.back());
        for (int i = deck.size() - 2; i >= 0; --i) {
            dq.push_front(dq.back());
            dq.pop_back();
            dq.push_front(deck[i]);
        }
        return vector<int>(dq.begin(), dq.end());

=======

        sort(deck.begin(), deck.end());
        deque<int> dq;
        dq.push_back(deck.back());
        for (int i = deck.size() - 2; i >= 0; i--) {
            dq.push_front(dq.back());
            dq.pop_back();
            dq.push_front(deck[i]);
        }
        return vector<int>(dq.begin(), dq.end());

=======

        sort(deck.begin(), deck.end());
        vector<int> res(deck.size());
        queue<int> q;
        for (int i = 0; i < deck.size(); i++) {
            q.push(i);
        }
        for (int i = 0; i < deck.size(); i++) {
            res[q.front()] = deck[i];
            q.pop();
            if (!q.empty()) {
                q.push(q.front());
                q.pop();
            }
        }
        return res;

=======

        sort(deck.begin(), deck.end());
        vector<int> res(deck.size());
        queue<int> q;
        for (int i = 0; i < deck.size(); ++i) {
            q.push(i);
        }
        for (int i = 0; i < deck.size(); ++i) {
            res[q.front()] = deck[i];
            q.pop();
            if (q.empty()) {
                break;
            }
            q.push(q.front());
            q.pop();
        }
        return res;

=======

        int n = deck.size();
        vector<int> ans(n);
        sort(deck.begin(), deck.end());
        queue<int> q;
        for (int i = 0; i < n; i++) {
            q.push(i);
        }
        int i = 0;
        while (!q.empty()) {
            ans[q.front()] = deck[i++];
            q.pop();
            if (!q.empty()) {
                q.push(q.front());
                q.pop();
            }
        }
        return ans;

=======

        sort(deck.begin(), deck.end());
        deque<int> q;
        for (int i = deck.size() - 1; i >= 0; --i) {
            if (q.size() > 0) {
                q.push_front(q.back());
                q.pop_back();
            }
            q.push_front(deck[i]);
        }
        vector<int> ans(q.begin(), q.end());
        return ans;

=======

        int n = deck.size();
        if (n <= 1) return deck;
        sort(deck.begin(), deck.end());
        deque<int> dq;
        dq.push_back(deck[n-1]);
        for (int i = n-2; i >= 0; i--) {
            int t = dq.back();
            dq.pop_back();
            dq.push_front(t);
            dq.push_front(deck[i]);
        }
        vector<int> res;
        while (!dq.empty()) {
            res.push_back(dq.front());
            dq.pop_front();
        }
        return res;

=======

        sort(deck.begin(), deck.end());
        vector<int> res(deck.size());
        int pos = 0;
        for (int i = 0; i < deck.size(); i++) {
            res[pos] = deck[i];
            pos = (pos + 2) % deck.size();
            while (res[pos] != 0) {
                pos = (pos + 1) % deck.size();
            }
        }
        return res;

=======

        sort(deck.begin(), deck.end());
        vector<int> ans(deck.size(), 0);
        int i = 0, j = 0;
        while (i < deck.size()) {
            if (ans[j] == 0) {
                ans[j] = deck[i];
                i++;
            }
            j = (j + 1) % deck.size();
        }
        return ans;

=======

        sort(deck.begin(), deck.end());
        vector<int> result;
        int n = deck.size();
        result.push_back(deck[0]);
        for (int i = 1; i < n; ++i) {
            int temp = result[result.size() - 1];
            result.pop_back();
            result.insert(result.begin(), temp);
            result.insert(result.begin(), deck[i]);
        }
        return result;
