Synthesizing 10/10 solutions

=======

        sort(tokens.begin(), tokens.end());
        int left = 0, right = tokens.size() - 1;
        int score = 0;
        while (left <= right) {
            if (power >= tokens[left]) {
                power -= tokens[left];
                score++;
                left++;
            } else if (score > 0 && right > left) {
                power += tokens[right];
                right--;
                score--;
            } else {
                break;
            }
        }
        return score;

=======

        sort(tokens.begin(), tokens.end());
        int i = 0, j = tokens.size() - 1, score = 0, maxScore = 0;
        while (i <= j) {
            if (power >= tokens[i]) {
                power -= tokens[i];
                score++;
                i++;
                maxScore = max(maxScore, score);
            } else if (score > 0) {
                power += tokens[j];
                score--;
                j--;
            } else {
                break;
            }
        }
        return maxScore;

=======

        sort(tokens.begin(), tokens.end());
        int i = 0, j = tokens.size() - 1, score = 0, maxScore = 0;
        while (i <= j) {
            if (power >= tokens[i]) {
                power -= tokens[i++];
                maxScore = max(maxScore, ++score);
            } else if (score > 0) {
                power += tokens[j--];
                --score;
            } else {
                break;
            }
        }
        return maxScore;

=======

        sort(tokens.begin(), tokens.end());
        int i = 0, j = tokens.size() - 1;
        int score = 0, ans = 0;
        while (i <= j) {
            if (power >= tokens[i]) {
                power -= tokens[i++];
                ans = max(ans, ++score);
            } else if (score > 0) {
                power += tokens[j--];
                --score;
            } else {
                break;
            }
        }
        return ans;

=======

        sort(tokens.begin(), tokens.end());
        int i = 0, j = tokens.size() - 1;
        int score = 0, max_score = 0;
        while (i <= j) {
            if (power >= tokens[i]) {
                power -= tokens[i++];
                max_score = max(max_score, ++score);
            } else if (score > 0) {
                power += tokens[j--];
                score--;
            } else {
                break;
            }
        }
        return max_score;

=======

        sort(tokens.begin(), tokens.end());
        int maxScore = 0, score = 0;
        int i = 0, j = tokens.size() - 1;
        while (i <= j) {
            if (power >= tokens[i]) {
                power -= tokens[i++];
                maxScore = max(maxScore, ++score);
            } else if (score > 0) {
                power += tokens[j--];
                --score;
            } else {
                break;
            }
        }
        return maxScore;

=======

        sort(tokens.begin(), tokens.end());
        int l = 0, r = tokens.size() - 1;
        int score = 0;
        int maxScore = 0;
        while (l <= r) {
            if (power >= tokens[l]) {
                power -= tokens[l++];
                maxScore = max(maxScore, ++score);
            } else if (score > 0) {
                power += tokens[r--];
                --score;
            } else {
                break;
            }
        }
        return maxScore;

=======

        sort(begin(tokens), end(tokens));
        int i = 0, j = tokens.size() - 1;
        int score = 0, maxScore = 0;
        while (i <= j) {
            if (power >= tokens[i]) {
                power -= tokens[i++];
                maxScore = max(maxScore, ++score);
            } else if (score > 0) {
                power += tokens[j--];
                score--;
            } else {
                break;
            }
        }
        return maxScore;

=======

        int n = tokens.size();
        int res = 0;
        sort(tokens.begin(), tokens.end());
        int l = 0, r = n - 1;
        while (l <= r) {
            if (power >= tokens[l]) {
                power -= tokens[l++];
                res++;
            }
            else if (res > 0 && l < r) {
                power += tokens[r--];
                res--;
            }
            else
                break;
        }
        return res;

=======

        int n = tokens.size();
        if(n == 0) return 0;
        sort(tokens.begin(), tokens.end());
        int i = 0, j = n-1;
        int score = 0, maxScore = 0;
        while(i <= j){
            if(power >= tokens[i]){
                power -= tokens[i++];
                score++;
                maxScore = max(maxScore, score);
            } else if(score > 0){
                power += tokens[j--];
                score--;
            } else {
                break;
            }
        }
        return maxScore;
