Synthesizing 10/10 solutions

=======

        int n = s.length();
        int k = n / 4;
        unordered_map<char, int> cnt;
        for (char c : s) {
            cnt[c]++;
        }
        int l = 0;
        int r = 0;
        int res = n;
        while (r < n) {
            cnt[s[r]]--;
            while (l <= r && cnt['Q'] <= k && cnt['W'] <= k && cnt['E'] <= k && cnt['R'] <= k) {
                res = min(res, r - l + 1);
                cnt[s[l]]++;
                l++;
            }
            r++;
        }
        return res;

=======

        unordered_map<char, int> cnt;
        for (char c : s) {
            cnt[c]++;
        }
        int n = s.size();
        int need = n / 4;
        int l = 0, r = 0;
        int ans = n;
        while (r < n) {
            cnt[s[r]]--;
            while (l <= r && cnt['Q'] <= need && cnt['W'] <= need && cnt['E'] <= need && cnt['R'] <= need) {
                ans = min(ans, r - l + 1);
                cnt[s[l]]++;
                l++;
            }
            r++;
        }
        return ans;

=======

        int n = s.size();
        int m = n / 4;
        unordered_map<char, int> mp;
        for (char c : s) {
            mp[c]++;
        }
        int i = 0, j = 0;
        int ans = n;
        while (j < n) {
            while (j < n && (mp['Q'] > m || mp['W'] > m || mp['E'] > m || mp['R'] > m)) {
                mp[s[j]]--;
                j++;
            }
            while (i < n && mp['Q'] <= m && mp['W'] <= m && mp['E'] <= m && mp['R'] <= m) {
                ans = min(ans, j - i);
                mp[s[i]]++;
                i++;
            }
        }
        return ans;

=======

        int n = s.size();
        int res = n;
        unordered_map<char, int> count;
        for (char c : s) {
            count[c]++;
        }
        int i = 0;
        for (int j = 0; j < n; j++) {
            count[s[j]]--;
            while (i < n && count['Q'] <= n/4 && count['W'] <= n/4 && count['E'] <= n/4 && count['R'] <= n/4) {
                res = min(res, j - i + 1);
                count[s[i]]++;
                i++;
            }
        }
        return res;

=======

        int n = s.size();
        int target = n / 4;
        unordered_map<char, int> count;
        for (auto c : s) {
            ++count[c];
        }
        int res = n;
        int i = 0;
        for (int j = 0; j < n; ++j) {
            --count[s[j]];
            while (i < n && count['Q'] <= target && count['W'] <= target && count['E'] <= target && count['R'] <= target) {
                res = min(res, j - i + 1);
                ++count[s[i]];
                ++i;
            }
        }
        return res;

=======

        int n = s.size(), count = n / 4;
        int q = 0, w = 0, e = 0, r = 0;
        for (char c : s) {
            if (c == 'Q') q++;
            if (c == 'W') w++;
            if (c == 'E') e++;
            if (c == 'R') r++;
        }
        int ans = n;
        for (int i = 0, j = 0; j < n; j++) {
            if (s[j] == 'Q') q--;
            if (s[j] == 'W') w--;
            if (s[j] == 'E') e--;
            if (s[j] == 'R') r--;
            while (q <= count && w <= count && e <= count && r <= count) {
                ans = min(ans, j - i + 1);
                if (s[i] == 'Q') q++;
                if (s[i] == 'W') w++;
                if (s[i] == 'E') e++;
                if (s[i] == 'R') r++;
                i++;
            }
        }
        return ans;

=======

        int n = s.size();
        int t = n / 4;
        unordered_map<char, int> cnt;
        for (auto c : s) {
            cnt[c]++;
        }
        int ans = n;
        int i = 0;
        for (int j = 0; j < n; ++j) {
            cnt[s[j]]--;
            while (i < n && cnt['Q'] <= t && cnt['W'] <= t && cnt['E'] <= t && cnt['R'] <= t) {
                ans = min(ans, j - i + 1);
                cnt[s[i]]++;
                i++;
            }
        }
        return ans;

=======

        int n = s.size();
        int target = n / 4;
        int ans = n;
        unordered_map<char, int> mp;
        for (char c : s) {
            mp[c]++;
        }
        int i = 0;
        for (int j = 0; j < n; j++) {
            mp[s[j]]--;
            while (i < n && mp['Q'] <= target && mp['W'] <= target && mp['E'] <= target && mp['R'] <= target) {
                ans = min(ans, j - i + 1);
                mp[s[i]]++;
                i++;
            }
        }
        return ans;

=======

        int n = s.size();
        if (n % 4 == 0) {
            int m = n / 4;
            unordered_map<char, int> map;
            for (auto c : s) {
                map[c]++;
            }
            int i = 0, j = 0, minLen = n;
            while (j < n) {
                map[s[j]]--;
                while (i <= j && map['Q'] <= m && map['W'] <= m && map['E'] <= m && map['R'] <= m) {
                    minLen = min(minLen, j - i + 1);
                    map[s[i]]++;
                    i++;
                }
                j++;
            }
            return minLen;
        }
        return 0;

=======

        int n = s.length();
        int k = n / 4;
        vector<int> cnt(128);
        for (char c: s) ++cnt[c];
        int l = 0, r = 0, res = n;
        while (r < n) {
            --cnt[s[r]];
            while (l <= r && cnt['Q'] <= k && cnt['W'] <= k && cnt['E'] <= k && cnt['R'] <= k) {
                res = min(res, r - l + 1);
                ++cnt[s[l++]];
            }
            ++r;
        }
        return res;
