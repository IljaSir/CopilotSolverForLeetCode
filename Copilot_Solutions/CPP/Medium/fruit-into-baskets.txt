Synthesizing 10/10 solutions

=======

        int n = fruits.size();
        int i = 0, j = 0, ans = 0;
        unordered_map<int, int> mp;
        while (j < n) {
            mp[fruits[j]]++;
            while (mp.size() > 2) {
                mp[fruits[i]]--;
                if (mp[fruits[i]] == 0) {
                    mp.erase(fruits[i]);
                }
                i++;
            }
            ans = max(ans, j - i + 1);
            j++;
        }
        return ans;

=======

        int n = fruits.size();
        int l = 0, r = 0, res = 0;
        unordered_map<int, int> m;
        while (r < n) {
            m[fruits[r]]++;
            while (m.size() > 2) {
                m[fruits[l]]--;
                if (m[fruits[l]] == 0) {
                    m.erase(fruits[l]);
                }
                l++;
            }
            res = max(res, r - l + 1);
            r++;
        }
        return res;

=======

        int n = fruits.size();
        int ans = 0;
        int i = 0;
        unordered_map<int, int> m;
        for (int j = 0; j < n; ++j) {
            m[fruits[j]]++;
            while (m.size() > 2) {
                m[fruits[i]]--;
                if (m[fruits[i]] == 0) m.erase(fruits[i]);
                i++;
            }
            ans = max(ans, j - i + 1);
        }
        return ans;

=======

        int n = fruits.size();
        int ans = 0;
        int i = 0;
        for (int j = 0; j < n; ++j) {
            if (j == n - 1 || fruits[j] != fruits[j + 1]) {
                int k = j + 1;
                while (k < n && fruits[k] == fruits[j]) ++k;
                int cnt = k - i;
                int pre = 0;
                for (int p = i - 1; p >= 0 && fruits[p] == fruits[i - 1]; --p) pre++;
                cnt += pre;
                ans = max(ans, cnt);
                i = k;
            }
        }
        return ans;

=======

        int n = fruits.size();
        int ans = 0;
        int i = 0;
        int j = 0;
        unordered_map<int, int> cnt;
        while (j < n) {
            cnt[fruits[j]]++;
            while (cnt.size() > 2) {
                cnt[fruits[i]]--;
                if (cnt[fruits[i]] == 0) {
                    cnt.erase(fruits[i]);
                }
                i++;
            }
            ans = max(ans, j - i + 1);
            j++;
        }
        return ans;

=======

        int n = fruits.size();
        if (n <= 2) return n;
        int l = 0, r = 0;
        int ans = 0;
        unordered_map<int, int> m;
        while (r < n) {
            m[fruits[r]]++;
            while (m.size() > 2) {
                m[fruits[l]]--;
                if (m[fruits[l]] == 0) m.erase(fruits[l]);
                l++;
            }
            ans = max(ans, r - l + 1);
            r++;
        }
        return ans;

=======

        int i = 0, j = 0, k = 0, n = fruits.size(), res = 0;
        while (j < n) {
            if (fruits[i] == fruits[j]) {
                j++;
            } else if (k == 0) {
                k = fruits[j++];
            } else if (fruits[k] == fruits[j]) {
                j++;
            } else {
                i = j - 1;
                while (fruits[i - 1] == fruits[i]) i--;
                k = fruits[j++];
            }
            res = max(res, j - i);
        }
        return res;

=======

        unordered_map<int, int> m;
        int ans = 0;
        int len = fruits.size();
        int i = 0, j = 0;
        while (j < len) {
            m[fruits[j]]++;
            while (m.size() > 2) {
                m[fruits[i]]--;
                if (m[fruits[i]] == 0) {
                    m.erase(fruits[i]);
                }
                i++;
            }
            ans = max(ans, j - i + 1);
            j++;
        }
        return ans;

=======

        int n = fruits.size();
        int res = 0;
        int i = 0;
        int j = 0;
        int k = 0;
        for (int j = 1; j < n; j++) {
            if (fruits[j] == fruits[j - 1]) continue;
            if (k == 0) k = j;
            else if (fruits[k] != fruits[j]) {
                res = max(res, j - i);
                i = k;
                k = j;
            }
        }
        return max(res, n - i);

=======

        int len = fruits.size();
        if (len == 0) {
            return 0;
        }
        int max = 1;
        int count = 1;
        int last = fruits[0];
        int lastLast = fruits[0];
        for (int i = 1; i < len; i++) {
            if (fruits[i] == last) {
                count++;
            } else {
                if (fruits[i] == lastLast) {
                    count++;
                    last = lastLast;
                    lastLast = fruits[i];
                } else {
                    lastLast = last;
                    last = fruits[i];
                    count = 1;
                }
            }
            if (count > max) {
                max = count;
            }
        }
        return max;
