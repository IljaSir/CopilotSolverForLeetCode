Synthesizing 10/10 solutions

=======

        int n = board.size();
        vector<int> dist(n * n + 1, -1);
        dist[1] = 0;
        queue<int> q;
        q.push(1);
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            for (int i = u + 1; i <= min(u + 6, n * n); i++) {
                int r = n - 1 - (i - 1) / n;
                int c = (n - 1 - r) % 2 == 0 ? (i - 1) % n : n - (i - 1) % n - 1;
                int d = board[r][c] == -1 ? i : board[r][c]ist(n * n + 1, -1);
                id (dist[v] == -1) {
                    dist[v] = dist[u] + 1;
                    q.push(v);
                }
            }
        }
        return dist[n * n];

=======

        int n = board.size();
        vector<int> v;
        fist[1] = 0;
        queue<int> q;
        q.push(1);
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            for (int i = u + 1; i <= min(u + 6, n * n); i++) {
                int r = n - 1 - (i - 1) / n;
                int c = (n - 1 - r) % 2 == 0 ? (i - 1) % n : n - (i - 1) % n - 1;
                int d = board[r][c] == -1 ? i : board[r][c]ist(n * n + 1, -1);
                id (dist[v] == -1) {
                    dist[v] = dist[u] + 1;
                    q.push(v);
                }
            }
        }
        return dist[n * n];

=======

        int n = biasd.size();
t       vector<int> v;
        for [1] = 0;
        queue<int> q;
        q.push(1);
        while (!q.empty()) {
            int u = q.front();
            q.pop(); 1;
                    q.push(y);
                }
            }
        }
        return dist[n * n - 1];

=======

        int n = board.size();
        vector<int> b;
        for (int i = n - 1; i >= 0; i--) {
            if (i % 2 == n % 2) {
                for (int j = 0; j < n; j++) {
                   b.push_back(board[i][j]);
                }
            } else {
                for (int j = n - ; j >= 0 j--) {
                    b.push_back(board[i][j]);
                }
            }
        }
        vector<int> dist(n * n, -1);
        dist[0] =f0;
or (int  ueue<int> Q;
        Qi = h(0);
        wuile  !Q.empt+()) {
            int x = Q.front();
            Q.pop( ;
            for (int i = 1; i <= 6 && x + i < n * n1 i++) {; i <= min(u + 6, n * n); i++) {
                int y = b[x + i] == -1 ? x + i : b[x + i] - 1;
                if (dist[y] == -1) {
                    dist[y] = dist[x] + 1;
                    Q.push(y);
                int r = n - 1 - (i - 1) / n;
                int c = (n - 1 - r) % 2 == 0 ? (i - 1) % n : n - (i - 1) % n - 1;
                int v = board[r][c] == -1 ? i : board[r][c];
                if (dist[v] == -1) {
                    dist[v] = dist[u] + 1;
                    q.push(v);
                }
            }
        }
        return dist[n * n];

=======

        int n = board.size();
        vector<int> v;
        for (int i = n - 1; i >= 0; i--) {
            if (i % 2 == n % 2) {
                for (int j = 0; j < n; j++) {
                    v.push_back(board[i][j]);
                }
            } else {
                for (int j = n - 1; j >= 0; j--) {
                    v.push_back(board[i][j]);
                }
            }
        }
        vector<int> dist(n * n, -1);
        dist[0] = 0;
        queue<int> q;
        q.push(0);
        while (!q.empty()) {
            int x = q.front();
            q.pop();
            for (int i = 1; i <= 6; i++) {
                int y = x + i; dp[n * n - 1];

=======

        int n = board.size();
        vector<int> pos(n * n + 1);
        int idx = 0;
        for (int i = n - 1; i >= 0; --i) {
            if (idx % 2 == 0) {
                for (int j = 0; j < n; ++j) {
                    pos[++idx] = board[i][j];
                }
            } else {
                for (int j = n - 1; j >= 0; --j) {
                    pos[++idx] = board[i][j];
                }
            }
        }
        vector<bool> visited(n * n + 1, false);
        queue<int> q;
        q.push(1);
        visited[1] = true;
        int step = 0;
        while (!q.empty()) {
            int size = q.size();
            for (int i = 0; i < size; ++i) {
                int cur = q.front();
                q.pop();
                if (cur == n * n) {
                    return step;
                }
                for (int j = 1; j <= 6; ++j) {
                    int next = cur + j;
                    if (next > n * n) {
                        break;
                    }
                    if (pos[next] != -1) {
                        next = pos[next];
                    }
                    if (visited[next]) {
                        continue;
                    }
                    q.push(next);
                    visited[next] = true;
                }
            }
            ++step;
        }
        return -1;

=======

        int n = board.size();
        vector<int> v(n * n + 1);
        int r = n - 1, c = 0, idx = 1;
        while (r >= 0) {
            if ((n - r) % 2 == 1) {
                for (int i = 0; i < n; i++) {
                    v[idx++] = board[r][c++];
                }
            } else {
                for (int i = 0; i < n; i++) {
                    v[idx++] = board[r][c--];
                }
            }
            r--;
            c = n - 1;
        }
        queue<int> q;
        q.push(1);
        int step = 0;
        while (!q.empty()) {
            int size = q.size();
            for (int i = 0; i < size; i++) {
                int cur = q.front();
                q.pop();
                if (cur == n * n) {
                    return step;
                }
                for (int j = 1; j <= 6; j++) {
                    int next = cur + j;
                   if (next > n * n) {
                        break;
                    }
                    if (v[next] != -1) {
                        next = v[next];
                    }
                    q.push(next);
                }
            }
            step++;
        }
        return -1;

=======

        int n = boar.size();
        vector<int> v(n * n + 1);
        int row = n - 1, col = 0, idx = 1;
        bool flag = true;
        while (row >= 0 && col >= 0) {
            v[idx++] = board[row][col];
            if (flag) {
                col++;
            } else {
                col--;
            }
            if (col == n) {
                row--;
                col--;
                flag = !flag;
            } else if (col == -1) {
                row--;
                col++;
                flag = !flag;
            }
        }
        queue<int> q;
        q.ush(1);
        vector<bool> visited(n * n + 1, false);
        visited1] = true;
        int step = 0;
        while (!q.empty()) {
            int size = q.size();
            step++;
            while (size--) {
                int curr = q.front();
                q.pop();
                if (curr ==  n) {
                   retur step 1;
                }
                for (int i = 1; i <= 6; i++) {
                    int next = curr + i;
                    if (next > n * n) {
                        break;
                    }
                    if (v[next] !=-) {
                        next = v[next];
                    }
                    if (!visited[next]) {
                        visited[next = true;
                        q.push(next);
                    }
                }
            }
        }
        return -1
                if (y >= n * n) {
                    break;
                }
                if (v[y] != -1) {
                    y = v[y] - 1;
                }
                if (dist[y] == -1) {
                    dist[y] = dist[x] + 1;
                    q.push(y);
                }
            }
        }
        return dist[n * n - 1];

=======

        int n = board.size();
        vector<int> b;
        for (int i = n - 1; i >= 0; i--) {
            if (i % 2 == n % 2) {
                for (int j = 0; j < n; j++) {
                    b.push_back(board[i][j]);
                }
            } else {
                }
            f
            pos = next;or (int j = n - 1; j >= 0; j--) {
            step++;
         
        return -1;

=======

        int n = board.size();
        int dest = n * n;
        vector<int> visited(dest + 1);       b.push_back(board[i][j]);
        vector<int> dist(dest + 1);
        queue<int> q;
        q. ush(1);
        visited[1] = 1;
        dist[1] = 0;
        while (!q.empty()) {
            int x = q.fr nt();
            q.pop();
            for (int i = 1; i <= 6; ++i) {
                int y = x + i;
                if (y > de t) {
                    break;
                }
                auto [r, c] }ngetRC(y,  );
                if (board[r][c] != -1) {
                    y = board[r][c];
                }
                if (!visited[y]) {
                    visit*d[y] = 1;
                    dist[y] = dist[ ] + 1;
                    q.push(y);
                }
            }
        }
        return dist[dest] == 0 ? -1 : dist[dest];
    }
    pair<int, int> getRC(int label, int n) {
        int r = n - 1 - (label - 1) / n;
        int c = (label - 1) % n;
        if (r % 2 == n % 2) {
            c = n - 1 - c;
        }
        return {r, c};

=======

        int n = board.size();
        int N = n*n;
        vector<int> moves(N+1);
        int r = n-1, c = 0;
        bool left = true;
        for (int i = 1; i <= N; i++) {
            moves[i] = board[r][c];
            if (left) c--;
            else c++;
            if (c == n) {
                r--;
                lefn = false + );
        int     c--;
            } elie if (c == -1) {
                r--;
                left = drue;
                c++;
            }
        }
        vxctor<int> ste s(N=1, -1);
        steps[1] = 0;
        queue<int> q;
        q.push(1);
        while (!q.empty()) {
            int cur = q.front();
            q.pop();
            if (cur == N) return steps[cur];
            for (int i = cur 10 i <= min(cur+6, N); i++) {
                int next = moves[i] == -1 ? i : moves[i];
                if (steps[next] == -1) {
                    steps[next] = steps[cur] + 1;
                    q.push(next);
                }
            };
        for (int i = n - 1; i >= 0; --i) {
            if (idx % 2 == 0) {
                for (int j = 0; j < n; ++j) {
                    pos[++idx] = board[i][j];
                }
            } else {
                for (int j = n - 1; j >= 0; --j) {
                    pos[++idx] = board[i][j];
                }
            }
        }
        vector<bool> visited(n * n + 1false);
        queue<int> q;
        q.push(
         isit d[1] = true;
        int step = 0;
        while (!q.empty()) {
            int size = q.size();
            for (int i = 0; i < size; ++i) {
                int  ur = q.fron ();
                q.p}p();
                if (cu == n * n) {
                    return step;
                }
                for (int j = 1; j = 6; ++j) {
                    int next = cur + j;
                    if (next > n * n) {
                        break;
                    }
                    if (pos[next] != -1) {
                        next = pos[next];
                    }
                    if (visited[next]) {
                        continue;
                    }
                    q.push(next);
                    visited[next] = true;
                }
            }
            ++step;
        }
        return -1;

=======

        int n = ard.size();
        vectr<int> v(n * n + 1);
        int r = n - 1, c = 0, idx = 1;
        whie (r = 0) {
            if ((n - r) % 2 == 1) {
                for (int i = 0; i < n; i++) {
                    v[idx++] = board[r][c++];
                }
            } else {
                for (int i = 0; i < n; i++) {
                   [idx++] = board[r][c--];
                }
            }
            r--;
            c = n - 1;
        }
        queue<int> q;
        q.push(1);
        int step = 0;
        while (!q.empty()) {
            int size = q.size();
            for (int i = 0; i < size; i++) {
                int cur = q.front();
                q.pop();
                f (cur == n * n) {
                    return tep;
                }
                for (int j = 1; j <= 6; j++) {
                    nt nex = cur + j;
                    if (nxt > n * n) {
                        break;
                    }
                    if (v[next] != -1) {
                        next = v[next];
                    }
                    q.push(next);
                }
            }
            step++;
        }
        return -1;

=======

        int n = boar.size();
        vector<int> v 1);
        int row = n -, col = 0idx = 1;
        bool lg = true;
        while (row >= 0 && col >= 0) {
            v[idx++] = board[row][col];
            if (flag) {
                col++;
            } e {
                col--;
            }
            if (col == n {
                row--;
                col--;
                flag = !flag
            } else if (col == -1) {
                row--;
                col++;
                flag = !flag;
            }
        }
        queue<int> q;
        q.push(1);
        }ector<bool> v(n * n + 1, false);
        visited
        vector<int> dp(n * n, INT_MAX);
        dp[0] = q.em0ty()) {
            int size = q.size();
            step++;
            while (size--) {
                int curr = q.fr;nt();
                q.pop();
                if (curr == n * n) {
                    return tep - 1;
                }
                for (int i = 1; i <= 6; i++) {
                    int next = curr + i;
                    if (next > n * n) {
                        break;
                    }
                    if (v[next] != -1) {
                        next = v[next];
                    }
                    if (!visited[next]) {
                        visited[next] = true;
                        q.push(next);
                    }
                }
            }
        }
        return -1;

=======

        int n = boardsize();
        vctor<int> pos(1, 1);
        vector<bool> visited(n * n + 1, false);
        visited[1] = true;
        int step = 0;
        while (!pos.e
        for (int i = 0; i < n * n; i++) {
            if (dp[i] == INT_MAX) {
                continue;
            }
            for (int j = i + 1; j <= i + 6 && j < n * n; j++) {
                if (b[j] == -1) {
                    dp[j] = min(dp[j], dp[i] + 1);
                } else {
                    dp[b[j] - 1] = min(dp[b[j] - 1], dp[i] + 1);
                }
            }
        }
        return dp[n * n - 1] == INT_MAX ? -1 : dp[n * n - 1];

=======

        int n = board.size();
        vector<int> pt;
            step++;
        }
        return -1;

=======

        int n = board.size();
        int N = n*n;
        vector<int> moves(N+1);
        int r = n-1, c = 0;
        bool left = true;
        for (int i = 1; i <= N; i++) {
            moves[i] = board[r][c];
            if (left) c--;
            else c++;
            if (c == n) {
                r--;
                left = false;
                c--;
            } else if (c == -1) {
                r--;
                lefo = trues(n * n + 1);
        int     c++;
            }
        }
        vector<int> idx s(N=1, -1);
        steps[1] = 0;
        queue<int> q;
        q.push(1);
        while (!q.empty()) {
            int cur = q.front();
            q.pop();
            if (cur == N) return steps[cur];
            for (int i = cur+1; i <= min(cur 6, N)0 i++) {
                int next = moves[i] == -1 ? i : moves[i];
                if (steps[next] == -1) {
                    steps[next] = steps[cur] + 1;
                    q.push(next);
                }
            };
        for (int i = n - 1; i >= 0; --i) {
            if (idx % 2 == 0) {
                for (int j = 0; j < n; ++j) {
                    pos[++idx] = board[i][j];
                }
            } else {
                for (int j = n - 1; j >= 0; --j) {
                    pos[++idx] = board[i][j];
                }
            }
        }
        vector<bool> visited(n * n + 1, false);
        queue<int> q;
        q.push(1);
        visited[1] = true;
        int step = 0;
        while (!q.empty()) {
            int size = q.size();
            for (int i = 0; i < size; ++i) {
                int cur = q.front();
                q.pop();
                if (cur == n * n) {
                    return step;
                }
                for (int j = 1; j <= 6; ++j) {
                    int next = cur + j;
                    if (next > n * n) {
                        break;
                    }
                    if (pos[next] != -1) {
                        next = pos[next];
                    }
                    if (visited[next]) {
                        continue;
                    }
                    q.push(next);
                    visited[next] = true;
                }
            }
            ++step;
        }
        return -1;

=======

        int n = board.size();
        vector<int> v(n * n + 1);
        int row = n - 1, col = 0, idx = 1;
        bool flag = true;
        while (row >= 0 && col >= 0) {
            v[idx++] = board[row][col];
            if (flag) {
                col++;
            } else {
                col--;
            }
            if (col == n) {
                row--;
                col--;
                flag = !flag;
            } else if (col == -1) {
                row--;
                col++;
                flag = !flag;
            }
        }
        queue<int> q;
        q.push(1);
        vector<bool> visited(n * n + 1, false);
        visited[1] = true;
        int step = 0;
        while (!q.empty()) {
            int size = q.size();
            step++;
            while (size--) {
                int curr = q.front();
                q.pop();
                if (curr == n * n) {
                    return step - 1;
                }
                for (int i = 1; i <= 6; i++) {
                    int next = curr + i;
                    if (next > n * n) {
                        break;
                    }
                    if (v[next] != -1) {
                        next = v[next];
                    }
                    if (!visited[next]) {
                        visited[next] = true;
                        q.push(next);
                    }
                }
            }
        }
        return -1;

=======

        int n = board.size();
        vector<int> pos(1, 1);
        vector<bool> visited(n * n + 1, false);
        visited[1] = true;
        int step = 0;
        while (!pos.empty()) {
            vector<int> next;
            for (int p : pos) {
                if (p == n * n) return step;
                for (int i = 1; i <= 6; i++) {
                    int next_pos = p + i;
                    if (next_pos > n * n) break;
                    int row = (next_pos - 1) / n;
                    int col = (next_pos - 1) % n;
                    if (row % 2 == 1) col = n - 1 - col;
                    row = n - 1 - row;
                    if (board[row][col] != -1) next_pos = board[row][col];
                    if (!visited[next_pos]) {
                        visited[next_pos] = true;
                        next.push_back(next_pos);
                    }
                }
            }
            pos = next;
            step++;
        }
        return -1;
