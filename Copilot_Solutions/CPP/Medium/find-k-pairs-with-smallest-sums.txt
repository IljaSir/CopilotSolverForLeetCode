Synthesizing 10/10 solutions

=======

        vector<vector<int>> res;
        if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {
            return res;
        }
        priority_queue<pair<int, pair<int, int>>> pq;
        for (int i = 0; i < nums1.size(); i++) {
            pq.push(make_pair(-nums1[i] - nums2[0], make_pair(i, 0)));
        }
        while (k > 0 && !pq.empty()) {
            auto item = pq.top();
            pq.pop();
            res.push_back({nums1[item.second.first], nums2[item.second.second]});
            if (item.second.second + 1 < nums2.size()) {
                pq.push(make_pair(-nums1[item.second.first] - nums2[item.second.second + 1], make_pair(item.second.first, item.second.second + 1)));
            }
            k--;
        }
        return res;

=======

        vector<vector<int>> res;
        if (nums1.empty() || nums2.empty()) return res;
        priority_queue<pair<int, pair<int, int>>> pq;
        for (int i = 0; i < nums1.size(); i++) {
            pq.push({nums1[i] + nums2[0], {i, 0}});
        }
        while (k-- && !pq.empty()) {
            auto t = pq.top(); pq.pop();
            int i = t.second.first, j = t.second.second;
            res.push_back({nums1[i], nums2[j]});
            if (j + 1 < nums2.size()) {
                pq.push({nums1[i] + nums2[j + 1], {i, j + 1}});
            }
        }
        return res;

=======

        int m = nums1.size();
        int n = nums2.size();
        vector<vector<int>> ans;
        if (m == 0 || n == 0 || k == 0) {
            return ans;
        }
        auto cmp = [&nums1, &nums2](const pair<int, int>& a, const pair<int, int>& b) {
            return nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second];
        };
        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> pq(cmp);
        pq.push({0, 0});
        while (!pq.empty() && k--) {
            auto [i, j] = pq.top();
            pq.pop();
            ans.push_back({nums1[i], nums2[j]});
            if (j == 0 && i + 1 < m) {
                pq.push({i + 1, j});
            }
            if (j + 1 < n) {
                pq.push({i, j + 1});
            }
        }
        return ans;

=======

        vector<vector<int>> res;
        int m = nums1.size();
        int n = nums2.size();
        if (m == 0 || n == 0) return res;
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq; // min heap
        for (int i = 0; i < m; i++) pq.push({nums1[i] + nums2[0], {i, 0}});
        while (k-- && !pq.empty()) {
            auto p = pq.top();
            pq.pop();
            res.push_back({nums1[p.second.first], nums2[p.second.second]});
            if (p.second.second + 1 < n) {
                pq.push({nums1[p.second.first] + nums2[p.second.second + 1], {p.second.first, p.second.second + 1}});
            }
        }
        return res;

=======

        vector<vector<int>> result;
        int n1 = nums1.size();
        int n2 = nums2.size();
        if (n1 == 0 || n2 == 0) return result;
        priority_queue<pair<int, pair<int, int>>> pq;
        for (int i = 0; i < n1; ++i) {
            pq.push({-nums1[i] - nums2[0], {i, 0}});
        }
        while (k > 0 && !pq.empty()) {
            auto p = pq.top();
            pq.pop();
            result.push_back({nums1[p.second.first], nums2[p.second.second]});
            if (p.second.second + 1 < n2) {
                pq.push({-nums1[p.second.first] - nums2[p.second.second + 1], {p.second.first, p.second.second + 1}});
            }
            --k;
        }
        return result;

=======

        vector<vector<int>> res;
        int n1 = nums1.size();
        int n2 = nums2.size();
        if (n1 == 0 || n2 == 0) return res;
        vector<int> idx(n1, 0);
        while (k-- && res.size() < n1 * n2) {
            int minSum = INT_MAX;
            int minIdx = -1;
            for (int i = 0; i < n1; ++i) {
                if (idx[i] < n2 && nums1[i] + nums2[idx[i]] < minSum) {
                    minSum = nums1[i] + nums2[idx[i]];
                    minIdx = i;
                }
            }
            res.push_back({nums1[minIdx], nums2[idx[minIdx]]});
            idx[minIdx]++;
        }
        return res;

=======

        vector<vector<int>> result;
        if (nums1.size() == 0 || nums2.size() == 0)
            return result;
        priority_queue<pair<int, pair<int, int>>> pq;
        for (int i = 0; i < nums1.size(); i++) {
            pq.push(make_pair(nums1[i] + nums2[0], make_pair(i, 0)));
        }
        while (k-- && !pq.empty()) {
            auto p = pq.top();
            pq.pop();
            int i = p.second.first;
            int j = p.second.second;
            result.push_back({nums1[i], nums2[j]});
            if (j + 1 < nums2.size())
                pq.push(make_pair(nums1[i] + nums2[j + 1], make_pair(i, j + 1)));
        }
        return result;

=======

        vector<vector<int>> ret;
        if (nums1.size() == 0 || nums2.size() == 0) {
            return ret;
        }
        priority_queue<pair<int, pair<int, int>>> pq;
        pq.push(make_pair(-(nums1[0] + nums2[0]), make_pair(0, 0)));
        while (k > 0 && pq.size() > 0) {
            auto p = pq.top();
            pq.pop();
            int i = p.second.first;
            int j = p.second.second;
            ret.push_back({nums1[i], nums2[j]});
            if (i + 1 < nums1.size()) {
                pq.push(make_pair(-(nums1[i + 1] + nums2[j]), make_pair(i + 1, j)));
            }
            if (i == 0 && j + 1 < nums2.size()) {
                pq.push(make_pair(-(nums1[i] + nums2[j + 1]), make_pair(i, j + 1)));
            }
            k--;
        }
        return ret;

=======

        vector<vector<int>> res;
        if (nums1.empty() || nums2.empty() || k <= 0) return res;
        auto comp = [&nums1, &nums2](const pair<int, int>& a, const pair<int, int>& b) {
            return nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second];
        };
        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> q(comp);
        q.push({0, 0});
        while (!q.empty() && k > 0) {
            auto p = q.top();
            q.pop();
            res.push_back({nums1[p.first], nums2[p.second]});
            if (p.first + 1 < nums1.size()) q.push({p.first + 1, p.second});
            if (p.first == 0 && p.second + 1 < nums2.size()) q.push({p.first, p.second + 1});
            k--;
        }
        return res;

=======

        vector<vector<int>> result;
        priority_queue<pair<int, int>> q;
        for(int i = 0; i < nums1.size(); i++) {
            for(int j = 0; j < nums2.size(); j++) {
                if(q.size() < k) {
                    q.push({nums1[i] + nums2[j], i});
                } else if(nums1[i] + nums2[j] < q.top().first) {
                    q.pop();
                    q.push({nums1[i] + nums2[j], i});
                }
            }
        }
        while(!q.empty()) {
            result.push_back({nums1[q.top().second], q.top().first - nums1[q.top().second]});
            q.pop();
        }
        return result;
