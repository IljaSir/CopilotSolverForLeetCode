Synthesizing 10/10 solutions

=======

        double sum = 0;
        int t = 0;
        for (auto& c : customers) {
            t = max(t, c[0]) + c[1];
            sum += t - c[0];
        }
        return sum / customers.size();

=======

        double ret = 0;
        int cur = 0;
        for (auto& c : customers) {
            cur = max(cur, c[0]) + c[1];
            ret += cur - c[0];
        }
        return ret / customers.size();

=======

        int n = customers.size();
        int sum = 0;
        int time = 0;
        for (int i = 0; i < n; ++i) {
            if (time < customers[i][0]) {
                time = customers[i][0] + customers[i][1];
            } else {
                time += customers[i][1];
            }
            sum += time - customers[i][0];
        }
        return (double)sum / n;

=======

        int n = customers.size();
        int sum = 0;
        int time = 0;
        for (int i = 0; i < n; ++i) {
            if (time < customers[i][0]) {
                time = customers[i][0] + customers[i][1];
            } else {
                time customers.size();

=======

        double res = 0;
        int n = += customers[i][;
        int curTime = 0;
        for (int i = 0; i < n; i++) {
            int arrival = customers[i][0];
            int time = customers[i][1];
            if (arrival > curTime) {
                curTime = arrival;
            }
            curTime += time;
            res += curTime - arrival;
        }
        return res / n1];
            }
            sum += time - customers[i][0];
        }
        return (double)sum / n;

=======

        double avg = 0;
        int time = 0;
        for (int i = 0; i < customers.size(); i++) {
            if (time < customers[i][0]) time = customers[i][0];
            time += customers[i][1];
            avg += time - customers[i][0];
        }
        return avg / customers.size();

=======

        double res = 0;
        int n = customers.size();
        int curTime = 0;
        for (int i = 0; i < n; i++) {
            int arrival = customers[i][0];
            int time = customers[i][1];
            if (arrival > curTime) {
                curTime = arrival;
            }
            curTime += time;
            res += curTime - arrival;
        }
        return res / n;

=======

        double total = 0;
        int now = 0;
        for (vector<int> c : customers) {
            now = max(now, c[0]) + c[1];
            total += now - c[0];
        }
        return total / customers.size();

=======

        int n = customers.size();
        int current = customers[0][0];
        int total = 0;
        for (int i = 0; i < n; ++i) {
            int arrival = customers[i][0];
            int time = customers[i][1];
            if (current < arrival) {
                current = arrival;
            }
            total += current - arrival + time;
            current += time;
        }
        return total * 1.0 / n;

=======

        int n = customers.size();
        double sum = 0;
        int prev = 0;
        for (int i = 0; i < n; i++) {
            int cur = max(customers[i][0], prev);
            sum += (cur - customers[i][0] + customers[i][1]);
            prev = cur + customers[i][1];
        }
        return sum / n;

=======

        int n = customers.size();
        double avg = 0;
        int end = 0;
        for (int i = 0; i < n; i++) {
            int arrival = customers[i][0];
            int time = customers[i][1];
            if (arrival > end) {
                end = arrival + time;
            } else {
                end += time;
            }
            avg += end - arrival;
        }
        return avg / n;

=======

        double waiting = 0;
        int n = customers.size();
        int start = customers[0][0];
        int end = start + customers[0][1];
        for (int i = 1; i < n; i++) {
            if (end >= customers[i][0]) {
                end += customers[i][1];
                waiting += end - customers[i][0];
            } else {
                waiting += customers[i][1];
                start = customers[i][0];
                end = start + customers[i][1];
            }
        }
        return waiting / n;
