Synthesizing 10/10 solutions

=======

        sort(arr.begin(), arr.end());
        int n = arr.size();
        vector<int> preSum(n);
        preSum[0] = arr[0];
        for (int i = 1; i < n; ++i) {
            preSum[i] = preSum[i - 1] + arr[i];
        }
        int l = 0, r = arr.back();
        int res = 0;
        int diff = INT_MAX;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            int idx = upper_bound(arr.begin(), arr.end(), mid) - arr.begin();
            int cur = preSum[idx - 1] + (n - idx) * mid;
            if (cur == target) return mid;
            if (abs(cur - target) < diff) {
                res = mid;
                diff = abs(cur - target);
            } else if (abs(cur - target) == diff) {
                res = min(res, mid);
            }
            if (cur > target) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        return res;

=======

        int n = arr.size();
        sort(arr.begin(), arr.end());
        vector<int> prefix(n + 1, 0);
        for (int i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] + arr[i];
        }
        int l = 0, r = arr[n - 1];
        int ans = -1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            int index = lower_bound(arr.begin(), arr.end(), mid) - arr.begin();
            int sum = prefix[index] + (n - index) * mid;
            if (sum <= target) {
                ans = mid;
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        int sum1 = check(arr, ans);
        int sum2 = check(arr, ans + 1);
        if (abs(target - sum1) <= abs(target - sum2)) {
            return ans;
        }
        return ans + 1;

=======

        int sum = 0;
        int max = 0;
        for (int i = 0; i < arr.size(); i++) {
            sum += arr[i];
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        if (sum <= target) {
            return max;
        }
        int l = 0;
        int r = max;
        while (l < r) {
            int mid = (l + r) / 2;
            int newSum = 0;
            for (int i = 0; i < arr.size(); i++) {
                if (arr[i] > mid) {
                    newSum += mid;
                } else {
                    newSum += arr[i];
                }
            }
            if (newSum < target) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        int s1 = 0;
        for (int i = 0; i < arr.size(); i++) {
            if (arr[i] > l - 1) {
                s1 += l - 1;
            } else {
                s1 += arr[i];
            }
        }
        int s2 = 0;
        for (int i = 0; i < arr.size(); i++) {
            if (arr[i] > l) {
                s2 += l;
            } else {
                s2 += arr[i];
            }
        }
        return abs(s1 - target) <= abs(s2 - target) ? l - 1 : l;

=======

        int sum = 0;
        int max = 0;
        for (int i = 0; i < arr.size(); i++) {
            sum += arr[i];
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        if (sum == target) {
            return max;
        }
        // binary search
        int l = 0;
        int r = max;
        int mid;
        int res = 0;
        int diff = INT_MAX;
        while (l <= r) {
            mid = (l + r) / 2;
            int newSum = 0;
            for (int i = 0; i < arr.size(); i++) {
                if (arr[i] > mid) {
                    newSum += mid;
                } else {
                    newSum += arr[i];
                }
            }
            if (abs(newSum - target) < diff) {
                res = mid;
                diff = abs(newSum - target);
            }
            if (newSum == target) {
                return mid;
            } else if (newSum > target) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        return res;

=======

        int n = arr.size();
        sort(arr.begin(), arr.end());
        vector<int> sum(n + 1);
        for (int i = 0; i < n; i++) sum[i + 1] = sum[i] + arr[i];
        int l = 0, r = arr.back();
        while (l < r) {
            int m = (l + r) >> 1;
            int i = upper_bound(arr.begin(), arr.end(), m) - arr.begin();
            int s = sum[i] + (n - i) * m;
            if (s >= target) r = m;
            else l = m + 1;
        }
        int i = upper_bound(arr.begin(), arr.end(), l) - arr.begin();
        int s1 = sum[i] + (n - i) * l;
        int s2 = sum[i] + (n - i) * (l - 1);
        return abs(s1 - target) <= abs(s2 - target) ? l : l - 1;

=======

        int sum = 0;
        for (int i = 0; i < arr.size(); i++) {
            sum += arr[i];
        }
        if (sum <= target) {
            return arr[arr.size() - 1];
        }
        int i = 0;
        int j = arr.size() - 1;
        while (i < j) {
            int mid = (i + j) / 2;
            int s = 0;
            for (int k = 0; k < arr.size(); k++) {
                if (k <= mid) {
                    s += arr[k];
                } else {
                    s += arr[mid];
                }
            }
            if (s >= target) {
                j = mid;
            } else {
                i = mid + 1;
            }
        }
        int s = 0;
        for (int k = 0; k < arr.size(); k++) {
            if (k <= i) {
                s += arr[k];
            } else {
                s += arr[i];
            }
        }
        if (s == target) {
            return arr[i];
        }
        int s1 = 0;
        for (int k = 0; k < arr.size(); k++) {
            if (k <= i - 1) {
                s1 += arr[k];
            } else {
                s1 += arr[i - 1];
            }
        }
        if (abs(target - s) < abs(target - s1)) {
            return arr[i];
        } else {
            return arr[i - 1];
        }

=======

        int n = arr.size();
        sort(arr.begin(), arr.end());
        vector<int> pre(n+1);
        for (int i = 0; i < n; i++) {
            pre[i+1] = pre[i] + arr[i];
        }
        int l = 0, r = arr[n-1];
        int res = 0, diff = INT_MAX;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            int idx = lower_bound(arr.begin(), arr.end(), mid) - arr.begin();
            int sum = pre[idx] + (n - idx) * mid;
            if (sum <= target) {
                if (target - sum < diff) {
                    diff = target - sum;
                    res = mid;
                }
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return res;

=======

        int n = arr.size();
        sort(arr.begin(), arr.end());
        vector<int> presum(n+1);
        for (int i = 1; i <= n; ++i) presum[i] = presum[i-1] + arr[i-1];
        int l = 0, r = arr[n-1];
        while (l < r) {
            int mid = l + (r-l)/2;
            auto it = lower_bound(arr.begin(), arr.end(), mid);
            int sum = presum[it-arr.begin()] + (arr.end()-it)*mid;
            if (sum <= target) l = mid+1;
            else r = mid;
        }
        int res = l;
        auto it = lower_bound(arr.begin(), arr.end(), l);
        int sum = presum[it-arr.begin()] + (arr.end()-it)*l;
        if (abs(sum-target) >= abs(sum-l+1-target)) res = l-1;
        return res;

=======

        int n = arr.size();
        sort(arr.begin(), arr.end());
        int sum = 0, i = 0;
        while (i < n && sum + arr[i] * (n - i) < target) {
            sum += arr[i];
            i++;
        }
        if (i == n) {
            return arr[n - 1];
        }
        int res = (target - sum) / (n - i);
        int diff1 = abs(target - sum - res * (n - i));
        int diff2 = abs(target - sum - (res + 1) * (n - i));
        if (diff1 <= diff2) {
            return res;
        }
        return res + 1;

=======

        sort(arr.begin(), arr.end());
        int n = arr.size();
        vector<int> preSum(n+1,0);
        for(int i = 1; i <= n; ++i){
            preSum[i] = preSum[i-1] + arr[i-1];
        }
        int l = 0, r = arr[n-1];
        int ans = 0;
        int diff = INT_MAX;
        while(l <= r){
            int mid = l + (r-l)/2;
            auto it = upper_bound(arr.begin(), arr.end(), mid);
            int idx = it - arr.begin();
            int curSum = preSum[idx] + (n-idx)*mid;
            if(curSum == target){
                return mid;
            }
            else if(curSum < target){
                l = mid + 1;
                if(target - curSum < diff){
                    diff = target - curSum;
                    ans = mid;
                }
                else if(target - curSum == diff){
                    ans = min(ans, mid);
                }
            }
            else{
                r = mid - 1;
                if(curSum - target < diff){
                    diff = curSum - target;
                    ans = mid;
                }
                else if(curSum - target == diff){
                    ans = min(ans, mid);
                }
            }
        }
        return ans;
