Synthesizing 10/10 solutions

=======

        int n = nums.size();
        for (int i = 1; i < n; ++i) {
            nums[i] += nums[i - 1];
        }
        int ans = nums[firstLen + secondLen - 1];
        int maxFirst = nums[firstLen - 1];
        int maxSecond = nums[secondLen - 1];
        for (int i = firstLen + secondLen; i < n; ++i) {
            maxFirst = max(maxFirst, nums[i - secondLen] - nums[i - firstLen - secondLen]);
            maxSecond = max(maxSecond, nums[i - firstLen] - nums[i - firstLen - secondLen]);
            ans = max(ans, max(maxFirst + nums[i] - nums[i - secondLen], maxSecond + nums[i] - nums[i - firstLen]));
        }
        return ans;

=======

        int n = nums.size();
        vector<int> sum(n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
        int res = 0;
        for (int i = firstLen; i <= n; ++i) {
            int first = sum[i] - sum[i - firstLen];
            for (int j = i + secondLen; j <= n; ++j) {
                int second = sum[j] - sum[j - secondLen];
                res = max(res, first + second);
            }
            for (int j = secondLen; j < i - firstLen; ++j) {
                int second = sum[j] - sum[j - secondLen];
                res = max(res, first + second);
            }
        }
        return res;

=======

        int n = nums.size();
        vector<int> sum(n+1, 0);
        for (int i = 0; i < n; i++) {
            sum[i+1] = sum[i] + nums[i];
        }
        int ans = 0;
        for (int i = firstLen; i <= n; i++) {
            int first = sum[i] - sum[i-firstLen];
            for (int j = secondLen; j <= n; j++) {
                if (i < j || j < i-firstLen) {
                    ans = max(ans, first + sum[j] - sum[j-secondLen]);
                }
            }
            for (int j = i+secondLen; j <= n; j++) {
                if (j < i || j > i+firstLen) {
                    ans = max(ans, first + sum[j] - sum[j-secondLen]);
                }
            }
        }
        for (int i = secondLen; i <= n; i++) {
            int first = sum[i] - sum[i-secondLen];
            for (int j = firstLen; j <= n; j++) {
                if (i < j || j < i-secondLen) {
                    ans = max(ans, first + sum[j] - sum[j-firstLen]);
                }
            }
            for (int j = i+firstLen; j <= n; j++) {
                if (j < i || j > i+secondLen) {
                    ans = max(ans, first + sum[j] - sum[j-firstLen]);
                }
            }
        }
        return ans;

=======

        int n = nums.size();
        for (int i = 1; i < n; i++) {
            nums[i] += nums[i-1];
        }
        int ans = nums[firstLen + secondLen - 1];
        int maxFirst = nums[firstLen - 1];
        int maxSecond = nums[secondLen - 1];
        for (int i = firstLen + secondLen; i < n; i++) {
            maxFirst = max(maxFirst, nums[i - secondLen] - nums[i - secondLen - firstLen]);
            maxSecond = max(maxSecond, nums[i - firstLen] - nums[i - firstLen - secondLen]);
            ans = max(ans, max(maxFirst + nums[i] - nums[i - secondLen], maxSecond + nums[i] - nums[i - firstLen]));
        }
        return ans;

=======

        int n = nums.size();
        vector<int> pre(n + 1, 0);
        for (int i = 0; i < n; ++i) {
            pre[i + 1] = pre[i] + nums[i];
        }
        int res = 0;
        for (int i = 0; i < n; ++i) {
            int l = pre[i + 1] - pre[i];
            if (i + firstLen > n) break;
            for (int j = i + firstLen; j < n; ++j) {
                int m = pre[j + 1] - pre[j];
                if (j + secondLen > n) break;
                int r = pre[j + secondLen] - pre[j];
                res = max(res, l + r);
            }
            for (int j = i + firstLen; j < n; ++j) {
                int m = pre[j + 1] - pre[j];
                if (j + firstLen > n) break;
                int r = pre[j + firstLen] - pre[j];
                res = max(res, l + r);
            }
        }
        return res;

=======

        int n = nums.size();
        vector<int> pre(n, 0);
        pre[0] = nums[0];
        for (int i = 1; i < n; ++i) {
            pre[i] = pre[i-1] + nums[i];
        }
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            int firstSum = 0;
            if (i + firstLen - 1 < n) {
                firstSum = pre[i + firstLen - 1] - (i > 0 ? pre[i-1] : 0);
            }
            for (int j = 0; j < n; ++j) {
                if (j + secondLen - 1 < n) {
                    int secondSum = 0;
                    if (i > j + secondLen - 1 || i + firstLen - 1 < j) {
                        secondSum = pre[j + secondLen - 1] - (j > 0 ? pre[j-1] : 0);
                    }
                    ans = max(ans, firstSum + secondSum);
                }
            }
        }
        return ans;

=======

        int n = nums.size();
        vector<int> preSum(n+1, 0);
        for (int i = 0; i < n; ++i) {
            preSum[i+1] = preSum[i] + nums[i];
        }
        int res = 0;
        for (int i = firstLen; i <= n; ++i) {
            int sum1 = preSum[i] - preSum[i-firstLen];
            int sum2 = 0;
            for (int j = secondLen; j < i-firstLen+1; ++j) {
                sum2 = max(sum2, preSum[j] - preSum[j-secondLen]);
            }
            for (int j = i+secondLen; j <= n; ++j) {
                sum2 = max(sum2, preSum[j] - preSum[j-secondLen]);
            }
            res = max(res, sum1+sum2);
        }
        return res;

=======

        int n = nums.size();
        vector<int> prefix(n + 1);
        for (int i = 0; i < n; ++i) {
            prefix[i + 1] = nums[i] + prefix[i];
        }
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            if (i + firstLen > n) break;
            int first = prefix[i + firstLen] - prefix[i];
            for (int j = 0; j < n; ++j) {
                if (j + secondLen > n) break;
                if (i < j && i + firstLen > j) continue;
                if (j < i && j + secondLen > i) continue;
                int second = prefix[j + secondLen] - prefix[j];
                ans = max(ans, first + second);
            }
        }
        return ans;

=======

        int n = nums.size();
        int sum[n];
        for (int i = 0; i < n; i++) {
            if (i == 0) {
                sum[i] = nums[i];
            } else {
                sum[i] = sum[i - 1] + nums[i];
            }
        }
        int leftMax = 0;
        int rightMax = 0;
        int ans = 0;
        for (int i = firstLen - 1; i < n - secondLen; i++) {
            leftMax = max(leftMax, sum[i] - (i - firstLen >= 0 ? sum[i - firstLen] : 0));
            rightMax = sum[n - 1] - sum[i] - (n - i - secondLen - 1 >= 0 ? sum[n - i - secondLen - 1] : 0);
            ans = max(ans, leftMax + rightMax);
        }
        leftMax = 0;
        rightMax = 0;
        for (int i = secondLen - 1; i < n - firstLen; i++) {
            leftMax = max(leftMax, sum[i] - (i - secondLen >= 0 ? sum[i - secondLen] : 0));
            rightMax = sum[n - 1] - sum[i] - (n - i - firstLen - 1 >= 0 ? sum[n - i - firstLen - 1] : 0);
            ans = max(ans, leftMax + rightMax);
        }
        return ans;

=======

        int n = nums.size(), sum = 0;
        vector<int> prefix(n+1, 0);
        for (int i = 0; i < n; i++) {
            prefix[i+1] = prefix[i] + nums[i];
        }
        int res = 0;
        for (int i = 0; i < n; i++) {
            int cur = 0;
            if (i + firstLen - 1 < n) {
                cur += prefix[i+firstLen] - prefix[i];
                if (i + firstLen + secondLen - 1 < n) {
                    cur += prefix[i+firstLen+secondLen] - prefix[i+firstLen];
                    res = max(res, cur);
                }
                if (i - secondLen >= 0) {
                    cur += prefix[i] - prefix[i-secondLen];
                    res = max(res, cur);
                }
            }
            if (i + secondLen - 1 < n) {
                cur += prefix[i+secondLen] - prefix[i];
                if (i + secondLen + firstLen - 1 < n) {
                    cur += prefix[i+secondLen+firstLen] - prefix[i+secondLen];
                    res = max(res, cur);
                }
                if (i - firstLen >= 0) {
                    cur += prefix[i] - prefix[i-firstLen];
                    res = max(res, cur);
                }
            }
        }
        return res;
