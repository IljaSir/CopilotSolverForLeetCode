Synthesizing 10/10 solutions (Duplicates hidden)

=======

        unordered_set<string> good(words.begin(), words.end());
        for (string word: words) {
            for (int k = 1; k < word.size(); ++k)
                good.erase(word.substr(k));
        }
        int ans = 0;
        for (string word: good)
            ans += word.size() + 1;
        return ans;

=======

        for (int i = 0; i < words.size(); i++) {
            reverse(words[i].begin(), words[i].end());
        }
        sort(words.begin(), words.end());
        int res = 0;
        for (int i = 0; i < words.size(); i++) {
            if (i == words.size() - 1 || words[i] != words[i + 1].substr(0, words[i].size())) {
                res += words[i].size() + 1;
            }
        }
        return res;

=======

        unordered_set<string> st(words.begin(), words.end());
        for (string w : words) {
            for (int i = 1; i < w.size(); ++i) {
                st.erase(w.substr(i));
            }
        }
        int res = 0;
        for (string w : st) res += w.size() + 1;
        return res;

=======

        for (string& word : words) {
            reverse(word.begin(), word.end());
        }
        sort(words.begin(), words.end());
        int res = 0;
        for (int i = 0; i < words.size(); ++i) {
            if (i + 1 < words.size() && words[i + 1].find(words[i]) == 0) {
                continue;
            }
            res += words[i].size() + 1;
        }
        return res;

=======

        unordered_set<string> st(words.begin(), words.end());
        for (string word: words) {
            for (int i = 1; i < word.size(); ++i) {
                st.erase(word.substr(i));
            }
        }
        int res = 0;
        for (string word: st) {
            res += word.size() + 1;
        }
        return res;

=======

        int res = 0;
        unordered_set<string> s(words.begin(), words.end());
        for (string word : s) {
            for (int i = 1; i < word.size(); ++i) {
                s.erase(word.substr(i));
            }
        }
        for (string word : s) {
            res += word.size() + 1;
        }
        return res;

=======

        int n = words.size();
        unordered_set<string> s(words.begin(), words.end());
        for (auto w : words)
            for (int i = 1; i < w.size(); i++)
                s.erase(w.substr(i));
        int res = 0;
        for (auto w : s)
            res += w.size() + 1;
        return res;

=======

        int result = 0;
        unordered_set<string> word_set(words.begin(), words.end());
        for (string word : words) {
            for (int i = 1; i < word.size(); i++) {
                word_set.erase(word.substr(i));
            }
        }
        for (string word : word_set) {
            result += word.size() + 1;
        }
        return result;

=======

        int n = words.size();
        if (n == 1) return words[0].size() + 1;
        vector<string> w;
        for (int i = 0; i < n; i++) {
            string s = words[i];
            reverse(s.begin(), s.end());
            w.push_back(s);
        }
        sort(w.begin(), w.end());
        int ans = w[0].size() + 1;
        for (int i = 1; i < n; i++) {
            if (w[i].find(w[i-1]) != 0) {
                ans += w[i].size() + 1;
            }
        }
        return ans;
