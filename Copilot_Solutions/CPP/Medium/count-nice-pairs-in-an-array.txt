Synthesizing 10/10 solutions

=======

        unordered_map<int, int> m;
        int res = 0, mod = 1e9+7;
        for (int num : nums) {
            string s = to_string(num);
            reverse(s.begin(), s.end());
            int rev = stoi(s);
            res = (res + m[num - rev]++) % mod;
        }
        return res;

=======

        unordered_map<int, int> counts;
        for (int num : nums) {
            int rev = 0;
            for (int x = num; x > 0; x /= 10) {
                rev = rev * 10 + x % 10;
            }
            counts[num - rev]++;
        }
        int ans = 0;
        for (auto& [_, count] : counts) {
            ans = (ans + count * (count - 1) / 2) % 1000000007;
        }
        return ans;

=======

        unordered_map<int, int> m;
        int res = 0;
        for (int n : nums) {
            int r = rev(n);
            res += m[n - r];
            m[n - r]++;
        }
        return res % 1000000007;
    }
    
    int rev(int n) {
        int r = 0;
        while (n) {
            r = r * 10 + n % 10;
            n /= 10;
        }
        return r;

=======

        map<int, int> m;
        int ans = 0;
        for (int i = 0; i < nums.size(); i++) {
            int x = nums[i], y = 0;
            while (x) {
                y = y * 10 + x % 10;
                x /= 10;
            }
            int diff = y - nums[i];
            ans += m[diff];
            m[diff]++;
        }
        return ans % (1000000000 + 7);

=======

        unordered_map<int, int> mp;
        int mod = 1e9+7;
        int ans = 0;
        for (int i = 0; i < nums.size(); ++i) {
            int r = reverse(nums[i]);
            int d = nums[i] - r;
            if (mp.count(d)) {
                ans = (ans + mp[d]) % mod;
            }
            mp[d]++;
        }
        return ans;
    }
    
    int reverse(int x) {
        int r = 0;
        while (x) {
            r = r * 10 + x % 10;
            x /= 10;
        }
        return r;

=======

        unordered_map<long, long> m;
        long res = 0;
        for (int n : nums) {
            long rev = 0, x = n;
            while (x) {
                rev = rev * 10 + x % 10;
                x /= 10;
            }
            res += m[rev - n]++;
        }
        return res % (long)(1e9 + 7);

=======

        unordered_map<int, int> mp;
        long long res = 0;
        const int mod = 1e9 + 7;
        for (int num : nums) {
            int val = num - rev(num);
            res += mp[val];
            res %= mod;
            mp[val]++;
        }
        return res;
    }
    int rev(int n) {
        int res = 0;
        while (n) {
            res = res * 10 + n % 10;
            n /= 10;
        }
        return res;

=======

        unordered_map<int, int> cache;
        int res = 0;
        for (auto num : nums) {
            int rev = 0;
            int tmp = num;
            while (tmp) {
                rev = rev * 10 + tmp % 10;
                tmp /= 10;
            }
            int diff = num - rev;
            if (cache.count(diff)) {
                res += cache[diff];
            }
            cache[diff]++;
        }
        return res % 1000000007;

=======

        int M = 1000000007;
        unordered_map<int, int> mp;
        for (auto& n : nums) {
            int rev = 0;
            int t = n;
            while (t) {
                rev = rev * 10 + t % 10;
                t /= 10;
            }
            mp[n - rev]++;
        }
        int ans = 0;
        for (auto& [k, v] : mp) {
            ans += (long long)v * (v - 1) / 2;
            ans %= M;
        }
        return ans;

=======

        int res = 0;
        unordered_map<long long, int> cnt;
        const int mod = 1e9 + 7;
        for (auto& num : nums) {
            long long rev = 0, tmp = num;
            while (tmp) {
                rev = rev * 10 + tmp % 10;
                tmp /= 10;
            }
            res = (res + cnt[num - rev]) % mod;
            cnt[num - rev]++;
        }
        return res;
