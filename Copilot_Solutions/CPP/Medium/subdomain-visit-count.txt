Synthesizing 10/10 solutions

=======

        unordered_map<string, int> count;
        for (auto& cpdomain : cpdomains) {
            int i = cpdomain.find(' ');
            int n = stoi(cpdomain.substr(0, i));
            string s = cpdomain.substr(i + 1);
            for (i = 0; i < s.size(); ++i) {
                if (s[i] == '.') count[s.substr(i + 1)] += n;
            }
            count[s] += n;
        }
        vector<string> ans;
        for (auto& [s, n] : count) {
            ans.push_back(to_string(n) + ' ' + s);
        }
        return ans;

=======

        unordered_map<string, int> m;
        for (auto cp : cpdomains) {
            int i = cp.find(' ');
            int n = stoi(cp.substr(0, i));
            string s = cp.substr(i + 1);
            for (int i = 0; i < s.size(); ++i) {
                if (s[i] == '.') {
                    m[s.substr(i + 1)] += n;
                }
            }
            m[s] += n;
        }
        vector<string> res;
        for (auto a : m) {
            res.push_back(to_string(a.second) + " " + a.first);
        }
        return res;

=======

        unordered_map<string, int> m;
        for (auto cpdomain : cpdomains) {
            int idx = cpdomain.find(' ');
            int count = stoi(cpdomain.substr(0, idx));
            string domain = cpdomain.substr(idx + 1);
            for (int i = 0; i < domain.size(); ++i) {
                if (domain[i] == '.') {
                    m[domain.substr(i + 1)] += count;
                }
            }
            m[domain] += count;
        }
        vector<string> res;
        for (auto it = m.begin(); it != m.end(); ++it) {
            res.push_back(to_string(it->second) + " " + it->first);
        }
        return res;

=======

        unordered_map<string, int> m;
        for (auto &s: cpdomains) {
            int i = s.find(' ');
            int n = stoi(s.substr(0, i));
            string domain = s.substr(i + 1);
            for (int i = 0; i < domain.size(); ++i) {
                if (domain[i] == '.') {
                    m[domain.substr(i + 1)] += n;
                }
            }
            m[domain] += n;
        }
        vector<string> res;
        for (auto &p: m) {
            res.push_back(to_string(p.second) + ' ' + p.first);
        }
        return res;

=======

        unordered_map<string, int> count;
        for (auto cpdomain : cpdomains) {
            int space = cpdomain.find(' ');
            int n = stoi(cpdomain.substr(0, space));
            string s = cpdomain.substr(space + 1);
            for (int i = 0; i < s.size(); ++i) {
                if (s[i] == '.') {
                    count[s.substr(i + 1)] += n;
                }
            }
            count[s] += n;
        }
        vector<string> ans;
        for (auto& [s, n] : count) {
            ans.push_back(to_string(n) + ' ' + s);
        }
        return ans;

=======

        unordered_map<string, int> counts;
        for (auto& cpdomain : cpdomains) {
            auto pos = cpdomain.find(' ');
            int count = stoi(cpdomain.substr(0, pos));
            string domain = cpdomain.substr(pos + 1);
            while (true) {
                counts[domain] += count;
                pos = domain.find('.');
                if (pos == string::npos) break;
                domain = domain.substr(pos + 1);
            }
        }

        vector<string> result;
        for (auto& [domain, count] : counts) {
            result.push_back(to_string(count) + " " + domain);
        }
        return result;

=======

        unordered_map<string, int> counts;
        for (string &cpdomain: cpdomains) {
            int i = cpdomain.find(' ');
            int n = stoi(cpdomain.substr(0, i));
            string &s = cpdomain.substr(i + 1);
            for (int i = 0; i < s.size(); ++i) {
                if (s[i] == '.') counts[s.substr(i + 1)] += n;
            }
            counts[s] += n;
        }

        vector<string> ans;
        for (auto &p: counts) {
            ans.push_back(to_string(p.second) + " " + p.first);
        }
        return ans;

=======

        vector<string> result;
        unordered_map<string, int> count;
        for (auto cpdomain : cpdomains) {
            int space = cpdomain.find(' ');
            int num = stoi(cpdomain.substr(0, space));
            for (int i = space + 1; i < cpdomain.size(); i++) {
                if (cpdomain[i] == '.' || i == cpdomain.size() - 1) {
                    count[cpdomain.substr(i + 1)] += num;
                }
            }
        }
        for (auto it = count.begin(); it != count.end(); it++) {
            result.push_back(to_string(it->second) + " " + it->first);
        }
        return result;

=======

        map<string, int> m;
        for (auto &s : cpdomains) {
            int i = s.find(' ');
            int cnt = stoi(s.substr(0, i));
            string domain = s.substr(i + 1);
            m[domain] += cnt;
            for (int i = 0; i < domain.size(); i++) {
                if (domain[i] == '.') {
                    m[domain.substr(i + 1)] += cnt;
                }
            }
        }
        vector<string> res;
        for (auto &p : m) {
            res.push_back(to_string(p.second) + " " + p.first);
        }
        return res;

=======

        unordered_map<string, int> domain;
        for (auto& cpdomain : cpdomains) {
            int space = cpdomain.find(' ');
            int count = stoi(cpdomain.substr(0, space));
            string subdomain = cpdomain.substr(space + 1);
            while (!subdomain.empty()) {
                domain[subdomain] += count;
                int dot = subdomain.find('.');
                if (dot == string::npos) break;
                subdomain = subdomain.substr(dot + 1);
            }
        }
        vector<string> result;
        for (auto& pair : domain) {
            result.push_back(to_string(pair.second) + " " + pair.first);
        }
        return result;
