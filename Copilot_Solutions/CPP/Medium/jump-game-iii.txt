Synthesizing 10/10 solutions

=======

        if (start < 0 || start >= arr.size() || arr[start] < 0) {
            return false;
        }
        if (arr[start] == 0) {
            return true;
        }
        arr[start] = -arr[start];
        return canReach(arr, start + arr[start]) || canReach(arr, start - arr[start]);

=======

        if (start < 0 || start >= arr.size() || arr[start] < 0) return false;
        if (arr[start] == 0) return true;
        int val = arr[start];
        arr[start] = -arr[start];
        return canReach(arr, start + val) || canReach(arr, start - val);

=======

        if (start < 0 || start >= arr.size() || arr[start] < 0) return false;
        if (arr[start] == 0) return true;
        int tmp = arr[start];
        arr[start] = -arr[start];
        return canReach(arr, start + tmp) || canReach(arr, start - tmp);

=======

        int n = arr.size();
        if (start < 0 || start >= n || arr[start] < 0) return false;
        if (arr[start] == 0) return true;
        arr[start] = -arr[start];
        return canReach(arr, start + arr[start]) || canReach(arr, start - arr[start]);

=======

        vector<bool> visited(arr.size(), false);
        return dfs(arr, start, visited);
    }
    bool dfs(vector<int>& arr, int start, vector<bool>& visited) {
        if (start < 0 || start >= arr.size() || visited[start]) return false;
        if (arr[start] == 0) return true;
        visited[start] = true;
        return dfs(arr, start + arr[start], visited) || dfs(arr, start - arr[start], visited);

=======

        int n = arr.size();
        vector<bool> visited(n, false);
        queue<int> q;
        q.push(start);
        visited[start] = true;
        while (!q.empty()) {
            int i = q.front();
            q.pop();
            if (arr[i] == 0) return true;
            if (i + arr[i] < n && !visited[i + arr[i]]) {
                q.push(i + arr[i]);
                visited[i + arr[i]] = true;
            }
            if (i - arr[i] >= 0 && !visited[i - arr[i]]) {
                q.push(i - arr[i]);
                visited[i - arr[i]] = true;
            }
        }
        return false;

=======

        queue<int> q;
        q.push(start);
        while (!q.empty()) {
            int i = q.front();
            q.pop();
            if (arr[i] == 0) return true;
            if (arr[i] < 0) continue;
            if (i + arr[i] < arr.size()) q.push(i + arr[i]);
            if (i - arr[i] >= 0) q.push(i - arr[i]);
            arr[i] = -arr[i];
        }
        return false;

=======

        int n = arr.size();
        vector<bool> visited(n, false);
        queue<int> q;
        q.push(start);
        visited[start] = true;
        while (!q.empty()) {
            int curr = q.front();
            q.pop();
            if (arr[curr] == 0) {
                return true;
            }
            if (curr + arr[curr] < n && !visited[curr + arr[curr]]) {
                q.push(curr + arr[curr]);
                visited[curr + arr[curr]] = true;
            }
            if (curr - arr[curr] >= 0 && !visited[curr - arr[curr]]) {
                q.push(curr - arr[curr]);
                visited[curr - arr[curr]] = true;
            }
        }
        return false;

=======

        int n = arr.size();
        if (arr[start] == 0) return true;
        if (arr[start] == -1) return false;
        int tmp = arr[start];
        arr[start] = -1;
        if (start + tmp < n && canReach(arr, start + tmp)) return true;
        if (start - tmp >= 0 && canReach(arr, start - tmp)) return true;
        return false;

=======

        int N = arr.size();
        vector<int> visited(N, 0);
        queue<int> q;
        q.push(start);
        while (!q.empty()) {
            int i = q.front(); q.pop();
            if (arr[i] == 0) return true;
            visited[i] = 1;
            if (i + arr[i] < N && !visited[i+arr[i]]) q.push(i+arr[i]);
            if (i - arr[i] >= 0 && !visited[i-arr[i]]) q.push(i-arr[i]);
        }
        return false;
