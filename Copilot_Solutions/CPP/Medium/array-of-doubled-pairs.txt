Synthesizing 9/10 solutions

=======

        unordered_map<int, int> count;
        for (int a : arr) count[a]++;
        vector<int> keys;
        for (auto it : count) keys.push_back(it.first);
        sort(keys.begin(), keys.end(), [](int a, int b) {
            return abs(a) < abs(b);
        });
        for (int x : keys) {
            if (count[x] > count[2 * x]) return false;
            count[2 * x] -= count[x];
        }
        return true;

=======

        map<int, int> counter;
        for (int i = 0; i < arr.size(); i++) {
            counter[arr[i]]++;
        }
        for (auto it = counter.begin(); it != counter.end(); it++) {
            int key = it->first;
            int value = it->second;
            if (value == 0) {
                continue;
            }
            if (key < 0) {
                if (key % 2 != 0) {
                    return false;
                }
                if (counter[key / 2] < value) {
                    return false;
                }
                counter[key / 2] -= value;
            } else {
                if (counter[key * 2] < value) {
                    return false;
                }
                counter[key * 2] -= value;
            }
        }
        return true;

=======

        int n = arr.size();
        if (n % 2 != 0) return false;
        unordered_map<int, int> mp;
        sort(arr.begin(), arr.end());
        for (int i = 0; i < n; i++) {
            mp[arr[i]]++;
        }
        for (int i = 0; i < n; i++) {
            if (mp[arr[i]] > 0) {
                if (arr[i] < 0) {
                    if (mp[arr[i] / 2] == 0) return false;
                    mp[arr[i] / 2]--;
                }
                else {
                    if (mp[arr[i] * 2] == 0) return false;
                    mp[arr[i] * 2]--;
                }
                mp[arr[i]]--;
            }
        }
        return true;

=======

        map<int, int> m;
        for (int i = 0; i < arr.size(); ++i) {
            ++m[arr[i]];
        }
        for (auto &p : m) {
            if (p.second > 0) {
                if (p.first < 0) {
                    if (m[p.first / 2] < p.second || p.first % 2 != 0) {
                        return false;
                    }
                } else {
                    if (m[p.first * 2] < p.second) {
                        return false;
                    }
                }
                m[p.first * 2] -= p.second;
            }
        }
        return true;

=======

        unordered_map<int, int> counter;
        for (int x : arr) {
            counter[x]++;
        }
        vector<int> keys;
        for (auto& kv : counter) {
            keys.push_back(kv.first);
        }
        sort(keys.begin(), keys.end(), [](int x, int y) {
            return abs(x) < abs(y);
        });
        for (int key : keys) {
            if (counter[key] > counter[2 * key]) {
                return false;
            }
            counter[2 * key] -= counter[key];
        }
        return true;

=======

        map<int, int> count;
        int n = arr.size();
        for (int i = 0; i < n; i++) {
            count[arr[i]]++;
        }
        for (auto& p : count) {
            int x = p.first;
            int c = p.second;
            if (x < 0) {
                if (x % 2 != 0) {
                    return false;
                }
                if (count[x / 2] < c) {
                    return false;
                }
                count[x / 2] -= c;
            } else {
                if (count[2 * x] < c) {
                    return false;
                }
                count[2 * x] -= c;
            }
        }
        return true;

=======

        map<int, int> m;
        for (auto& x : arr) {
            m[x]++;
        }
        for (auto& x : m) {
            if (x.first < 0) {
                if (x.second > m[x.first / 2]) {
                    return false;
                }
                m[x.first / 2] -= x.second;
            } else {
                if (x.second > m[2 * x.first]) {
                    return false;
                }
                m[2 * x.first] -= x.second;
            }
        }
        return true;

=======

        map<int, int> count;
        for (auto &a : arr) count[a]++;
        for (auto &p : count) {
            if (p.second > 0) {
                if (p.first < 0) {
                    if (p.first % 2 != 0) return false;
                    if (count[p.first / 2] < p.second) return false;
                    count[p.first / 2] -= p.second;
                } else {
                    if (count[2 * p.first] < p.second) return false;
                    count[2 * p.first] -= p.second;
                }
            }
        }
        return true;

=======

        map<int, int> mp;
        for(auto &x: arr) mp[x] ++;
        for(auto &x: mp) {
            if(x.second == 0) continue;
            if(x.first < 0) {
                if(x.first % 2 == 1 || mp.find(x.first / 2) == mp.end() || mp[x.first / 2] < x.second) return false;
                mp[x.first / 2] -= x.second;
            } else {
                if(mp.find(2 * x.first) == mp.end() || mp[2 * x.first] < x.second) return false;
                mp[2 * x.first] -= x.second;
            }
        }
        return true;
