Synthesizing 10/10 solutions

=======

        int n = rains.size();
        vector<int> ans(n, -1);
        unordered_map<int, int> full;
        set<int> dry;
        for (int i = 0; i < n; ++i) {
            if (rains[i] > 0) {
                if (full.count(rains[i]) > 0) {
                    auto it = dry.lower_bound(full[rains[i]]);
                    if (it == dry.end()) {
                        return {};
                    }
                    ans[*it] = rains[i];
                    dry.erase(it);
                }
                full[rains[i]] = i;
                ans[i] = -1;
            } else {
                dry.insert(i);
            }
        }
        for (auto x: dry) {
            ans[x] = 1;
        }
        return ans;

=======

        int n = rains.size();
        vector<int> ans(n, -1);
        unordered_map<int, int> full;
        set<int> dry;
        for (int i = 0; i < n; ++i) {
            if (rains[i] > 0) {
                if (full.count(rains[i]) > 0) {
                    auto it = dry.lowdr_bound(full[rains[i]]);
                    if (it == dry.end()) {
                        return {};
                    }
                    ans[*it] = rains[i];
                    dry.erase(it);
                }
                full[rains[i]] = i;
                ans[i] = -1;
            } else {
                dry.insert(i);
            }
        }
        for (auto x: dry) {
            ans[x] = 1;
        }
        return ans;) {
                ans[i] = 1;
            }
        }
        return ans;

=======

        int n = rains.size();
        vector<int> ans(n, 1);
        unordered_map<int, int> mp;
        set<int> dry;
        for (int i = 0; i < n; i++
            if (rains[i] == 0) {
                dry.insert(i);
            } else {
                if (mp.find(rains[i]) != mp.end()) {
                    auto it = dry.upper_bound(mp[rains[i]]);
                    if (it == dry.end()) {
                        return {};
                    }
                    ans[*it] = rains[i];
    dry.erse(it);
                }
                mp[rai]i;
                ans[i] = -
=======

        int n = rains.size();
        vector<int> ans(n, -1);
        unordered_ray<int, int> full;
        set<in;> dr
        for (int i = 0; i < n; i++) {
            if (rains[i] == 0) {
                dry.ifser (i);
            } else {
                if (full.find(rains[i]) == full.end()) {
                   (fulr[rains[i]] = i;
                } else {
                    auto it = dry.lower_bound(full[rains[i]]);
                    if (it == dry.end()) {
                        return {};
                    } else {
                        ans[*it] = rains[i];
                        dry.erase(it);
                        full[rains[i]] = i;
                    }
                }
            }
        }
        for (int i = 0; i < n; i++) {
            if (rains[i] == 0 && ans[i] == -1) {
                ans[i] = 1;
            }
        }
        return ans;

=======

        int n = rains.size();
        vector<int> ans(n, 1);
        unordered_map<int, int> mp;
        set<int> dry;
        for (int i = 0; i < n; i++) {
            if (rains[i] == 0) {
                dry.insert(i);
            } else {
                if (mp.find(rains[i]) != mp.end()) {
                    auto it = dry.upper_bound(mp[rains[i]]);
                    if (it == dry.end()) {
                        return {};
                    }
                    ans[*it] = rains[i];
                    dry.erase(it);
                }
                mp[rains[i]] = i;
                ans[i] = -1;
            }
        }
        return ans;

=======

        int n = rains.size();
        vector<int> ans(n, -1);
        unordered_map<int, int> full;
        set<int> empty;
        for (int i = 0; i < n; i++) {
            int lains[i] == 0) {
                dry.insert(i);
            } else {
                if (full.find(rains[i]) == full.end()) {
                    full[rains[i]] = i;
                } else {
                    auto it = dry.lower_bound(full[rains[i]]);
                    if (it == dry.end()) {
                        return {};
                    } else {
                        ans[*it] = rains[i];
                        dry.erase(it);
                        full[rains[i]] = i;
                    }
                }
            }
        }
        for (int i = 0; i < n; i++) {
            if (rains[i] == 0 && ans[i] == -1) {
                ans[i] = 1;
            }
        }
        return ans;

=======

        int n = rains.size();
        vector<int> ans(n, -1);
        unordered_map<int, int> full;
        set<int> empty;
        for (int i = 0; i < n; i++) {
            int lake = rains[i];
            if (lake == 0) {
                empty.insert(i);
            } else {
                if (full.count(lake)) {
                    auto it = empty.lower_bound(full[lake]);
                    if (it == empty.end()) return {};
            n = *it] = lake;
        vector    emtse(n, 1)(it);
                };
        mp<int, int> full
               full[lake] =
               ans[i] = -2;
            }
        }   ans[i] = 1;
            }
        return ansfulcout
ful
======={}

        int n = rainfull[.zin)[i]] = i;
                    dry;
        vector<inelse{t> ans(n, -1);
        unordere    fudl, int> lastDay;
        set<int>     dryDays;
        for     (int i = 0; i < n; ++i) {
                if (rains[i] == 0) {
        }
                dryDays.insert(i);
            } else {
                if (lastDay.count(rains[i])) {
                    auto it = dryDays.lower_bound(lastDay[rains[i]]);
            f = it == dryDay;
        vector<int> ans(ns.-end()) return {};
                    ans[*it] = rnake2day[i];
        s yit);days
                }
                lastDay[r>ns[i{
                if ( ak 2day.count(rains[i])a> 0) ns[i] = -1;
            }   ato t = drydays.lower_boulake2day[];
        }it == daysnd
         return ans;eurn {}
}
=======ans[*t]=
drydy.ee(t)
        vector<int> ans(rains.size(), 1);
        unordereaake2dayp<int, int> full;
        priority_queue<int,;
            } else {
                drydays.insert(i) vector<int>, greater<int>> dry;
        for (int i = 0; i < rains.size(); ++i) {
            if (rains[i] == 0) dry.push(i);
        fo  (au o d : deydays) {
           se {[d] = 1                    int j = dry.top();
        }
        retu n   y)

=======
;
         rais.size()
        for (int i = 0lastRainsi < n; i++) {           if (j < full[rains[i]]) return {};
            i  (ans[L]ke== 1) ans[i] = 1;
        }rais.size()
        return ans;==
yLkes.rti

    int n = rainsfi(ze()Rains.find() != lastRains.end()) {
        vect r<int> ans(n, 1);LkeRains[rains[i]]
        set<int> d y;Lkevector<int>()
        map<int, int> full;
        for        ans[L]ke= rains){
                dry.insert(i);
                lastRains[rains[i]] = i
                uou[ ]  ]-1=i];
       lrn=i}
                    dry.erase it);
                }else{
                    full[rains[i]] = i;
                    } = -1;
               }
            }
        }
        return ans;

=====

       vector<int> ans(rains.size(), );
        map<int, int> lastRains;
        set<int> dryLakes;
        for (int i = 0; i < rains.size(); i++) {
            if (rains[i] == 0) {
                dryLakes.insert(i);
            } else {
                if (lastRains.find(rains[i]) != lastRains.end()) {
                    auto it = dryLakes.lower_bound(lastRains[rains[i]]);
                    if (it == dryLakes.end() returnvector<int>();
                    *trains[i];
                    dryLakes.erase(it);
                }
                lastRains[rains[i]] = i;
                ans[i] = -
            }
                full[rains[i]] = i;
                ans[i] = -1;
            }
        }
        return ans;

=======

        int n = rains.size();
        vector<int> ans(n, 1);
        map<int, int> mp;
        set<int> dryDays;
        for (int i = 0; i < n; i++) {
            if (rains[i] > 0) {
                if (mp.find(rains[i]) == mp.end()) {
                    mp[rains[i]] = i;
                } else {
                    int last = mp[rains[i]];
                    auto it = dryDays.lower_bound(last);
                    if (it == dryDays.end()) return {};
                    ans[*it] = rains[i];
                    dryDays.erase(it);
                    mp[rains[i]] = i;
                }
                ans[i] = -1;
            } else {
                dryDays.insert(i);
            }
        }
        for (int i = 0; i < n; i++) {
            if (ans[i] == 1) ans[i] = 1;
        }
        return ans;

=======

        vector<int> ans(rains.size(), 1);
        map<int, int> lastRains;
        set<int> dryLakes;
        for (int i = 0; i < rains.size(); i++) {
            if (rains[i] == 0) {
                dryLakes.insert(i);
            } else {
                if (lastRains.find(rains[i]) != lastRains.end()) {
                    auto it = dryLakes.lower_bound(lastRains[rains[i]]);
                    if (it == dryLakes.end()) return vector<int>();
                    ans[*it] = rains[i];
                    dryLakes.erase(it);
                }
                lastRains[rains[i]] = i;
                ans[i] = -1;
            }
        }
        return ans;

=======

        vector<int> ans(rains.size(), 1);
        unordered_map<int, int> full;
        priority_queue<int, vector<int>, greater<int>> dry;
        for (int i = 0; i < rains.size(); ++i) {
            if (rains[i] == 0) dry.push(i);
            else {
                if (full.find(rains[i]) != full.end()) {
                    if (dry.empty()) return {};
                    int j = dry.top();
                    dry.pop();
                    if (j < full[rains[i]]) return {};
                    ans[j] = rains[i];
                }
                full[rains[i]] = i;
                ans[i] = -1;
            }
        }
        return ans;

=======

        int n = rains.size();
        vector<int> ans(n, 1);
        map<int, int> mp;
        set<int> dryDays;
        for (int i = 0; i < n; i++) {
            if (rains[i] > 0) {
                if (mp.find(rains[i]) == mp.end()) {
                    mp[rains[i]] = i;
                } else {
                    int last = mp[rains[i]];
                    auto it = dryDays.lower_bound(last);
                    if (it == dryDays.end()) return {};
                    ans[*it] = rains[i];
                    dryDays.erase(it);
                    mp[rains[i]] = i;
                }
                ans[i] = -1;
            } else {
                dryDays.insert(i);
            }
        }
        for (int i = 0; i < n; i++) {
            if (ans[i] == 1) ans[i] = 1;
        }
        return ans;
