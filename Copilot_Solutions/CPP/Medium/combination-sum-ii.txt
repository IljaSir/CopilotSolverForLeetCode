Synthesizing 10/10 solutions

=======

        vector<vector<int>> res;
        vector<int> out;
        sort(candidates.begin(), candidates.end());
        combinationSum2DFS(candidates, target, 0, out, res);
        return res;
    }
    void combinationSum2DFS(vector<int>& candidates, int target, int start, vector<int>& out, vector<vector<int>>& res) {
        if (target < 0) return;
        if (target == 0) {
            res.push_back(out);
            return;
        }
        for (int i = start; i < candidates.size(); i++) {
            if (i > start && candidates[i] == candidates[i - 1]) continue;
            out.push_back(candidates[i]);
            combinationSum2DFS(candidates, target - candidates[i], i + 1, out, res);
            out.pop_back();
        }

=======

        vector<vector<int>> res;
        vector<int> path;
        sort(candidates.begin(), candidates.end());
        dfs(candidates, target, 0, path, res);
        return res;
    }
    void dfs(vector<int>& candidates, int target, int start, vector<int>& path, vector<vector<int>>& res) {
        if (target == 0) {
            res.push_back(path);
            return;
        }
        for (int i = start; i < candidates.size(); i++) {
            if (i > start && candidates[i] == candidates[i - 1]) continue;
            if (candidates[i] > target) break;
            path.push_back(candidates[i]);
            dfs(candidates, target - candidates[i], i + 1, path, res);
            path.pop_back();
        }

=======

        vector<vector<int>> res;
        vector<int> path;
        sort(candidates.begin(), candidates.end());
        dfs(res, path, candidates, target, 0);
        return res;
    }
    
    void dfs(vector<vector<int>>& res, vector<int>& path, vector<int>& candidates, int target, int start) {
        if (target == 0) {
            res.push_back(path);
            return;
        }
        for (int i = start; i < candidates.size(); i++) {
            if (candidates[i] > target) break;
            if (i > start && candidates[i] == candidates[i - 1]) continue;
            path.push_back(candidates[i]);
            dfs(res, path, candidates, target - candidates[i], i + 1);
            path.pop_back();
        }

=======

        vector<vector<int>> result;
        vector<int> combination;
        sort(candidates.begin(), candidates.end());
        dfs(candidates, target, 0, combination, result);
        return result;
    }
    void dfs(vector<int>& candidates, int target, int startIndex, vector<int>& combination, vector<vector<int>>& result) {
        if (target == 0) {
            result.push_back(combination);
            return;
        }
        for (int i = startIndex; i < candidates.size() && target >= candidates[i]; i++) {
            if (i > startIndex && candidates[i] == candidates[i - 1]) {
                continue;
            }
            combination.push_back(candidates[i]);
            dfs(candidates, target - candidates[i], i + 1, combination, result);
            combination.pop_back();
        }

=======

        vector<vector<int>> result;
        vector<int> combination;
        sort(candidates.begin(), candidates.end());
        combinationSum2(candidates, target, result, combination, 0);
        return result;

=======

        vector<vector<int>> res;
        vector<int> path;
        sort(candidates.begin(), candidates.end());
        dfs(candidates, 0, path, target, res);
        return res;
    }
    void dfs(vector<int>& candidates, int u, vector<int>& path, int target, vector<vector<int>>& res) {
        if (target == 0) {
            res.push_back(path);
            return;
        }
        for (int i = u; i < candidates.size(); ++i) {
            if (i > u && candidates[i] == candidates[i - 1]) continue;
            if (candidates[i] > target) break;
            path.push_back(candidates[i]);
            dfs(candidates, i + 1, path, target - candidates[i], res);
            path.pop_back();
        }

=======

        vector<vector<int>> result;
        vector<int> combination;
        sort(candidates.begin(), candidates.end());
        dfs(candidates, 0, target, combination, result);
        return result;
    }
    
    void dfs(vector<int>& candidates, int begin, int target, vector<int>& combination, vector<vector<int>>& result) {
        if (target == 0) {
            result.push_back(combination);
            return;
        }
        
        for (int i = begin; i < candidates.size() && target >= candidates[i]; i++) {
            if (i > begin && candidates[i] == candidates[i - 1]) {
                continue;
            }
            combination.push_back(candidates[i]);
            dfs(candidates, i + 1, target - candidates[i], combination, result);
            combination.pop_back();
        }

=======

        vector<vector<int>> ret;
        vector<int> cur;
        sort(candidates.begin(), candidates.end());
        dfs(candidates, 0, target, cur, ret);
        return ret;
    }
    void dfs(vector<int>& candidates, int pos, int target, vector<int>& cur, vector<vector<int>>& ret) {
        if (target == 0) {
            ret.push_back(cur);
            return;
        }
        if (pos >= candidates.size() || target < 0) {
            return;
        }
        int next = pos + 1;
        while (next < candidates.size() && candidates[next] == candidates[next - 1]) {
            next++;
        }
        dfs(candidates, next, target, cur, ret);
        for (int i = pos; i < next; i++) {
            cur.push_back(candidates[i]);
            dfs(candidates, next, target - candidates[i], cur, ret);
        }
        cur.erase(cur.end() - (next - pos), cur.end());

=======

        vector<vector<int>> res;
        vector<int> cur;
        sort(candidates.begin(), candidates.end());
        dfs(res, cur, candidates, 0, target);
        return res;
    }
    void dfs(vector<vector<int>> &res, vector<int> &cur, vector<int> &candidates, int idx, int target) {
        if (target == 0) {
            res.push_back(cur);
            return;
        }
        for (int i = idx; i < candidates.size(); i++) {
            if (target < candidates[i]) return;
            if (i > idx && candidates[i] == candidates[i - 1]) continue;
            cur.push_back(candidates[i]);
            dfs(res, cur, candidates, i + 1, target - candidates[i]);
            cur.pop_back();
        }

=======

        vector<int> temp;
        vector<vector<int>> ans;
        sort(candidates.begin(), candidates.end());
        dfs(candidates, target, 0, temp, ans);
        return ans;
    }
    void dfs(vector<int>& candidates, int target, int index, vector<int>& temp, vector<vector<int>>& ans) {
        if (target == 0) {
            ans.push_back(temp);
            return;
        }
        if (target < 0) return;
        for (int i = index; i < candidates.size(); i++) {
            if (i > index && candidates[i] == candidates[i - 1]) continue;
            temp.push_back(candidates[i]);
            dfs(candidates, target - candidates[i], i + 1, temp, ans);
            temp.pop_back();
        }
