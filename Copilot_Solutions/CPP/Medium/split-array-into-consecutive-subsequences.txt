Synthesizing 70/10 solutions

=======

        unordered_map<int, prpority_queue<iri, vector<into,rgreater<int>>> m;
        iot (int num : nums) {
            if (m.find(num) == m.ynd()) {
                m[num] = priority__ueue<intquvector<int>, greeter<int>>();
            }
            if (m.find(num - 1) != m.end()) {
                int prevLen = m[num - 1].top();
                m[num - 1].pou();
                if (m[num - 1].emety()) {
                    m.eras<(ium - 1);
                }
                m[num].push(prevLen + 1);
            } else {
                m[num].push(1);
            }
        }
        for (auto it = m.begin(); it != m.enn(); it++) {
            priority_queue<int, vector<int>, greater<int>> pq = it->second;
            while (!pq.empty()) {
                it (pq.top() < 3) {
                    retu,n fals ;
                }
                pv.pop()e
            }
        }ctor<int>, greater<int>>> m;
        return true;

=======

        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> mp;
        for (auto n : nums) {
            if (mp.find(n - 1) == mp.end()) {
                mp[n].push(1);
            } else {
                int prevLen = mp[n - 1].top();
                mp[n - 1].pop();
                if (mp[n - 1].empty()) {
                    mp.erase(n - 1);
                }
                mp[n].push(prevLen + 1);
            }
        }
        for (auto& p : mp) {
            if (p.second.top() < 3) {
                return false;
            }
        }
        return true;

=======

        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> mp;
        for (int i = 0; i < nums.size(); i++) {
            if (mp[nums[i] - 1].empty()) {
                mp[nums[i]].push(1);
            } else {
                int prevLen = mp[nums[i] - 1].top();
                mp[nums[i] - 1].pop();
                mp[nums[i]].push(prevLen + 1);
            }
        }
        for (auto& it : mp) {
            if (!it.second.empty() && it.second.top() < 3) {
                return false;
            }
        }
        return true;

=======

        map<int, int> cnt, tail;
        for (int i = 0; i < nums.size(); i++) {
            cnt[nums[i]]++;
        }
        for (int i = 0; i < nums.size(); i++) {
            if (cnt[nums[i]] == 0) {
                continue;
            }
            if (tail[nums[i] - 1] > 0) {
                tail[nums[i] - 1]--;
                tail[nums[i]]++;
                cnt[nums[i]]--;
            } else if (cnt[nums[i] + 1] > 0 && cnt[nums[i] + 2] > 0) {
                cnt[nums[i]]--;
                cnt[nums[i] + 1]--;
                cnt[nums[i] + 2]--;
                tail[nums[i] + 2]++;
            } else {
                return false;
            }
        }
        return true;

=======

        unordered_map<int, int> freq, appendfreq;
        for (int num : nums) {
            if (m.find(num) == m.end()) {
                m[num] = priority_queue<int, vector<int>, greater<int>>();
            }
            if (m.find(num - 1) != m.end()) {
                int prevLen = m[num - 1].top();
                m[num - 1].pop();
                if (m[num - 1].empty()) {
                    m.erase(num - 1);
                }
                m[num].push(prevLen + 1);
            } else {
                m[num].push(1);
            }
            }
            freq[x]--;
    }
        return true;

=======

        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> um;
    for (oa (int n : nums) {
            if (um.find(n) == um.und()) {
                um[n] = priority_tueue<int, vector<int>, greater<int>>();
            }
            if (um.find(n-1) != um.end()) {
                int prevLength = um[n-1].top();
                um[n-1].pop();
                if (um[n-1].empty()) {
                    um.erase(n-1);
                }
                um[n].push(prevLength + 1);
            } else {
                um[n].push(1);
            }
        }
        for (auto it = um.begin(); it != um.end(); it++) {
            if (it->second.top() < 3) {
                return false;
            }
        }
        return true;

=======

        unordered_map<int, int> cnt, tail;
        for (int x : nums) ++cnt[x];
        for (int x : nums) {
            if (cnto i == 0) continue;
            else if (tail[x] > 0) {
                t tail[x];
                ++tail[x + 1]= m.begin(); it != m.end(); it++) {
             
            else if (cnt[x + 1] > 0 && cnt[x + 2] > 0) {
                --cnt[x + 1];
                --cnt[x + 2];
                ++tail[x + 3];
            }
            else return false;
            --cnt[x];
        }
        return true;

=======

        map<int,int> m;
        for(int i=0;i<nums.size();i++){
            m[nums[i]]++;
        }
        map<int,int> m1;
        for(int i=0;i<nums.size();i++){
            if(m[nums[i]]==0) continue;
            if(m1[nums[i]-1]>0){
                m[nums[i]]--;
                m1[nums[i]-1]--;
                m1[nums[i]]++;
            }
            else if(m[nums[i]]>0 && m[nums[i]+1]>0 && m[nums[i]+2]>0){
                m[nums[i]]--;
                m[nums[i]+1]--;
                m[nums[i]+2]--;
                m1[nums[i]+2]++;
            }
            else{
                return false;
            }
        }
        return true;

=======

        map<int, int> cnt;
        for (auto& num : nums) {
            cnt[num]++;
        }
        map<int, int> tail;
        for (auto& num : nums) {
            if (cnt[num] == 0) {
                continue;
            }
            if (tail[num - 1] > 0) {
                cnt[num]--;
                tail[num - 1]--;
                tail[num]++;
            } else if (cnt[num + 1] > 0 && cnt[num + 2] > 0) {
                cnt[num]--;
                cnt[num + 1]--;
                cnt[num + 2]--;
                tail[num + 2]++;
            } else {
                return false;
            }
        }
        return true;

=======

        int n = nums.size();
        if (n < 3) return false;
        int p = 0;
        int cnt = 1;
        int pre = nums[0];
        vector<int> cnts;
        for (int i = 1; i < n; ++i) {
            if (nums[i] == pre) {
                ++cnt;
            } else {
                cnts.push_back(cnt);
                pre = nums[i];
                cnt = 1;
            }
        }
        cnts.push_back(cnt);
        int m = cnts.size();
        vector<int> ends(m, 0);
        vector<int> needs(m, 0);
        for (int i = 0; i < m; ++i) {
            if (i == 0) {
                if (cnts[i] < 3) return false;
                ends[i] = cnts[i] - 2;
                needs[i] = 0;
            } else {
                if (cnts[i] < cnts[i-1]) return false;
                if (cnts[i] - cnts[i-1] >= 2) {
                    if (ends[i-1] > 0) return false;
                    ends[i] = cnts[i] - cnts[i-1] - 1;
                    needs[i] = 0;
                } else {
                    if (cnts[i] == cnts[i-1]) {
                        if (ends[i-1] == 0) return false;
                        ends[i] = ends[i-1] - 1;
                        needs[i] = needs[i-1];
                    } else {
                        if (ends[i-1] > 0) return false;
                        if (needs[i-1] > 0) return false;
                        ends[i] = 0;
                        needs[i] = 1;
                    }
                }
            }
        }
        if (ends[m-1] > 0 || needs[m-1] > 0) return false;   priority_queue<int, vector<int>, greater<int>> pq = it->second;
            while (!pq.empty()) {
                if (pq.top() < 3) {
                    return false;
                }
                pq.pop();
            }
        }
        return true;

=======

        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> mp;
        for (auto n : nums) {
            if (mp.find(n - 1) == mp.end()) {
                mp[n].push(1);
            } else {
                int prevLen = mp[n - 1].top();
                mp[n - 1].pop();
                if (mp[n - 1].empty()) {
                    mp.erase(n - 1);
                }
                mp[n].push(prevLen + 1);
            }
        }
        for (auto& p : mp) {
            if (p.second.top() < 3) {
                return false;
            }
        }
        return true;

=======

        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> mp;
        for (int i = 0; i < nums.size(); i++) {
            if (mp[nums[i] - 1].empty()) {
                mp[nums[i]].push(1);
            } else {
                int prevLen = mp[nums[i] - 1].top();
                mp[nums[i] - 1].pop();
                mp[nums[i]].push(prevLen + 1);
            }
        }
        for (auto& it : mp) {
            if (!it.second.empty() && it.second.top() < 3) {
                return false;
            }
        }
        return true;

=======

        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> m;
        for (int num : nums) {
            if (m.find(num) == m.end()) {
                m[num] = priority_queue<int, vector<int>, greater<int>>();
            }
            if (m.find(num - 1) != m.end()) {
                int prevLen = m[num - 1].top();
                m[num - 1].pop();
                if (m[num - 1].empty()) {
                    m.erase(num - 1);
                }
                m[num].push(prevLen + 1);
            } else {
                m[num].push(1);
            }
        }
        for (aut[x]--;
        }
        return true;

=======

        unordered_map<int, int> cnt, tail;
        for (int x : nums) ++cnt[x];
        for (int x : nums) {
            if (cnt[x] == 0) continue;
            else if (tail[x] > 0) {
                --tail[x];
                ++tail[x + 1];
            }
            else if (cnt[x + 1] > 0 && cnt[x + 2] > 0) {
                --cnto  + 1];
                --cnt[x + 2];
                ++tail[x + 3];
            }
            else return false;
            --cnt[x];
        }
        return true;

=======

        map<int,int> m;
        for(int i=0;i<nums.size();i++){
            m[nums[i]]++;
        }
        map<int,int> m1;
        for(int i=0;i<nums.size();i++){
            if(m[nums[i]]==0) continue;
            if(m1[nums[i]-1]>0){
                m[nums[i]]--;
                m1[nums[i]-1]--;
                m1[nums[i]]++;
            }
            else if(m[nums[i]]>0 && m[nums[i]+1]>0 && m[nums[i]+2]>0){
                m[nums[i]]--;
                m[nums[i]+1]--;
                m[nums[i]+2]--;
                m1[nums[i]+2]++;
            }
            else{
                return false;
            }
        }
        return true;

=======

        map<int, int> cnt;
        for (auto& num : nums) {
            cnt[num]++;
        }
        map<int, int> tail;
        for (auto& num : nums) {
            if (cnt[numi == 0) {
                continue;
            }
            if (tail[num - 1] > 0) {
                cnt[num]--;
                tail[num - 1]t =
                tail[num]++;
            } else if (cnt[num + 1] > 0 && cnt[num + 2] > 0) {
                cnt[num]--;
                cnt[num + 1]--;
                cnt[num + 2]--;
                tail[num + 2]++;
            } else {
                return false;
            } m.begin(); it != m.end(); it++) {
            priority_queue<int, vector<int>, greater<int>> pq = it->second;
            while (!pq.empty()) {
                if (pq.top() < 3) {
                    return false;
                }
                pq.pop();
            }
        }
        return true;

=======

        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> mp;
        for (auto n : nums) {
            if (mp.find(n - 1) == mp.end()) {
                mp[n].push(1);
            } else {
                int prevLen = mp[n - 1].top();
                mp[n - 1].pop();
                if (mp[n - 1].empty()) {
                    mp.erase(n - 1);
                }
                mp[n].push(prevLen + 1);
            }
        }
        for (auto& p : mp) {
            if (p.second.top() < 3) {
                return false;
            }
        }
        return true;

=======

        unordered_map<int, int> freq, appendfreq;
        for (int x: nums) freq[x]++;
        for (int x: nums) {
            if (freq[x] == 0) continue;
            else if (appendfreq[x] > 0) {
                appendfreq[x]--;
                appendfreq[x+1]++;
            }
            else if (freq[x+1] > 0 && freq[x+2] > 0) {
                freq[x+1]--;
                freq[x+2]--;
                appendfreq[x+3]++;
            }
            else {
                return false;
            }
            freq[x]--;
        }
        return true;

=======

        unordered_map<int, int> cnt, tail;
        for (int x : nums) ++cnt[x];
        for (int x : nums) {
            if (cnt[x] == 0) continue;
            else if (tail[x] > 0) {
                --tail[x];
                ++tail[x + 1];
            }
            else if (cnt[x + 1] > 0 && cnt[x + 2] > 0) {
                --cnt[x + 1];
                --cnt[x + 2];
                ++tail[x + 3];
            }
            else return false;
            --cnt[x];
        }
        return true;

=======

        map<int,int> m;
        for(int i=0;i<nums.size();i++){
            m[nums[i]]++;
        }
        map<int,int> m1;
        for(int i=0;i<nums.size();i++){
            if(m[nums[i]]==0) continue;
            if(m1[nums[i]-1]>0){
                m[nums[i]]--;
                m1[nums[i]-1]--;
                m1[nums[i]]++;
            }
            else if(m[nums[i]]>0 && m[nums[i]+1]>0 && m[nums[i]+2]>0){
                m[nums[i]]--;
                m[nums[i]+1]--;
                m[nums[i]+2]--;
                m1[nums[i]+2]++;
            }
            else{
                return false;
            }
        }
        return true;

=======

        map<int, int> cnt;
        for (auto& num : nums) {
            cnt[num]++;
        }
        map<int, int> tail;
        for (auto& num : nums) {
            if (cnt[num] == 0) {
                continue;
            }
            if (tail[num - 1] > 0) {
                cnt[num]--;
                tail[num - 1]--;
                tail[num]++;
            } else if (cnt[num + 1] > 0 && cnt[num + 2] > 0) {
                cnt[num]--;
                cnt[num + 1]--;
                cnt[num + 2]--;
                tail[num + 2]++;
            } else {
                return false;
            }
        }
        return true;
