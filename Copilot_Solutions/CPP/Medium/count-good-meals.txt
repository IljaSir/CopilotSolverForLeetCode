Synthesizing 10/10 solutions

=======

        const int MOD = 1e9 + 7;
        unordered_map<int, int> cnt;
        int maxVal = *max_element(deliciousness.begin(), deliciousness.end());
        int maxSum = maxVal * 2;
        int pairs = 0;
        for (int val : deliciousness) {
            for (int sum = 1; sum <= maxSum; sum <<= 1) {
                int count = cnt.count(sum - val) ? cnt[sum - val] : 0;
                pairs = (pairs + count) % MOD;
            }
            cnt[val]++;
        }
        return pairs;

=======

        unordered_map<int, int> m;
        int res = 0;
        for (int i = 0; i < deliciousness.size(); i++) {
            for (int j = 0; j < 22; j++) {
                int target = pow(2, j);
                if (m.count(target - deliciousness[i])) {
                    res = (res + m[target - deliciousness[i]]) % 1000000007;
                }
            }
            m[deliciousness[i]]++;
        }
        return res;

=======

        unordered_map<int, int> m;
        int res = 0;
        for (int i = 0; i < deliciousness.size(); ++i) {
            for (int j = 0; j <= 21; ++j) {
                int t = 1 << j;
                res = (res + m[t - deliciousness[i]]) % 1000000007;
            }
            ++m[deliciousness[i]];
        }
        return res;

=======

        int mod = 1e9 + 7;
        unordered_map<int, int> mp;
        int ans = 0;
        for (int i = 0; i < deliciousness.size(); i++) {
            for (int j = 0; j <= 20; j++) {
                int sum = (1 << j) - deliciousness[i];
                if (mp.find(sum) != mp.end()) {
                    ans += mp[sum];
                    ans %= mod;
                }
            }
            mp[deliciousness[i]]++;
        }
        return ans;

=======

        int n = deliciousness.size();
        unordered_map<int, int> mp;
        int res = 0;
        for (int i = 0; i < n; i++) {
            int val = deliciousness[i];
            for (int j = 0; j < 22; j++) {
                int target = 1 << j;
                if (mp.count(target - val)) {
                    res += mp[target - val];
                    res %= 1000000007;
                }
            }
            mp[val]++;
        }
        return res;

=======

        int MOD = 1e9 + 7;
        int mx = 0;
        for (int x: deliciousness) mx = max(mx, x);
        int maxSum = mx * 2;
        int pairs = 0;
        unordered_map<int, int> cnt;
        for (int x: deliciousness) {
            for (int sum = 1; sum <= maxSum; sum <<= 1) {
                int y = sum - x;
                if (cnt.count(y)) pairs = (pairs + cnt[y]) % MOD;
            }
            cnt[x]++;
        }
        return pairs;

=======

        map<int, int> m;
        int res = 0;
        int mod = 1e9 + 7;
        for (auto d : deliciousness) {
            int sum = 1;
            for (int i = 0; i <= 21; i++) {
                if (m.count(sum - d)) {
                    res += m[sum - d];
                    res %= mod;
                }
                sum <<= 1;
            }
            m[d]++;
        }
        return res;

=======

        int maxSum = 0;
        for (auto& d : deliciousness) {
            maxSum = max(maxSum, d);
        }
        maxSum *= 2;
        
        unordered_map<int, int> m;
        int ans = 0;
        for (auto& d : deliciousness) {
            int sum = 1;
            while (sum <= maxSum) {
                ans += m[sum - d];
                ans %= 1000000007;
                sum *= 2;
            }
            m[d]++;
        }
        return ans;

=======

        const int mod = 1e9 + 7;
        int max = 0;
        for (auto &d : deliciousness) {
            max = std::max(max, d);
        }
        int max_sum = max * 2;
        std::unordered_map<int, int> m;
        int count = 0;
        for (auto &d : deliciousness) {
            for (int i = 1; i <= max_sum; i <<= 1) {
                int t = i - d;
                if (m.count(t)) {
                    count = (count + m[t]) % mod;
                }
            }
            m[d]++;
        }
        return count;

=======

        long n = deliciousness.size();
        long mod = 1000000007;
        long sum = 0;
        unordered_map<int, int> m;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j <= 21; ++j) {
                int x = pow(2, j) - deliciousness[i];
                if (m.find(x) != m.end()) {
                    sum = (sum + m[x]) % mod;
                }
            }
            m[deliciousness[i]]++;
        }
        return sum;
