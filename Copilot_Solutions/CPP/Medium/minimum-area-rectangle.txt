Synthesizing 10/10 solutions (Duplicates hidden)

=======

        unordered_map<int, unordered_set<int>> mp;
        for (auto v : points) {
            mp[v[0]].insert(v[1]);
        }
        int ans = INT_MAX;
        for (int i = 0; i < points.size(); ++i) {
            for (int j = i + 1; j < points.size(); ++j) {
                if (points[i][0] == points[j][0] || points[i][1] == points[j][1]) {
                    continue;
                }
                if (mp[points[i][0]].count(points[j][1]) && mp[points[j][0]].count(points[i][1])) {
                    ans = min(ans, abs(points[i][0] - points[j][0]) * abs(points[i][1] - points[j][1]));
                }
            }
        }
        return ans == INT_MAX ? 0 : ans;

=======

        int ans = INT_MAX;
        unordered_map<int, unordered_set<int>> mp;
        for (auto& p : points) {
            mp[p[0]].insert(p[1]);
        }
        for (int i = 0; i < points.size(); ++i) {
            for (int j = i + 1; j < points.size(); ++j) {
                if (points[i][0] == points[j][0] || points[i][1] == points[j][1]) {
                    continue;
                }
                if (mp[points[i][0]].count(points[j][1]) && mp[points[j][0]].count(points[i][1])) {
                    ans = min(ans, abs(points[j][0] - points[i][0]) * abs(points[j][1] - points[i][1]));
                }
            }
        }
        return ans == INT_MAX ? 0 : ans;

=======

        unordered_set<int> s;
        for (auto& p : points) {
            s.insert(p[0] * 40001 + p[1]);
        }
        int ans = INT_MAX;
        for (auto& p1 : points) {
            for (auto& p2 : points) {
                if (p1[0] == p2[0] || p1[1] == p2[1]) {
                    continue;
                }
                if (s.count(p1[0] * 40001 + p2[1]) && s.count(p2[0] * 40001 + p1[1])) {
                    ans = min(ans, abs(p1[0] - p2[0]) * abs(p1[1] - p2[1]));
                }
            }
        }
        return ans == INT_MAX ? 0 : ans;

=======

        int n = points.size();
        int ans = INT_MAX;
        unordered_map<int, vector<int>> mp;
        for (int i = 0; i < n; i++) {
            mp[points[i][0]].push_back(points[i][1]);
        }
        for (int i = 0; i < n - 1; i++) {
            for (int j = i + 1; j < n; j++) {
                if (points[i][0] == points[j][0] || points[i][1] == points[j][1]) {
                    continue;
                }
                if (binary_search(mp[points[i][0]].begin(), mp[points[i][0]].end(), points[j][1])
                    && binary_search(mp[points[j][0]].begin(), mp[points[j][0]].end(), points[i][1])) {
                    ans = min(ans, abs(points[i][0] - points[j][0]) * abs(points[i][1] - points[j][1]));
                }
            }
        }
        return ans == INT_MAX ? 0 : ans;

=======

        int n = points.size();
        if (n < 4) return 0;
        unordered_map<int, set<int>> m;
        for (auto& p : points) m[p[0]].insert(p[1]);
        int ans = INT_MAX;
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                int x1 = points[i][0], y1 = points[i][1];
                int x2 = points[j][0], y2 = points[j][1];
                if (x1 == x2 || y1 == y2) continue;
                if (m[x1].count(y2) && m[x2].count(y1)) {
                    ans = min(ans, abs(x1 - x2) * abs(y1 - y2));
                }
            }
        }
        return ans == INT_MAX ? 0 : ans;

=======

        int n = points.size();
        map<int, set<int>> mp;
        for (auto& p: points) {
            mp[p[0]].insert(p[1]);
        }
        int res = INT_MAX;
        for (auto it1 = mp.begin(); it1 != mp.end(); ++it1) {
            for (auto it2 = next(it1); it2 != mp.end(); ++it2) {
                vector<int> y;
                set_intersection(it1->second.begin(), it1->second.end(), it2->second.begin(), it2->second.end(), back_inserter(y));
                for (int i = 1; i < y.size(); ++i) {
                    res = min(res, (it2->first - it1->first) * (y[i] - y[i - 1]));
                }
            }
        }
        return res == INT_MAX ? 0 : res;

=======

        unordered_map<int, unordered_set<int>> M;
        for (auto &p : points) {
            M[p[0]].insert(p[1]);
        }
        int res = INT_MAX;
        for (auto &p : points) {
            for (auto &q : points) {
                if (p[0] == q[0] || p[1] == q[1]) continue;
                if (M[p[0]].count(q[1]) && M[q[0]].count(p[1])) {
                    res = min(res, abs(p[0] - q[0]) * abs(p[1] - q[1]));
                }
            }
        }
        return res == INT_MAX ? 0 : res;

=======

        int n = points.size();
        int ans = 1e9;
        unordered_map<int, unordered_set<int>> mp;
        for (auto p: points) {
            mp[p[0]].insert(p[1]);
        }
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                int x1 = points[i][0], y1 = points[i][1];
                int x2 = points[j][0], y2 = points[j][1];
                if (x1 != x2 && y1 != y2 && mp[x1].count(y2) && mp[x2].count(y1)) {
                    ans = min(ans, abs(x1 - x2) * abs(y1 - y2));
                }
            }
        }
        return ans == 1e9 ? 0 : ans;

=======

        int n = points.size();
        if(n < 4) return 0;
        int ans = INT_MAX;
        unordered_map<int, unordered_set<int>> m;
        for(auto& p: points) {
            m[p[0]].insert(p[1]);
        }
        for(int i = 0; i < n; ++i) {
            for(int j = i+1; j < n; ++j) {
                if(points[i][0] == points[j][0] || points[i][1] == points[j][1]) continue;
                if(m[points[i][0]].count(points[j][1]) && m[points[j][0]].count(points[i][1])) {
                    ans = min(ans, abs(points[i][0] - points[j][0]) * abs(points[i][1] - points[j][1]));
                }
            }
        }
        return ans == INT_MAX ? 0 : ans;
