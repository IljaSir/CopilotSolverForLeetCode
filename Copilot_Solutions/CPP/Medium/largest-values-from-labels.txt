Synthesizing 10/10 solutions

=======

        vector<pair<int, int>> v;
        for (int i = 0; i < values.size(); ++i) {
            v.push_back({values[i], labels[i]});
        }
        sort(v.begin(), v.end(), [](auto& a, auto& b) {
            return a.first > b.first;
        });
        int ans = 0;
        int num = 0;
        unordered_map<int, int> cnt;
        for (auto& p : v) {
            if (num == numWanted) {
                break;
            }
            if (cnt[p.second] < useLimit) {
                ans += p.first;
                ++cnt[p.second];
                ++num;
            }
        }
        return ans;

=======

        int n = values.size();
        vector<pair<int, int>> v(n);
        for (int i = 0; i < n; ++i) {
            v[i] = {values[i], labels[i]};
        }
        sort(v.begin(), v.end(), greater<pair<int, int>>());
        unordered_map<int, int> m;
        int result = 0;
        for (int i = 0; i < n; ++i) {
            if (numWanted == 0) {
                break;
            }
            if (m[v[i].second] < useLimit) {
                ++m[v[i].second];
                result += v[i].first;
                --numWanted;
            }
        }
        return result;

=======

        vector<pair<int, int>> items;
        for (int i = 0; i < values.size(); ++i) {
            items.push_back({values[i], labels[i]});
        }
        sort(items.begin(), items.end(), [](const pair<int, int>& p1, const pair<int, int>& p2) {
            return p1.first > p2.first;
        });
        unordered_map<int, int> label_count;
        int sum = 0;
        for (int i = 0; i < items.size(); ++i) {
            if (numWanted == 0) {
                break;
            }
            if (label_count[items[i].second] < useLimit) {
                sum += items[i].first;
                label_count[items[i].second]++;
                numWanted--;
            }
        }
        return sum;

=======

        int n = values.size();
        vector<pair<int, int>> v;
        for (int i = 0; i < n; i++) {
            v.push_back({values[i], labels[i]});
        }
        sort(v.begin(), v.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
            return a.first > b.first;
        });
        unordered_map<int, int> m;
        int ans = 0;
        for (int i = 0; i < n; i++) {
            if (numWanted == 0) {
                break;
            }
            if (m[v[i].second] < useLimit) {
                ans += v[i].first;
                m[v[i].second]++;
                numWanted--;
            }
        }
        return ans;

=======

        vector<pair<int,int>> v;
        for(int i=0;i<values.size();i++){
            v.push_back({values[i],labels[i]});
        }
        sort(v.begin(),v.end(),greater<pair<int,int>>());
        map<int,int> mp;
        int ans=0;
        for(int i=0;i<v.size();i++){
            if(mp[v[i].second]<useLimit){
                ans+=v[i].first;
                mp[v[i].second]++;
                numWanted--;
            }
            if(numWanted==0) break;
        }
        return ans;

=======

        vector<pair<int, int>> v;
        for (int i = 0; i < values.size(); i++) {
            v.push_back({values[i], labels[i]});
        }
        sort(v.begin(), v.end(), [](const auto& a, const auto& b) {
            return a.first > b.first;
        });
        unordered_map<int, int> m;
        int ans = 0;
        for (auto& p : v) {
            if (numWanted <= 0) break;
            if (m[p.second] < useLimit) {
                ans += p.first;
                m[p.second]++;
                numWanted--;
            }
        }
        return ans;

=======

        int n = values.size();
        vector<pair<int, int>> v;
        for (int i = 0; i < n; ++i) {
            v.emplace_back(values[i], labels[i]);
        }
        sort(v.begin(), v.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
            return a.first > b.first;
        });
        unordered_map<int, int> cnt;
        int res = 0;
        for (int i = 0; i < n && numWanted > 0; ++i) {
            if (++cnt[v[i].second] <= useLimit) {
                res += v[i].first;
                --numWanted;
            }
        }
        return res;

=======

        vector<pair<int,int>> v;
        int n = values.size();
        for(int i = 0; i < n; i++){
            v.push_back({values[i],labels[i]});
        }
        sort(v.begin(),v.end());
        reverse(v.begin(),v.end());
        map<int,int> m;
        int ans = 0;
        for(int i = 0; i < n; i++){
            if(numWanted == 0) break;
            if(m[v[i].second] < useLimit){
                m[v[i].second]++;
                ans += v[i].first;
                numWanted--;
            }
        }
        return ans;

=======

        vector<pair<int, int>> v;
        for (int i = 0; i < values.size(); i++)
            v.push_back({values[i], labels[i]});
        sort(v.begin(), v.end(), [](const auto& a, const auto& b) {
            return a.first > b.first;
        });
        unordered_map<int, int> m;
        int ans = 0;
        for (int i = 0; i < v.size(); i++) {
            if (numWanted == 0) break;
            int value = v[i].first;
            int label = v[i].second;
            if (m[label] < useLimit) {
                ans += value;
                m[label]++;
                numWanted--;
            }
        }
        return ans;

=======

        map<int, vector<int>> m;
        for (int i = 0; i < values.size(); i++) {
            m[values[i]].push_back(labels[i]);
        }
        map<int, int> use;
        int res = 0;
        for (auto it = m.rbegin(); it != m.rend(); it++) {
            for (int i = 0; i < it->second.size(); i++) {
                if (numWanted == 0) {
                    return res;
                }
                if (use[it->second[i]] < useLimit) {
                    res += it->first;
                    numWanted--;
                    use[it->second[i]]++;
                }
            }
        }
        return res;
