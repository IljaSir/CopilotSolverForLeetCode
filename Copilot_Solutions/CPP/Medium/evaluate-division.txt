Synthesizing 10/10 solutions

=======

        unordered_map<string, unordered_map<string, double>> graph;
        for (int i = 0; i < equations.size(); i++) {
            graph[equations[i][0]][equations[i][1]] = values[i];
            graph[equations[i][1]][equations[i][0]] = 1 / values[i];
        }
        vector<double> ans;
        for (auto& query: queries) {
            unordered_set<string> visited;
            ans.push_back(dfs(query[0], query[1], graph, visited));
        }
        return ans;
    }
    
    double dfs(string& start, string& end, unordered_map<string, unordered_map<string, double>>& graph, unordered_set<string>& visited) {
        if (!graph.count(start)) return -1.0;
        if (graph[start].count(end)) return graph[start][end];
        visited.insert(start);
        for (auto& [node, val]: graph[start]) {
            if (visited.count(node)) continue;
            double ret = dfs(node, end, graph, visited);
            if (ret != -1.0) return ret * val;
        }
        return -1.0;

=======

        unordered_map<string, unordered_map<string, double>> graph;
        for (int i = 0; i < equations.size(); ++i) {
            graph[equations[i][0]][equations[i][1]] = values[i];
            graph[equations[i][1]][equations[i][0]] = 1 / values[i];
        }
        vector<double> res;
        for (auto& query : queries) {
            unordered_set<string> visited;
            res.push_back(dfs(query[0], query[1], graph, visited));
        }
        return res;

=======

        unordered_map<string, unordered_map<string, double>> graph;
        for (int i = 0; i < equations.size(); ++i) {
            graph[equations[i][0]][equations[i][1]] = values[i];
            graph[equations[i][1]][equations[i][0]] = 1 / values[i];
        }
        vector<double> res;
        for (const auto& q : queries) {
            unordered_set<string> visited;
            res.push_back(dfs(graph, q[0], q[1], visited));
        }
        return res;
    }
    double dfs(unordered_map<string, unordered_map<string, double>>& graph, string start, string end, unordered_set<string>& visited) {
        if (visited.count(start)) return -1.0;
        if (graph.count(start) && graph[start].count(end)) return graph[start][end];
        visited.insert(start);
        for (const auto& p : graph[start]) {
            double tmp = dfs(graph, p.first, end, visited);
            if (tmp != -1.0) return tmp * p.second;
        }
        return -1.0;

=======

        unordered_map<string, unordered_map<string, double>> graph;
        for (int i = 0; i < equations.size(); ++i) {
            graph[equations[i][0]][equations[i][1]] = values[i];
            graph[equations[i][1]][equations[i][0]] = 1.0 / values[i];
        }
        vector<double> result;
        for (auto& query : queries) {
            unordered_set<string> visited;
            result.push_back(dfs(graph, query[0], query[1], visited));
        }
        return result;
    }
    
    double dfs(unordered_map<string, unordered_map<string, double>>& graph, string& start, string& end, unordered_set<string>& visited) {
        if (graph.count(start) == 0 || graph.count(end) == 0) {
            return -1.0;
        }
        if (graph[start].count(end) == 1) {
            return graph[start][end];
        }
        visited.insert(start);
        for (auto& neighbor : graph[start]) {
            if (visited.count(neighbor.first) == 0) {
                double result = dfs(graph, neighbor.first, end, visited);
                if (result != -1.0) {
                    return neighbor.second * result;
                }
            }
        }
        return -1.0;

=======

        unordered_map<string, unordered_map<string, double>> mp;
        for (int i = 0; i < equations.size(); i++) {
            mp[equations[i][0]][equations[i][1]] = values[i];
            mp[equations[i][1]][equations[i][0]] = 1.0 / values[i];
        }
        
        vector<double> ans;
        for (auto& q : queries) {
            double res = -1.0;
            if (mp.find(q[0]) != mp.end() && mp.find(q[1]) != mp.end()) {
                unordered_set<string> visited;
                res = dfs(q[0], q[1], mp, visited);
            }
            ans.push_back(res);
        }
        return ans;
    }
    
    double dfs(string s, string t, unordered_map<string, unordered_map<string, double>>& mp, unordered_set<string>& visited) {
        if (s == t) return 1.0;
        visited.insert(s);
        for (auto& p : mp[s]) {
            if (visited.find(p.first) == visited.end()) {
                double res = dfs(p.first, t, mp, visited);
                if (res != -1.0) {
                    return res * p.second;
                }
            }
        }
        return -1.0;

=======

        unordered_map<string, unordered_map<string, double>> graph;
        for (int i = 0; i < equations.size(); i++) {
            graph[equations[i][0]].insert({equations[i][1], values[i]});
            graph[equations[i][1]].insert({equations[i][0], 1 / values[i]});
        }
        vector<double> res;
        for (auto &q: queries) {
            if (graph.find(q[0]) == graph.end() || graph.find(q[1]) == graph.end())
                res.push_back(-1);
            else {
                unordered_set<string> visited;
                res.push_back(dfs(graph, q[0], q[1], visited));
            }
        }
        return res;
    }
    
    double dfs(unordered_map<string, unordered_map<string, double>> &graph, string &start, string &end, unordered_set<string> &visited) {
        if (start == end) return 1;
        visited.insert(start);
        for (auto &p: graph[start]) {
            if (visited.find(p.first) == visited.end()) {
                double d = dfs(graph, p.first, end, visited);
                if (d != -1) return d * p.second;
            }
        }
        return -1;

=======

        int n = equations.size();
        unordered_map<string, unordered_map<string, double>> g;
        for (int i = 0; i < n; i++) {
            string a = equations[i][0], b = equations[i][1];
            g[a][b] = values[i];
            g[b][a] = 1 / values[i];
        }
        vector<double> res;
        for (auto& q : queries) {
            string a = q[0], b = q[1];
            if (!g.count(a) || !g.count(b)) {
                res.push_back(-1.0);
                continue;
            }
            unordered_set<string> visited;
            double ans = dfs(g, a, b, visited);
            res.push_back(ans);
        }
        return res;

=======

        vector<double> res;
        unordered_map<string, unordered_map<string, double>> graph;
        for(int i = 0; i < equations.size(); i++) {
            graph[equations[i][0]][equations[i][1]] = values[i];
            graph[equations[i][1]][equations[i][0]] = 1.0 / values[i];
        }
        for(auto& it : graph) {
            it.second[it.first] = 1.0;
            unordered_set<string> visited;
            dfs(it.first, it.first, graph, visited);
        }
        for(auto& query : queries) {
            if(graph.count(query[0]) && graph[query[0]].count(query[1]))
                res.push_back(graph[query[0]][query[1]]);
            else
                res.push_back(-1.0);
        }
        return res;
    }
    void dfs(string start, string cur, unordered_map<string, unordered_map<string, double>>& graph, unordered_set<string>& visited) {
        visited.insert(cur);
        for(auto& it : graph[cur]) {
            if(visited.count(it.first))
                continue;
            graph[start][it.first] = graph[start][cur] * graph[cur][it.first];
            dfs(start, it.first, graph, visited);
        }

=======

        map<string, map<string, double>> g;
        vector<double> ans;
        int n = values.size();
        for (int i = 0; i < n; i++) {
            string &s1 = equations[i][0];
            string &s2 = equations[i][1];
            g[s1][s2] = values[i];
            g[s2][s1] = 1.0 / values[i];
        }
        for (auto &p: g) {
            string &s1 = p.first;
            for (auto &p1: g[s1]) {
                string &s2 = p1.first;
                double v = p1.second;
                for (auto &p2: g[s2]) {
                    string &s3 = p2.first;
                    double v2 = p2.second;
                    g[s1][s3] = v * v2;
                }
            }
        }
        for (auto &q: queries) {
            string &s1 = q[0];
            string &s2 = q[1];
            if (g.count(s1) && g[s1].count(s2)) {
                ans.push_back(g[s1][s2]);
            } else {
                ans.push_back(-1.0);
            }
        }
        return ans;

=======

        unordered_map<string, int> table;
        int n = equations.size();
        int m = queries.size();
        int idx = 0;
        for (int i = 0; i < n; i++) {
            if (!table.count(equations[i][0])) table[equations[i][0]] = idx++;
            if (!table.count(equations[i][1])) table[equations[i][1]] = idx++;
        }
        vector<vector<double>> g(idx, vector<double>(idx, -1));
        for (int i = 0; i < n; i++) {
            int x = table[equations[i][0]];
            int y = table[equations[i][1]];
            g[x][y] = values[i];
            g[y][x] = 1 / values[i];
        }
        for (int i = 0; i < idx; i++) g[i][i] = 1;
        for (int k = 0; k < idx; k++) {
            for (int i = 0; i < idx; i++) {
                for (int j = 0; j < idx; j++) {
                    if (g[i][k] > 0 && g[k][j] > 0) {
                        g[i][j] = g[i][k] * g[k][j];
                    }
                }
            }
        }
        vector<double> ans(m);
        for (int i = 0; i < m; i++) {
            if (!table.count(queries[i][0]) || !table.count(queries[i][1])) {
                ans[i] = -1;
                continue;
            }
            int x = table[queries[i][0]];
            int y = table[queries[i][1]];
            ans[i] = g[x][y];
        }
        return ans;
