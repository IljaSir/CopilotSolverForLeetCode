Synthesizing 10/10 solutions

=======

        vector<vector<int>> graph(n);
        for (auto& road: roads) {
            graph[road[0]].push_back(road[1]);
            graph[road[1]].push_back(road[0]);
        }
        vector<int> visited(n, 0);
        vector<int> values(n, 0);
        for (int i = 0; i < n; ++i) {
            if (visited[i] == 0) {
                visited[i] = 1;
                dfs(graph, i, visited, values);
            }
        }
        long long ans = 0;
        for (auto& road: roads) {
            ans += (long long) values[road[0]] * values[road[1]];
        }
        return ans;
    }
    
    int dfs(vector<vector<int>>& graph, int root, vector<int>& visited, vector<int>& values) {
        int total = 1;
        for (auto& child: graph[root]) {
            if (visited[child] == 0) {
                visited[child] = 1;
                int subtree = dfs(graph, child, visited, values);
                values[root] += subtree;
                total += subtree;
            }
        }
        values[root] += 1;
        return total;

=======

        vector<vector<int>> graph(n);
        for (auto &road : roads) {
            graph[road[0]].push_back(road[1]);
            graph[road[1]].push_back(road[0]);
        }
        vector<int> visited(n, 0);
        vector<int> values(n, 0);
        function<void(int, int)> dfs = [&](int node, int value) {
            visited[node] = 1;
            values[node] = value;
            for (auto &next : graph[node]) {
                if (visited[next]) continue;
                dfs(next, value + 1);
            }
        };
        dfs(0, 1);
        long long res = 0;
        for (auto &road : roads) {
            res += values[road[0]] + values[road[1]];
        }
        return res;

=======

        vector<vector<int>> adj(n);
        for (auto& road : roads) {
            adj[road[0]].push_back(road[1]);
            adj[road[1]].push_back(road[0]);
        }

        vector<int> val(n);
        for (int i = 0; i < n; ++i) {
            val[i] = i + 1;
        }
        long long ans = 0;
        vector<bool> visited(n);
        for (int i = 0; i < n; ++i) {
            if (!visited[i]) {
                long long sum = 0;
                dfs(i, adj, val, visited, sum);
                ans += sum;
            }
        }
        return ans;

=======

        vector<vector<int>> g(n);
        for (auto& r : roads) {
            g[r[0]].push_back(r[1]);
            g[r[1]].push_back(r[0]);
        }
        vector<int> v(n, 0);
        for (int i = 0; i < n; ++i) v[i] = i + 1;
        long long ans = 0;
        function<void(int, int)> dfs = [&](int u, int p) {
            for (int v : g[u]) {
                if (v == p) continue;
                ans += v[u] + v[v];
                dfs(v, u);
            }
        };
        dfs(0, -1);
        return ans;

=======

        vector<vector<int>> graph(n);
        for (auto& r : roads) {
            graph[r[0]].push_back(r[1]);
            graph[r[1]].push_back(r[0]);
        }
        vector<int> visited(n, 0);
        visited[0] = 1;
        int max_total = 0;
        for (int i = 1; i <= n; ++i) {
            int total = 0;
            for (int j = 0; j < n; ++j) {
                if (visited[j] == 1) {
                    total += i;
                    visited[j] = 2;
                    for (auto& v : graph[j]) {
                        if (visited[v] == 0) {
                            visited[v] = 1;
                        }
                    }
                }
            }
            max_total = max(max_total, total);
        }
        return max_total;

=======

        vector<vector<int>> graph(n);
        for (auto& r : roads) {
            graph[r[0]].push_back(r[1]);
            graph[r[1]].push_back(r[0]);
        }
        vector<int> visited(n, 0);
        long long sum = 0;
        dfs(graph, 0, visited, sum);
        return sum;
    }
    void dfs(vector<vector<int>>& graph, int cur, vector<int>& visited, long long& sum) {
        visited[cur] = 1;
        for (int next : graph[cur]) {
            if (visited[next] == 0) {
                sum += 1 + graph[cur].size() + graph[next].size();
                dfs(graph, next, visited, sum);
            }
        }

=======

        long long res = 0;
        vector<vector<int>> g(n);
        for (auto& r : roads) {
            g[r[0]].push_back(r[1]);
            g[r[1]].push_back(r[0]);
        }
        vector<bool> visited(n, false);
        vector<int> val(n);
        function<void(int)> dfs = [&](int u) {
            visited[u] = true;
            val[u] = 1;
            for (auto v : g[u]) {
                if (!visited[v]) {
                    dfs(v);
                    val[u] += val[v];
                }
            }
        };
        dfs(0);
        for (auto& r : roads) {
            res += (long long)val[r[0]] * val[r[1]];
        }
        return res;

=======

        vector<vector<int>> graph(n);
        for (auto& edge : roads) {
            graph[edge[0]].push_back(edge[1]);
            graph[edge[1]].push_back(edge[0]);
        }
        vector<int> visited(n, 0);
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            if (!visited[i]) {
                ans = max(ans, dfs(i, graph, visited));
            }
        }
        return ans;
    }
    
    int dfs(int node, vector<vector<int>>& graph, vector<int>& visited) {
        visited[node] = 1;
        int ans = node + 1;
        for (int nei : graph[node]) {
            if (!visited[nei]) {
                ans += dfs(nei, graph, visited);
            }
        }
        return ans;

=======

        vector<vector<int>> graph(n);
        for(auto & road : roads){
            graph[road[0]].push_back(road[1]);
            graph[road[1]].push_back(road[0]);
        }
        vector<int> visited(n, 0);
        long long ans = 0;
        for(int i = 0; i < n; i++){
            if(visited[i] == 0){
                vector<int> cnt(n, 0);
                dfs(graph, visited, cnt, i);
                long long sum = 0;
                for(int j = 0; j < n; j++){
                    sum += cnt[j] * (cnt[j] - 1) / 2;
                }
                ans = max(ans, sum);
            }
        }
        return ans;
    }
    void dfs(vector<vector<int>> & graph, vector<int> & visited, vector<int> & cnt, int i){
        visited[i] = 1;
        cnt[i] = 1;
        for(auto & j : graph[i]){
            if(visited[j] == 0){
                dfs(graph, visited, cnt, j);
                cnt[i] += cnt[j];
            }
        }

=======

        vector<int> values(n);
        iota(begin(values), end(values), 1);
        long long ans = 0;
        do {
            long long tmp = 0;
            for (auto &road: roads) {
                tmp += values[road[0]] + values[road[1]];
            }
            ans = max(ans, tmp);
        } while (next_permutation(begin(values), end(values)));
        return ans;
