Synthesizing 10/10 solutions

=======

def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        ans = [[]]
        for n in sorted(nums):
            ans += [a + [n] for a in ans if a + [n] not in ans]
        return ans

=======

def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()
        def dfs(nums, path):
            res.append(path)
            for i in range(len(nums)):
                if i > 0 and nums[i] == nums[i - 1]:
                    continue
                dfs(nums[i + 1:], path + [nums[i]])
        dfs(nums, [])
        return res

=======

def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res = [[]]
        for n in nums:
            res += [r + [n] for r in res if r + [n] not in res]
        return res

=======

def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res = [[]]
        for num in nums:
            res += [item + [num] for item in res if item + [num] not in res]
        return res

=======

def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res = []
        def dfs(nums, path, res):
            res.append(path)
            for i in range(len(nums)):
                if i > 0 and nums[i] == nums[i-1]:
                    continue
                dfs(nums[i+1:], path+[nums[i]], res)
        dfs(nums, [], res)
        return res

=======

def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        def helper(nums, path, res):
            res.append(path)
            for i in range(len(nums)):
                if i > 0 and nums[i] == nums[i-1]:
                    continue
                helper(nums[i+1:], path+[nums[i]], res)
        res = []
        nums.sort()
        helper(nums, [], res)
        return res

=======

def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res = []
        self.dfs(nums, 0, [], res)
        return res

=======

def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        res = [[]]
        nums.sort()
        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i-1]:
                res += [j + [nums[i]] for j in res[-len(res)//2:]]
            else:
                res += [j + [nums[i]] for j in res]
        return res

=======

def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        nums = sorted(nums)
        res = [[]]
        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i-1]:
                res += [x + [nums[i]] for x in res[-len(res)//2:]]
            else:
                res += [x + [nums[i]] for x in res]
        return res

=======

def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        res = []
        for i in range(len(nums)+1):
            for subset in itertools.combinations(nums, i):
                if sorted(subset) not in res:
                    res.append(sorted(subset))
        return res
