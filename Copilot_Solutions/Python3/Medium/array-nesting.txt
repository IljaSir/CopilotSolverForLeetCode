Synthesizing 10/10 solutions

=======

def arrayNesting(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        for i in range(n):
            if nums[i] != -1:
                cnt = 0
                j = i
                while nums[j] != -1:
                    cnt += 1
                    t = nums[j]
                    nums[j] = -1
                    j = t
                ans = max(ans, cnt)
        return ans

=======

def arrayNesting(self, nums: List[int]) -> int:
        def dfs(i):
            if visited[i]:
                return 0
            visited[i] = True
            return 1 + dfs(nums[i])
        visited = [False] * len(nums)
        return max(dfs(i) for i in range(len(nums)))

=======

def arrayNesting(self, nums: List[int]) -> int:
        n = len(nums)
        visited = [False] * n
        ans = 0
        for i in range(n):
            if not visited[i]:
                cnt = 0
                while not visited[i]:
                    visited[i] = True
                    i = nums[i]
                    cnt += 1
                ans = max(ans, cnt)
        return ans

=======

def arrayNesting(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        for i in range(n):
            count = 0
            while nums[i] != -1:
                nums[i], i = -1, nums[i]
                count += 1
            ans = max(ans, count)
        return ans

=======

def arrayNesting(self, nums: List[int]) -> int:
        visited = set()
        res = 0
        for i in range(len(nums)):
            if i not in visited:
                count = 0
                while i not in visited:
                    visited.add(i)
                    i = nums[i]
                    count += 1
                res = max(res, count)
        return res

=======

def arrayNesting(self, nums: List[int]) -> int:
        def dfs(i):
            if i in visited:
                return 0
            visited.add(i)
            return 1 + dfs(nums[i])
        visited = set()
        return max(dfs(i) for i in range(len(nums)))

=======

def arrayNesting(self, nums: List[int]) -> int:
        visited = [False] * len(nums)
        max_len = 0
        for i in range(len(nums)):
            if not visited[i]:
                count = 0
                while not visited[i]:
                    visited[i] = True
                    i = nums[i]
                    count += 1
                max_len = max(max_len, count)
        return max_len

=======

def arrayNesting(self, nums: List[int]) -> int:
        res = 0
        for i in range(len(nums)):
            if nums[i] >= 0:
                count = 0
                while nums[i] >= 0:
                    count += 1
                    tmp = nums[i]
                    nums[i] = -1
                    i = tmp
                res = max(res, count)
        return res

=======

def arrayNesting(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        for i in range(n):
            j = i
            cnt = 0
            while nums[j] != -1:
                cnt += 1
                k = nums[j]
                nums[j] = -1
                j = k
            ans = max(ans, cnt)
        return ans

=======

def arrayNesting(self, nums: List[int]) -> int:
        visited = set()
        max_len = 0
        for i in range(len(nums)):
            if i in visited:
                continue
            visited.add(i)
            cur = nums[i]
            cur_len = 1
            while cur != i:
                cur_len += 1
                visited.add(cur)
                cur = nums[cur]
            max_len = max(max_len, cur_len)
        return max_len
