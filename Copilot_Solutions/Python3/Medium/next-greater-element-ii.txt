Synthesizing 10/10 solutions (Duplicates hidden)

=======

def nextGreaterElements(self, nums: List[int]) -> List[int]:
        res = [-1] * len(nums)
        stack = []
        for i in range(len(nums)):
            while stack and nums[stack[-1]] < nums[i]:
                res[stack.pop()] = nums[i]
            stack.append(i)
        for i in range(len(nums)):
            while stack and nums[stack[-1]] < nums[i]:
                res[stack.pop()] = nums[i]
            stack.append(i)
        return res

=======

def nextGreaterElements(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = [-1] * n
        stack = []
        for i in range(n):
            while stack and nums[stack[-1]] < nums[i]:
                res[stack.pop()] = nums[i]
            stack.append(i)
        for i in range(n):
            while stack and nums[stack[-1]] < nums[i]:
                res[stack.pop()] = nums[i]
        return res

=======

def nextGreaterElements(self, nums: List[int]) -> List[int]:
        stack = []
        n = len(nums)
        res = [-1] * n
        for i in range(n * 2):
            while stack and nums[stack[-1]] < nums[i % n]:
                res[stack.pop()] = nums[i % n]
            stack.append(i % n)
        return res

=======

def nextGreaterElements(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = [-1]*n
        stack = []
        for i in range(2*n):
            while stack and nums[stack[-1]] < nums[i%n]:
                res[stack.pop()] = nums[i%n]
            stack.append(i%n)
        return res

=======

def nextGreaterElements(self, nums: List[int]) -> List[int]:
        n = len(nums)
        stack = []
        res = [-1] * n
        for i in range(n * 2):
            while stack and nums[stack[-1]] < nums[i % n]:
                res[stack.pop()] = nums[i % n]
            stack.append(i % n)
        return res

=======

def nextGreaterElements(self, nums: List[int]) -> List[int]:
        N = len(nums)
        stack = []
        res = [-1] * N
        for i in range(N * 2):
            while stack and nums[stack[-1]] < nums[i % N]:
                res[stack.pop()] = nums[i % N]
            stack.append(i % N)
        return res

=======

def nextGreaterElements(self, nums: List[int]) -> List[int]:
        # O(N^2)
        # ans = [-1] * len(nums)
        # for i in range(len(nums)):
        #     for j in range(i+1, len(nums)):
        #         if nums[j] > nums[i]:
        #             ans[i] = nums[j]
        #             break
        #     if ans[i] == -1:
        #         for j in range(i):
        #             if nums[j] > nums[i]:
        #                 ans[i] = nums[j]
        #                 break
        # return ans
        # O(N)
        ans = [-1] * len(nums)
        stack = []
        for i in range(2*len(nums)):
            while stack and nums[stack[-1]] < nums[i%len(nums)]:
                ans[stack.pop()] = nums[i%len(nums)]
            stack.append(i%len(nums))
        return ans
