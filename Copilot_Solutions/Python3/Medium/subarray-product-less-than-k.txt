Synthesizing 10/10 solutions (Duplicates hidden)

=======

def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        if k <= 1:
            return 0
        prod = 1
        ans = left = 0
        for right, val in enumerate(nums):
            prod *= val
            while prod >= k:
                prod /= nums[left]
                left += 1
            ans += right - left + 1
        return ans

=======

def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        if k <= 1:
            return 0
        n = len(nums)
        res = 0
        left = 0
        prod = 1
        for right in range(n):
            prod *= nums[right]
            while prod >= k:
                prod /= nums[left]
                left += 1
            res += right - left + 1
        return res

=======

def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        if k == 0:
            return 0
        l = 0
        r = 0
        p = 1
        res = 0
        while r < len(nums):
            p *= nums[r]
            while p >= k:
                p /= nums[l]
                l += 1
            res += r - l + 1
            r += 1
        return res

=======

def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        if k<=1:
            return 0
        prod = 1
        left = 0
        count = 0
        for right in range(len(nums)):
            prod *= nums[right]
            while prod>=k:
                prod /= nums[left]
                left += 1
            count += right-left+1
        return count

=======

def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        if k <= 1:
            return 0
        i = 0
        n = len(nums)
        count = 0
        product = 1
        for j in range(n):
            product *= nums[j]
            while product >= k:
                product /= nums[i]
                i += 1
            count += j - i + 1
        return count
