Synthesizing 10/10 solutions

=======

def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:
        n = len(grid)
        row_max = [0] * n
        col_max = [0] * n
        for i in range(n):
            for j in range(n):
                row_max[i] = max(row_max[i], grid[i][j])
                col_max[j] = max(col_max[j], grid[i][j])
        ans = 0
        for i in range(n):
            for j in range(n):
                ans += min(row_max[i], col_max[j]) - grid[i][j]
        return ans

=======

def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:
        row_max = [max(row) for row in grid]
        col_max = [max(col) for col in zip(*grid)]
        return sum(min(row_max[r], col_max[c]) - val for r, row in enumerate(grid) for c, val in enumerate(row))

=======

def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:
        top = [max(row) for row in grid]
        left = [max(col) for col in zip(*grid)]
        return sum(min(top[r], left[c]) - val for r, row in enumerate(grid) for c, val in enumerate(row))

=======

def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:
        rmax = [max(row) for row in grid]
        cmax = [max(col) for col in zip(*grid)]
        return sum(min(rmax[r], cmax[c]) - val for r, row in enumerate(grid) for c, val in enumerate(row))

=======

def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:
        n = len(grid)
        left = [0] * n
        top = [0] * n
        for i in range(n):
            for j in range(n):
                left[i] = max(left[i], grid[i][j])
                top[j] = max(top[j], grid[i][j])
        ans = 0
        for i in range(n):
            for j in range(n):
                ans += min(left[i], top[j]) - grid[i][j]
        return ans

=======

def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:
        n = len(grid)
        row = [max(grid[i]) for i in range(n)]
        col = [max([grid[i][j] for i in range(n)]) for j in range(n)]
        return sum(min(row[i], col[j]) - grid[i][j] for i in range(n) for j in range(n))

=======

def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:
        n = len(grid)
        row = [max(grid[i]) for i in range(n)]
        col = [max([grid[i][j] for i in range(n)]) for j in range(n)]
        res = 0
        for i in range(n):
            for j in range(n):
                res += min(row[i], col[j]) - grid[i][j]
        return res

=======

def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:
        n = len(grid)
        max_top = [0] * n
        max_left = [0] * n
        for i in range(n):
            for j in range(n):
                max_top[i] = max(max_top[i], grid[i][j])
                max_left[j] = max(max_left[j], grid[i][j])
        res = 0
        for i in range(n):
            for j in range(n):
                res += min(max_top[i], max_left[j]) - grid[i][j]
        return res

=======

def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:
        row_max = list(map(max, grid))
        col_max = list(map(max, zip(*grid)))
        return sum(min(row_max[r], col_max[c]) - val
                   for r, row in enumerate(grid)
                   for c, val in enumerate(row))

=======

def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:
        l, r = len(grid), len(grid[0])
        row_max, col_max = [0] * l, [0] * r
        for i in range(l):
            for j in range(r):
                row_max[i] = max(row_max[i], grid[i][j])
                col_max[j] = max(col_max[j], grid[i][j])
        ans = 0
        for i in range(l):
            for j in range(r):
                ans += min(row_max[i], col_max[j]) - grid[i][j]
        return ans
