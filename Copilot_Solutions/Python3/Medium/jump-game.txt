Synthesizing 9/10 solutions

=======

def canJump(self, nums: List[int]) -> bool:
        last = len(nums) - 1
        for i in range(last, -1, -1):
            if i + nums[i] >= last:
                last = i
        return last == 0

=======

def canJump(self, nums: List[int]) -> bool:
        n = len(nums)
        dp = [False] * n
        dp[0] = True
        for i in range(n):
            if dp[i]:
                for j in range(1, nums[i] + 1):
                    if i + j < n:
                        dp[i + j] = True
                    else:
                        break
        return dp[-1]

=======

def canJump(self, nums: List[int]) -> bool:
        n = len(nums)
        if n == 1:
            return True
        if nums[0] == 0:
            return False
        for i in range(n-1):
            if nums[i] == 0:
                j = i-1
                while j >= 0:
                    if j + nums[j] > i:
                        break
                    j -= 1
                if j < 0:
                    return False
        return True

=======

def canJump(self, nums: List[int]) -> bool:
        if len(nums) == 1:
            return True
        if nums[0] == 0:
            return False
        dp = [0] * len(nums)
        dp[0] = 1
        for i in range(len(nums)):
            if dp[i] == 1:
                for j in range(1, nums[i] + 1):
                    if i + j < len(nums):
                        dp[i + j] = 1
        return dp[-1] == 1

=======

def canJump(self, nums: List[int]) -> bool:
        if len(nums) == 1:
            return True
        i = 0
        while i < len(nums) - 1:
            if nums[i] == 0:
                return False
            i += nums[i]
        return True

=======

def canJump(self, nums: List[int]) -> bool:
        if len(nums) == 1:
            return True
        if nums[0] == 0:
            return False
        i = 0
        while i < len(nums):
            if i + nums[i] >= len(nums) - 1:
                return True
            if nums[i] == 0:
                return False
            max_step = 0
            max_index = 0
            for j in range(1, nums[i] + 1):
                if nums[i + j] + j > max_step:
                    max_step = nums[i + j] + j
                    max_index = j
            i += max_index

=======

def canJump(self, nums: List[int]) -> bool:
        if len(nums) == 1:
            return True
        if nums[0] == 0:
            return False
        max_reach = 0
        for i in range(len(nums)):
            if i > max_reach:
                return False
            max_reach = max(max_reach, i + nums[i])
            if max_reach >= len(nums) - 1:
                return True
        return False

=======

def canJump(self, nums: List[int]) -> bool:
        if not nums or len(nums) == 1:
            return True
        max_index = 0
        for i, num in enumerate(nums):
            if i > max_index:
                return False
            max_index = max(max_index, i + num)
            if max_index >= len(nums) - 1:
                return True
        return False

=======

def canJump(self, nums: List[int]) -> bool:
        n = len(nums)
        if n == 1:
            return True
        jump = nums[0]
        for i in range(1, n):
            if jump == 0:
                return False
            if jump < i:
                return False
            jump = max(jump, i + nums[i])
        return True
