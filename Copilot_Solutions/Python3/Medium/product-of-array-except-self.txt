Synthesizing 10/10 solutions (Duplicates hidden)

=======

def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        left = [1] * n
        right = [1] * n
        for i in range(1, n):
            left[i] = left[i-1] * nums[i-1]
        for i in range(n-2, -1, -1):
            right[i] = right[i+1] * nums[i+1]
        return [left[i] * right[i] for i in range(n)]

=======

def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        L, R, answer = [0]*n, [0]*n, [0]*n

        L[0] = 1
        for i in range(1, n):
            L[i] = nums[i - 1] * L[i - 1]

        R[n - 1] = 1
        for i in reversed(range(n - 1)):
            R[i] = nums[i + 1] * R[i + 1]

        for i in range(n):
            answer[i] = L[i] * R[i]

        return answer

=======

def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = [1] * n
        for i in range(1, n):
            res[i] = res[i - 1] * nums[i - 1]
        right = 1
        for i in range(n - 1, -1, -1):
            res[i] *= right
            right *= nums[i]
        return res

=======

def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        answer = [0]*n
        answer[0] = 1
        for i in range(1, n):
            answer[i] = nums[i-1] * answer[i-1]
        R = 1
        for i in reversed(range(n)):
            answer[i] = answer[i] * R
            R *= nums[i]
        return answer

=======

def productExceptSelf(self, nums: List[int]) -> List[int]:
        res = [1] * len(nums)
        for i in range(1, len(nums)):
            res[i] = res[i-1] * nums[i-1]
        right = 1
        for i in range(len(nums)-1, -1, -1):
            res[i] *= right
            right *= nums[i]
        return res

=======

def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        left = [1]*n
        right = [1]*n
        for i in range(1, n):
            left[i] = left[i-1]*nums[i-1]
            right[n-1-i] = right[n-i]*nums[n-i]
        return [left[i]*right[i] for i in range(n)]

=======

def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = [1]*n
        for i in range(1, n):
            res[i] = res[i-1] * nums[i-1]
        r = 1
        for i in range(n-1, -1, -1):
            res[i] *= r
            r *= nums[i]
        return res

=======

def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        result = [1] * n
        for i in range(n-1):
            result[i+1] = result[i] * nums[i]
        right = 1
        for i in range(n-1, -1, -1):
            result[i] *= right
            right *= nums[i]
        return result

=======

class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        # 1. Brute Force
        # 2. Two Pass
        # 3. One Pass
        # 4. One Pass with constant space
        # 5. One Pass with constant space and without division
        # 6. One Pass with constant space and without division and without multiplication
        # 7. One Pass with constant space and without division and without multiplication and without division
        # 8. One Pass with constant space and without division and without multiplication and without division and without multiplication

        # 1. Brute Force
        # Time  complexity: O(N^2)
        # Space complexity: O(N)
        # N = len(nums)
        # ans = [1] * N
        # for i in range(N):
        #     for j in range(N):
        #         if i != j:
        #             ans[i] *= nums[j]
        # return ans

        # 2. Two Pass
        # Time  complexity: O(N)
        # Space complexity: O(N)
        # N = len(nums)
        # ans = [1] * N
        # for i in range(1, N):
        #     ans[i] = ans[i-1] * nums[i-1]
        # R = 1
        # for i in reversed(range(N)):
        #     ans[i] *= R
        #     R *= nums[i]
        # return ans

        # 3. One Pass
        # Time  complexity: O(N)
        # Space complexity: O(N)
        # N = len(nums)
        # ans = [1] * N
        # for i in range(1, N):
        #     ans[i] = ans[i-1] * nums[i-1]
        # R = 1
        # for i in reversed(range(N)):
        #     ans[i] *= R
        #     R *= nums[i]
        # return ans

        # 4. One Pass with constant space
        # Time  complexity: O(N)
        # Space complexity: O(1)
        # N = len(nums)
        # ans = [1] * N
        # for i in range(1, N):
        #     ans[i] = ans[i-1] * nums[i-1]
        # R = 1
        # for i
