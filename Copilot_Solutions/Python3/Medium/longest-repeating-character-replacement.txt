Synthesizing 10/10 solutions

=======

def characterReplacement(self, s: str, k: int) -> int:
        if not s:
            return 0
        cnt = collections.Counter()
        max_cnt = 0
        left = 0
        for right in range(len(s)):
            cnt[s[right]] += 1
            max_cnt = max(max_cnt, cnt[s[right]])
            if right - left + 1 - max_cnt > k:
                cnt[s[left]] -= 1
                left += 1
        return right - left + 1

=======

def characterReplacement(self, s: str, k: int) -> int:
        from collections import Counter
        c = Counter()
        max_count = 0
        i = 0
        for j, ch in enumerate(s):
            c[ch] += 1
            max_count = max(max_count, c[ch])
            if j - i + 1 - max_count > k:
                c[s[i]] -= 1
                i += 1
        return j - i + 1

=======

def characterReplacement(self, s: str, k: int) -> int:
        if len(s) == 1:
            return 1
        left = 0
        right = 0
        max_len = 0
        max_char = 0
        count = [0] * 26
        while right < len(s):
            count[ord(s[right]) - ord('A')] += 1
            max_char = max(max_char, count[ord(s[right]) - ord('A')])
            while right - left + 1 - max_char > k:
                count[ord(s[left]) - ord('A')] -= 1
                left += 1
            max_len = max(max_len, right - left + 1)
            right += 1
        return max_len

=======

def characterReplacement(self, s: str, k: int) -> int:
        n = len(s)
        d = {}
        for i in range(26):
            d[chr(i+65)] = 0
        max_len = 0
        start = 0
        for end in range(n):
            d[s[end]] += 1
            max_len = max(max_len, d[s[end]])
            if end - start + 1 - max_len > k:
                d[s[start]] -= 1
                start += 1
        return n - start

=======

def characterReplacement(self, s: str, k: int) -> int:
        if len(s) == 1:
            return 1
        l = 0
        r = 1
        max_count = 1
        max_char = s[0]
        char_count = {s[0]: 1}
        while r < len(s):
            char_count[s[r]] = char_count.get(s[r], 0) + 1
            if char_count[s[r]] > max_count:
                max_count = char_count[s[r]]
                max_char = s[r]
            if r - l + 1 - max_count > k:
                char_count[s[l]] -= 1
                l += 1
            r += 1
        return r - l

=======

def characterReplacement(self, s: str, k: int) -> int:
        if len(s) == 1:
            return 1
        i = 0
        j = 0
        m = 0
        maxLen = 0
        while j < len(s):
            if s[j] == s[i]:
                j += 1
            else:
                if m < k:
                    m += 1
                    j += 1
                else:
                    maxLen = max(maxLen, j - i)
                    i += 1
        maxLen = max(maxLen, j - i)
        return maxLen

=======

def characterReplacement(self, s: str, k: int) -> int:
        n = len(s)
        if n == 0:
            return 0

        # sliding window
        left, right = 0, 0
        # count the frequency of each character
        count = collections.Counter()
        # the length of the longest substring
        max_len = 1

        while right < n:
            # add the character at the right end of the window
            count[s[right]] += 1
            # get the most frequent character
            max_count = count.most_common(1)[0][1]
            # if the number of characters other than the most frequent character <= k, we can extend the window
            if right - left + 1 - max_count <= k:
                max_len = max(max_len, right - left + 1)
            else:
                count[s[left]] -= 1
                left += 1
            right += 1

        return max_len

=======

def characterReplacement(self, s: str, k: int) -> int:
        # sliding window
        # 窗口内的字符个数 - 窗口内出现次数最多的字符个数 + k >= 窗口长度
        # 满足条件则窗口右移，不满足条件则窗口左移
        d = {}
        i, j = 0, 0
        res = 0
        while j < len(s):
            if s[j] not in d:
                d[s[j]] = 1
            else:
                d[s[j]] += 1
            if j - i + 1 - max(d.values()) <= k:
                res = max(res, j - i + 1)
                j += 1
            else:
                d[s[i]] -= 1
                i += 1
        return res

=======

def characterReplacement(self, s: str, k: int) -> int:
        # sliding window
        # 1. keep track of most freq char
        # 2. if len(window) - most_freq_char > k, then we need to move the window
        # 3. return max(len(window))
        most_freq = 0
        l = 0
        d = {}
        for r in range(len(s)):
            d[s[r]] = d.get(s[r], 0) + 1
            most_freq = max(most_freq, d[s[r]])
            if r - l + 1 - most_freq > k:
                d[s[l]] -= 1
                l += 1
        return len(s) - l

=======

def characterReplacement(self, s: str, k: int) -> int:
        # sliding window
        # window size is the number of characters in the window
        # window size is the max number of characters that are not the most frequent character
        # if the window size is greater than k, then we need to shrink the window
        # this is because we need to replace the characters that are not the most frequent character
        # we can shrink the window by moving the start pointer to the right
        # we need to keep track of the most frequent character in the window
        # we can do this by using a counter
        # we can then get the number of characters that are not the most frequent character by subtracting the most frequent character from the window size
        # if the number of characters that are not the most frequent character is greater than k, then we need to shrink the window
        # we can shrink the window by moving the start pointer to the right
        # we need to decrement the counter as we move the start pointer to the right
        # the most frequent character is the character that has the highest value in the counter
        # the window size is the number of characters in the window
        # the window size is the max number of characters that are not the most frequent character
        # the number of characters that are not the most frequent character is the window size minus the most frequent character
        # if the number of characters that are not the most frequent character is greater than k, then we need to shrink the window
        # we can shrink the window by moving the start pointer to the right
        # we need to decrement the counter as we move the start pointer to the right
        # we can return the max window size
        # the max window size is the longest substring containing the same letter we can get after performing the above operations
        # we can initialize the max window size to 0
        max_window_size = 0
        # we can initialize the start pointer to 0
        start = 0
        # we can initialize the counter to 0
        counter = collections.Counter()
        # we can iterate through the string
        for end, char in enumerate(s):
            # we can increment the counter for the current character
            counter[char] += 1
            # we can get the most frequent character
            most_frequent_char = counter.most_common(1)[0][0]
            # we
