Synthesizing 10/10 solutions

=======

def reorderedPowerOf2(self, n: int) -> bool:
        def isPowerOfTwo(n):
            if n == 0:
                return False
            while n != 1:
                if n % 2 != 0:
                    return False
                n = n // 2
            return True
        
        num = list(str(n))
        num.sort()
        for i in range(30):
            if isPowerOfTwo(2**i):
                if num == list(str(2**i)):
                    return True
        return False

=======

def reorderedPowerOf2(self, n: int) -> bool:
        def isPowerOfTwo(n):
            if n == 0: 
                return False
            while n != 1: 
                if n % 2 != 0: 
                    return False
                n = n // 2
            return True
        s = str(n)
        arr = set()
        for i in range(len(s)):
            for j in range(len(s)):
                if i != j:
                    t = s[i] + s[j]
                    if len(t) == len(s):
                        if int(t) not in arr:
                            arr.add(int(t))
        for i in arr:
            if isPowerOfTwo(i):
                return True
        return False

=======

def reorderedPowerOf2(self, n: int) -> bool:
        import collections
        c = collections.Counter(str(n))
        for i in range(31):
            if collections.Counter(str(1<<i)) == c:
                return True
        return False

=======

def reorderedPowerOf2(self, n: int) -> bool:
        n = str(n)
        for i in range(30):
            if sorted(str(1<<i)) == sorted(n):
                return True
        return False

=======

def reorderedPowerOf2(self, n: int) -> bool:
        s = str(n)
        for i in range(31):
            if sorted(str(2**i)) == sorted(s):
                return True
        return False

=======

def reorderedPowerOf2(self, n: int) -> bool:
        n = str(n)
        n = sorted(n)
        for i in range(30):
            if sorted(str(2**i)) == n:
                return True
        return False

=======

def reorderedPowerOf2(self, n: int) -> bool:
        # if n == 1:
        #     return True
        # if n == 10:
        #     return False
        # if n == 16:
        #     return True
        # if n == 24:
        #     return False
        # if n == 46:
        #     return True
        # if n == 64:
        #     return True
        # if n == 128:
        #     return True
        # if n == 256:
        #     return True
        # if n == 512:
        #     return True
        # if n == 1024:
        #     return True
        # if n == 2048:
        #     return True
        # if n == 4096:
        #     return True
        # if n == 8192:
        #     return True
        # if n == 16384:
        #     return True
        # if n == 32768:
        #     return True
        # if n == 65536:
        #     return True
        # if n == 131072:
        #     return True
        # if n == 262144:
        #     return True
        # if n == 524288:
        #     return True
        # if n == 1048576:
        #     return True
        # if n == 2097152:
        #     return True
        # if n == 4194304:
        #     return True
        # if n == 8388608:
        #     return True
        # if n == 16777216:
        #     return True
        # if n == 33554432:
        #     return True
        # if n == 67108864:
        #     return True
        # if n == 134217728:
        #     return True
        # if n == 268435456:
        #     return True
        # if n == 536870912:
        #     return True
        # return False
        return sorted(str(n)) in [sorted(str(1<<i)) for i in range(31)]

=======

def reorderedPowerOf2(self, n: int) -> bool:
        def check(n):
            return sorted(str(n)) == sorted(str(1 << i))
        return any(check(n) for i in range(31))

=======

def reorderedPowerOf2(self, n: int) -> bool:
        n = str(n)
        return any(sorted(n) == sorted(str(1 << i)) for i in range(31))

=======

def reorderedPowerOf2(self, n: int) -> bool:
        n = str(n)
        def getPermutation(s, n):
            if n == 0:
                return []
            if n == 1:
                return [s]
            res = []
            for i in range(len(s)):
                for j in getPermutation(s[:i] + s[i+1:], n-1):
                    res.append(s[i] + j)
            return res
        for i in getPermutation(n, len(n)):
            if i[0] != '0' and bin(int(i)).count('1') == 1:
                return True
        return False
