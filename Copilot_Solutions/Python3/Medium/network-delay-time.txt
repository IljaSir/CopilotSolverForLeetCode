Synthesizing 10/10 solutions

=======

def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        graph = collections.defaultdict(list)
        for u, v, w in times:
            graph[u].append((v, w))
        
        Q = [(0, k)]
        dist = collections.defaultdict(int)
        
        while Q:
            time, node = heapq.heappop(Q)
            if node not in dist:
                dist[node] = time
                for v, w in graph[node]:
                    alt = time + w
                    heapq.heappush(Q, (alt, v))
        
        if len(dist) == n:
            return max(dist.values())
        return -1

=======

def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        graph = collections.defaultdict(list)
        for u, v, w in times:
            graph[u].append((v, w))
        dist = {node: float('inf') for node in range(1, n+1)}
        
        def dfs(node, elapsed):
            if elapsed >= dist[node]:
                return
            dist[node] = elapsed
            for v, w in sorted(graph[node]):
                dfs(v, elapsed + w)
        
        dfs(k, 0)
        ans = max(dist.values())
        return ans if ans < float('inf') else -1

=======

def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        graph = collections.defaultdict(list)
        for u, v, w in times:
            graph[u].append((v, w))
        dist = {node: float('inf') for node in range(1, n + 1)}
        seen = [False] * (n + 1)
        dist[k] = 0
        while True:
            cand_node = -1
            cand_dist = float('inf')
            for i in range(1, n + 1):
                if not seen[i] and dist[i] < cand_dist:
                    cand_dist = dist[i]
                    cand_node = i
            if cand_node < 0:
                break
            seen[cand_node] = True
            for nei, d in graph[cand_node]:
                dist[nei] = min(dist[nei], dist[cand_node] + d)
        ans = max(dist.values())
        return ans if ans < float('inf') else -1

=======

def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        graph = collections.defaultdict(dict)
        for u, v, w in times:
            graph[u][v] = w
        dist = {node: float('inf') for node in range(1, n+1)}
        dist[k] = 0
        seen = [False] * (n+1)
        while True:
            cand_node = -1
            cand_dist = float('inf')
            for i in range(1, n+1):
                if not seen[i] and dist[i] < cand_dist:
                    cand_dist = dist[i]
                    cand_node = i
            if cand_node < 0: break
            seen[cand_node] = True
            for nei, d in graph[cand_node].items():
                dist[nei] = min(dist[nei], dist[cand_node] + d)
        ans = max(dist.values())
        return ans if ans < float('inf') else -1

=======

def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        graph = collections.defaultdict(dict)
        for u, v, t in times:
            graph[u][v] = t
        dist = {node: float('inf') for node in range(1, n+1)}
        seen = [False] * (n+1)
        dist[k] = 0
        while True:
            cand_node = -1
            cand_dist = float('inf')
            for i in range(1, n+1):
                if not seen[i] and dist[i] < cand_dist:
                    cand_dist = dist[i]
                    cand_node = i
            if cand_node < 0: break
            seen[cand_node] = True
            for nei, d in graph[cand_node].items():
                dist[nei] = min(dist[nei], dist[cand_node] + d)
        ans = max(dist.values())
        return ans if ans < float('inf') else -1

=======

def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        graph = [[] for _ in range(n+1)]
        for u, v, w in times:
            graph[u].append((v, w))
        dist = [float('inf')] * (n+1)
        dist[k] = 0
        pq = [(0, k)]
        while pq:
            d, u = heapq.heappop(pq)
            if d > dist[u]:
                continue
            for v, w in graph[u]:
                if dist[u] + w < dist[v]:
                    dist[v] = dist[u] + w
                    heapq.heappush(pq, (dist[v], v))
        ans = max(dist[1:])
        return ans if ans < float('inf') else -1

=======

def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        import heapq
        graph = collections.defaultdict(list)
        for u, v, w in times:
            graph[u].append((v, w))
        dist = [float('inf')] * (n + 1)
        dist[k] = 0
        q = [(0, k)]
        while q:
            d, node = heapq.heappop(q)
            if d > dist[node]:
                continue
            for v, w in graph[node]:
                if dist[node] + w < dist[v]:
                    dist[v] = dist[node] + w
                    heapq.heappush(q, (dist[v], v))
        return max(dist[1:]) if max(dist[1:]) < float('inf') else -1

=======

def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        # Dijkstra's algorithm, O(ElogV)
        # https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm
        from heapq import heappush, heappop
        graph = collections.defaultdict(list)
        for u, v, w in times:
            graph[u].append((v, w))
        dist = {node: float('inf') for node in range(1, n+1)}
        dist[k] = 0
        pq = [(0, k)]
        while pq:
            d, node = heappop(pq)
            if d > dist[node]:
                continue
            for nei, d2 in graph[node]:
                d2 += d
                if d2 < dist[nei]:
                    dist[nei] = d2
                    heappush(pq, (d2, nei))
        ans = max(dist.values())
        return ans if ans < float('inf') else -1

=======

def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        from collections import defaultdict
        # create a graph
        graph = defaultdict(dict)
        for u, v, w in times:
            graph[u][v] = w
        
        # create a distance table
        distance = {node: float('inf') for node in range(1, n+1)}
        distance[k] = 0
        
        # create a visited table
        visited = set()
        
        # create a priority queue
        import heapq
        pq = [(0, k)]
        
        while pq:
            dist, node = heapq.heappop(pq)
            if node in visited:
                continue
            visited.add(node)
            for nei, nei_dist in graph[node].items():
                if nei not in visited:
                    heapq.heappush(pq, (dist+nei_dist, nei))
                    distance[nei] = min(distance[nei], dist+nei_dist)
        
        return max(distance.values()) if len(visited) == n else -1

=======

def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        # Dijkstra's algorithm
        # 1. Initialize dist to infinity
        # 2. Initialize dist[k] to 0
        # 3. Repeat until all nodes are visited:
        #    a. Find node with smallest dist
        #    b. Iterate through all neighbors and update dist
        #    c. Mark node as visited
        # 4. Return max(dist)
        dist = [float('inf') for _ in range(n)]
        dist[k-1] = 0
        visited = [False for _ in range(n)]
        while not all(visited):
            # find node with smallest dist
            min_dist = float('inf')
            min_node = None
            for i in range(n):
                if not visited[i] and dist[i] < min_dist:
                    min_dist = dist[i]
                    min_node = i
            # iterate through all neighbors and update dist
            for time in times:
                if time[0] == min_node+1:
                    dist[time[1]-1] = min(dist[time[1]-1], dist[time[0]-1] + time[2])
            # mark node as visited
            visited[min_node] = True
        # return max(dist)
        max_dist = max(dist)
        return max_dist if max_dist != float('inf') else -1
