Synthesizing 10/10 solutions

=======

def lengthOfLongestSubstring(self, s: str) -> int:
        seen = set()
        start = 0
        max_len = 0
        for i, c in enumerate(s):
            if c in seen:
                while s[start] != c:
                    seen.remove(s[start])
                    start += 1
                start += 1
            else:
                seen.add(c)
                max_len = max(max_len, i - start + 1)
        return max_len

=======

def lengthOfLongestSubstring(self, s: str) -> int:
        if len(s) == 0:
            return 0
        if len(s) == 1:
            return 1
        start = 0
        end = 1
        max_len = 1
        while end < len(s):
            if s[end] in s[start:end]:
                start = s[start:end].index(s[end]) + start + 1
            end += 1
            max_len = max(max_len, end - start)
        return max_len

=======

def lengthOfLongestSubstring(self, s: str) -> int:
        if not s:
            return 0
        if len(s) == 1:
            return 1
        start = 0
        end = 1
        max_len = 0
        while end < len(s):
            if s[end] not in s[start:end]:
                end += 1
                max_len = max(max_len, end - start)
            else:
                start += 1
        return max_len

=======

def lengthOfLongestSubstring(self, s: str) -> int:
        if not s:
            return 0
        start = 0
        max_len = 0
        char_map = {}
        for i, c in enumerate(s):
            if c in char_map and char_map[c] >= start:
                start = char_map[c] + 1
            char_map[c] = i
            max_len = max(max_len, i - start + 1)
        return max_len

=======

def lengthOfLongestSubstring(self, s: str) -> int:
        if len(s) == 0:
            return 0
        if len(s) == 1:
            return 1
        max_len = 0
        for i in range(len(s)):
            tmp = set()
            for j in range(i, len(s)):
                if s[j] not in tmp:
                    tmp.add(s[j])
                    max_len = max(max_len, len(tmp))
                else:
                    break
        return max_len

=======

def lengthOfLongestSubstring(self, s: str) -> int:
        # print(s)
        if not s:
            return 0
        if len(s) == 1:
            return 1
        maxLen = 0
        for i in range(len(s)):
            for j in range(i+1, len(s)):
                if s[j] not in s[i:j]:
                    if j-i+1 > maxLen:
                        maxLen = j-i+1
                else:
                    break
        return maxLen

=======

def lengthOfLongestSubstring(self, s: str) -> int:
        s = list(s)
        max_length = 0
        while s:
            tmp = []
            for i in s:
                if i not in tmp:
                    tmp.append(i)
                else:
                    break
            max_length = max(max_length, len(tmp))
            s = s[1:]
        return max_length

=======

def lengthOfLongestSubstring(self, s: str) -> int:
        # left = 0
        # right = 0
        # max_len = 0
        # count = 0
        # while right < len(s):
        #     if s[right] in s[left:right]:
        #         max_len = max(max_len, count)
        #         left += 1
        #         right = left
        #         count = 0
        #     else:
        #         right += 1
        #         count += 1
        # return max(max_len, count)
        left = 0
        right = 0
        max_len = 0
        count = 0
        while right < len(s):
            if s[right] in s[left:right]:
                max_len = max(max_len, count)
                left += 1
                right = left
                count = 0
            else:
                right += 1
                count += 1
        return max(max_len, count)

=======

def lengthOfLongestSubstring(self, s: str) -> int:
        # sliding window
        if not s:
            return 0
        if len(s) == 1:
            return 1
        left, right = 0, 1
        s_set = set()
        s_set.add(s[left])
        max_len = 1
        while right < len(s):
            if s[right] in s_set:
                while s[left] != s[right]:
                    s_set.remove(s[left])
                    left += 1
                left += 1
            else:
                s_set.add(s[right])
                max_len = max(max_len, right - left + 1)
            right += 1
        return max_len

=======

def lengthOfLongestSubstring(self, s: str) -> int:
        if not s:
            return 0
        # 1. Initialize the max length
        max_len = 1
        # 2. Initialize the left pointer
        left = 0
        # 3. Initialize the right pointer
        right = 1
        # 4. Initialize the set
        char_set = set(s[left])
        # 5. Loop the string
        while right < len(s):
            if s[right] not in char_set:
                char_set.add(s[right])
                right += 1
                max_len = max(max_len, right - left)
            else:
                char_set.remove(s[left])
                left += 1
        # 6. Return the max length
        return max_len
