Synthesizing 10/10 solutions

=======

def lengthLongestPath(self, input: str) -> int:
        pass

=======

def lengthLongestPath(self, input: str) -> int:
        max_len = 0
        path_len = {0: 0}
        for line in input.splitlines():
            name = line.lstrip('\t')
            depth = len(line) - len(name)
            if '.' in name:
                max_len = max(max_len, path_len[depth] + len(name))
            else:
                path_len[depth + 1] = path_len[depth] + len(name) + 1
        return max_len

=======

def lengthLongestPath(self, input: str) -> int:
        stack = [(-1,0)]
        res = 0
        for line in input.splitlines():
            name = line.lstrip('\t')
            depth = len(line) - len(name)
            while stack[-1][0] >= depth:
                stack.pop()
            if '.' in name:
                res = max(res, stack[-1][1] + len(name))
            else:
                stack.append((depth, stack[-1][1] + len(name) + 1))
        return res

=======

def lengthLongestPath(self, input: str) -> int:
        stack = []
        max_len = 0
        for line in input.splitlines():
            name = line.lstrip('\t')
            depth = len(line) - len(name)
            while stack and stack[-1][1] >= depth:
                stack.pop()
            if '.' in name:
                max_len = max(max_len, len('/'.join([p[0] for p in stack]) + '/' + name))
            else:
                stack.append((name, depth))
        return max_len

=======

def lengthLongestPath(self, input: str) -> int:
        stack = []
        longest = 0
        for line in input.split('\n'):
            name = line.lstrip('\t')
            depth = len(line) - len(name)
            while len(stack) > depth:
                stack.pop()
            stack.append(len(name))
            if '.' in name:
                longest = max(longest, sum(stack) + len(stack) - 1)
        return longest

=======

def lengthLongestPath(self, input: str) -> int:
        max_len = 0
        stack = []
        for line in input.split('\n'):
            name = line.lstrip('\t')
            depth = len(line) - len(name)
            while len(stack) > depth:
                stack.pop()
            stack.append(len(name))
            if '.' in name:
                max_len = max(max_len, sum(stack) + len(stack) - 1)
        return max_len

=======

def lengthLongestPath(self, input: str) -> int:
        stack = []
        max_len = 0
        for line in input.splitlines():
            level = line.count('\t')
            name = line.replace('\t', '')
            while len(stack) > level:
                stack.pop()
            if '.' in name:
                max_len = max(max_len, len('/'.join(stack)) + len(name))
            else:
                stack.append(name)
        return max_len

=======

def lengthLongestPath(self, input: str) -> int:
        stack = []
        max_len = 0
        for line in input.splitlines():
            level = line.count('\t')
            while len(stack) > level:
                stack.pop()
            stack.append(len(line) - level + 1)
            if '.' in line:
                max_len = max(max_len, sum(stack))
        return max_len

=======

def lengthLongestPath(self, input: str) -> int:
        max_len = 0
        stack = []
        for path in input.splitlines():
            depth = path.count('\t')
            while len(stack) > depth:
                stack.pop()
            stack.append(len(path) - depth)
            if '.' in path:
                max_len = max(max_len, sum(stack) + len(stack) - 1)
        return max_len

=======

        paths = input.split('
