Synthesizing 10/10 solutions

=======

def ambiguousCoordinates(self, s: str) -> List[str]:
        def make(frag):
            N = len(frag)
            for d in range(1, N+1):
                left = frag[:d]
                right = frag[d:]
                if ((not left.startswith('0') or left == '0')
                        and (not right.endswith('0'))):
                    yield left + ('.' if d != N else '') + right
        s = s[1:-1]
        return ["({}, {})".format(*cand)
                for i in range(1, len(s))
                for cand in itertools.product(make(s[:i]), make(s[i:]))]

=======

def ambiguousCoordinates(self, s: str) -> List[str]:
        def make(frag):
            N = len(frag)
            for d in range(1, N+1):
                left, right = frag[:d], frag[d:]
                if ((not left.startswith('0') or left == '0')
                        and (not right.endswith('0'))):
                    yield left + ('.' if d != N else '') + right
        s = s[1:-1]
        return ["({}, {})".format(*cand)
                for i in range(1, len(s))
                for cand in itertools.product(make(s[:i]), make(s[i:]))]

=======

def ambiguousCoordinates(self, s: str) -> List[str]:
        def f(s):
            if not s or (len(s) > 1 and s[0] == '0' and s[-1] == '0'):
                return []
            if s[0] == '0':
                return ['0.' + s[1:]]
            if s[-1] == '0':
                return [s]
            return [s[:i] + '.' + s[i:] for i in range(1, len(s))] + [s]
        s = s[1:-1]
        return ['({}, {})'.format(*t) for i in range(1, len(s)) for t in itertools.product(f(s[:i]), f(s[i:]))]

=======

def ambiguousCoordinates(self, s: str) -> List[str]:
        def f(s):
            n = len(s)
            if n == 1 or s[0] != '0' and s[-1] != '0':
                yield s
            for i in range(1, n):
                if (s[0] != '0' or i == 1) and s[i] != '0':
                    yield s[:i] + '.' + s[i:]
        s = s[1:-1]
        return ['({}, {})'.format(*cand) for i in range(1, len(s)) for cand in itertools.product(f(s[:i]), f(s[i:]))]

=======

def ambiguousCoordinates(self, s: str) -> List[str]:
        def f(s):
            if not s or (len(s) > 1 and s[0] == '0' and s[-1] == '0'):
                return []
            if s[-1] == '0':
                return [s]
            if s[0] == '0':
                return [s[0] + '.' + s[1:]]
            return [s] + [s[:i] + '.' + s[i:] for i in range(1, len(s))]
        s = s[1:-1]
        return ['({}, {})'.format(*t) for i in range(1, len(s)) for t in itertools.product(f(s[:i]), f(s[i:]))]

=======

def ambiguousCoordinates(self, s: str) -> List[str]:
        def f(s):
            n = len(s)
            if n == 1:
                return [s]
            if s[0] == '0' and s[-1] == '0':
                return []
            if s[0] == '0':
                return [s[0] + '.' + s[1:]]
            if s[-1] == '0':
                return [s]
            return [s] + [s[:i] + '.' + s[i:] for i in range(1, n)]
        s = s[1:-1]
        return ['({}, {})'.format(i, j) for i, j in itertools.product(f(s[:i]), f(s[i:])) for i in range(1, len(s))]

=======

def ambiguousCoordinates(self, s: str) -> List[str]:
        def f(s):
            if len(s) == 1 or s[-1] != "0" and s[0] != "0":
                yield s
            if s[0] != "0" and s[-1] == "0":
                yield s[:-1]
            if s[0] == "0" and s[-1] != "0":
                yield "0." + s[1:]
        s = s[1:-1]
        return ["({}, {})".format(a, b) for i in range(1, len(s)) for a in f(s[:i]) for b in f(s[i:])]

=======

def ambiguousCoordinates(self, s: str) -> List[str]:
        def possible_num(s):
            if len(s) == 1:
                return True
            if s[0] == '0' and s[-1] == '0':
                return False
            if s[0] == '0' or s[-1] == '0':
                return True
            return True
        s = s[1:-1]
        ans = []
        for i in range(1, len(s)):
            for x in itertools.product(*map(possible_num, [s[:i], s[i:]])):
                if all(x):
                    ans.append('({}, {})'.format(s[:i], s[i:]))
                elif x[0] and s[i] != '0':
                    ans.append('({}.{}, {})'.format(s[:i], s[i], s[i+1:]))
                elif x[1] and s[i-1] != '0':
                    ans.append('({}, {}.{})'.format(s[:i-1], s[i-1], s[i:]))
        return ans

=======

def ambiguousCoordinates(self, s: str) -> List[str]:
        s = s[1:-1]
        def possible(s):
            if not s or (s[0] == '0' and s[-1] == '0'): return []
            if s[0] == '0': return [s[0] + '.' + s[1:]]
            if s[-1] == '0': return [s]
            return [s] + [s[:i] + '.' + s[i:] for i in range(1, len(s))]
        return ['({}, {})'.format(a, b) for i in range(1, len(s)) for a in possible(s[:i]) for b in possible(s[i:])]

=======

def ambiguousCoordinates(self, s: str) -> List[str]:
        def get_nums(s):
            if s.startswith('0') and s.endswith('0'):
                return [s]
            if s.startswith('0'):
                return [s[0] + '.' + s[1:]]
            if s.endswith('0'):
                return [s]
            return [s] + [s[:i] + '.' + s[i:] for i in range(1, len(s))]
        s = s[1:-1]
        return ['({}, {})'.format(*t) for i in range(1, len(s)) for t in itertools.product(get_nums(s[:i]), get_nums(s[i:]))]
