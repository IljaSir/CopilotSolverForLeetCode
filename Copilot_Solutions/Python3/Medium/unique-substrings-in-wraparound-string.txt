Synthesizing 10/10 solutions (Duplicates hidden)

=======

def findSubstringInWraproundString(self, s: str) -> int:
        if not s: return 0
        dp = [0] * 26
        dp[ord(s[0]) - ord('a')] = 1
        cnt = 1
        for i in range(1, len(s)):
            if ord(s[i]) - ord(s[i - 1]) == 1 or ord(s[i - 1]) - ord(s[i]) == 25:
                cnt += 1
            else:
                cnt = 1
            dp[ord(s[i]) - ord('a')] = max(dp[ord(s[i]) - ord('a')], cnt)
        return sum(dp)

=======

def findSubstringInWraproundString(self, s: str) -> int:
        if not s:
            return 0
        count = [0] * 26
        cur = 1
        for i in range(len(s)):
            if i > 0 and (ord(s[i]) - ord(s[i-1]) == 1 or s[i-1] == 'z' and s[i] == 'a'):
                cur += 1
            else:
                cur = 1
            count[ord(s[i]) - ord('a')] = max(count[ord(s[i]) - ord('a')], cur)
        return sum(count)

=======

def findSubstringInWraproundString(self, s: str) -> int:
        
        pass

=======

def findSubstringInWraproundString(self, s: str) -> int:
        n = len(s)
        if n == 1:
            return 1
        dp = [0] * 26
        dp[ord(s[0]) - ord('a')] = 1
        max_len = 1
        for i in range(1, n):
            if (ord(s[i]) - ord(s[i - 1])) % 26 == 1:
                max_len += 1
            else:
                max_len = 1
            dp[ord(s[i]) - ord('a')] = max(dp[ord(s[i]) - ord('a')], max_len)
        return sum(dp)

=======

def findSubstringInWraproundString(self, s: str) -> int:
        d = {}
        for i in range(len(s)):
            d[s[i]] = 1
        for i in range(1, len(s)):
            if ord(s[i]) - ord(s[i-1]) == 1 or ord(s[i]) - ord(s[i-1]) == -25:
                d[s[i]] = max(d[s[i]], d[s[i-1]]+1)
        return sum(d.values())

=======

def findSubstringInWraproundString(self, s: str) -> int:
        if not s: return 0
        # dp[i] means the number of substring ends with i
        dp = [0]*26
        # count the continuous substring
        count = 0
        for i in range(len(s)):
            if i > 0 and (ord(s[i]) - ord(s[i-1])) % 26 == 1:
                count += 1
            else:
                count = 1
            # update dp
            dp[ord(s[i]) - ord('a')] = max(dp[ord(s[i]) - ord('a')], count)
        return sum(dp)
