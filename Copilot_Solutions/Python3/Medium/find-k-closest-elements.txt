Synthesizing 10/10 solutions

=======

def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        l, r = 0, len(arr) - k
        while l < r:
            m = (l + r) // 2
            if x - arr[m] > arr[m+k] - x:
                l = m + 1
            else:
                r = m
        return arr[l:l+k]

=======

def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        left = 0
        right = len(arr) - k
        while left < right:
            mid = (left + right) // 2
            if x - arr[mid] > arr[mid + k] - x:
                left = mid + 1
            else:
                right = mid
        return arr[left:left+k]

=======

def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        n = len(arr)
        l, r = 0, n - k
        while l < r:
            mid = (l + r) // 2
            if x - arr[mid] > arr[mid + k] - x:
                l = mid + 1
            else:
                r = mid
        return arr[l:l + k]

=======

def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        l, r = 0, len(arr) - 1
        while r - l + 1 > k:
            if abs(arr[l] - x) > abs(arr[r] - x):
                l += 1
            else:
                r -= 1
        return arr[l:r+1]

=======

def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        left = 0
        right = len(arr) - 1
        while left < right:
            mid = (left + right) // 2
            if arr[mid] < x:
                left = mid + 1
            else:
                right = mid
        l = left
        r = left
        while r - l < k:
            if l == 0:
                return arr[:k]
            if r == len(arr):
                return arr[-k:]
            if abs(arr[l-1] - x) <= abs(arr[r] - x):
                l -= 1
            else:
                r += 1
        return arr[l:r]

=======

def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        if x < arr[0]:
            return arr[:k]
        if x > arr[-1]:
            return arr[-k:]
        l, r = 0, len(arr) - k
        while l < r:
            m = (l + r) // 2
            if x - arr[m] > arr[m + k] - x:
                l = m + 1
            else:
                r = m
        return arr[l:l + k]

=======

def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        if x <= arr[0]:
            return arr[:k]
        if x >= arr[-1]:
            return arr[-k:]
        idx = bisect.bisect_left(arr, x)
        if idx == len(arr):
            idx -= 1
        if arr[idx] == x:
            return arr[idx:idx+k]
        if idx == 0:
            idx = 1
        left = idx - 1
        right = idx
        while right - left < k:
            if left < 0:
                right += 1
                continue
            if right >= len(arr):
                left -= 1
                continue
            if abs(arr[left] - x) <= abs(arr[right] - x):
                left -= 1
            else:
                right += 1
        return arr[left+1:right]

=======

def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        def find(arr, x):
            l, r = 0, len(arr) - 1
            while l < r:
                mid = (l + r) // 2
                if arr[mid] < x:
                    l = mid + 1
                else:
                    r = mid
            return l
        idx = find(arr, x)
        l, r = idx - 1, idx
        while r - l - 1 < k:
            if l < 0:
                r += 1
            elif r >= len(arr):
                l -= 1
            elif x - arr[l] <= arr[r] - x:
                l -= 1
            else:
                r += 1
        return arr[l + 1:r]

=======

def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        k_closest = []
        for i in range(len(arr)):
            if len(k_closest) < k:
                k_closest.append(arr[i])
            else:
                if abs(arr[i]-x) < abs(k_closest[-1]-x):
                    k_closest.pop()
                    k_closest.append(arr[i])
                elif abs(arr[i]-x) == abs(k_closest[-1]-x):
                    if arr[i] < k_closest[-1]:
                        k_closest.pop()
                        k_closest.append(arr[i])
                else:
                    pass
        k_closest.sort()
        return k_closest

=======

def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        # use binary search to find the closest element
        # then use two pointers to expand
        def binarySearch(arr, x):
            l, r = 0, len(arr)-1
            while l <= r:
                mid = (l+r)//2
                if arr[mid] == x:
                    return mid
                elif arr[mid] > x:
                    r = mid - 1
                else:
                    l = mid + 1
            if l == len(arr):
                return l-1
            if r == -1:
                return 0
            if x-arr[r] <= arr[l]-x:
                return r
            return l
        idx = binarySearch(arr, x)
        l, r = idx, idx
        while r-l+1 < k:
            if l == 0:
                r += 1
            elif r == len(arr)-1:
                l -= 1
            else:
                if x-arr[l-1] <= arr[r+1]-x:
                    l -= 1
                else:
                    r += 1
        return arr[l:r+1]
