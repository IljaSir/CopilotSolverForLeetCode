Synthesizing 10/10 solutions

=======

def maxRotateFunction(self, nums: List[int]) -> int:
        n = len(nums)
        s = sum(nums)
        f = sum(i * v for i, v in enumerate(nums))
        ans = f
        for i in range(n - 1, 0, -1):
            f += s - n * nums[i]
            ans = max(ans, f)
        return ans

=======

def maxRotateFunction(self, nums: List[int]) -> int:
        n = len(nums)
        s = sum(nums)
        f = sum(i * nums[i] for i in range(n))
        ans = f
        for i in range(n-1, 0, -1):
            f += s - n * nums[i]
            ans = max(ans, f)
        return ans

=======

def maxRotateFunction(self, nums: List[int]) -> int:
        n = len(nums)
        s = sum(nums)
        t = sum(i * v for i, v in enumerate(nums))
        res = t
        for i in range(n - 1, 0, -1):
            t = t + s - n * nums[i]
            res = max(res, t)
        return res

=======

def maxRotateFunction(self, nums: List[int]) -> int:
        n = len(nums)
        f = sum(i * nums[i] for i in range(n))
        s = sum(nums)
        res = f
        for i in range(1, n):
            f += s - n * nums[n - i]
            res = max(res, f)
        return res

=======

def maxRotateFunction(self, nums: List[int]) -> int:
        n = len(nums)
        s = sum(nums)
        t = sum(i * v for i, v in enumerate(nums))
        res = t
        for i in range(1, n):
            t = t + s - n * nums[n - i]
            res = max(res, t)
        return res

=======

def maxRotateFunction(self, nums: List[int]) -> int:
        n = len(nums)
        s = sum(nums)
        res = 0
        for i in range(n):
            res += i*nums[i]
        max_res = res
        for i in range(1, n):
            res = res + s - n*nums[n-i]
            max_res = max(max_res, res)
        return max_res

=======

def maxRotateFunction(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return 0
        res = [0]*len(nums)
        for i in range(len(nums)):
            for j in range(len(nums)):
                res[i] += j*nums[(i+j)%len(nums)]
        return max(res)

=======

def maxRotateFunction(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return 0
        res = []
        for i in range(len(nums)):
            res.append(sum([nums[(i+j)%len(nums)]*j for j in range(len(nums))]))
        return max(res)

=======

def maxRotateFunction(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return 0
        total = sum(nums)
        n = len(nums)
        curr = sum([i * nums[i] for i in range(n)])
        max_val = curr
        for i in range(n-1, 0, -1):
            curr = curr + total - n * nums[i]
            max_val = max(max_val, curr)
        return max_val

=======

def maxRotateFunction(self, nums: List[int]) -> int:
        max_val = -float('inf')
        n = len(nums)
        for i in range(n):
            temp = sum([nums[j] * (j-i) for j in range(n)])
            max_val = max(max_val, temp)
        return max_val
