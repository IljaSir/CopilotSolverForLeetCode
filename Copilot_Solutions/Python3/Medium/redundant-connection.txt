Synthesizing 10/10 solutions (Duplicates hidden)

=======

def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        n = len(edges)
        parent = [i for i in range(n+1)]
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
        def union(x, y):
            parent[find(x)] = find(y)
        for x, y in edges:
            if find(x) != find(y):
                union(x, y)
            else:
                return x, y

=======

def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        n = len(edges)
        parent = [i for i in range(n+1)]
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
        def union(x, y):
            x, y = find(x), find(y)
            if x != y:
                parent[x] = y
                return True
            return False
        for x, y in edges:
            if not union(x, y):
                return [x, y]

=======

def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        n = len(edges)
        parent = [i for i in range(n+1)]
        def find(x):
            if x != parent[x]:
                parent[x] = find(parent[x])
            return parent[x]
        def union(x, y):
            parent[find(x)] = find(y)
        for a, b in edges:
            if find(a) == find(b):
                return [a, b]
            union(a, b)

=======

def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        n = len(edges)
        parent = list(range(n+1))
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
        def union(x, y):
            parent[find(x)] = find(y)
        for x, y in edges:
            if find(x) == find(y):
                return [x, y]
            union(x, y)

=======

def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        parent = [i for i in range(len(edges)+1)]
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
        def union(x,y):
            parent[find(x)] = find(y)
        for x,y in edges:
            if find(x) != find(y):
                union(x,y)
            else:
                return x,y

=======

def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        def find(x):
            if x != parent[x]:
                parent[x] = find(parent[x])
            return parent[x]
        def union(x, y):
            parent[find(x)] = find(y)
        parent = list(range(len(edges)+1))
        for x, y in edges:
            if find(x) == find(y):
                return [x, y]
            else:
                union(x, y)

=======

def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        n = len(edges)
        parent = list(range(n+1))
        
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
        
        for edge in edges:
            x, y = edge
            if find(x) == find(y):
                return edge
            parent[find(x)] = find(y)

=======

def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        def find(x):
            if x != parent[x]:
                parent[x] = find(parent[x])
            return parent[x]
        def union(x,y):
            parent[find(x)] = find(y)
        parent = [i for i in range(len(edges)+1)]
        for x,y in edges:
            if find(x) == find(y):
                return [x,y]
            else:
                union(x,y)

=======

def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        parent = {}
        rank = {}
        def find(x):
            if x != parent[x]:
                parent[x] = find(parent[x])
            return parent[x]
        def union(x, y):
            xroot = find(x)
            yroot = find(y)
            if xroot == yroot:
                return False
            if rank[xroot] < rank[yroot]:
                parent[xroot] = yroot
            elif rank[xroot] > rank[yroot]:
                parent[yroot] = xroot
            else:
                parent[yroot] = xroot
                rank[xroot] += 1
            return True
        for edge in edges:
            if edge[0] not in parent:
                parent[edge[0]] = edge[0]
                rank[edge[0]] = 0
            if edge[1] not in parent:
                parent[edge[1]] = edge[1]
                rank[edge[1]] = 0
            if not union(edge[0], edge[1]):
                return edge
