Synthesizing 9/10 solutions (Duplicates hidden)

=======

def getMoneyAmount(self, n: int) -> int:
        dp = [[0] * (n + 1) for _ in range(n + 1)]
        for lo in range(n, 0, -1):
            for hi in range(lo + 1, n + 1):
                dp[lo][hi] = min(x + max(dp[lo][x - 1], dp[x + 1][hi]) for x in range(lo, hi))
        return dp[1][n]

=======

def getMoneyAmount(self, n: int) -> int:
        dp = [[0] * (n+1) for _ in range(n+1)]
        for j in range(2, n+1):
            for i in range(j-1, 0, -1):
                global_min = float('inf')
                for k in range(i+1, j):
                    local_max = k + max(dp[i][k-1], dp[k+1][j])
                    global_min = min(global_min, local_max)
                dp[i][j] = i+1 if j-i == 1 else global_min
        return dp[1][n]

=======

def getMoneyAmount(self, n: int) -> int:
        dp = [[0 for _ in range(n+1)] for _ in range(n+1)]
        for i in range(n, 0, -1):
            for j in range(i+1, n+1):
                dp[i][j] = min(k+max(dp[i][k-1], dp[k+1][j]) for k in range(i, j))
        return dp[1][n]

=======

def getMoneyAmount(self, n: int) -> int:
        dp = [[0] * (n+1) for _ in range(n+1)]
        for length in range(2, n+1):
            for start in range(1, n-length+2):
                global_min = float('inf')
                for piv in range(start+1, start+length-1):
                    local_max = piv + max(dp[start][piv-1], dp[piv+1][start+length-1])
                    global_min = min(global_min, local_max)
                dp[start][start+length-1] = start if length == 2 else global_min
        return dp[1][n]

=======

def getMoneyAmount(self, n: int) -> int:
        
        pass

=======

def getMoneyAmount(self, n: int) -> int:
        # dp[i][j] = the min money to guarantee a win for subproblem [i, j].
        # Note: subproblems are inclusive.
        # dp[i][j] = min(k + max(dp[i][k-1], dp[k+1][j])) where i <= k <= j
        dp = [[0]*(n+1) for _ in range(n+1)]
        for lo in range(n, 0, -1):
            for hi in range(lo+1, n+1):
                dp[lo][hi] = min(k + max(dp[lo][k-1], dp[k+1][hi])
                                 for k in range(lo, hi))
        return dp[1][n]
