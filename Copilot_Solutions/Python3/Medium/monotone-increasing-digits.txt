Synthesizing 10/10 solutions (Duplicates hidden)

=======

def monotoneIncreasingDigits(self, n: int) -> int:
        s = str(n)
        i = 1
        while i < len(s) and s[i-1] <= s[i]:
            i += 1
        if i < len(s):
            while i > 0 and s[i-1] > s[i]:
                s = s[:i-1] + str(int(s[i-1])-1) + '9'*(len(s)-i)
                i -= 1
        return int(s)

=======

def monotoneIncreasingDigits(self, n: int) -> int:
        s = str(n)
        for i in range(len(s)-1, 0, -1):
            if s[i] < s[i-1]:
                return int(s[:i-1] + str(int(s[i-1])-1) + '9'*(len(s)-i))
        return n

=======

def monotoneIncreasingDigits(self, n: int) -> int:
        s = str(n)
        for i in range(len(s)-1):
            if s[i] > s[i+1]:
                return int(s[:i] + str(int(s[i])-1) + '9'*(len(s)-i-1))
        return n

=======

def monotoneIncreasingDigits(self, n: int) -> int:
        s = str(n)
        for i in range(len(s) - 1, 0, -1):
            if s[i - 1] > s[i]:
                s = s[:i - 1] + str(int(s[i - 1]) - 1) + '9' * (len(s) - i)
        return int(s)

=======

def monotoneIncreasingDigits(self, n: int) -> int:
        s = str(n)
        for i in range(len(s)-1,0,-1):
            if s[i] < s[i-1]:
                s = s[:i-1] + str(int(s[i-1])-1) + '9'*(len(s)-i)
        return int(s)

=======

def monotoneIncreasingDigits(self, n: int) -> int:
        # 1. Find the first non-increasing digit from the left
        # 2. Decrease the digit by 1, and set all the digits after it to 9
        # 3. Repeat 1 and 2 until the number is monotone increasing
        num = str(n)
        for i in range(len(num)-1):
            if num[i] > num[i+1]:
                num = num[:i] + str(int(num[i])-1) + '9'*(len(num)-i-1)
                break
        return int(num)
