Synthesizing 10/10 solutions (Duplicates hidden)

=======

def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:
        if endGene not in bank:
            return -1
        queue = collections.deque([(startGene, 0)])
        while queue:
            gene, step = queue.popleft()
            if gene == endGene:
                return step
            for i in range(len(gene)):
                for c in 'ACGT':
                    new_gene = gene[:i] + c + gene[i+1:]
                    if new_gene in bank:
                        bank.remove(new_gene)
                        queue.append((new_gene, step+1))
        return -1

=======

def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:
        if endGene not in bank:
            return -1
        bank = set(bank)
        queue = collections.deque([(startGene, 0)])
        while queue:
            gene, steps = queue.popleft()
            if gene == endGene:
                return steps
            for i in range(len(gene)):
                for c in 'ACGT':
                    new_gene = gene[:i] + c + gene[i+1:]
                    if new_gene in bank:
                        bank.remove(new_gene)
                        queue.append((new_gene, steps + 1))
        return -1

=======

def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:
        if endGene not in bank:
            return -1
        bank = set(bank)
        queue = collections.deque([(startGene, 0)])
        while queue:
            gene, steps = queue.popleft()
            if gene == endGene:
                return steps
            for i in range(len(gene)):
                for c in 'ACGT':
                    new_gene = gene[:i] + c + gene[i+1:]
                    if new_gene in bank:
                        queue.append((new_gene, steps + 1))
                        bank.remove(new_gene)
        return -1

=======

def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:
        if endGene not in bank:
            return -1
        bank = set(bank)
        queue = [(startGene, 0)]
        while queue:
            gene, steps = queue.pop(0)
            if gene == endGene:
                return steps
            for i in range(len(gene)):
                for c in ['A', 'C', 'G', 'T']:
                    if c != gene[i]:
                        new_gene = gene[:i] + c + gene[i+1:]
                        if new_gene in bank:
                            queue.append((new_gene, steps+1))
                            bank.remove(new_gene)
        return -1

=======

def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:
        
        pass

=======

def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:
        if endGene not in bank:
            return -1
        if startGene == endGene:
            return 0
        bank = set(bank)
        queue = [(startGene, 0)]
        while queue:
            gene, steps = queue.pop(0)
            if gene == endGene:
                return steps
            for i in range(8):
                for c in "ACGT":
                    new_gene = gene[:i] + c + gene[i+1:]
                    if new_gene in bank:
                        bank.remove(new_gene)
                        queue.append((new_gene, steps+1))
        return -1

=======

def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:
        bank = set(bank)
        if endGene not in bank:
            return -1
        startGene, endGene = set([startGene]), set([endGene])
        step = 0
        while startGene:
            step += 1
            nextStartGene = set()
            for gene in startGene:
                for i in range(8):
                    for c in 'ACGT':
                        nextGene = gene[:i] + c + gene[i+1:]
                        if nextGene in endGene:
                            return step
                        if nextGene in bank:
                            bank.remove(nextGene)
                            nextStartGene.add(nextGene)
            startGene = nextStartGene
            if len(startGene) > len(endGene):
                startGene, endGene = endGene, startGene
        return -1

=======

def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:
        if endGene not in bank:
            return -1
        bank = set(bank)
        visited = set()
        queue = [(startGene, 0)]
        while queue:
            gene, count = queue.pop(0)
            if gene == endGene:
                return count
            if gene in visited:
                continue
            visited.add(gene)
            for i in range(len(gene)):
                for c in 'ACGT':
                    new_gene = gene[:i] + c + gene[i+1:]
                    if new_gene in bank:
                        queue.append((new_gene, count+1))
        return -1

=======

def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:
        # BFS
        if not startGene or not endGene or not bank:
            return -1
        if endGene not in bank:
            return -1
        bank = set(bank)
        queue = collections.deque()
        queue.append((startGene, 0))
        while queue:
            cur, step = queue.popleft()
            if cur == endGene:
                return step
            for i in range(len(cur)):
                for j in "ACGT":
                    new = cur[:i] + j + cur[i+1:]
                    if new in bank:
                        bank.remove(new)
                        queue.append((new, step+1))
        return -1
