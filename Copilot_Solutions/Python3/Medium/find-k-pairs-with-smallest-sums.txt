Synthesizing 10/10 solutions

=======

def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        if not nums1 or not nums2:
            return []
        heap = []
        for i in range(min(k, len(nums1))):
            heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))
        result = []
        while heap and k > 0:
            _, i, j = heapq.heappop(heap)
            result.append([nums1[i], nums2[j]])
            if j + 1 < len(nums2):
                heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))
            k -= 1
        return result

=======

def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        result = []
        for num1 in nums1:
            for num2 in nums2:
                result.append([num1, num2])
        result.sort(key=lambda x: x[0] + x[1])
        return result[:k]

=======

def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        if not nums1 or not nums2:
            return []
        heap = []
        for i in range(min(k, len(nums1))):
            for j in range(min(k, len(nums2))):
                if len(heap) < k:
                    heapq.heappush(heap, (-(nums1[i] + nums2[j]), [nums1[i], nums2[j]]))
                else:
                    if nums1[i] + nums2[j] > -heap[0][0]:
                        break
                    else:
                        heapq.heappushpop(heap, (-(nums1[i] + nums2[j]), [nums1[i], nums2[j]]))
        return [x[1] for x in heap]

=======

def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        if not nums1 or not nums2:
            return []
        pairs = []
        for i in range(len(nums1)):
            for j in range(len(nums2)):
                pairs.append([nums1[i], nums2[j]])
        pairs.sort(key=lambda x:x[0]+x[1])
        return pairs[:k]

=======

def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        if not nums1 or not nums2 or k == 0:
            return []
        h = [(nums1[0] + nums2[0], 0, 0)]
        res = []
        while h and len(res) < k:
            _, i, j = heapq.heappop(h)
            res.append([nums1[i], nums2[j]])
            if i + 1 < len(nums1):
                heapq.heappush(h, (nums1[i + 1] + nums2[j], i + 1, j))
            if i == 0 and j + 1 < len(nums2):
                heapq.heappush(h, (nums1[i] + nums2[j + 1], i, j + 1))
        return res

=======

def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        if not nums1 or not nums2:
            return []
        import heapq
        heap = []
        n1 = len(nums1)
        n2 = len(nums2)
        for i in range(n1):
            for j in range(n2):
                if len(heap) < k:
                    heapq.heappush(heap, (-nums1[i]-nums2[j], i, j))
                else:
                    if nums1[i]+nums2[j] < -heap[0][0]:
                        heapq.heappop(heap)
                        heapq.heappush(heap, (-nums1[i]-nums2[j], i, j))
                    else:
                        break
        ret = []
        while heap:
            _, i, j = heapq.heappop(heap)
            ret.append([nums1[i], nums2[j]])
        return ret[::-1]

=======

def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        if not nums1 or not nums2:
            return []
        heap = []
        for i in range(len(nums1)):
            for j in range(len(nums2)):
                if i == 0 and j < k:
                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))
                elif i > 0 and j == 0:
                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))
                else:
                    break
        result = []
        while len(result) < k and heap:
            _, i, j = heapq.heappop(heap)
            result.append([nums1[i], nums2[j]])
            if j + 1 < len(nums2):
                heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))
        return result

=======

def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        # return heapq.nsmallest(k, [[a,b] for a in nums1 for b in nums2], key=sum)
        return heapq.nsmallest(k, [[a,b] for a in nums1 for b in nums2], key=lambda x: x[0] + x[1])

=======

def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        if not nums1 or not nums2 or not k:
            return []
        import heapq
        q = []
        for i in range(0, min(k, len(nums1))):
            heapq.heappush(q, (nums1[i] + nums2[0], i, 0))
        res = []
        while q and len(res) < k:
            _, i, j = heapq.heappop(q)
            res.append([nums1[i], nums2[j]])
            if j + 1 < len(nums2):
                heapq.heappush(q, (nums1[i] + nums2[j + 1], i, j + 1))
        return res

=======

class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        # nums1, nums2 are sorted
        # return the k smallest pairs
        # return the smallest sum
        # return the smallest sum pair
        # return the k smallest sum pair
        # return the k smallest sum pairs
