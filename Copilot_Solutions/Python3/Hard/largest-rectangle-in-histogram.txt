Synthesizing 10/10 solutions

=======

def largestRectangleArea(self, heights: List[int]) -> int:
        stack = [-1]
        max_area = 0
        for i, h in enumerate(heights):
            while stack[-1] != -1 and heights[stack[-1]] >= h:
                max_area = max(max_area, heights[stack.pop()] * (i - stack[-1] - 1))
            stack.append(i)
        while stack[-1] != -1:
            max_area = max(max_area, heights[stack.pop()] * (len(heights) - stack[-1] - 1))
        return max_area

=======

def largestRectangleArea(self, heights: List[int]) -> int:
        heights = [0] + heights + [0]
        stack = []
        res = 0
        for i in range(len(heights)):
            while stack and heights[stack[-1]] > heights[i]:
                h = heights[stack.pop()]
                w = i - stack[-1] - 1
                res = max(res, h * w)
            stack.append(i)
        return res

=======

def largestRectangleArea(self, heights: List[int]) -> int:
        stack = []
        max_area = 0
        heights.append(0)
        for i in range(len(heights)):
            while stack and heights[stack[-1]] >= heights[i]:
                h = heights[stack.pop()]
                w = i if not stack else i - stack[-1] - 1
                max_area = max(max_area, h * w)
            stack.append(i)
        return max_area

=======

def largestRectangleArea(self, heights: List[int]) -> int:
        max_area = 0
        heights.append(0)
        stack = [-1]
        for i, height in enumerate(heights):
            while height < heights[stack[-1]]:
                h = heights[stack.pop()]
                w = i - stack[-1] - 1
                max_area = max(max_area, h * w)
            stack.append(i)
        return max_area

=======

def largestRectangleArea(self, heights: List[int]) -> int:
        stack = []
        max_area = 0
        heights.append(0)
        for i, h in enumerate(heights):
            if not stack or h >= heights[stack[-1]]:
                stack.append(i)
            else:
                while stack and h < heights[stack[-1]]:
                    idx = stack.pop()
                    if stack:
                        max_area = max(max_area, heights[idx] * (i - stack[-1] - 1))
                    else:
                        max_area = max(max_area, heights[idx] * i)
                stack.append(i)
        return max_area

=======

def largestRectangleArea(self, heights: List[int]) -> int:
        if not heights:
            return 0
        stack = []
        heights.append(0)
        max_area = 0
        for i in range(len(heights)):
            while stack and heights[i] < heights[stack[-1]]:
                h = heights[stack.pop()]
                w = i if not stack else i - stack[-1] - 1
                max_area = max(max_area, h * w)
            stack.append(i)
        return max_area

=======

def largestRectangleArea(self, heights: List[int]) -> int:
        stack = []
        res = 0
        for i, h in enumerate(heights):
            while stack and h < heights[stack[-1]]:
                j = stack.pop()
                res = max(res, heights[j] * (i - stack[-1] - 1 if stack else i))
            stack.append(i)
        while stack:
            j = stack.pop()
            res = max(res, heights[j] * (len(heights) - stack[-1] - 1 if stack else len(heights)))
        return res

=======

def largestRectangleArea(self, heights: List[int]) -> int:
        # 暴力解法
        # n = len(heights)
        # maxarea = 0
        # for i in range(n):
        #     left = i
        #     right = i
        #     while left - 1 >= 0 and heights[left - 1] >= heights[i]:
        #         left -= 1
        #     while right + 1 < n and heights[right + 1] >= heights[i]:
        #         right += 1
        #     maxarea = max(maxarea, (right - left + 1) * heights[i])
        # return maxarea
        # 单调栈
        # 1. 单调递增栈
        # 2. 用一个0元素来结束栈，方便处理最后一次计算
        # 3. 每次计算都是以当前元素为高度的矩形，所以要用当前元素的前一个元素来计算宽度
        n = len(heights)
        stack = [-1]
        maxarea = 0
        for i in range(n):
            while stack[-1] != -1 and heights[stack[-1]] >= heights[i]:
                maxarea = max(maxarea, heights[stack.pop()] * (i - stack[-1] - 1))
            stack.append(i)
        while stack[-1] != -1:
            maxarea = max(maxarea, heights[stack.pop()] * (n - stack[-1] - 1))
        return maxarea

=======

def largestRectangleArea(self, heights: List[int]) -> int:
        # brute force
        # area = 0
        # for i in range(len(heights)):
        #     left = i
        #     right = i
        #     while left > 0 and heights[left-1] >= heights[i]:
        #         left -= 1
        #     while right < len(heights)-1 and heights[right+1] >= heights[i]:
        #         right += 1
        #     area = max(area, (right-left+1)*heights[i])
        # return area
        
        # stack
        area = 0
        stack = []
        for i in range(len(heights)):
            while stack and heights[stack[-1]] > heights[i]:
                h = heights[stack.pop()]
                w = i if not stack else i-stack[-1]-1
                area = max(area, h*w)
            stack.append(i)
        while stack:
            h = heights[stack.pop()]
            w = len(heights) if not stack else len(heights)-stack[-1]-1
            area = max(area, h*w)
        return area

=======

class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        # 1. brute force
        # 2. stack
        # 3. divide and conquer
        # 4. mono stack
        # 5. mono queue
        # 6. binary search
        # 7. segment tree
        # 8. line sweep
        # 9. math
        # 10. dp
        # 11. greedy
        # 12. bit manipulation
        # 13. simulation
        # 14. backtracking
        # 15. recursion
        # 16. bfs
        # 17. dfs
        # 18. union find
        # 19. dp
        # 20. greedy
        # 21. two pointers
        # 22. bit manipulation
        # 23. simulation
        # 24. backtracking
        # 25. recursion
        # 26. bfs
        # 27. dfs
        # 28. union find
        # 29. dp
        # 30. greedy
        # 31. two pointers
        # 32. bit manipulation
        # 33. simulation
        # 34. backtracking
        # 35. recursion
        # 36. bfs
        # 37. dfs
        # 38. union find
        # 39. dp
        # 40. greedy
        # 41. two pointers
        # 42. bit manipulation
        # 43. simulation
        # 44. backtracking
        # 45. recursion
        # 46. bfs
        # 47. dfs
        # 48. union find
        # 49. dp
        # 50. greedy
        # 51. two pointers
        # 52. bit manipulation
        # 53. simulation
        # 54. backtracking
        # 55. recursion
        # 56. bfs
        # 57. dfs
        # 58. union find
        # 59. dp
        # 60. greedy
        # 61. two pointers
        # 62. bit manipulation
        # 63. simulation
        # 64. backtracking
        # 65. recursion
        # 66. bfs
        # 67. dfs
