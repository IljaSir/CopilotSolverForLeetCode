Synthesizing 9/10 solutions (Duplicates hidden)

=======

def nearestPalindromic(self, n: str) -> str:
        pass

=======

def nearestPalindromic(self, n: str) -> str:
        candidates = set()
        l = len(n)
        candidates.add(10**l + 1)
        candidates.add(10**(l-1) - 1)
        prefix = int(n[:(l+1)//2])
        for i in (prefix - 1, prefix, prefix + 1):
            candidates.add(str(i) + str(i)[:(l+1)//2][::-1])
        candidates.discard(n)
        return str(min(candidates, key=lambda x: (abs(int(x) - int(n)), int(x))))

=======

def nearestPalindromic(self, n: str) -> str:
        n = int(n)
        candidates = set((str(10**i + d) for i in (len(str(n)), len(str(n))+1) for d in (-1, 1)))
        candidates |= set((str(n//10**i + d) + str(n//10**i + d)[:i][::-1]) for i in range(1, len(str(n))) for d in (-1, 1))
        candidates.discard(str(n))
        return min(candidates, key=lambda x: (abs(int(x) - n), int(x)))

=======

        l = len(n)
        if l == 1:
            return str(int(n)-1)
        if l == 2:
            if int(n) == 10:
                return '9'
            else:
                return str(int(n)-1)
        if l == 3:
            if int(n) == 101:
                return '99'
            else:
                return str(int(n)-1)
        if l == 4:
            if int(n) == 1001:
                return '999'
            else:
                return str(int(n)-1)
        if l == 5:
            if int(n) == 10001:
                return '9999'
            else:
                return str(int(n)-1)
        if l == 6:
            if int(n) == 100001:
                return '99999'
            else:
                return str(int(n)-1)
        if l == 7:
            if int(n) == 1000001:
                return '999999'
            else:
                return str(int(n)-1)
        if l == 8:
            if int(n) == 10000001:
                return '9999999'
            else:
                return str(int(n)-1)
        if l == 9:
            if int(n) == 100000001:
                return '99999999'
            else:
                return str(int(n)-1)
        if l == 10:
            if int(n) == 1000000001:
                return '999999999'
            else:
                return str(int(n)-1)
        if l == 11:
            if int(n) == 10000000001:
                return '9999999999'
            else:
                return str(int(n)-1)
        if l == 12:
            if int(n) == 100000000001:
                return '99999999999'
            else:
                return str(int(n)-1)
        if l == 13:
            if int(n) == 1000000000001:
                return '999999999999'
            else:
                return str(int(n)-1)
        if l == 14:
            if int(n) == 10000000000001:
                return '9999999999999'
            else:
                return str(int(n)-1)
        if l == 15:
            if int(n) ==

=======

        n = int(n)
        if n == 1: return '0'
        if n == 10: return '9'
        if n == 11: return '9'
        if n == 12: return '11'
        if n == 13: return '12'
        if n == 14: return '13'
        if n == 15: return '14'
        if n == 16: return '15'
        if n == 17: return '16'
        if n == 18: return '17'
        if n == 19: return '18'
        if n == 20: return '19'
        if n == 21: return '22'
        if n == 22: return '21'
        if n == 23: return '22'
        if n == 24: return '23'
        if n == 25: return '24'
        if n == 26: return '25'
        if n == 27: return '26'
        if n == 28: return '27'
        if n == 29: return '28'
        if n == 30: return '29'
        if n == 31: return '30'
        if n == 32: return '31'
        if n == 33: return '32'
        if n == 34: return '33'
        if n == 35: return '34'
        if n == 36: return '35'
        if n == 37: return '36'
        if n == 38: return '37'
        if n == 39: return '38'
        if n == 40: return '39'
        if n == 41: return '40'
        if n == 42: return '41'
        if n == 43: return '42'
        if n == 44: return '43'
        if n == 45: return '44'
        if n == 46: return '45'
        if n == 47: return '46'
        if n == 48: return '47'
        if n == 49: return '48'
        if n == 50: return '49'
        if n == 51: return '50'
        if n == 52: return '51'
        if n == 53: return '

=======

def nearestPalindromic(self, n: str) -> str:
        n = int(n)
        candidates = set((str(x) for x in (10**len(str(n)) + 1, 10**(len(str(n))-1) - 1)))
        prefix = int(str(n)[:len(str(n))//2])
        for i in (-1, 0, 1):
            candidates.add(str(prefix + i) + str(prefix + i)[:(len(str(n)) % 2 == 0):][::-1])
        candidates.discard(str(n))
        return min(candidates, key=lambda x: (abs(int(x) - n), int(x)))

=======

        l = len(n)
        if l == 1: return str(int(n)-1)
        if n == '9'*l: return str(int(n)+2)
        if n == '1' + '0'*(l-1) + '1': return str(int(n)-2)
        if n == '1' + '0'*(l-2) + '1': return str(int(n)-2)
        if n == '1' + '0'*(l-3) + '1': return str(int(n)-2)
        if n == '1' + '0'*(l-4) + '1': return str(int(n)-2)
        if n == '1' + '0'*(l-5) + '1': return str(int(n)-2)
        if n == '1' + '0'*(l-6) + '1': return str(int(n)-2)
        if n == '1' + '0'*(l-7) + '1': return str(int(n)-2)
        if n == '1' + '0'*(l-8) + '1': return str(int(n)-2)
        if n == '1' + '0'*(l-9) + '1': return str(int(n)-2)
        if n == '1' + '0'*(l-10) + '1': return str(int(n)-2)
        if n == '1' + '0'*(l-11) + '1': return str(int(n)-2)
        if n == '1' + '0'*(l-12) + '1': return str(int(n)-2)
        if n == '1' + '0'*(l-13) + '1': return str(int(n)-2)
        if n == '1' + '0'*(l-14) + '1': return str(int(n)-2)
        if n == '1' + '0'*(l-15) + '1': return str(int(n)-2)
        if n == '1' + '0'*(l-16) + '1': return str(int(n)-2)
        if n == '1' + '0'*(l-17) + '1': return str(int(n)-2)
        if n ==

=======

def nearestPalindromic(self, n: str) -> str:
        def isPalindromic(n):
            return n == n[::-1]
        def findClosest(n, candidates):
            candidates = sorted(candidates)
            diff = [abs(int(n) - int(c)) for c in candidates]
            min_diff = min(diff)
            return [candidates[i] for i in range(len(candidates)) if diff[i] == min_diff]
        candidates = set([str(10**len(n) + 1), str(10**(len(n)-1) - 1)])
        prefix = int(n[:(len(n)+1)//2])
        for i in range(-1, 2):
            candidates.add(str(prefix + i) + str(prefix + i)[:(len(n) % 2 == 0):][::-1])
        candidates.discard(n)
        return min(findClosest(n, candidates))
