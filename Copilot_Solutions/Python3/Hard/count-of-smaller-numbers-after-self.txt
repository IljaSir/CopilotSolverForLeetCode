Synthesizing 10/10 solutions

=======

def countSmaller(self, nums: List[int]) -> List[int]:
        res = []
        for i in range(len(nums)):
            count = 0
            for j in range(i+1, len(nums)):
                if nums[j] < nums[i]:
                    count += 1
            res.append(count)
        return res

=======

def countSmaller(self, nums: List[int]) -> List[int]:
        if not nums:
            return []
        n = len(nums)
        res = [0] * n
        for i in range(n-2, -1, -1):
            for j in range(i+1, n):
                if nums[j] < nums[i]:
                    res[i] += 1
        return res

=======

def countSmaller(self, nums: List[int]) -> List[int]:
        res = []
        for i in range(len(nums)):
            res.append(sum([1 for j in range(i+1, len(nums)) if nums[j] < nums[i]]))
        return res

=======

def countSmaller(self, nums: List[int]) -> List[int]:
        n = len(nums)
        if n == 0: return []
        if n == 1: return [0]
        mid = n // 2
        left = self.countSmaller(nums[:mid])
        right = self.countSmaller(nums[mid:])
        res = [0] * n
        i = j = 0
        while i < len(left) and j < len(right):
            if nums[mid + i] < nums[j]:
                res[i + j] += left[i] + 1
                i += 1
            else:
                res[i + j] += right[j]
                j += 1
        while i < len(left):
            res[i + j] += left[i]
            i += 1
        while j < len(right):
            res[i + j] += right[j]
            j += 1
        return res

=======

def countSmaller(self, nums: List[int]) -> List[int]:
        return [sum(1 for j in range(i+1, len(nums)) if nums[j] < nums[i]) for i in range(len(nums))]

=======

def countSmaller(self, nums: List[int]) -> List[int]:
        return self.countSmaller_BST(nums)

=======

def countSmaller(self, nums: List[int]) -> List[int]:
        # merge sort
        def merge_sort(l, r):
            if l >= r:
                return
            m = l + (r-l)//2
            merge_sort(l, m)
            merge_sort(m+1, r)
            merge(l, m, r)
        def merge(l, m, r):
            i, j = l, m + 1
            while i <= m and j <= r:
                if nums[i] > nums[j]:
                    count[nums[i]] += r - j + 1
                    i += 1
                else:
                    j += 1
            nums[l:r+1] = sorted(nums[l:r+1])
        n = len(nums)
        count = collections.Counter()
        merge_sort(0, n-1)
        return [count[num] for num in nums]

=======

def countSmaller(self, nums: List[int]) -> List[int]:
        n = len(nums)
        sorted_nums = sorted(nums)
        index = {num: i for i, num in enumerate(sorted_nums)}
        bit = [0] * (n + 1)
        def update(i):
            while i <= n:
                bit[i] += 1
                i += i & -i
        def query(i):
            res = 0
            while i:
                res += bit[i]
                i -= i & -i
            return res
        res = []
        for num in nums[::-1]:
            res.append(query(index[num]))
            update(index[num] + 1)
        return res[::-1]

=======

def countSmaller(self, nums: List[int]) -> List[int]:
        # Solution 1 - 400 ms
        """
        # merge sort
        def sort(enum):
            half = len(enum) // 2
            if half:
                left, right = sort(enum[:half]), sort(enum[half:])
                for i in range(len(enum))[::-1]:
                    if not right or left and left[-1][1] > right[-1][1]:
                        res[left[-1][0]] += len(right)
                        enum[i] = left.pop()
                    else:
                        enum[i] = right.pop()
            return enum
        res = [0] * len(nums)
        sort(list(enumerate(nums)))
        return res
        """
        # Solution 2 - 76 ms
        def mergeSort(nums):
            n = len(nums)
            if n <= 1:
                return nums, [0] * n
            m = n // 2
            left, left_count = mergeSort(nums[:m])
            right, right_count = mergeSort(nums[m:])
            i = j = n - 1
            res = []
            count = [0] * n
            while i >= 0 and j >= m:
                if left[i] > right[j]:
                    count[i] = j - m + 1
                    res.append(left[i])
                    i -= 1
                else:
                    res.append(right[j])
                    j -= 1
            while i >= 0:
                res.append(left[i])
                i -= 1
            while j >= m:
                res.append(right[j])
                j -= 1
            return res[::-1], count[:m] + count[m:]
        res, _ = mergeSort(nums)
        return res

=======

class Solution:
    def countSmaller(self, nums: List[int]) -> List[int]:
        # 1. sort and binary search
        # 2. merge sort
        # 3. segment tree
        # 4. fenwick tree
        # 5. binary indexed tree
        # 6. BIT
        # 7. BIT
        # 8. BIT
        # 9. BIT
        # 10. BIT
        # 11. BIT
        # 12. BIT
        # 13. BIT
        # 14. BIT
        # 15. BIT
        # 16. BIT
        # 17. BIT
        # 18. BIT
        # 19. BIT
        # 20. BIT
        # 21. BIT
        # 22. BIT
        # 23. BIT
        # 24. BIT
        # 25. BIT
        # 26. BIT
        # 27. BIT
        # 28. BIT
        # 29. BIT
        # 30. BIT
        # 31. BIT
        # 32. BIT
        # 33. BIT
        # 34. BIT
        # 35. BIT
        # 36. BIT
        # 37. BIT
        # 38. BIT
        # 39. BIT
        # 40. BIT
        # 41. BIT
        # 42. BIT
        # 43. BIT
        # 44. BIT
        # 45. BIT
        # 46. BIT
        # 47. BIT
        # 48. BIT
        # 49. BIT
        # 50. BIT
        # 51. BIT
        # 52. BIT
        # 53. BIT
        # 54. BIT
        # 55. BIT
        # 56. BIT
        # 57. BIT
        # 58. BIT
        # 59. BIT
        # 60. BIT
        # 61. BIT
        # 62. BIT
        # 63. BIT
        # 64. BIT
        # 65. BIT
        # 66. BIT
        # 67. BIT
        # 68. BIT
        # 69. BIT
        # 70. BIT
