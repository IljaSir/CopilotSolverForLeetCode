Synthesizing 10/10 solutions (Duplicates hidden)

=======

def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        graph = collections.defaultdict(list)
        for a, b in sorted(tickets)[::-1]:
            graph[a] += b,
        route = []
        def dfs(a):
            while graph[a]:
                dfs(graph[a].pop())
            route.append(a)
        dfs('JFK')
        return route[::-1]

=======

def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        graph = collections.defaultdict(list)
        for f, t in sorted(tickets)[::-1]:
            graph[f] += t,
        route = []
        def visit(airport):
            while graph[airport]:
                visit(graph[airport].pop())
            route.append(airport)
        visit('JFK')
        return route[::-1]

=======

def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        graph = collections.defaultdict(list)
        for src, dst in sorted(tickets)[::-1]:
            graph[src].append(dst)
        route = []
        def dfs(src):
            while graph[src]:
                dfs(graph[src].pop())
            route.append(src)
        dfs("JFK")
        return route[::-1]

=======

def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        graph = collections.defaultdict(list)
        for start, end in sorted(tickets, reverse=True):
            graph[start].append(end)
        route, stack = [], ['JFK']
        while stack:
            while graph[stack[-1]]:
                stack.append(graph[stack[-1]].pop())
            route.append(stack.pop())
        return route[::-1]

=======

def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        def dfs(v):
            while graph[v]:
                dfs(graph[v].pop())
            res.append(v)
        
        graph = collections.defaultdict(list)
        for u, v in sorted(tickets)[::-1]:
            graph[u].append(v)
        res = []
        dfs("JFK")
        return res[::-1]

=======

def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        from collections import defaultdict
        graph = defaultdict(list)
        for u, v in tickets:
            graph[u].append(v)
        for key in graph:
            graph[key].sort()
        res = []
        def dfs(u):
            while graph[u]:
                dfs(graph[u].pop(0))
            res.append(u)
        dfs('JFK')
        return res[::-1]

=======

def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        def dfs(cur):
            while cur in graph and graph[cur]:
                dfs(graph[cur].pop())
            res.insert(0, cur)
        graph = collections.defaultdict(list)
        for u, v in sorted(tickets)[::-1]:
            graph[u].append(v)
        res = []
        dfs('JFK')
        return res

=======

def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        from collections import defaultdict
        def dfs(s):
            while graph[s]:
                dfs(graph[s].pop())
            res.append(s)
        graph = defaultdict(list)
        res = []
        for f, t in sorted(tickets)[::-1]:
            graph[f].append(t)
        dfs('JFK')
        return res[::-1]

=======

def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        # construct the graph
        graph = collections.defaultdict(list)
        for u, v in tickets:
            graph[u].append(v)
        for u in graph:
            graph[u].sort(reverse=True)
        
        # backtracking
        route = []
        def dfs(u):
            while graph[u]:
                dfs(graph[u].pop())
            route.append(u)
        
        dfs('JFK')
        return route[::-1]
