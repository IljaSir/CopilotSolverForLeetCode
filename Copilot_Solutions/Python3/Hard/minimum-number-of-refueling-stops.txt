Synthesizing 9/10 solutions (Duplicates hidden)

=======

def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:
        dp = [startFuel] + [0] * len(stations)
        for i, (location, capacity) in enumerate(stations):
            for t in range(i, -1, -1):
                if dp[t] >= location:
                    dp[t + 1] = max(dp[t + 1], dp[t] + capacity)
        for i, d in enumerate(dp):
            if d >= target: return i
        return -1

=======

def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:
        n = len(stations)
        dp = [startFuel] + [0] * n
        for i in range(n):
            for t in range(i, -1, -1):
                if dp[t] >= stations[i][0]:
                    dp[t + 1] = max(dp[t + 1], dp[t] + stations[i][1])
        for i, d in enumerate(dp):
            if d >= target:
                return i
        return -1

=======

def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:
        stations.append([target, 0])
        dp = [startFuel] + [0] * len(stations)
        for i, (location, capacity) in enumerate(stations):
            for t in range(i, -1, -1):
                if dp[t] >= location:
                    dp[t+1] = max(dp[t+1], dp[t] + capacity)
        for i, d in enumerate(dp):
            if d >= target: return i
        return -1

=======

def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:
        stations.append([target, 0])
        n = len(stations)
        dp = [startFuel] + [0] * n
        for i in range(n):
            for t in range(i, -1, -1):
                if dp[t] >= stations[i][0]:
                    dp[t+1] = max(dp[t+1], dp[t] + stations[i][1])
        for i, d in enumerate(dp):
            if d >= target: return i
        return -1

=======

def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:
        n = len(stations)
        dp = [startFuel] + [0] * n
        for i, (s, f) in enumerate(stations):
            for t in range(i, -1, -1):
                if dp[t] >= s:
                    dp[t + 1] = max(dp[t + 1], dp[t] + f)
        for i, d in enumerate(dp):
            if d >= target:
                return i
        return -1

=======

def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:
        # dp[i] = max distance we can go with i stops
        dp = [startFuel] + [0] * len(stations)
        for i, (location, capacity) in enumerate(stations):
            for t in range(i, -1, -1):
                if dp[t] >= location:
                    dp[t+1] = max(dp[t+1], dp[t] + capacity)
        for i, d in enumerate(dp):
            if d >= target: return i
        return -1

=======

def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:
        pq = []
        stations.append([target, float('inf')])
        N = len(stations)
        i = 0
        res = 0
        while startFuel < target:
            while i < N and stations[i][0] <= startFuel:
                heapq.heappush(pq, -stations[i][1])
                i += 1
            if not pq:
                return -1
            startFuel -= heapq.heappop(pq)
            res += 1
        return res

=======

def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:
        # dp[i] = max distance can reach with i refueling stops
        dp = [startFuel] + [0] * len(stations)
        for i, (location, capacity) in enumerate(stations):
            for t in range(i, -1, -1):
                if dp[t] >= location:
                    dp[t+1] = max(dp[t+1], dp[t] + capacity)
        for i, d in enumerate(dp):
            if d >= target:
                return i
        return -1
