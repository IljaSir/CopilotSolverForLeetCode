Synthesizing 10/10 solutions (Duplicates hidden)

=======

def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:
        
        pass

=======

class Solution:
    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:
        # https://leetcode.com/problems/redundant-connection-ii/discuss/108045/C++JavaPython-One-Pass-Union-Find
        # https://leetcode.com/problems/redundant-connection-ii/discuss/108045/C%2B%2BJavaPython-One-Pass-Union-Find/110634
        # https://leetcode.com/problems/redundant-connection-ii/discuss/108045/C%2B%2BJavaPython-One-Pass-Union-Find/110629
        # https://leetcode.com/problems/redundant-connection-ii/discuss/108045/C%2B%2BJavaPython-One-Pass-Union-Find/110628
        # https://leetcode.com/problems/redundant-connection-ii/discuss/108045/C%2B%2BJavaPython-One-Pass-Union-Find/110627
        # https://leetcode.com/problems/redundant-connection-ii/discuss/108045/C%2B%2BJavaPython-One-Pass-Union-Find/110626
        # https://leetcode.com/problems/redundant-connection-ii/discuss/108045/C%2B%2BJavaPython-One-Pass-Union-Find/110625
        # https://leetcode.com/problems/redundant-connection-ii/discuss/108045/C%2B%2BJavaPython-One-Pass-Union-Find/110624
        # https://leetcode.com/problems/redundant-connection-ii/discuss/108045/C%2B%2BJavaPython-One-Pass-Union-Find/110623
        # https://leetcode.com/problems/redundant-connection-ii/discuss/108045/C%2B%2BJavaPython-One-Pass-Union-Find/110622
        # https://leetcode.com/problems/redundant-connection-ii/discuss/108045/C%2B%2BJavaPython-One-Pass-Union-Find/110621
        # https://leetcode.com/problems/redundant-connection-ii/discuss/108045/C%2B%2BJavaPython-One-Pass-Union-Find/110620
        # https://leetcode.com/problems/redundant-connection-ii/discuss/108045/C%2B%2BJ

=======

def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:
        
        # find the node with two parents
        parents = {}
        for edge in edges:
            if edge[1] not in parents:
                parents[edge[1]] = []
            parents[edge[1]].append(edge[0])
        
        # find the node with two parents
        node = -1
        for key in parents:
            if len(parents[key]) == 2:
                node = key
                break
        if node == -1:
            return self.findRedundantConnection(edges)
        
        # remove the edge that leads to the node with two parents
        for edge in edges:
            if edge[1] == node and edge[0] == parents[node][0]:
                edges.remove(edge)
                break
        
        # check if the graph is a tree
        if self.findRedundantConnection(edges) == []:
            return edge
        else:
            return parents[node][1], node

=======

def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:
        n = len(edges)
        # 1. build graph
        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
        # 2. find the node with two parents
        parents = [0] * (n + 1)
        for u, v in edges:
            parents[v] += 1
        candidates = []
        for i in range(1, n + 1):
            if parents[i] == 2:
                candidates.append(i)
        # 3. remove the edge with the later appearance
        if candidates:
            for u, v in edges[::-1]:
                if v == candidates[1]:
                    return [u, v]
        # 4. find cycle
        def dfs(u):
            seen.add(u)
            for v in graph[u]:
                if v in seen:
                    return True
                if dfs(v):
                    return True
            seen.remove(u)
            return False
        # 5. remove the edge that forms cycle
        for u, v in edges[::-1]:
            seen = set()
            if parents[v] == 0 and dfs(v):
                return [u, v]
        return []

=======

class Solution:
    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:
        # 1. Find the node with two parents
        # 2. If there is no node with two parents, then the redundant edge is the last edge
        # 3. If there is a node with two parents, then the redundant edge is the edge that makes the cycle
        # 4. If the redundant edge is not the last edge, then the redundant edge is the one that makes the cycle
        # 5. If the redundant edge is the last edge, then the redundant edge is the last edge
        # 6. If the redundant edge is the last edge, then the redundant edge is the last edge
        # 7. If the redundant edge is the last edge, then the redundant edge is the last edge
        # 8. If the redundant edge is the last edge, then the redundant edge is the last edge
        # 9. If the redundant edge is the last edge, then the redundant edge is the last edge
        # 10. If the redundant edge is the last edge, then the redundant edge is the last edge
        # 11. If the redundant edge is the last edge, then the redundant edge is the last edge
        # 12. If the redundant edge is the last edge, then the redundant edge is the last edge
        # 13. If the redundant edge is the last edge, then the redundant edge is the last edge
        # 14. If the redundant edge is the last edge, then the redundant edge is the last edge
        # 15. If the redundant edge is the last edge, then the redundant edge is the last edge
        # 16. If the redundant edge is the last edge, then the redundant edge is the last edge
        # 17. If the redundant edge is the last edge, then the redundant edge is the last edge
        # 18. If the redundant edge is the last edge, then the redundant edge is the last edge
        # 19. If the redundant edge is the last edge, then the redundant edge is the last edge
        # 20. If the redundant edge is the last edge, then the redundant edge is the last edge
        # 21. If the redundant edge is the last edge, then the redundant edge is the last edge
        # 22. If the redundant edge is the last edge, then the redundant edge is the
