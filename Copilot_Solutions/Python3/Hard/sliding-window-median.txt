Synthesizing 10/10 solutions

=======

def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        def get_median(arr):
            if len(arr) % 2 == 0:
                return (arr[len(arr) // 2] + arr[len(arr) // 2 - 1]) / 2
            else:
                return arr[len(arr) // 2]
        arr = sorted(nums[:k])
        res = [get_median(arr)]
        for i in range(k, len(nums)):
            arr.remove(nums[i - k])
            bisect.insort(arr, nums[i])
            res.append(get_median(arr))
        return res

=======

def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        def get_median(arr):
            n = len(arr)
            if n % 2 == 0:
                return (arr[n//2] + arr[n//2 - 1]) / 2
            else:
                return arr[n//2]
        arr = sorted(nums[:k])
        res = [get_median(arr)]
        for i in range(k, len(nums)):
            arr.remove(nums[i-k])
            bisect.insort(arr, nums[i])
            res.append(get_median(arr))
        return res

=======

def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        def get_median(l):
            if len(l) % 2 == 0:
                return (l[len(l) // 2] + l[len(l) // 2 - 1]) / 2
            else:
                return l[len(l) // 2]
        l = sorted(nums[:k])
        result = [get_median(l)]
        for i in range(k, len(nums)):
            l.remove(nums[i - k])
            bisect.insort(l, nums[i])
            result.append(get_median(l))
        return result

=======

def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        def getMedian():
            if k % 2 == 1:
                return sortedNums[k // 2]
            else:
                return (sortedNums[k // 2] + sortedNums[k // 2 - 1]) / 2

        sortedNums = sorted(nums[:k])
        res = [getMedian()]
        for i in range(k, len(nums)):
            sortedNums.remove(nums[i - k])
            bisect.insort(sortedNums, nums[i])
            res.append(getMedian())
        return res

=======

def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        if k == 1:
            return nums
        if k == 2:
            return [sum(nums[:2])/2] + [sum(nums[i:i+2])/2 for i in range(1,len(nums)-1)] + [sum(nums[-2:])/2]
        if k == 3:
            return [sorted(nums[:3])[1]] + [sorted(nums[i:i+3])[1] for i in range(1,len(nums)-2)] + [sorted(nums[-3:])[1]]
        def get_median(nums):
            nums = sorted(nums)
            mid = len(nums) // 2
            return (nums[mid] + nums[~mid]) / 2
        return [get_median(nums[i:i+k]) for i in range(len(nums)-k+1)]

=======

def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        if k == 1:
            return nums
        if k == len(nums):
            return [sorted(nums)[k//2] if k % 2 == 1 else sum(sorted(nums)[k//2-1:k//2+1])/2]
        res = []
        for i in range(len(nums)-k+1):
            res.append(sorted(nums[i:i+k])[k//2] if k % 2 == 1 else sum(sorted(nums[i:i+k])[k//2-1:k//2+1])/2)
        return res

=======

def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        def median(arr):
            arr_len = len(arr)
            if arr_len % 2 == 0:
                return (arr[arr_len // 2 - 1] + arr[arr_len // 2]) / 2
            else:
                return arr[arr_len // 2]
        ans = []
        left = 0
        right = k
        while right <= len(nums):
            ans.append(median(sorted(nums[left:right])))
            left += 1
            right += 1
        return ans

=======

def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        def median():
            if k % 2:
                return sorted_window[k // 2]
            return (sorted_window[k // 2] + sorted_window[k // 2 - 1]) / 2

        window, sorted_window = nums[:k], sorted(nums[:k])
        result = [median()]
        for i in range(k, len(nums)):
            del sorted_window[bisect_left(sorted_window, window.pop(0))]
            bisect.insort(sorted_window, nums[i])
            window.append(nums[i])
            result.append(median())
        return result

=======

def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        from sortedcontainers import SortedList
        n = len(nums)
        if k == 1:
            return nums
        if k == n:
            return [sum(nums) / n]
        window = SortedList(nums[:k])
        res = [window[k // 2] / 1.0 if k % 2 == 1 else (window[k // 2 - 1] + window[k // 2]) / 2.0]
        for i in range(k, n):
            window.remove(nums[i - k])
            window.add(nums[i])
            res.append(window[k // 2] / 1.0 if k % 2 == 1 else (window[k // 2 - 1] + window[k // 2]) / 2.0)
        return res

=======

class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        # 滑动窗口，求中位数
        # 1. 暴力解法，时间复杂度O(nklogk)
        # 2. 优先队列，时间复杂度O(nklogk)
        # 3. 二分查找，时间复杂度O(nklogk)
        # 4. 有序数组，时间复杂度O(nklogk)
        # 5. 滑动窗口，时间复杂度O(nk)
        # 6. 滑动窗口，时间复杂度O(nk)
        # 7. 滑动窗口，时间复杂度O(nlogk)
        # 8. 滑动窗口，时间复杂度O(nlogk)
        # 9. 滑动窗口，时间复杂度O(nlogk)
        # 10. 滑动窗口，时间复杂度O(n)
        # 11. 滑动窗口，时间复杂度O(n)
        # 12. 滑动窗口，时间复杂度O(n)
        # 13. 滑动窗口，时间复杂度O(n)
        # 14. 滑动窗口，时间复杂度O(n)
        # 15. 滑动窗口，时间复杂度O(n)
        # 16. 滑动窗口，时间复杂度O(n)
        # 17. 滑动窗口，时间复杂度O(n)
        # 18. 滑动窗口，时间复杂度O(n)
        # 19. 滑动窗口，时间复杂度O(n)
        # 20. 滑动窗口，时间复杂度O(n)
        # 21. 滑动窗口，时间复杂度O(n)
        # 22. 滑动窗口，时间复杂度O(n)
        # 23. 滑动
