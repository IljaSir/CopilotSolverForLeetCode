Synthesizing 10/10 solutions (Duplicates hidden)

=======

        int n = tops.length;
        int[] top = new int[7];
        int[] bottom = new int[7];
        int[] same = new int[7];
        for (int i = 0; i < n; i++) {
            top[tops[i]]++;
            bottom[bottoms[i]]++;
            if (tops[i] == bottoms[i]) {
                same[tops[i]]++;
            }
        }
        for (int i = 1; i <= 6; i++) {
            if (top[i] + bottom[i] - same[i] == n) {
                return n - Math.max(top[i], bottom[i]);
            }
        }
        return -1;

=======

        int[] a = new int[7];
        int[] b = new int[7];
        int[] same = new int[7];
        for (int i = 0; i < tops.length; i++) {
            a[tops[i]]++;
            b[bottoms[i]]++;
            if (tops[i] == bottoms[i]) {
                same[tops[i]]++;
            }
        }
        for (int i = 1; i <= 6; i++) {
            if (a[i] + b[i] - same[i] == tops.length) {
                return Math.min(a[i], b[i]) - same[i];
            }
        }
        return -1;

=======

        int n = tops.length;
        int[] topCount = new int[7];
        int[] bottomCount = new int[7];
        int[] sameCount = new int[7];
        for (int i = 0; i < n; i++) {
            topCount[tops[i]]++;
            bottomCount[bottoms[i]]++;
            if (tops[i] == bottoms[i]) {
                sameCount[tops[i]]++;
            }
        }
        for (int i = 1; i <= 6; i++) {
            if (topCount[i] + bottomCount[i] - sameCount[i] == n) {
                return n - Math.max(topCount[i], bottomCount[i]);
            }
        }
        return -1;

=======

        int n = tops.length;
        int[] topCount = new int[7];
        int[] bottomCount = new int[7];
        int[] sameCount = new int[7];
        for (int i = 0; i < n; i++) {
            topCount[tops[i]]++;
            bottomCount[bottoms[i]]++;
            if (tops[i] == bottoms[i]) {
                sameCount[tops[i]]++;
            }
        }
        int min = Integer.MAX_VALUE;
        for (int i = 1; i <= 6; i++) {
            if (topCount[i] + bottomCount[i] - sameCount[i] == n) {
                min = Math.min(min, Math.min(topCount[i], bottomCount[i]) - sameCount[i]);
            }
        }
        return min == Integer.MAX_VALUE ? -1 : min;

=======

        int n = tops.length;
        int[] topCount = new int[7];
        int[] bottomCount = new int[7];
        int[] same = new int[7];
        for (int i = 0; i < n; i++) {
            topCount[tops[i]]++;
            bottomCount[bottoms[i]]++;
            if (tops[i] == bottoms[i])
                same[tops[i]]++;
        }
        for (int i = 1; i <= 6; i++) {
            if (topCount[i] + bottomCount[i] - same[i] == n) {
                return n - Math.max(topCount[i], bottomCount[i]);
            }
        }
        return -1;

=======

        int[] cnt = new int[7];
        int[] top = new int[7];
        int[] bottom = new int[7];
        for (int i = 0; i < tops.length; i++) {
            cnt[tops[i]]++;
            cnt[bottoms[i]]++;
            top[tops[i]]++;
            bottom[bottoms[i]]++;
        }
        int min = Integer.MAX_VALUE;
        for (int i = 1; i < 7; i++) {
            if (cnt[i] == tops.length) {
                min = Math.min(min, Math.min(tops.length - top[i], tops.length - bottom[i]));
            }
        }
        return min == Integer.MAX_VALUE ? -1 : min;

=======

        int n = tops.length;
        int[] topCount = new int[7];
        int[] bottomCount = new int[7];
        int[] topBottom = new int[7];
        for (int i = 0; i < n; i++) {
            topCount[tops[i]]++;
            bottomCount[bottoms[i]]++;
            if (tops[i] == bottoms[i]) {
                topBottom[tops[i]]++;
            }
        }
        for (int i = 1; i <= 6; i++) {
            if (topCount[i] + bottomCount[i] - topBottom[i] == n) {
                return n - Math.max(topCount[i], bottomCount[i]);
            }
        }
        return -1;
