Synthesizing 10/10 solutions

=======

        int n = position.length;
        int[][] cars = new int[n][2];
        for (int i = 0; i < n; i++) {
            cars[i][0] = position[i];
            cars[i][1] = speed[i];
        }
        Arrays.sort(cars, (a, b) -> a[0] - b[0]);
        int res = 0;
        double cur = 0;
        for (int i = n - 1; i >= 0; i--) {
            double time = (target - cars[i][0]) * 1.0 / cars[i][1];
            if (time > cur) {
                res++;
                cur = time;
            }
        }
        return res;

=======

        int n = position.length;
        int[][] arr = new int[n][2];
        for (int i = 0; i < n; i++) {
            arr[i][0] = position[i];
            arr[i][1] = speed[i];
        }
        Arrays.sort(arr, new Comparator<int[]>() {
            @Override
            public int compare(int[] a, int[] b) {
                return b[0] - a[0];
            }
        });
        int res = 0;
        double cur = 0;
        for (int i = 0; i < n; i++) {
            double time = (double) (target - arr[i][0]) / arr[i][1];
            if (time > cur) {
                res++;
                cur = time;
            }
        }
        return res;

=======

        int n = position.length;
        if (n == 0) return 0;
        int[][] cars = new int[n][2];
        for (int i = 0; i < n; i++) {
            cars[i][0] = position[i];
            cars[i][1] = speed[i];
        }
        Arrays.sort(cars, (a, b) -> b[0] - a[0]);
        int res = 1;
        double time = (double)(target - cars[0][0]) / cars[0][1];
        for (int i = 1; i < n; i++) {
            double t = (double)(target - cars[i][0]) / cars[i][1];
            if (t > time) {
                res++;
                time = t;
            }
        }
        return res;

=======

        int n = position.length;
        if (n == 1) return 1;
        int[][] cars = new int[n][2];
        for (int i = 0; i < n; i++) {
            cars[i][0] = position[i];
            cars[i][1] = speed[i];
        }
        Arrays.sort(cars, (a, b) -> b[0] - a[0]);
        double time = (target - cars[0][0]) / (double)cars[0][1];
        int fleets = 1;
        for (int i = 1; i < n; i++) {
            double t = (target - cars[i][0]) / (double)cars[i][1];
            if (t > time) {
                fleets++;
                time = t;
            }
        }
        return fleets;

=======

        int n = position.length;
        if (n == 1) return 1;
        double[][] cars = new double[n][2];
        for (int i = 0; i < n; i++) {
            cars[i][0] = position[i];
            cars[i][1] = (target - position[i]) / (double) speed[i];
        }
        Arrays.sort(cars, (a, b) -> Double.compare(b[0], a[0]));
        int ans = 1;
        double curTime = cars[0][1];
        for (int i = 1; i < n; i++) {
            if (cars[i][1] > curTime) {
                ans++;
                curTime = cars[i][1];
            }
        }
        return ans;

=======

        if (position.length == 0) {
            return 0;
        }
        int[] time = new int[position.length];
        for (int i = 0; i < position.length; i++) {
            time[i] = (target - position[i]) / speed[i];
        }
        int ans = 1;
        int maxTime = time[0];
        for (int i = 1; i < time.length; i++) {
            if (time[i] > maxTime) {
                ans++;
                maxTime = time[i];
            }
        }
        return ans;

=======

        int n = position.length;
        int res = 0;
        double[] time = new double[target + 1];
        for (int i = 0; i < n; i++) {
            time[position[i]] = (double)(target - position[i]) / speed[i];
        }
        double cur = 0;
        for (int i = target; i >= 0; i--) {
            if (time[i] > cur) {
                cur = time[i];
                res++;
            }
        }
        return res;

=======

        if (position.length == 0) return 0;
        int res = 0;
        double time = 0;
        Map<Integer, Double> map = new HashMap<>();
        for (int i = 0; i < position.length; i++) {
            map.put(position[i], (double) (target - position[i]) / speed[i]);
        }
        Arrays.sort(position);
        for (int i = position.length - 1; i >= 0; i--) {
            if (map.get(position[i]) > time) {
                res++;
                time = map.get(position[i]);
            }
        }
        return res;

=======

        // int[] posSpeed = new int[position.length];
        // for (int i = 0; i < position.length; i++) {
        //     posSpeed[i] = position[i] * 1000000 + speed[i];
        // }
        // Arrays.sort(posSpeed);
        // int fleetCount = 0;
        // double lastFleetTime = 0.0;
        // for (int i = 0; i < posSpeed.length; i++) {
        //     double time = (target - posSpeed[i] / 1000000) / (posSpeed[i] % 1000000);
        //     if (time > lastFleetTime) {
        //         fleetCount++;
        //         lastFleetTime = time;
        //     }
        // }
        // return fleetCount;
        int n = position.length;
        int[][] cars = new int[n][2];
        for (int i = 0; i < n; i++) {
            cars[i][0] = position[i];
            cars[i][1] = speed[i];
        }
        Arrays.sort(cars, new Comparator<int[]>() {
            @Override
            public int compare(int[] car1, int[] car2) {
                return car2[0] - car1[0];
            }
        });
        int ans = 0;
        double cur = 0;
        for (int[] car: cars) {
            double time = (double)(target - car[0]) / car[1];
            if (time > cur) {
                ans++;
                cur = time;
            }
        }
        return ans;

=======

        int n = position.length;
        int ans = 0;
        if (n == 0) return ans;
        if (n == 1) return 1;
        int[] pos = new int[n];
        int[] spd = new int[n];
        for (int i = 0; i < n; i++) {
            pos[i] = position[i];
            spd[i] = speed[i];
        }
        Arrays.sort(pos);
        double[] time = new double[n];
        for (int i = 0; i < n; i++) {
            time[i] = (double) (target - pos[i]) / spd[i];
        }
        int i = n - 1;
        while (i >= 0) {
            ans++;
            double max = time[i];
            while (i >= 0 && time[i] <= max) {
                i--;
            }
        }
        return ans;
