Synthesizing 10/10 solutions

=======

        long l = 0, r = (long) 1e15;
        while (l < r) {
            long m = (l + r) / 2;
            long trips = 0;
            for (int t : time) {
                trips += m / t;
                if (trips >= totalTrips) {
                    break;
                }
            }
            if (trips >= totalTrips) {
                r = m;
            } else {
                l = m + 1;
            }
        }
        return l;

=======

        long l = 0, r = (long)1e18;
        while (l < r) {
            long m = (l + r) / 2;
            long sum = 0;
            for (int i = 0; i < time.length; i++) {
                sum += m / time[i];
            }
            if (sum < totalTrips) {
                l = m + 1;
            } else {
                r = m;
            }
        }
        return l;

=======

        long l = 1;
        long r = (long)1e9;
        while (l < r) {
            long m = (l + r) / 2;
            long trips = 0;
            for (int t : time) {
                trips += m / t;
            }
            if (trips < totalTrips) {
                l = m + 1;
            } else {
                r = m;
            }
        }
        return l;

=======

        long left = 0;
        long right = (long)1e17;
        long ans = 0;
        while (left <= right) {
            long mid = left + (right - left) / 2;
            long cnt = 0;
            for (int i = 0; i < time.length; i++) {
                cnt += mid / time[i];
            }
            if (cnt >= totalTrips) {
                ans = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return ans;

=======

        long low = 0;
        long high = 1000000000000000000L;
        while (low < high) {
            long mid = low + (high - low) / 2;
            long trips = 0;
            for (int t : time) {
                trips += mid / t;
            }
            if (trips < totalTrips) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;

=======

        long min = 1;
        long max = (long)totalTrips * (long)time[0];
        while (min < max) {
            long mid = min + (max - min) / 2;
            long trips = 0;
            for (int i = 0; i < time.length; i++) {
                trips += mid / time[i];
            }
            if (trips >= totalTrips) {
                max = mid;
            }
            else {
                min = mid + 1;
            }
        }
        return min;

=======

        long l = 1;
        long r = (long)totalTrips * 10000000;
        while (l < r) {
            long m = (l + r) / 2;
            long count = 0;
            for (int t: time) {
                count += m / t;
            }
            if (count < totalTrips) {
                l = m + 1;
            } else {
                r = m;
            }
        }
        return l;

=======

        long left = 0;
        long right = (long) 1e18;
        while (left < right) {
            long mid = (left + right) >>> 1;
            if (count(time, mid) >= totalTrips) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }

    private long count(int[] time, long t) {
        long ans = 0;
        for (int i = 0; i < time.length; i++) {
            ans += (t / time[i]);
        }
        return ans;

=======

        long min = 0;
        long max = 1000000000000000000L;
        while (min < max) {
            long mid = min + (max - min) / 2;
            long sum = 0;
            for (int i = 0; i < time.length; i++) {
                sum += mid / time[i];
            }
            if (sum >= totalTrips) {
                max = mid;
            } else {
                min = mid + 1;
            }
        }
        return min;

=======

        long l = 0, r = 1L * totalTrips * 1000000000;
        while (l < r) {
            long m = (l + r) >> 1;
            if (check(time, m, totalTrips)) {
                r = m;
            } else {
                l = m + 1;
            }
        }
        return l;
    }
    
    boolean check(int[] time, long t, int totalTrips) {
        long trips = 0;
        for (int i = 0; i < time.length; i++) {
            trips += t / time[i];
        }
        return trips >= totalTrips;
