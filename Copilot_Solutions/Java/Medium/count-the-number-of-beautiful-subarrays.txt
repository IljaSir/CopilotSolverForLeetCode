Synthesizing 10/10 solutions

=======

        int n = nums.length;
        int[] odd = new int[n + 2];
        int cnt = 0;
        for (int i = 0; i < n; i++) {
            if (nums[i] % 2 == 1) {
                odd[++cnt] = i;
            }
        }
        odd[0] = -1;
        odd[cnt + 1] = n;
        long ans = 0;
        for (int i = 1; i <= cnt; i++) {
            ans += (long) (odd[i] - odd[i - 1]) * (odd[i + 1] - odd[i]);
        }
        return ans;

=======

        long count = 0;
        for(int i = 0; i < nums.length; i++){
            int odd = 0;
            for(int j = i; j < nums.length; j++){
                if(nums[j] % 2 == 1){
                    odd++;
                }
                if(odd % 2 == 1){
                    count++;
                }
            }
        }
        return count;

=======

        int len = nums.length;
        int[] odd = new int[len + 2];
        int count = 0;
        for (int i = 0; i < len; i++) {
            if (nums[i] % 2 == 1) {
                odd[++count] = i;
            }
        }
        odd[0] = -1;
        odd[count + 1] = len;
        long ans = 0;
        for (int i = 1; i <= count; i++) {
            ans += (long) (odd[i] - odd[i - 1]) * (odd[i + 1] - odd[i]);
        }
        return ans;

=======

        long res = 0;
        int[] odd = new int[nums.length + 2];
        int cnt = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] % 2 == 1) {
                odd[++cnt] = i;
            }
        }
        odd[0] = -1;
        odd[cnt + 1] = nums.length;
        for (int i = 1; i <= cnt; i++) {
            res += (long)(odd[i] - odd[i - 1]) * (odd[i + 1] - odd[i]);
        }
        return res;

=======

        int n = nums.length;
        int[] pre = new int[n + 1];
        pre[0] = 1;
        int odd = 0;
        long ans = 0;
        for (int i = 0; i < n; ++i) {
            odd += nums[i] & 1;
            ans += pre[odd];
            pre[odd]++;
        }
        return ans;

=======

        return atMost(nums, 1) - atMost(nums, 0);
    }
    private long atMost(int[] nums, int k) {
        long res = 0;
        int i = 0;
        for (int j = 0; j < nums.length; j++) {
            k -= nums[j] % 2;
            while (k < 0) {
                k += nums[i++] % 2;
            }
            res += j - i + 1;
        }
        return res;
    }
}

=======

        int n = nums.length;
        int[] even = new int[n];
        int[] odd = new int[n];
        for (int i = 0; i < n; i++) {
            if (nums[i] % 2 == 0) {
                even[i] = i > 0 ? even[i - 1] + 1 : 1;
                odd[i] = i > 0 ? odd[i - 1] : 0;
            } else {
                odd[i] = i > 0 ? even[i - 1] + 1 : 1;
                even[i] = i > 0 ? odd[i - 1] : 0;
            }
        }
        long ans = 0;
        for (int i = 0; i < n; i++) {
            ans += odd[i];
        }
        return ans;

=======

        int n = nums.length;
        int[] even = new int[n + 1];
        int[] odd = new int[n + 1];
        int cur = 0;
        for (int i = 0; i < n; i++) {
            if (nums[i] % 2 == 0) {
                even[cur]++;
            } else {
                odd[cur]++;
                cur++;
            }
        }
        long ans = 0;
        for (int i = 0; i <= cur; i++) {
            ans += (long) even[i] * odd[i];
        }
        return ans;

=======

        return count(nums, 1) - count(nums, 0);
    }
    private long count(int[] nums, int k) {
        int n = nums.length;
        long res = 0;
        int count = 0;
        for (int l = 0, r = 0; r < n; r++) {
            count += nums[r] & 1;
            while (count > k) {
                count -= nums[l++] & 1;
            }
            res += r - l + 1;
        }
        return res;

=======

        int n = nums.length;
        int[] odd = new int[n + 1];
        int sum = 0;
        for (int i = 0; i < n; i++) {
            sum = sum + (nums[i] & 1);
            odd[sum]++;
        }
        long ans = 0;
        for (int i = 0; i <= n; i++) {
            ans += (long)odd[i] * (odd[i] - 1) / 2;
        }
        return ans;
