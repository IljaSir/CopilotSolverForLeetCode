Synthesizing 10/10 solutions

=======

        int[][] graph = new int[n][n];
        for (int i = 0; i < n; i++) {
            Arrays.fill(graph[i], Integer.MAX_VALUE);
            graph[i][i] = 0;
        }
        for (int[] road : roads) {
            int a = road[0] - 1;
            int b = road[1] - 1;
            graph[a][b] = road[2];
            graph[b][a] = road[2];
        }
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (graph[i][k] != Integer.MAX_VALUE && graph[k][j] != Integer.MAX_VALUE) {
                        graph[i][j] = Math.min(graph[i][j], Math.max(graph[i][k], graph[k][j]));
                    }
                }
            }
        }
        return graph[0][n - 1];

=======

        int[][] dist = new int[n+1][n+1];
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                dist[i][j] = 100000000;
            }
        }
        for (int[] road : roads) {
            dist[road[0]][road[1]] = road[2];
            dist[road[1]][road[0]] = road[2];
        }
        for (int i = 1; i <= n; i++) {
            dist[i][i] = 0;
        }
        for (int k = 1; k <= n; k++) {
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= n; j++) {
                    if (dist[i][j] > dist[i][k] + dist[k][j]) {
                        dist[i][j] = dist[i][k] + dist[k][j];
                    }
                }
            }
        }
        int[] dp = new int[n+1];
        Arrays.fill(dp, 100000000);
        dp[1] = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (dist[i][j] < 100000000) {
                    dp[j] = Math.min(dp[j], Math.max(dp[i], dist[i][j]));
                }
            }
        }
        return dp[n];

=======

        int[][] graph = new int[n + 1][n + 1];
        for (int i = 0; i < n + 1; i++) {
            Arrays.fill(graph[i], Integer.MAX_VALUE);
        }
        for (int[] r : roads) {
            graph[r[0]][r[1]] = Math.min(graph[r[0]][r[1]], r[2]);
            graph[r[1]][r[0]] = Math.min(graph[r[1]][r[0]], r[2]);
        }
        for (int i = 1; i <= n; i++) {
            graph[i][i] = 0;
        }
        for (int k = 1; k <= n; k++) {
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= n; j++) {
                    if (graph[i][k] == Integer.MAX_VALUE || graph[k][j] == Integer.MAX_VALUE) {
                        continue;
                    }
                    graph[i][j] = Math.min(graph[i][j], Math.max(graph[i][k], graph[k][j]));
                }
            }
        }
        return graph[1][n];

=======

        int[][] map = new int[n][n];
        for (int i = 0; i < roads.length; i++) {
            int a = roads[i][0] - 1;
            int b = roads[i][1] - 1;
            int d = roads[i][2];
            map[a][b] = map[b][a] = d;
        }
        int[] dp = new int[n];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        boolean[] visited = new boolean[n];
        visited[0] = true;
        for (int i = 0; i < n; i++) {
            int min = Integer.MAX_VALUE;
            int minIndex = 0;
            for (int j = 0; j < n; j++) {
                if (!visited[j] && dp[j] < min) {
                    min = dp[j];
                    minIndex = j;
                }
            }
            visited[minIndex] = true;
            if (minIndex == n - 1) {
                break;
            }
            for (int j = 0; j < n; j++) {
                if (map[minIndex][j] != 0) {
                    dp[j] = Math.min(dp[j], Math.min(dp[minIndex], map[minIndex][j]));
                }
            }
        }
        return dp[n - 1];

=======

        int m = roads.length;
        int[][] dist = new int[n][n];
        for (int i = 0; i < n; i++) {
            Arrays.fill(dist[i], Integer.MAX_VALUE);
            dist[i][i] = 0;
        }
        for (int i = 0; i < m; i++) {
            int u = roads[i][0] - 1;
            int v = roads[i][1] - 1;
            int w = roads[i][2];
            dist[u][v] = w;
            dist[v][u] = w;
        }
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (dist[i][k] != Integer.MAX_VALUE && dist[k][j] != Integer.MAX_VALUE) {
                        dist[i][j] = Math.min(dist[i][j], Math.max(dist[i][k], dist[k][j]));
                    }
                }
            }
        }
        return dist[0][n - 1];

=======

        int[][] graph = new int[n][n];
        for (int[] r : roads) {
            int u = r[0] - 1;
            int v = r[1] - 1;
            int w = r[2];
            graph[u][v] = graph[v][u] = w;
        }
        int[] dist = new int[n];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[0] = 0;
        boolean[] visited = new boolean[n];
        for (int i = 0; i < n; i++) {
            int u = -1;
            for (int j = 0; j < n; j++) {
                if (!visited[j] && (u == -1 || dist[j] < dist[u])) {
                    u = j;
                }
            }
            visited[u] = true;
            for (int v = 0; v < n; v++) {
                if (graph[u][v] > 0) {
                    dist[v] = Math.min(dist[v], Math.max(dist[u], graph[u][v]));
                }
            }
        }
        return dist[n - 1];

=======

        int[][] dp = new int[n][n];
        for (int[] row : dp) {
            Arrays.fill(row, Integer.MAX_VALUE);
        }
        for (int[] road : roads) {
            int i = road[0] - 1;
            int j = road[1] - 1;
            dp[i][j] = road[2];
            dp[j][i] = road[2];
        }
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (dp[i][k] == Integer.MAX_VALUE || dp[k][j] == Integer.MAX_VALUE) {
                        continue;
                    }
                    dp[i][j] = Math.min(dp[i][j], Math.max(dp[i][k], dp[k][j]));
                }
            }
        }
        return dp[0][n - 1];

=======

        Map<Integer, List<int[]>> graph = new HashMap<>();
        for (int i = 0; i < roads.length; i++) {
            int[] road = roads[i];
            List<int[]> list = graph.getOrDefault(road[0], new ArrayList<>());
            list.add(new int[]{road[1], road[2]});
            graph.put(road[0], list);
            list = graph.getOrDefault(road[1], new ArrayList<>());
            list.add(new int[]{road[0], road[2]});
            graph.put(road[1], list);
        }
        int[][] dist = new int[n + 1][n + 1];
        for (int i = 1; i <= n; i++) {
            Arrays.fill(dist[i], Integer.MAX_VALUE);
        }
        for (int i = 1; i <= n; i++) {
            dist[i][i] = 0;
            Queue<int[]> queue = new LinkedList<>();
            queue.offer(new int[]{i, 0});
            while (!queue.isEmpty()) {
                int[] node = queue.poll();
                int u = node[0];
                int d = node[1];
                for (int[] edge : graph.getOrDefault(u, new ArrayList<>())) {
                    int v = edge[0];
                    int w = edge[1];
                    if (d + w < dist[i][v]) {
                        dist[i][v] = d + w;
                        queue.offer(new int[]{v, dist[i][v]});
                    }
                }
            }
        }
        int[][] dp = new int[n + 1][n + 1];
        for (int i = 1; i <= n; i++) {
            Arrays.fill(dp[i], Integer.MAX_VALUE);
        }
        dp[1][1] = 0;
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j < i; j++) {
                for (int k = j; k < i; k++) {
                    dp[i][j] = Math.min(dp[i][j], Math.max(dp[k][j], dist[k + 1][i]));
                }
            }
        }
        int ans = Integer.MAX_VALUE;
        for (int i = 1; i < n; i++) {
            ans = Math.min(ans, dp[n][i]);
        }
        return

=======

        int[][] distance = new int[n+1][n+1];
        for(int i=0; i<n+1; i++) {
            for(int j=0; j<n+1; j++) {
                distance[i][j] = Integer.MAX_VALUE;
            }
        }
        for(int i=0; i<roads.length; i++) {
            distance[roads[i][0]][roads[i][1]] = Math.min(distance[roads[i][0]][roads[i][1]], roads[i][2]);
            distance[roads[i][1]][roads[i][0]] = Math.min(distance[roads[i][1]][roads[i][0]], roads[i][2]);
        }
        for(int i=1; i<n+1; i++) {
            distance[i][i] = 0;
        }
        for(int k=1; k<n+1; k++) {
            for(int i=1; i<n+1; i++) {
                for(int j=1; j<n+1; j++) {
                    if(distance[i][k] != Integer.MAX_VALUE && distance[k][j] != Integer.MAX_VALUE) {
                        distance[i][j] = Math.min(distance[i][j], Math.max(distance[i][k], distance[k][j]));
                    }
                }
            }
        }
        return distance[1][n];

=======

        // Dijkstra's Algorithm
        // O(n + mlogn) time complexity, O(n + m) space complexity
        Map<Integer, Map<Integer, Integer>> graph = new HashMap<>();
        for (int[] road : roads) {
            graph.putIfAbsent(road[0], new HashMap<>());
            graph.putIfAbsent(road[1], new HashMap<>());
            graph.get(road[0]).put(road[1], road[2]);
            graph.get(road[1]).put(road[0], road[2]);
        }
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);
        pq.offer(new int[]{1, 0});
        Map<Integer, Integer> dist = new HashMap<>();
        while (!pq.isEmpty()) {
            int[] curr = pq.poll();
            if (dist.containsKey(curr[0])) {
                continue;
            }
            dist.put(curr[0], curr[1]);
            if (curr[0] == n) {
                break;
            }
            for (Map.Entry<Integer, Integer> neighbor : graph.getOrDefault(curr[0], new HashMap<>()).entrySet()) {
                if (!dist.containsKey(neighbor.getKey())) {
                    pq.offer(new int[]{neighbor.getKey(), Math.max(curr[1], neighbor.getValue())});
                }
            }
        }
        return dist.get(n);
