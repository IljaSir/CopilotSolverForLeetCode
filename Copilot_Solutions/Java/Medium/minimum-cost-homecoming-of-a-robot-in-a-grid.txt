Synthesizing 10/10 solutions

=======

        int m = rowCosts.length;
        int n = colCosts.length;
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = Integer.MAX_VALUE;
            }
        }
        dp[startPos[0]][startPos[1]] = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        pq.offer(new int[]{startPos[0], startPos[1], 0});
        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            int x = cur[0];
            int y = cur[1];
            int cost = cur[2];
            if (x == homePos[0] && y == homePos[1]) {
                return cost;
            }
            if (dp[x][y] != cost) {
                continue;
            }
            if (x > 0) {
                int nextX = x - 1;
                int nextY = y;
                int nextCost = cost + rowCosts[nextX];
                if (dp[nextX][nextY] > nextCost) {
                    dp[nextX][nextY] = nextCost;
                    pq.offer(new int[]{nextX, nextY, nextCost});
                }
            }
            if (x < m - 1) {
                int nextX = x + 1;
                int nextY = y;
                int nextCost = cost + rowCosts[nextX];
                if (dp[nextX][nextY] > nextCost) {
                    dp[nextX][nextY] = nextCost;
                    pq.offer(new int[]{nextX, nextY, nextCost});
                }
            }
            if (y > 0) {
                int nextX = x;
                int nextY = y - 1;
                int nextCost = cost + colCosts[nextY];
                if (dp[nextX][nextY] > nextCost) {
                    dp[nextX][nextY] = nextCost;
                    pq.offer(new int[]{nextX, nextY, nextCost});
                }
            }
            if (y < n - 1) {
                int nextX = x;
                int nextY = y + 1

=======

        int m = rowCosts.length;
        int n = colCosts.length;
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = Integer.MAX_VALUE;
            }
        }
        dp[startPos[0]][startPos[1]] = 0;
        for (int i = startPos[0]; i < m; i++) {
            for (int j = startPos[1]; j < n; j++) {
                if (i == startPos[0] && j == startPos[1]) {
                    continue;
                }
                if (i > 0) {
                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + rowCosts[i]);
                }
                if (j > 0) {
                    dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + colCosts[j]);
                }
            }
        }
        return dp[homePos[0]][homePos[1]];

=======

        int m = rowCosts.length;
        int n = colCosts.length;
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = Integer.MAX_VALUE;
            }
        }
        dp[startPos[0]][startPos[1]] = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        pq.offer(new int[] {0, startPos[0], startPos[1]});
        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            int x = cur[1];
            int y = cur[2];
            if (x == homePos[0] && y == homePos[1]) {
                return cur[0];
            }
            if (x + 1 < m) {
                if (dp[x + 1][y] > dp[x][y] + rowCosts[x + 1]) {
                    dp[x + 1][y] = dp[x][y] + rowCosts[x + 1];
                    pq.offer(new int[] {dp[x + 1][y], x + 1, y});
                }
            }
            if (x - 1 >= 0) {
                if (dp[x - 1][y] > dp[x][y] + rowCosts[x]) {
                    dp[x - 1][y] = dp[x][y] + rowCosts[x];
                    pq.offer(new int[] {dp[x - 1][y], x - 1, y});
                }
            }
            if (y + 1 < n) {
                if (dp[x][y + 1] > dp[x][y] + colCosts[y + 1]) {
                    dp[x][y + 1] = dp[x][y] + colCosts[y + 1];
                    pq.offer(new int[] {dp[x][y + 1], x, y + 1});
                }
            }
            if (y - 1 >= 0) {
                if (dp[x][y - 1] > dp[x][y] + colCosts[y]) {
                    dp[x][y - 1] = dp[x][

=======

        int m = rowCosts.length;
        int n = colCosts.length;
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = Integer.MAX_VALUE;
            }
        }
        dp[startPos[0]][startPos[1]] = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        pq.offer(new int[] {startPos[0], startPos[1], 0});
        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            int x = cur[0];
            int y = cur[1];
            if (x == homePos[0] && y == homePos[1]) {
                return dp[x][y];
            }
            for (int[] dir : dirs) {
                int nx = x + dir[0];
                int ny = y + dir[1];
                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {
                    int cost = dp[x][y];
                    if (dir[0] == 0) {
                        cost += colCosts[ny];
                    } else {
                        cost += rowCosts[nx];
                    }
                    if (dp[nx][ny] > cost) {
                        dp[nx][ny] = cost;
                        pq.offer(new int[] {nx, ny, cost});
                    }
                }
            }
        }
        return -1;

=======

        int m = rowCosts.length;
        int n = colCosts.length;
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = Integer.MAX_VALUE;
            }
        }
        dp[startPos[0]][startPos[1]] = 0;
        int[] dx = new int[]{-1, 0, 1, 0};
        int[] dy = new int[]{0, 1, 0, -1};
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < 4; k++) {
                    int x = i + dx[k];
                    int y = j + dy[k];
                    if (x >= 0 && x < m && y >= 0 && y < n) {
                        if (k < 2) {
                            dp[x][y] = Math.min(dp[x][y], dp[i][j] + rowCosts[x]);
                        } else {
                            dp[x][y] = Math.min(dp[x][y], dp[i][j] + colCosts[y]);
                        }
                    }
                }
            }
        }
        return dp[homePos[0]][homePos[1]];

=======

        int m = rowCosts.length;
        int n = colCosts.length;
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = Integer.MAX_VALUE;
            }
        }
        dp[startPos[0]][startPos[1]] = 0;
        for (int i = 0; i <= m; i++) {
            for (int j = 0; j <= n; j++) {
                if (i < m) {
                    dp[i][j] = Math.min(dp[i][j], dp[i][j] + rowCosts[i]);
                }
                if (j < n) {
                    dp[i][j] = Math.min(dp[i][j], dp[i][j] + colCosts[j]);
                }
            }
        }
        return dp[homePos[0]][homePos[1]];

=======

        int m = rowCosts.length;
        int n = colCosts.length;
        int[][] cost = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                cost[i][j] = Integer.MAX_VALUE;
            }
        }
        cost[startPos[0]][startPos[1]] = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        pq.offer(new int[]{startPos[0], startPos[1], 0});
        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            int x = cur[0];
            int y = cur[1];
            int c = cur[2];
            if (x == homePos[0] && y == homePos[1]) {
                return c;
            }
            if (x > 0) {
                int tmp = cost[x - 1][y] + rowCosts[x];
                if (tmp < cost[x][y]) {
                    cost[x][y] = tmp;
                    pq.offer(new int[]{x - 1, y, tmp});
                }
            }
            if (x < m - 1) {
                int tmp = cost[x + 1][y] + rowCosts[x + 1];
                if (tmp < cost[x][y]) {
                    cost[x][y] = tmp;
                    pq.offer(new int[]{x + 1, y, tmp});
                }
            }
            if (y > 0) {
                int tmp = cost[x][y - 1] + colCosts[y];
                if (tmp < cost[x][y]) {
                    cost[x][y] = tmp;
                    pq.offer(new int[]{x, y - 1, tmp});
                }
            }
            if (y < n - 1) {
                int tmp = cost[x][y + 1] + colCosts[y + 1];
                if (tmp < cost[x][y]) {
                    cost[x][y] = tmp;
                    pq.offer(new int[]{x, y + 1, tmp});
                }
            }
        }
        return -1;

=======

        int row = rowCosts.length;
        int col = colCosts.length;
        int[][] dp = new int[row][col];
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (i == 0 && j == 0) {
                    dp[i][j] = 0;
                } else if (i == 0) {
                    dp[i][j] = dp[i][j - 1] + colCosts[j];
                } else if (j == 0) {
                    dp[i][j] = dp[i - 1][j] + rowCosts[i];
                } else {
                    dp[i][j] = Math.min(dp[i - 1][j] + rowCosts[i], dp[i][j - 1] + colCosts[j]);
                }
            }
        }
        return dp[row - 1][col - 1];

=======

        int m = rowCosts.length, n = colCosts.length;
        int[][] dp = new int[m][n];
        int[][] cost = new int[m][n];
        dp[startPos[0]][startPos[1]] = 1;
        cost[startPos[0]][startPos[1]] = 0;
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(startPos);
        while (!queue.isEmpty()) {
            int[] cur = queue.poll();
            int x = cur[0], y = cur[1];
            if (x > 0 && dp[x - 1][y] == 0) {
                dp[x - 1][y] = 1;
                cost[x - 1][y] = cost[x][y] + rowCosts[x - 1];
                queue.offer(new int[] {x - 1, y});
            }
            if (x < m - 1 && dp[x + 1][y] == 0) {
                dp[x + 1][y] = 1;
                cost[x + 1][y] = cost[x][y] + rowCosts[x];
                queue.offer(new int[] {x + 1, y});
            }
            if (y > 0 && dp[x][y - 1] == 0) {
                dp[x][y - 1] = 1;
                cost[x][y - 1] = cost[x][y] + colCosts[y - 1];
                queue.offer(new int[] {x, y - 1});
            }
            if (y < n - 1 && dp[x][y + 1] == 0) {
                dp[x][y + 1] = 1;
                cost[x][y + 1] = cost[x][y] + colCosts[y];
                queue.offer(new int[] {x, y + 1});
            }
        }
        return cost[homePos[0]][homePos[1]];

=======

        return 0;
