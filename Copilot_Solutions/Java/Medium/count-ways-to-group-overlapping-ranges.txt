Synthesizing 6/10 solutions

=======

        int MOD = 1000000007;
        int n = ranges.length;
        int[] start = new int[n];
        int[] end = new int[n];
        for (int i = 0; i < n; i++) {
            start[i] = ranges[i][0];
            end[i] = ranges[i][1];
        }
        Arrays.sort(start);
        Arrays.sort(end);
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            dp[i] = (int) ((2L * dp[i - 1] - dp[binarySearch(end, start[i - 1]) - 1] + MOD) % MOD);
        }
        return dp[n];
    }

    private int binarySearch(int[] end, int target) {
        int l = 0, r = end.length;
        while (l < r) {
            int mid = (l + r) / 2;
            if (end[mid] >= target) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return l;

=======

        int n = ranges.length;
        int[] left = new int[n];
        int[] right = new int[n];
        for(int i = 0; i < n; i++){
            left[i] = ranges[i][0];
            right[i] = ranges[i][1];
        }
        Arrays.sort(left);
        Arrays.sort(right);
        int count = 0;
        int i = 0;
        int j = 0;
        int overlap = 0;
        while(i < n && j < n){
            if(left[i] <= right[j]){
                overlap++;
                i++;
            }else{
                overlap--;
                j++;
            }
            if(overlap == 0){
                count++;
            }
        }
        return (int)(Math.pow(2, count) % (Math.pow(10, 9) + 7));

=======

        int mod = 1000000007;
        int n = ranges.length;
        Arrays.sort(ranges, (a, b) -> a[0] - b[0]);
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        int[] pre = new int[n];
        pre[0] = 1;
        for (int i = 1; i < n; i++) {
            pre[i] = (pre[i - 1] + dp[i]) % mod;
        }
        for (int i = 1; i < n; i++) {
            int l = 0, r = i - 1;
            while (l < r) {
                int mid = l + r + 1 >> 1;
                if (ranges[mid][1] < ranges[i][0]) {
                    l = mid;
                } else {
                    r = mid - 1;
                }
            }
            if (ranges[l][1] >= ranges[i][0]) {
                dp[i] = pre[l];
            } else {
                dp[i] = pre[l] + 1;
            }
            dp[i] %= mod;
            pre[i] = (pre[i - 1] + dp[i]) % mod;
        }
        return dp[n - 1];

=======

        int n = ranges.length;
        long MOD = 1000000007;
        int[] start = new int[n];
        int[] end = new int[n];
        for(int i = 0; i < n; i++){
            start[i] = ranges[i][0];
            end[i] = ranges[i][1];
        }
        Arrays.sort(start);
        Arrays.sort(end);
        long[] dp = new long[n+1];
        dp[0] = 1;
        int s = 0, e = 0;
        for(int i = 0; i < n; i++){
            while(s < n && start[s] <= end[i]) s++;
            while(e < n && end[e] < start[i]) e++;
            dp[i+1] = dp[i] * (s - e + 1) % MOD;
        }
        return (int)dp[n]-1;

=======

        
    }
}

=======

        return 0;
