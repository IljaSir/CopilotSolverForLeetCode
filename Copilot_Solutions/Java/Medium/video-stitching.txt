Synthesizing 10/10 solutions

=======

        int[] dp = new int[time + 1];
        Arrays.fill(dp, time + 1);
        dp[0] = 0;
        for (int i = 1; i <= time; i++) {
            for (int[] clip : clips) {
                if (clip[0] < i && i <= clip[1]) {
                    dp[i] = Math.min(dp[i], dp[clip[0]] + 1);
                }
            }
        }
        return dp[time] == time + 1 ? -1 : dp[time];

=======

        int[] dp = new int[time + 1];
        Arrays.fill(dp, Integer.MAX_VALUE - 1);
        dp[0] = 0;
        for (int i = 1; i <= time; i++) {
            for (int[] clip : clips) {
                if (clip[0] < i && i <= clip[1]) {
                    dp[i] = Math.min(dp[i], dp[clip[0]] + 1);
                }
            }
        }
        return dp[time] == Integer.MAX_VALUE - 1 ? -1 : dp[time];

=======

        int[] dp = new int[time + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for (int i = 1; i <= time; i++) {
            for (int[] clip : clips) {
                int start = clip[0];
                int end = clip[1];
                if (start < i && i <= end) {
                    if (dp[start] != Integer.MAX_VALUE) {
                        dp[i] = Math.min(dp[i], dp[start] + 1);
                    }
                }
            }
        }
        return dp[time] == Integer.MAX_VALUE ? -1 : dp[time];

=======

        int[] dp = new int[time + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for (int i = 0; i <= time; i++) {
            for (int[] clip : clips) {
                if (clip[0] <= i && i <= clip[1]) {
                    if (dp[clip[0]] != Integer.MAX_VALUE) {
                        dp[i] = Math.min(dp[i], dp[clip[0]] + 1);
                    }
                }
            }
        }
        return dp[time] == Integer.MAX_VALUE ? -1 : dp[time];

=======

        int[] dp = new int[time + 1];
        Arrays.fill(dp, 101);
        dp[0] = 0;
        for (int i = 0; i < time; i++) {
            for (int[] c : clips) {
                if (c[0] <= i && c[1] >= i + 1) {
                    dp[i + 1] = Math.min(dp[i + 1], dp[c[0]] + 1);
                }
            }
        }
        return dp[time] == 101 ? -1 : dp[time];

=======

        int[] dp = new int[101];
        Arrays.fill(dp, 101);
        dp[0] = 0;
        for (int i = 0; i < 101; i++) {
            for (int[] clip : clips) {
                if (clip[0] <= i && i <= clip[1]) {
                    dp[i] = Math.min(dp[i], dp[clip[0]] + 1);
                }
            }
        }
        return dp[time] == 101 ? -1 : dp[time];

=======

        int[] dp = new int[time];
        Arrays.fill(dp, time+1);
        dp[0] = 0;
        for (int i = 0; i < time; i++) {
            for (int[] clip : clips) {
                if (clip[0] <= i && i <= clip[1]) {
                    dp[i] = Math.min(dp[i], dp[clip[0]] + 1);
                }
            }
        }
        return dp[time-1] == time+1 ? -1 : dp[time-1];

=======

        Arrays.sort(clips, (a, b) -> a[0] - b[0]);
        int start = 0;
        int end = 0;
        int count = 0;
        int i = 0;
        while (start < time) {
            while (i < clips.length && clips[i][0] <= start) {
                end = Math.max(end, clips[i][1]);
                i++;
            }
            if (start == end) {
                return -1;
            }
            start = end;
            count++;
        }
        return count;

=======

        int[] dp = new int[time+1];
        Arrays.fill(dp, Integer.MAX_VALUE-1);
        dp[0] = 0;
        for(int i = 0; i < clips.length; i++) {
            for(int j = clips[i][0]; j <= clips[i][1]; j++) {
                if(j <= time) {
                    dp[j] = Math.min(dp[j], dp[clips[i][0]]+1);
                }
            }
        }
        return dp[time] == Integer.MAX_VALUE-1 ? -1 : dp[time];

=======

        // sort clips by start time
        Arrays.sort(clips, new Comparator<int[]>() {
            @Override
            public int compare(int[] a, int[] b) {
                return a[0] - b[0];
            }
        });
        // check if there is clip start at 0
        if (clips[0][0] != 0) {
            return -1;
        }
        // maxEnd is the max end time we can reach
        int maxEnd = 0;
        // maxEndNext is the max end time we can reach if we add one more clip
        int maxEndNext = 0;
        // ans is the number of clips we need
        int ans = 0;
        for (int i = 0; i < clips.length; i++) {
            // if the current clip's start time is greater than the max end time we can reach
            // we cannot reach the end
            if (clips[i][0] > maxEnd) {
                return -1;
            }
            // update maxEndNext
            maxEndNext = Math.max(maxEndNext, clips[i][1]);
            // if we have reached the end
            if (maxEnd >= time) {
                return ans;
            }
            // if we have reached the max end time we can reach
            if (i == clips.length - 1 || clips[i + 1][0] > maxEnd) {
                // we need to add one more clip
                ans++;
                // update maxEnd
                maxEnd = maxEndNext;
            }
        }
        // if we have reached the end
        if (maxEnd >= time) {
            return ans;
        }
        return -1;
