Synthesizing 10/10 solutions

=======

        int n = nums.length;
        int[] sum = new int[n + 1];
        for (int i = 0; i < n; i++) {
            sum[i + 1] = sum[i] + nums[i];
        }
        int[] count = new int[k];
        for (int i = 0; i <= n; i++) {
            count[(sum[i] % k + k) % k]++;
        }
        int ans = 0;
        for (int i = 0; i < k; i++) {
            ans += count[i] * (count[i] - 1) / 2;
        }
        return ans;

=======

        int n = nums.length;
        int[] sum = new int[n];
        sum[0] = nums[0];
        for (int i = 1; i < n; i++) {
            sum[i] = sum[i - 1] + nums[i];
        }
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);
        int ans = 0;
        for (int s : sum) {
            int mod = s % k;
            if (mod < 0) {
                mod += k;
            }
            ans += map.getOrDefault(mod, 0);
            map.put(mod, map.getOrDefault(mod, 0) + 1);
        }
        return ans;

=======

        int[] count = new int[k];
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            count[((sum % k) + k) % k]++;
        }
        int ans = 0;
        for (int i = 0; i < k; i++) {
            if (count[i] > 1) {
                ans += count[i] * (count[i] - 1) / 2;
            }
        }
        ans += count[0];
        return ans;

=======

        int[] mod = new int[k];
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            mod[((sum % k) + k) % k]++;
        }
        int res = 0;
        for (int i = 0; i < k; i++) {
            if (mod[i] > 1) {
                res += (mod[i] * (mod[i] - 1)) / 2;
            }
        }
        return res + mod[0];

=======

        int n = nums.length;
        int[] sums = new int[n+1];
        for (int i = 0; i < n; i++) {
            sums[i+1] = sums[i] + nums[i];
        }
        int[] counts = new int[k];
        for (int i = 0; i < n+1; i++) {
            counts[(sums[i] % k + k) % k]++;
        }
        int ans = 0;
        for (int i = 0; i < k; i++) {
            ans += counts[i] * (counts[i] - 1) / 2;
        }
        return ans;

=======

        int[] mods = new int[k];
        mods[0] = 1;
        int sum = 0;
        int result = 0;
        for (int num : nums) {
            sum += num;
            int mod = (sum % k + k) % k;
            result += mods[mod];
            mods[mod]++;
        }
        return result;

=======

        int[] map = new int[k];
        int sum = 0;
        int count = 0;
        map[0] = 1;
        for (int num : nums) {
            sum += num;
            int mod = (sum % k + k) % k;
            if (map[mod] > 0) {
                count += map[mod];
            }
            map[mod]++;
        }
        return count;

=======

        int n = nums.length;
        int[] sum = new int[n + 1];
        int ans = 0;
        for (int i = 1; i <= n; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i <= n; i++) {
            int mod = (sum[i] % k + k) % k;
            int cnt = map.getOrDefault(mod, 0);
            ans += cnt;
            map.put(mod, cnt + 1);
        }
        return ans;

=======

        int[] mod = new int[k];
        int sum = 0;
        for (int num : nums) {
            sum += num;
            mod[((sum % k) + k) % k]++;
        }
        int res = mod[0];
        for (int i : mod) res += i * (i - 1) / 2;
        return res;

=======

        int[] count = new int[k];
        int sum = 0;
        int ans = 0;
        for (int num : nums) {
            sum += num;
            int mod = (sum % k + k) % k;
            count[mod]++;
        }
        for (int i : count) {
            ans += i * (i - 1) / 2;
        }
        return ans;
