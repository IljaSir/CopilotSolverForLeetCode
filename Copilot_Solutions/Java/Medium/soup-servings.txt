Synthesizing 10/10 solutions

=======

        if (n > 4800) {
            return 1.0;
        }
        int N = (n + 24) / 25;
        double[][] dp = new double[N + 1][N + 1];
        dp[N][N] = 0.5;
        for (int i = N; i >= 0; i--) {
            for (int j = N; j >= 0; j--) {
                if (i == N && j == N) {
                    continue;
                }
                if (i == 0 && j == 0) {
                    continue;
                }
                dp[i][j] = 0.25 * (dp[Math.max(0, i - 4)][j] + dp[Math.max(0, i - 3)][Math.max(0, j - 1)] + dp[Math.max(0, i - 2)][Math.max(0, j - 2)] + dp[Math.max(0, i - 1)][Math.max(0, j - 3)]);
            }
        }
        return dp[0][0];

=======

        if (n >= 4800) {
            return 1.0;
        }
        int N = (n + 24) / 25;
        double[][] dp = new double[N + 1][N + 1];
        return helper(dp, N, N);
    }

    private double helper(double[][] dp, int A, int B) {
        if (A <= 0 && B <= 0) {
            return 0.5;
        }
        if (A <= 0) {
            return 1.0;
        }
        if (B <= 0) {
            return 0.0;
        }
        if (dp[A][B] > 0) {
            return dp[A][B];
        }
        dp[A][B] = 0.25 * (helper(dp, A - 4, B) + helper(dp, A - 3, B - 1) + helper(dp, A - 2, B - 2) + helper(dp, A - 1, B - 3));
        return dp[A][B];

=======

        if (n > 5000) {
            return 1.0;
        }
        int N = (n + 24) / 25;
        double[][] dp = new double[N + 1][N + 1];
        dp[0][0] = 0.5;
        for (int i = 0; i <= N; i++) {
            for (int j = 0; j <= N; j++) {
                int s = i + j;
                if (s > 0) {
                    dp[i][j] += 0.25 * (i >= 4 ? dp[i - 4][j] : (j >= 4 ? dp[i][j - 4] : 0.5));
                    dp[i][j] += 0.25 * (i >= 3 && j >= 1 ? dp[i - 3][j - 1] : (j >= 3 && i >= 1 ? dp[i - 1][j - 3] : 0.5));
                    dp[i][j] += 0.25 * (i >= 2 && j >= 2 ? dp[i - 2][j - 2] : (j >= 2 && i >= 2 ? dp[i - 2][j - 2] : 0.5));
                    dp[i][j] += 0.25 * (i >= 1 && j >= 3 ? dp[i - 1][j - 3] : (j >= 1 && i >= 3 ? dp[i - 3][j - 1] : 0.5));
                }
            }
        }
        return dp[N][N];

=======

        if (n > 4800) {
            return 1.0;
        }

        int N = (n + 24) / 25;
        double[][] dp = new double[N + 1][N + 1];
        dp[0][0] = 0.5;

        for (int i = 0; i <= N; i++) {
            for (int j = 0; j <= N; j++) {
                int sum = i + j;
                if (sum == 0) {
                    continue;
                }

                double p = 0.25;
                if (i >= 4) {
                    dp[i][j] += p * dp[i - 4][j];
                } else {
                    dp[i][j] += p * 0.5;
                }

                if (i >= 3 && j >= 1) {
                    dp[i][j] += p * dp[i - 3][j - 1];
                } else if (i >= 3) {
                    dp[i][j] += p * 0.5;
                } else if (j >= 1) {
                    dp[i][j] += p * 0.5;
                }

                if (i >= 2 && j >= 2) {
                    dp[i][j] += p * dp[i - 2][j - 2];
                } else if (i >= 2) {
                    dp[i][j] += p * 0.5;
                } else if (j >= 2) {
                    dp[i][j] += p * 0.5;
                }

                if (i >= 1 && j >= 3) {
                    dp[i][j] += p * dp[i - 1][j - 3];
                } else if (i >= 1) {
                    dp[i][j] += p * 0.5;
                } else if (j >= 3) {
                    dp[i][j] += p * 0.5;
                }
            }
        }

        return dp[N][N];

=======

        if (n > 4800) {
            return 1.0;
        }
        int N = (n + 24) / 25;
        double[][] dp = new double[N+1][N+1];
        return helper(dp, N, N);
    }

    public double helper(double[][] dp, int a, int b) {
        if (a <= 0 && b <= 0) {
            return 0.5;
        }
        if (a <= 0) {
            return 1.0;
        }
        if (b <= 0) {
            return 0.0;
        }
        if (dp[a][b] > 0) {
            return dp[a][b];
        }
        dp[a][b] = 0.25 * (helper(dp, a-4, b) + helper(dp, a-3, b-1) + helper(dp, a-2, b-2) + helper(dp, a-1, b-3));
        return dp[a][b];

=======

        if (n > 4800) return 1;
        int N = (n + 24) / 25;
        double[][] dp = new double[N + 1][N + 1];
        dp[0][0] = 0.5;
        for (int i = 0; i <= N; i++) {
            for (int j = 0; j <= N; j++) {
                int a = Math.max(i - 4, 0);
                int b = Math.max(j - 8, 0);
                dp[i][j] += 0.25 * dp[a][b];
                a = Math.max(i - 3, 0);
                b = Math.max(j - 6, 0);
                dp[i][j] += 0.25 * dp[a][b];
                a = Math.max(i - 2, 0);
                b = Math.max(j - 6, 0);
                dp[i][j] += 0.25 * dp[a][b];
                a = Math.max(i - 1, 0);
                b = Math.max(j - 4, 0);
                dp[i][j] += 0.25 * dp[a][b];
            }
        }
        return dp[N][N];

=======

        if (n > 4800) return 1;
        int N = (n + 24) / 25;
        double[][] dp = new double[N + 1][N + 1];
        dp[0][0] = 0.5;
        for (int i = 0; i <= N; i++) {
            for (int j = 0; j <= N; j++) {
                int a = Math.min(i + 4, N);
                int b = Math.min(j + 3, N);
                dp[a][b] += dp[i][j] / 4;
                a = Math.min(i + 3, N);
                b = Math.min(j + 4, N);
                dp[a][b] += dp[i][j] / 4;
                a = Math.min(i + 2, N);
                b = Math.min(j + 2, N);
                dp[a][b] += dp[i][j] / 4;
                a = Math.min(i + 1, N);
                b = Math.min(j + 3, N);
                dp[a][b] += dp[i][j] / 4;
            }
        }
        return dp[N][N];

=======

        if (n > 4800) {
            return 1.0;
        }
        int N = n / 25 + (n % 25 == 0 ? 0 : 1);
        double[][] dp = new double[N + 1][N + 1];
        return helper(dp, N, N);
    }
    
    private double helper(double[][] dp, int A, int B) {
        if (A <= 0 && B <= 0) {
            return 0.5;
        }
        if (A <= 0) {
            return 1.0;
        }
        if (B <= 0) {
            return 0.0;
        }
        if (dp[A][B] != 0.0) {
            return dp[A][B];
        }
        dp[A][B] = 0.25 * (helper(dp, A - 4, B) + helper(dp, A - 3, B - 1) + helper(dp, A - 2, B - 2) + helper(dp, A - 1, B - 3));
        return dp[A][B];

=======

        if (n >= 4800)
            return 1;
        double[][] dp = new double[200][200];
        dp[0][0] = 0.5;
        for (int i = 0; i < 200; i++) {
            for (int j = 0; j < 200; j++) {
                double p = 0.25;
                if (i == 0)
                    p = 0.5;
                if (i == 0 && j == 0)
                    p = 0.25;
                dp[i][j] += p * (i >= 100 ? dp[i - 100][j] : 1);
                dp[i][j] += p * (i >= 75 && j >= 25 ? dp[i - 75][j - 25] : 1);
                dp[i][j] += p * (i >= 50 && j >= 50 ? dp[i - 50][j - 50] : 1);
                dp[i][j] += p * (i >= 25 && j >= 75 ? dp[i - 25][j - 75] : 1);
            }
        }
        return dp[(n + 24) / 25][(n + 24) / 25];

=======

        if (n > 4800) {
            return 1.0;
        }
        double[][] dp = new double[25][25];
        return helper(n, n, dp);
    }
    
    private double helper(int a, int b, double[][] dp) {
        if (a <= 0 && b <= 0) {
            return 0.5;
        }
        if (a <= 0) {
            return 1.0;
        }
        if (b <= 0) {
            return 0.0;
        }
        if (dp[a][b] > 0) {
            return dp[a][b];
        }
        dp[a][b] = 0.25 * (helper(a - 100, b, dp) + helper(a - 75, b - 25, dp) + helper(a - 50, b - 50, dp) + helper(a - 25, b - 75, dp));
        return dp[a][b];
