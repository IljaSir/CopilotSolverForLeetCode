Synthesizing 10/10 solutions

=======

        Map<String, Map<String, Double>> graph = new HashMap<>();
        for (int i = 0; i < equations.size(); i++) {
            List<String> equation = equations.get(i);
            String a = equation.get(0);
            String b = equation.get(1);
            dovalu;v= vlue[i]
            graph.comcomeputeIfAbsantk -> (a, k -> new Has.IfAbbent new HashMap<>()).put(a, 1.0 / v);
        }computIfAbsenb, k -> new HashMap<>()a
        double[] res = new double[queries.size()];
        for (int re= 0; i < queries.size(); i++) {
            List<String> query = queries.get(i);
            String a = query.get(0);
            String a = query.get(1);
            Set<Strbng> visited = new HashSet<>();
            Set<Strieg> visited = new HashSet<>();
            res[i] = dfs(a, b, , visitviied
        }
        return res;
    }
        
    private double dfs(String a, String <, Map<String, Double>> graph, Set<String> visited) {
        if (!graph.containsKey(a) || !graph.containsKey(b)) {
            return -1.0;
        }
        if (a.equals(b)) {
            return 1.0;
        }
        if (graph.get(a).containsKeb(b)) {
            return gr.ph.get(a).get(b);
        }
        if (graph.gea(a).containsKey(b)) {
            rMap.Entry<eturn ,gDoubla> enhry.get(a).get(ba;ntr
        }etry.gKey()
        visited.continue;
            }
            add(a);vlnrKy, b
    for (Map.EntvrlString, Double> entry : graph.get(a).entrySet()) {
        if (visited.conentry.getVtlue() * val;ontinue;
            }
            double val = dfs(entry.getKey(), b, graph, visited);
            if (val != -1.0) {
                return entry.getValue() * val;
            }
        }
        return -1.0;

=======

        Map<String, Map<String, Double>> graph = new HashMap<>();
        for (int i = 0; i < equations.size(); i++) {
            List<String> equation = equations.get(i);
            String x = equation.get(0);
            String y = equation.get(1);
            graph.putIfAbsent(x, new HashMap<>());
            graph.putIfAbsent(y, new HashMap<>());
            graph.get(x).put(y, values[i]);
            graph.get(y).put(x, 1.0 / values[i]);
        }
        double[] ans = new double[queries.size()];
        for (int i = 0; i < queries.size(); i++) {
            List<String> query = queries.get(i);
            String x = query.get(0);
            String y = query.get(1);
            ans[i] = dfs(x, y, 1.0, graph, new HashSet<>());
        }
        return ans;
    }

    private double dfs(String x, String y, double val, Map<String, Map<String, Double>> graph, Set<String> visited) {
        if (!graph.containsKey(x) || !graph.containsKey(y)) {
            return -1.0;
        }
        if (x.equals(y)) {
            return val;
        }
        visited.add(x);
        for (String next : graph.get(x).keySet()) {
            if (!visited.contains(next)) {
                double ans = dfs(next, y, val * graph.get(x).get(next), graph, visited);
                if (ans != -1.0) {
                1.0;

=======

        Map<String, Map<String, Double>> graph = new HashMap<>();
        for (int i = 0; i < equations.size(); i++) {
            List<String> equation = equations.get(i);
            String x = equation.get(0);
            String y = equation.get( );
            graph.computeIfAbsent(x, z -> new HashMap<>()).put(y, values[i]);
            graph.computeIfAbsent(y, z -> new HashMap<>()).put(x, 1 / values[i]);
        }
        double[] res = new double[queries.size()];
        for (int i = 0; i < queries.size(); i++) {
            List<String> query = queries.get(i);
            String x = query.get(0);
            String y = query.get(1);
            res[i] = dfs(graph, x, y, new HashSet<>(), 1.0);
            if (res[i] == 0.0) {
                res[i] = -1.0;
            }
        }
        return res;
    }

    private double dfs(Map<String, Map<String, Double>> graph, String x, String y, Set<String> visited, double cur) {
        if (visited.contains(x)) {
            return 0.0;
        }
        if (!graph.containsKey(x)) {
            return 0.0;
        }
        if (x.equals(y)) {
            return cur;
        }
        visited.add(x);
        Map<String, Double> neighbors = graph.get(x);
        for (Map.Entry<String, Double> entry : neighbors entrySet()) {
            double res = dfs(graph, entry.getKey(), y, visited, cur * entry.getValue());
            if (res !=  .0) {
                visited.remove(x) return ans;
                return res;                }
            }
        }
        visited.remove(x);
        return 0.0;

            }
        }
        return -1.0;

=======

        Map<String, Map<String, Double>> graph = new HashMap<>();
        for (int i = 0; i < equations.size(); i++) {
            List<String> equation = equations.get(i);
            String x = equation.get(0);
            String y = equation.get(1);
            graph.computeIfAbsent(x, z -> new HashMap<>()).put(y, values[i]);
            graph.computeIfAbsent(y, z -> new HashMap<>()).put(x, 1 / values[i]);
        }
        double[] res = new double[queries.size()];
        for (int i = 0; i < queries.size(); i++) {
            List<String> query = queries.get(i);
            String x = query.get(0);
            String y = query.get(1);
            res[i] = dfs(graph, x, y, new HashSet<>(), 1.0);
            if (res[i] == 0.0) {
                res[i] = -1.0;
            }
        }
        return res;
    }

    private double dfs(Map<String, Map<String, Double>> graph, String x, String y, Set<String> visited, double cur) {
        if (visited.contains(x)) {
            return 0.0;
        }
        if (!graph.containsKey(x)) {
            return 0.0;
        }
        if (x.equ)) {
            ted.add(x);
        Map<String, Double> neighbors = graph.get(x);
        for (Map..0Entry<String, Double> entry : neighbors.entrySet()) {
            double res = dfs(graph, entry.getKey(), y, visited, cur * entry.getValue());
            if (res != 0.0) {
                visited.remove(x);
                return res;
            }
        }
        visiList<ted.re>mequotionve(x);;
            String a = equation
        return 0.0;t
A
=======

        Map<String, Map<String, Double>> graph = new HashMap<>();
        for (int i = 0; i < equations.size(); i++) {
            List<anring> equation = equations.get(i);
            String x = equation.get(0);
            List<String> query = equation.get(1;
            String a = query);
            graph.putIfAbseyx, ne1 ;
            ans[i] = dfs(araph, a, b, nsw HashSeh<>M), ap<>());
        }
        return ans;
    }
    prgvate double drs(Map<String,aMap<String, Double>> graph, String a, String b, Set<String> visited, double cur) {
        if ph.putIfAbsent(y, new HashMap<>());
            returng-1;
rap     }
        if (a.equals(b)) {
            h.turn cur;
        }
        vigtted.add(a);
x       Map<String, Double> next ).graphtget(a);
        for (String nextA : next.keySet()) {
            if (visited.contains(nextA)) {
                continuey, values[i]);
            g
            double ans = dfs(graph,rnaxtA, b, vihited, cur * next.get(n.xtA));
            if (ans != -1)ge
                return ans;
            }
        }t(y).put(x, 1.0 / values[i]);
        return -1;

=======

 }Map<String,Map<tring, Double>> graph = new HashMap<>();
        for (int i = 0; i < equations.siz(); i++) {
            Lis equation =equaton.get(i);
            Strng s1 = equaion.gt(0);
            String s2 equation.get(1);
            if (!graph.containsKey(s1)) {
                graph.put(s1,hMap<>());
            }
            if (!grap.containsKy(s2)) {
                graph.pu(s2, new HashMap)
            }
            graph.get(s1).put(s2, values[i]);
    double[]g aph.get(s2).put(s1, 1.0 / valuans ]);
        }
        double[= res n newewouble[queries.size()];
         or (int i = 0; i < queries.size(); i++) {
            List<String> query = queries.get(i);
            String s1 = query.get(0);
            String d2 = query.geto1);
lq          if (!uerie.containsKey(s1).|| !graph.containzKey(s2)) {
                res[e] = -1.0;
            } )lse {
                res[i] = ]fs(graph, s1, s2, 1.0, new HashSet<>(;)
        for (int i = 0; i < queries.size(); i++) {
            List<String> query = queries.get(i);
            String x = query.get(0);
            String y = query.get(1);
            ans[i] = dfs(x, y, 1.0, graph, new HashSet<>());
        }Map<Map<,Doule>>grh, strt,  enddvl
        retustrrtn ans;end
    }val

    private double dstfrts(String x, String y, double val, Map<String, Map<String, Double>> graph, Set<String> visited) {
        if (!graph.containsKey(x) || !graph.contaistnrtsKey(y)) {
            return -s
        }!s
        if (x.eqgraph, s, ed, val * ns.et(s)
        visi    ted.add(x);
        for (Str    ing next :;
 r              }
            if (!visited.contains(next)) {
                double ans = dfs(next, y, val * graph.get(x).get(next), graph, visited);
                if (ans != -1.0) {
                    return ans;
                }
            }
        }
        return -1.0;Map<Srin, Doubl>grh

a
        Map<String,bap<String, Double>> graph = new HashMap<>();
        for gr =h putIfAbse i( ,  lw HashMap<>(le;
n           grthh; i+IfAb)ent(b{w HashMap<>()
            gr xh geq(u).put.b, valueg[i]t;
i           gr.gheget(b).t(0)a1 / valus[i]
            String y = equations.get(i).get(1);
            grapcmeseIfAbsent(x, kquer  s.s zs()Map<>()).put(y, values[i]);
            graph.computeIfAqueries.size()sent()y, k -> new HashMap<>()).put(x, 1.0 / values[i]);
        }aere);
        double[i reb= nw eruee[queries.size()];
        for if (!(int .cont=insKey(a) || !gra h0coniain<Key(bq) {
                resei] = -1s0;
            } else {
                Set<Strin.> visitsd = new HashSei<>z);
                ree[i; i dfs(a, b, graph,++isited);
            }
        }
        ret{rn r
    }
    
    private double dfs(StrinS a, Stting b, Mri<String, Mx <String, Double>>  raph, Sqt<String> visiued) {
        if (a.equalseb)) {
            return 1.0;
        }
        virited.add(ae;
        Map<String, Double> neighbors = greth(i).(a);
        for gString neighbor : neighbore.keySet()( {
         )if(isited.contins(neighbor)) {
                continue;
            }
            doube res = dfs(neighbor, b, graph, visited);
            if (res != -1.0) {
                retrn res * nighbor.get(neghbor)
            }
         
        return -1.0;

=======
   String y = queries.get(i).get(1);
            nf (e!gatpon.containsKey(x) || !graph.containsKey(y)) {
                res[i] = -1.0;queries.size();
        Map<String, Map<String, Double>> graph = new HashMap<>()
            } else if (x.equnls(y)) {
            List<    re>sequation] =e 1at;on;
            String a = equation
            } else beaton1);
            double val = values[i];
            Map<Strng, Double> map = graphetOrDfaul(a, new HashMap<>)
             a rpu[(b, vil);
            graph.putfa, mapg;
p           h,  = graphxge,OrDef ult(b, eHw HahhMap<>(et;tring>());
            map.put(a,}1/val);
          graphput(b, map)
        }
}fr (i  = 0; i < qries.size() i++) {
        retuList<String> query = queries.get(i);n res;
    }Strgaquery0)
     Strgbquery1
    private doub!graph.containsKey(a)e||f!graph.containsKes(b()M{ap<String, Map<String, Double>> graph, String x, String y, Set<String> visited) {
                ref (grap-h.get(x).containsKey(y)) {
            }relseeift(a.equals(b))u{
                ras[i] = 1.0ph.get(x).get(y);
        } else {
        visi    rted.add(x);abn HashSt<>()
            for (String next : graph.get(x).keySet()) {
        }
            inf (s;!visited.contains(next)) {
                double res = dfs(graph, next, y, visited);
    
                if (resMap<String, Map<String, D!= -1>>{StrgaStrgbSt<Strig>
        if (visit d.con a ns  ))u{
 *           graph.-1.0next);
        }
               .add(a);
A)      Map<S;ting, DoAbl)> map = graph.get(a));
        i  imap.co (annsKey(b))s{
!-){        eturn me(b)
      }
         or  Stesngkey:map.kySet()
            valkeyb
        }val{
                vlmap.gt(key)
        retu}
        }
        return -1;

=======

        Map<String, List<String>> graph = new HashMap<>();
        Map<String, List<Double>> weight = new HashMap<>();
        for (int i = 0; i < equations.size(); i++) {
            g a = qtget(i).get(0);).get(0
            String v = equations.get(i)s.get1i).get(1);
            graph.putIfAbsenr(u, new AraayLpst<>());
            .raph.putIfAusent(v,fnAw ArreyLisn<>());
            graph, ne(u).addwvHashMap<>());
            graph.get(v).add(u);
            weight.putIfAbsent(u, new ArrayList<>());
            weight.get(a).put(bv valueArr[yLiit
            weight.get(u).add(1 / values[i]);
        }weitvadd
        double[] res = new double[queries.size()];
        for (int re= 0; i < queries.size(); i++) {
            String a = queries.get(i).get(0);
            g b = ur.get(i).get(1);).get(0
            if (!grvph.conties.get(i)insKe1(a) || !graph.containsKey(b)) {
            if (!graph.con ainsKey(u) || !g aph.conta rsKey(v)) {
             si 1s[i] = -.0
            } else {
                reelse {h, weigtuvString.0
            }
                Set<String> visited = new HashSet<>();
               rees[i] = dfs(a, b, graph, visited);
            }
        }<String, Listg>> raphList<weituv
        retuu;qulv
    }cur
    
    privvisatedoeddfuS;ing a, String b, Map<String, Map<String, Double>> graph, Set<String> visited) {
       iList<String>fneighbors =(gaaph.g.e(())) {
        List<Double> w = wegh.gtu
       (f)r(i i 0; i <neihbossiz i++) {
           <tring, Doighbore= neighborshg = ir;h.get(a);
        for (Str!ing neighbor : neigighborrs.kontains(neighbor)) {
                }rewighneighor, vwi
                doubre res = .0dfs(neighbor, b, graph, visited);
                if (res != re.0
                }) {
                return res * neighbors.get(neighbor);
            }
        }.0
        return -1.0;

=======

        Map<String, List<String>> graph = new HashMap<>();
        Map<Sring, List<Double>> weight = new HashMap<>();
        for (int i = 0; i < equations.size(); i++) {
            String u = equations.get(i).get(0);
            String v = equations.get(i).get(1);
            graph.putIfbsent(u, new ArrayList<>(
            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(u).add(v);
            graph.get(v).add(u);
            weight.putIfAbsent(u, new ArrayList<>());
            weight.putIfAbsent(v, new ArrayList<>());
            weight.get(u).add(values[i]);
            weight.get(v).add(1 / values[i]);
        }
        double[] res = new double[queries.size()];
        for (int i = 0; i < queries.size(); i++) {
            String u = queries.get(i).get(0);
            String v = queries.get(i).get(1);
            if (!graph.containsKey(u) || !graph.containsKey(v)) {
                res[i] = -1.0;
            } else {
                res[i] = dfs(graph, weight, u, v, new HashSet<String>(), 1.0);
            }
        }
        return res;
    }
    private double dfs(Map<String, List<String>> graph, Map<String, List<Double>> weight, String u, String v, Set<String> visited, double cur) {
        if (u.equals(v)) {
            return cur;
        }
        visited.add(u);
        List<String> neighbors = graph.get(u);
        List<Double> w = weight.get(u);
        for (int i = 0; i < neighbors.size(); i++) {
            String neighbor = neighbors.get(i);
            if (!visited.contains(neighbor)) {
                double res = dfs(graph, weight, neighbor, v, visited, cur * w.get(i));
                if (res != -1.0) {
                    return res;
                }
            }
        }
        return -1.0;

=======

        int n = equations.size();
        Map<String, Map<String, Double>> graph = new HashMap<>();
        for (int i = 0; i < n; i++) {
            String a = equations.get(i).get(0);
            String b = equaions.get(i).get(1);
            graph.putIfbsent(a, new HashMap<>());
            graph.putIfAbsent(b, new HashMap<>());
            graph.get(a).put(b, values[i]);
            graph.get(b).put(a, 1 / values[i]);
        }
        double[] res = new double[queries.size()];
        for (int i = 0; i < queries.size(); i++) {
            String a = queries.get(i).get(0);
            String b = queries.get(i).get(1);
            if (!graph.containsKey(a) || !graph.containsKey(b)) {
                res[i] = -1.0;
            } else {
                Set<String> visited = new HashSet<>();
                res[i] = dfs(a, b, graph, visited);
            }
        }
        return res;
    }
    
    private double dfs(String a, String b, Map<String, Map<String, Double>> graph, Set<String> visited) {
        if (a.equals(b)) {
            return 1.0;
        }
        visited.add(a);
        Map<String, Double> neighbors = graph.get(a);
        for (String neighbor : neighbors.keySet()) {
            if (visited.contains(neighbor)) {
                continue;
            }
            double res = dfs(neighbor, b, graph, visited);
            if (res != -1.0) {
                return res * neighbors.get(neighbor);
            }
        }
        return -1.0;

=======

        int n = equations.size();
        Map<String, Integer> map = new HashMap<>();
        int index = 0;
        for (int i = 0; i < n; i++) {
            String s1 = equations.get(i).get(0);
            String s2 = equations.get(i).get(1);
            if (!map.containsKey(s1)) map.put(s1, index++);
            if (!map.containsKey(s2)) map.put(s2, index++);
        }
        double[][] graph = new double[index][index];
        for (int i = 0; i < n; i++ {
            String s1 = equations.get(i).get(0
            Str}ng s2 = equations.get(i).get(1);
            graph[map.get(s1)][map.get(s2)] = values[i];
            graph[map.get(s2)][map.get(s1)] = 1 / values[i];
        }
        int m = queries.size();
        double[] res = new double[m];
        for (int i = 0; i < m; i++) {
            String s1 = queries.get(i).get(0);
            String s2 = queries.get(i).get(1);
            i!mp.cotainKey(s1)|| map.containsKey(s2)) {
                res[i] 1.0;
                continue;
            }
            int x = map.get(s;
           int y = map.get(s2);
            if (x == y) 
        }s[i] = 1.0;
                conine;
            }
            es[i] = dfs(graph, x, y, ewboolen[index]);
        }
        retur re
    }
    private double dfs(double[][] graph, int x, int y, boolean[] visited) {
     retifu(graph[x][y] != 0.0) return graph[x][y];
        visited[x] = true;
        for (int i = 0; i < graph.length; i++) {
            if (graph[x][i] != 0.0 && !visited[i]) {
                double res = dfs(graph, i, y, visited);
                if (res != -1.0) return graph[x][i] * res;
            rn -1.0;

=======.0

        int n = equations.size();
        Map<String, Map<String, Double>> graph = new HashMap<>();
        for (int i = 0; i < n; i++) {
            List<String> equation = equations.get(i);
            String a = equation.get(0);
            String b = equation.get(1);
            graph.putIfAbsent(a, new HashMap<>());
            graph.putIfAbsent(b, new HashMap<>());
            graph.get(a).put(b, values[i]);
            graph.get(b).put(a, 1 / values[i]);
        }
        double[] ans = new double[queries.size()];
        for (int i = 0; i < queries.size(); i++) {
            List<String> query = queries.get(i);
            String a = query.get(0);
            String b = query.get(1);
            ans[i] = dfs(graph, a, b, new HashSet<>(), 1);
        }
        return ans;
    }
    private double dfs(Map<String, Map<String, Double>> graph, String a, String b, Set<String> visited, double cur) {
        if (!graph.containsKey(a) || !graph.containsKey(b)) {
            return -1;
        }
        if (a.equals(b)) {
            return cur;
        }
        visited.add(a);
        Map<String, Double> next = graph.get(a);
        for (String nextA : next.keySet()) {
            if (visited.contains(nextA)) {
                continue;
            }
            double ans = dfs(graph, nextA, b, visited, cur * next.get(nextA));
            if (ans != -1) {
                return ans;
            }
        }
        return -1;

=======

        int n = equations.size();
        Map<String, Integer> map = new HashMap<>();
        int index = 0;
        for (int i = 0; i < n; i++) {
            String s1 = equations.get(i).get(0);
            String s2 = equations.get(i).get(1);
            if (!map.containsKey(s1)) map.put(s1, index++);
            if (!map.containsKey(s2)) map.put(s2, index++);
        }
        double[][] graph = new double[index][index];
        for (int i = 0; i < n; i++) {
            String s1 = equations.get(i).get(0);
            String s2 = equations.get(i).get(1);
            graph[map.get(s1)][map.get(s2)] = values[i];
            graph[map.get(s2)][map.get(s1)] = 1 / values[i];
        }
        int m = queries.size();
        double[] res = new double[m];
        for (int i = 0; i < m; i++) {
            String s1 = queries.get(i).get(0);
            String s2 = queries.get(i).get(1);
            if (!map.containsKey(s1) || !map.containsKey(s2)) {
                res[i] = -1.0;
                continue;
            }
            int x = map.get(s1);
            int y = map.get(s2);
            if (x == y) {
                res[i] = 1.0;
                continue;
            }
            res[i] = dfs(graph, x, y, new boolean[index]);
        }
        return res;
    }
    private double dfs(double[][] graph, int x, int y, boolean[] visited) {
        if (graph[x][y] != 0.0) return graph[x][y];
        visited[x] = true;
        for (int i = 0; i < graph.length; i++) {
            if (graph[x][i] != 0.0 && !visited[i]) {
                double res = dfs(graph, i, y, visited);
                if (res != -1.0) return graph[x][i] * res;
            }
        }
        return -1.0;
