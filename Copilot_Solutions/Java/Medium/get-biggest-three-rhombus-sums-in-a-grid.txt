Synthesizing 10/10 solutions

=======

        int m = grid.length;
        int n = grid[0].length;
        int[][] sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + grid[i - 1][j - 1];
            }
        }
        Set<Integer> set = new HashSet<>();
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                for (int k = 0; k <= Math.min(i, j) && k <= Math.min(m - i, n - j); k++) {
                    int s = sum[i + k][j + k] - sum[i + k][j - k - 1] - sum[i - k - 1][j + k] + sum[i - k - 1][j - k - 1];
                    set.add(s);
                }
            }
        }
        List<Integer> list = new ArrayList<>(set);
        Collections.sort(list);
        int[] ans = new int[Math.min(3, list.size())];
        for (int i = 0; i < ans.length; i++) {
            ans[i] = list.get(list.size() - 1 - i);
        }
        return ans;

=======

        int m = grid.length;
        int n = grid[0].length;
        int[][] sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + grid[i - 1][j - 1];
            }
        }
        Set<Integer> set = new TreeSet<>((a, b) -> b - a);
        int[] dx = {1, 0, -1, 0};
        int[] dy = {0, 1, 0, -1};
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                for (int k = 0; k < 4; k++) {
                    int x = i + dx[k];
                    int y = j + dy[k];
                    int len = 0;
                    while (x > 0 && y > 0 && x <= m && y <= n) {
                        int cur = sum[x][y] - sum[x - len - 1][y] - sum[x][y - len - 1] + sum[x - len - 1][y - len - 1];
                        set.add(cur);
                        len++;
                        x += dx[k];
                        y += dy[k];
                    }
                }
            }
        }
        int[] ans = new int[3];
        int idx = 0;
        for (int num : set) {
            if (idx == 3) {
                break;
            }
            ans[idx++] = num;
        }
        return Arrays.copyOf(ans, idx);

=======

        int m = grid.length;
        int n = grid[0].length;
        int[][] sum = new int[m + 1][n + 1];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                sum[i + 1][j + 1] = grid[i][j] + sum[i][j + 1] + sum[i + 1][j] - sum[i][j];
            }
        }
        int[] ans = new int[3];
        int k = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                for (int l = 1; i + l < m && j + l < n && i - l >= 0 && j - l >= 0; l++) {
                    int cur = sum[i + l][j + l] - sum[i - l - 1][j + l] - sum[i + l][j - l - 1] + sum[i - l - 1][j - l - 1];
                    if (k < 3) {
                        ans[k++] = cur;
                    } else {
                        int min = ans[0];
                        int index = 0;
                        for (int p = 1; p < 3; p++) {
                            if (ans[p] < min) {
                                min = ans[p];
                                index = p;
                            }
                        }
                        if (min < cur) {
                            ans[index] = cur;
                        }
                    }
                }
            }
        }
        Arrays.sort(ans);
        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = ans[k - i - 1];
        }
        return res;

=======

        int m = grid.length;
        int n = grid[0].length;
        int[][] prefix = new int[m+1][n+1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                prefix[i][j] = prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1] + grid[i-1][j-1];
            }
        }
        int[] res = new int[m*n];
        int idx = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int r = 1;
                while (i-r >= 0 && i+r < m && j-r >= 0 && j+r < n) {
                    int sum = prefix[i+r+1][j+r+1] - prefix[i+r+1][j-r] - prefix[i-r][j+r+1] + prefix[i-r][j-r];
                    res[idx++] = sum;
                    r++;
                }
            }
        }
        Arrays.sort(res, 0, idx);
        int[] ans = new int[3];
        int cnt = 0;
        for (int i = idx-1; i >= 0; i--) {
            if (cnt == 0 || res[i] != ans[cnt-1]) {
                ans[cnt++] = res[i];
                if (cnt == 3) break;
            }
        }
        return Arrays.copyOf(ans, cnt);

=======

        int m = grid.length, n = grid[0].length;
        int[][][] dp = new int[m][n][2];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int sum = grid[i][j];
                if (i > 0) {
                    sum += dp[i - 1][j][0];
                }
                if (j > 0) {
                    sum += dp[i][j - 1][1];
                }
                if (i > 0 && j > 0) {
                    sum -= dp[i - 1][j - 1][0];
                }
                dp[i][j][0] = sum;
            }
        }
        for (int i = m - 1; i >= 0; i--) {
            for (int j = 0; j < n; j++) {
                int sum = grid[i][j];
                if (i < m - 1) {
                    sum += dp[i + 1][j][0];
                }
                if (j > 0) {
                    sum += dp[i][j - 1][1];
                }
                if (i < m - 1 && j > 0) {
                    sum -= dp[i + 1][j - 1][0];
                }
                dp[i][j][1] = sum;
            }
        }
        Set<Integer> set = new HashSet<>();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int sum = grid[i][j];
                for (int k = 1; k <= Math.min(i, j); k++) {
                    if (i + k >= m || j + k >= n) {
                        break;
                    }
                    sum += dp[i + k][j + k][1] - dp[i - k][j + k][1] - dp[i + k][j - k][1] + dp[i - k][j - k][1];
                    set.add(sum);
                }
            }
        }
        int[] ans = new int[set.size()];
        int i = 0;
        for (int x : set) {
            ans[i++] = x;
        }
        Arrays.sort

=======

        int m = grid.length, n = grid[0].length;
        int[][][] dp = new int[m][n][2];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j][0] = grid[i][j];
                dp[i][j][1] = grid[i][j];
                if (i > 0) {
                    dp[i][j][0] += dp[i - 1][j][0];
                }
                if (j > 0) {
                    dp[i][j][1] += dp[i][j - 1][1];
                }
                if (i > 0 && j > 0) {
                    dp[i][j][0] -= dp[i - 1][j - 1][0];
                    dp[i][j][1] -= dp[i - 1][j - 1][1];
                }
            }
        }
        Set<Integer> set = new TreeSet<>(Collections.reverseOrder());
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < 2; k++) {
                    for (int l = 1; i + l < m && j + l < n; l++) {
                        int sum = dp[i + l][j + l][k] - dp[i][j][k];
                        if (k == 0) {
                            sum -= dp[i + l][j][1] - dp[i][j][1];
                        } else {
                            sum -= dp[i][j + l][0] - dp[i][j][0];
                        }
                        set.add(sum);
                        if (set.size() > 3) {
                            set.remove(set.iterator().next());
                        }
                    }
                }
            }
        }
        return set.stream().mapToInt(i -> i).toArray();

=======

        int m = grid.length;
        int n = grid[0].length;
        int[] res = new int[3];
        int count = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int sum = grid[i][j];
                int l = 1;
                while (i - l >= 0 && j - l >= 0 && i + l < m && j + l < n) {
                    sum += grid[i - l][j] + grid[i + l][j] + grid[i][j - l] + grid[i][j + l];
                    if (count < 3) {
                        res[count++] = sum;
                        Arrays.sort(res);
                    } else {
                        if (sum > res[0]) {
                            res[0] = sum;
                            Arrays.sort(res);
                        }
                    }
                    l++;
                }
            }
        }
        int[] result = new int[count];
        for (int i = 0; i < count; i++) {
            result[i] = res[i];
        }
        return result;

=======

        int m = grid.length;
        int n = grid[0].length;
        int[] res = new int[3];
        int index = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < m; k++) {
                    for (int l = 0; l < n; l++) {
                        if (i == k && j == l) {
                            continue;
                        }
                        if (i == k || j == l) {
                            continue;
                        }
                        if (Math.abs(i - k) != Math.abs(j - l)) {
                            continue;
                        }
                        int sum = 0;
                        for (int x = i, y = j; x <= k && y <= l; x++, y++) {
                            sum += grid[x][y];
                        }
                        for (int x = k, y = l; x >= i && y >= j; x--, y--) {
                            sum += grid[x][y];
                        }
                        for (int x = i, y = l; x <= k && y >= j; x++, y--) {
                            sum += grid[x][y];
                        }
                        for (int x = k, y = j; x >= i && y <= l; x--, y++) {
                            sum += grid[x][y];
                        }
                        sum -= grid[i][j];
                        sum -= grid[k][l];
                        if (index == 0) {
                            res[index++] = sum;
                        } else if (index == 1) {
                            if (sum != res[0]) {
                                res[index++] = sum;
                            }
                        } else if (index == 2) {
                            if (sum != res[0] && sum != res[1]) {
                                res[index++] = sum;
                            }
                        } else {
                            if (sum != res[0] && sum != res[1] && sum != res[2]) {
                                if (sum > res[0]) {
                                    res[0] = sum;
                                } else if (sum > res[1]) {
                                    res[1] = sum;
                                } else if (sum > res[2]) {
                                    res[2] = sum;
                                }
                            }
                        }
                    }
                }
            }

=======

        int m = grid.length;
        int n = grid[0].length;
        int[][] sum = new int[m][n];
        for (int i = 0; i < m; i++){
            int s = 0;
            for (int j = 0; j < n; j++){
                s += grid[i][j];
                if (i == 0) sum[i][j] = s;
                else sum[i][j] = sum[i-1][j] + s;
            }
        }
        int[] ans = new int[3];
        int ansSize = 0;
        for (int i = 0; i < m; i++){
            for (int j = 0; j < n; j++){
                int l = 0, r = Math.min(i, j);
                while (l <= r){
                    int mid = (l + r) / 2;
                    int s = getSum(sum, i, j, mid);
                    if (s == 0) l = mid + 1;
                    else if (s > 0) r = mid - 1;
                    else {
                        l = mid;
                        break;
                    }
                }
                int s = getSum(sum, i, j, l);
                if (s != 0){
                    int pos = ansSize;
                    while (pos > 0 && ans[pos-1] < s) pos--;
                    if (pos < 3){
                        for (int k = ansSize; k > pos; k--) ans[k] = ans[k-1];
                        ans[pos] = s;
                        if (ansSize < 3) ansSize++;
                    }
                }
            }
        }
        int[] ret = new int[ansSize];
        for (int i = 0; i < ansSize; i++) ret[i] = ans[i];
        return ret;

=======

        int m = grid.length;
        int n = grid[0].length;
        int[] ans = new int[3];
        int i = 0;
        for (int x = 0; x < m; x++) {
            for (int y = 0; y < n; y++) {
                int sum = 0;
                for (int d = 0; d < Math.min(m, n); d++) {
                    int x1 = x - d;
                    int x2 = x + d;
                    int y1 = y - d;
                    int y2 = y + d;
                    if (x1 < 0 || x2 >= m || y1 < 0 || y2 >= n) {
                        break;
                    }
                    for (int j = y1; j <= y2; j++) {
                        sum += grid[x1][j];
                        sum += grid[x2][j];
                    }
                    for (int j = x1 + 1; j < x2; j++) {
                        sum += grid[j][y1];
                        sum += grid[j][y2];
                    }
                    ans[i++] = sum;
                    sum = 0;
                }
            }
        }
        Arrays.sort(ans);
        for (int j = 0; j < 3; j++) {
            if (ans[j] == 0) {
                ans[j] = ans[j + 1];
            }
        }
        return ans;
