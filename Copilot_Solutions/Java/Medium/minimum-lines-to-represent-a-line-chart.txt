Synthesizing 10/10 solutions

=======

        int n = stockPrices.length;
        int[] dp = new int[n];
        dp[0] = 1;
        for (int i = 1; i < n; i++) {
            dp[i] = 1;
            for (int j = 0; j < i; j++) {
                if ((long)stockPrices[j][1] * (stockPrices[i][0] - stockPrices[j][0]) <= (long)stockPrices[i][1] * (stockPrices[i][0] - stockPrices[j][0])) {
                    dp[i] = Math.max(dp[i], 1 + dp[j]);
                }
            }
        }
        int res = 0;
        for (int i = 0; i < n; i++) {
            res = Math.max(res, dp[i]);
        }
        return res;

=======

        int n = stockPrices.length;
        int[] dp = new int[n];
        int len = 0;
        for (int[] p : stockPrices) {
            int i = Arrays.binarySearch(dp, 0, len, p[1]);
            if (i < 0) i = - (i + 1);
            dp[i] = p[1];
            if (i == len) len++;
        }
        return len;

=======

        int n = stockPrices.length;
        int[] dp = new int[n];
        int len = 0;
        for (int[] p : stockPrices) {
            int i = Arrays.binarySearch(dp, 0, len, p[1]);
            if (i < 0) {
                i = -(i + 1);
            }
            dp[i] = p[1];
            if (i == len) {
                len++;
            }
        }
        return len;

=======

        int n = stockPrices.length;
        int[] dp = new int[n];
        int ans = 0;
        for (int i = 0; i < n; i++) {
            dp[i] = 1;
            for (int j = 0; j < i; j++) {
                if (stockPrices[j][1] < stockPrices[i][1]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            ans = Math.max(ans, dp[i]);
        }
        return ans;

=======

        int n = stockPrices.length;
        int[][] dp = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = Integer.MAX_VALUE;
            }
        }
        for (int i = 0; i < n; i++) {
            dp[i][i] = stockPrices[i][1];
        }
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < n - i; j++) {
                int k = j + i;
                for (int l = j; l < k; l++) {
                    if (dp[j][k] > dp[j][l] + dp[l + 1][k]) {
                        dp[j][k] = dp[j][l] + dp[l + 1][k];
                    }
                }
            }
        }
        return dp[0][n - 1];

=======

        int n = stockPrices.length;
        int[] dp = new int[n];
        int len = 0;
        for (int[] stock : stockPrices) {
            int i = Arrays.binarySearch(dp, 0, len, stock[1]);
            if (i < 0) {
                i = -(i + 1);
            }
            dp[i] = stock[1];
            if (i == len) {
                len++;
            }
        }
        return len;

=======

        int n = stockPrices.length;
        int[][] dp = new int[n][n];
        for(int i = 0; i < n; i++) {
            for(int j = i + 1; j < n; j++) {
                dp[i][j] = 1;
            }
        }
        for(int i = n - 1; i >= 0; i--) {
            for(int j = i + 1; j < n; j++) {
                for(int k = i + 1; k < j; k++) {
                    if((stockPrices[i][1] - stockPrices[j][1]) * (stockPrices[i][0] - stockPrices[k][0]) == (stockPrices[i][1] - stockPrices[k][1]) * (stockPrices[i][0] - stockPrices[j][0])) {
                        dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j] - 1);
                    }
                }
            }
        }
        int res = n;
        for(int i = 0; i < n; i++) {
            for(int j = i + 1; j < n; j++) {
                res = Math.min(res, dp[i][j] + 1);
            }
        }
        return res;

=======

        int n = stockPrices.length;
        if (n == 1) {
            return 1;
        }
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        int max = 1;
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (stockPrices[j][1] <= stockPrices[i][1]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            max = Math.max(max, dp[i]);
        }
        return max;

=======

        int n = stockPrices.length;
        int[] dp = new int[n];
        int res = 0;
        for (int i = 0; i < n; ++i) {
            int cur = 1;
            for (int j = 0; j < i; ++j) {
                if (stockPrices[j][1] <= stockPrices[i][1]) {
                    cur = Math.max(cur, dp[j] + 1);
                }
            }
            dp[i] = cur;
            res = Math.max(res, cur);
        }
        return res;

=======

        int n = stockPrices.length;
        int[] dp = new int[n + 1];
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            int p = Arrays.binarySearch(dp, 0, ans, stockPrices[i][1]);
            if (p < 0) p = -p - 1;
            dp[p] = stockPrices[i][1];
            if (p == ans) ++ans;
        }
        return ans;
