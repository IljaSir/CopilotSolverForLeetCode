Synthesizing 10/10 solutions

=======

        int n = grid[0].length;
        long[] sum = new long[n];
        sum[0] = grid[0][0];
        for (int i = 1; i < n; i++) {
            sum[i] = sum[i - 1] + grid[0][i];
        }
        long res = Long.MAX_VALUE;
        long cur = 0;
        for (int i = 0; i < n; i++) {
            if (i > 0) {
                cur += grid[1][i - 1];
            }
            if (i < n - 1) {
                res = Math.min(res, Math.max(cur, sum[n - 1] - sum[i] - grid[0][i]));
            }
        }
        return res;

=======

        int n = grid[0].length;
        long[] preSum = new long[n];
        preSum[0] = grid[0][0];
        for (int i = 1; i < n; i++) {
            preSum[i] = preSum[i - 1] + grid[0][i];
        }
        long[] sufSum = new long[n];
        sufSum[n - 1] = grid[1][n - 1];
        for (int i = n - 2; i >= 0; i--) {
            sufSum[i] = sufSum[i + 1] + grid[1][i];
        }
        long ans = sufSum[0];
        for (int i = 0; i < n; i++) {
            long sum = 0;
            if (i - 1 >= 0) {
                sum += preSum[i - 1];
            }
            if (i + 1 < n) {
                sum += sufSum[i + 1];
            }
            ans = Math.min(ans, sum);
        }
        return ans;

=======

        int n = grid[0].length;
        long[] preSum = new long[n];
        preSum[0] = grid[0][0];
        for (int i = 1; i < n; i++) {
            preSum[i] = preSum[i - 1] + grid[0][i];
        }
        long[] sufSum = new long[n];
        sufSum[n - 1] = grid[1][n - 1];
        for (int i = n - 2; i >= 0; i--) {
            sufSum[i] = sufSum[i + 1] + grid[1][i];
        }
        long res = Long.MAX_VALUE;
        for (int i = 0; i < n - 1; i++) {
            res = Math.min(res, Math.max(preSum[i], sufSum[i + 1]));
        }
        return res;

=======

        int n = grid[0].length;
        long[] left = new long[n];
        long[] right = new long[n];
        long sum = 0;
        for (int i = 0; i < n; i++) {
            sum += grid[0][i];
            left[i] = sum;
        }
        sum = 0;
        for (int i = n - 1; i >= 0; i--) {
            sum += grid[1][i];
            right[i] = sum;
        }
        long min = Long.MAX_VALUE;
        for (int i = 0; i < n - 1; i++) {
            min = Math.min(min, Math.max(left[i], right[i + 1]));
        }
        return min;

=======

        long[][] dp = new long[2][grid[0].length];
        for (int i = 0; i < grid[0].length; i++) {
            if (i == 0) {
                dp[0][i] = grid[0][i];
                dp[1][i] = grid[1][i];
            } else {
                dp[0][i] = grid[0][i] + dp[0][i - 1];
                dp[1][i] = grid[1][i] + dp[1][i - 1];
            }
        }
        long res = Long.MAX_VALUE;
        for (int i = 0; i < grid[0].length; i++) {
            long sum = 0;
            if (i == 0) {
                sum = dp[1][grid[0].length - 1];
            } else if (i == grid[0].length - 1) {
                sum = dp[0][grid[0].length - 2];
            } else {
                sum = Math.max(dp[0][i - 1], dp[1][grid[0].length - 1] - dp[1][i]);
            }
            res = Math.min(res, sum);
        }
        return res;

=======

        int n = grid[0].length;
        long[] preSum = new long[n];
        preSum[n-1] = grid[0][n-1];
        for (int i = n-2; i >= 0; i--) {
            preSum[i] = preSum[i+1] + grid[0][i];
        }
        long min = Long.MAX_VALUE;
        long sum = 0;
        for (int i = 0; i < n-1; i++) {
            sum += grid[1][i];
            min = Math.min(min, Math.max(sum, preSum[i+1]));
        }
        return min;

=======

        int n = grid[0].length;
        long[] sum = new long[n];
        long[] dp = new long[n];
        sum[0] = grid[0][0];
        for (int i = 1; i < n; i++) {
            sum[i] = sum[i - 1] + grid[0][i];
        }
        dp[0] = 0;
        for (int i = 1; i < n; i++) {
            dp[i] = dp[i - 1] + grid[1][i - 1];
        }
        long min = dp[n - 1];
        for (int i = 1; i < n; i++) {
            long temp = dp[i - 1] + sum[i - 1] - dp[i];
            min = Math.min(min, temp);
        }
        return min;

=======

        int n = grid[0].length;
        long[] sum = new long[n];
        long[] left = new long[n];
        long[] right = new long[n];
        for (int i = 0; i < n; i++) {
            sum[i] = grid[0][i] + grid[1][i];
        }
        for (int i = 1; i < n; i++) {
            left[i] = left[i - 1] + sum[i - 1];
        }
        for (int i = n - 2; i >= 0; i--) {
            right[i] = right[i + 1] + sum[i + 1];
        }
        long res = Long.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            res = Math.min(res, Math.max(left[i], right[i]));
        }
        return res;

=======

        long[] left = new long[grid[0].length];
        long[] right = new long[grid[0].length];
        long sum = 0;
        for(int i=0;i<grid[0].length;i++){
            sum += grid[0][i];
            left[i] = sum;
        }
        sum = 0;
        for(int i=grid[0].length-1;i>=0;i--){
            sum += grid[1][i];
            right[i] = sum;
        }
        long min = Long.MAX_VALUE;
        for(int i=0;i<grid[0].length-1;i++){
            min = Math.min(min, Math.max(left[i], right[i+1]));
        }
        return min;

=======

        int n = grid[0].length;
        long[] row0 = new long[n+1];
        long[] row1 = new long[n+1];
        long[] sum0 = new long[n+1];
        long[] sum1 = new long[n+1];
        for (int i = 0; i < n; i++) {
            row0[i+1] = grid[0][i];
            row1[i+1] = grid[1][i];
            sum0[i+1] = sum0[i] + grid[0][i];
            sum1[i+1] = sum1[i] + grid[1][i];
        }
        long min = Long.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            long score = 0;
            long left = sum0[i];
            long right = sum1[n] - sum1[i+1];
            score = Math.max(score, left + right);
            left = sum0[n] - sum0[i+1];
            right = sum1[i];
            score = Math.max(score, left + right);
            min = Math.min(min, score);
        }
        return min;
