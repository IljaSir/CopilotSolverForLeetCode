Synthesizing 10/10 solutions

=======

        if (start < 0 || start >= arr.length || arr[start] < 0) {
            return false;
        }
        if (arr[start] == 0) {
            return true;
        }
        int val = arr[start];
        arr[start] = -arr[start];
        return canReach(arr, start + val) || canReach(arr, start - val);

=======

        if (start < 0 || start >= arr.length || arr[start] < 0) {
            return false;
        }
        if (arr[start] == 0) {
            return true;
        }
        int jump = arr[start];
        arr[start] = -arr[start];
        return canReach(arr, start + jump) || canReach(arr, start - jump);

=======

        if (start < 0 || start >= arr.length || arr[start] < 0) {
            return false;
        }
        if (arr[start] == 0) {
            return true;
        }
        int v = arr[start];
        arr[start] = -arr[start];
        return canReach(arr, start + v) || canReach(arr, start - v);

=======

        return dfs(arr, start, new boolean[arr.length]);
    }
    private boolean dfs(int[] arr, int start, boolean[] visited) {
        if (start < 0 || start >= arr.length || visited[start]) {
            return false;
        }
        if (arr[start] == 0) {
            return true;
        }
        visited[start] = true;
        return dfs(arr, start + arr[start], visited) || dfs(arr, start - arr[start], visited);

=======

        if (arr[start] == 0) {
            return true;
        }
        if (arr[start] == -1) {
            return false;
        }
        int val = arr[start];
        arr[start] = -1;
        if (start + val < arr.length && canReach(arr, start + val)) {
            return true;
        }
        if (start - val >= 0 && canReach(arr, start - val)) {
            return true;
        }
        return false;

=======

        Set<Integer> visited = new HashSet<>();
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(start);
        while (!queue.isEmpty()) {
            int index = queue.poll();
            if (arr[index] == 0) {
                return true;
            }
            if (!visited.contains(index)) {
                visited.add(index);
                if (index - arr[index] >= 0) {
                    queue.offer(index - arr[index]);
                }
                if (index + arr[index] < arr.length) {
                    queue.offer(index + arr[index]);
                }
            }
        }
        return false;

=======

        int n = arr.length;
        boolean[] visited = new boolean[n];
        Queue<Integer> q = new LinkedList<>();
        q.add(start);
        while (!q.isEmpty()) {
            int i = q.remove();
            if (arr[i] == 0) {
                return true;
            }
            if (visited[i]) {
                continue;
            }
            visited[i] = true;
            if (i + arr[i] < n) {
                q.add(i + arr[i]);
            }
            if (i - arr[i] >= 0) {
                q.add(i - arr[i]);
            }
        }
        return false;

=======

        int n = arr.length;
        boolean[] visited = new boolean[n];
        Queue<Integer> q = new LinkedList<>();
        q.add(start);
        while (!q.isEmpty()) {
            int node = q.poll();
            if (arr[node] == 0) return true;
            if (visited[node]) continue;
            visited[node] = true;
            if (node + arr[node] < n) q.add(node + arr[node]);
            if (node - arr[node] >= 0) q.add(node - arr[node]);
        }
        return false;

=======

        int len = arr.length;
        boolean[] visited = new boolean[len];
        Queue<Integer> queue = new LinkedList<>();
        queue.add(start);
        while (!queue.isEmpty()) {
            int pos = queue.poll();
            if (arr[pos] == 0) {
                return true;
            }
            visited[pos] = true;
            if (pos + arr[pos] < len && !visited[pos + arr[pos]]) {
                queue.add(pos + arr[pos]);
            }
            if (pos - arr[pos] >= 0 && !visited[pos - arr[pos]]) {
                queue.add(pos - arr[pos]);
            }
        }
        return false;

=======

        boolean[] visited = new boolean[arr.length];
        Queue<Integer> q = new LinkedList<>();
        q.add(start);
        while (!q.isEmpty()) {
            int index = q.poll();
            if (!visited[index]) {
                visited[index] = true;
                if (arr[index] == 0) return true;
                if (arr[index] + index < arr.length) q.add(arr[index] + index);
                if (index - arr[index] >= 0) q.add(index - arr[index]);
            }
        }
        return false;
