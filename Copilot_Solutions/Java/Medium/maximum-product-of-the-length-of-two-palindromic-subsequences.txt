Synthesizing 10/10 solutions

=======

        int n = s.length();
        int[] dp = new int[1 << n];
        Arrays.fill(dp, -1);
        dp[0] = 0;
        for (int mask = 1; mask < (1 << n); mask++) {
            int len = 0;
            int i = 0;
            while (i < n && ((mask >> i) & 1) == 0) {
                i++;
            }
            int j = n - 1;
            while (j >= 0 && ((mask >> j) & 1) == 0) {
                j--;
            }
            if (s.charAt(i) == s.charAt(j)) {
                dp[mask] = dp[mask ^ (1 << i) ^ (1 << j)];
                if (dp[mask] != -1) {
                    dp[mask] += 2;
                }
            }
            if (dp[mask] == -1) {
                for (int k = i + 1; k < j; k++) {
                    if (((mask >> k) & 1) == 1) {
                        dp[mask] = Math.max(dp[mask], dp[mask ^ (1 << k)]);
                    }
                }
            }
        }
        int ans = 0;
        for (int mask1 = 0; mask1 < (1 << n); mask1++) {
            if (dp[mask1] != -1) {
                ans = Math.max(ans, dp[mask1] * dp[((1 << n) - 1) ^ mask1]);
            }
        }
        return ans;

=======

        int n = s.length();
        int[] dp = new int[1 << n];
        for (int i = 0; i < n; i++) {
            int mask = 0;
            for (int j = i; j < n; j++) {
                mask |= 1 << s.charAt(j) - 'a';
                dp[mask] = Math.max(dp[mask], j - i + 1);
            }
        }
        for (int i = 0; i < 26; i++) {
            for (int mask = 0; mask < 1 << 26; mask++) {
                if ((mask & 1 << i) != 0) {
                    dp[mask] = Math.max(dp[mask], dp[mask ^ 1 << i]);
                }
            }
        }
        int res = 0;
        for (int mask1 = 0; mask1 < 1 << 26; mask1++) {
            int mask2 = ((1 << 26) - 1) ^ mask1;
            res = Math.max(res, dp[mask1] * dp[mask2]);
        }
        return res;

=======

        int n = s.length();
        int[][] dp = new int[n + 1][n + 1];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (s.charAt(i) == s.charAt(n - j - 1)) {
                    dp[i + 1][j + 1] = dp[i][j] + 1;
                } else {
                    dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]);
                }
            }
        }
        int res = 0;
        for (int i = 0; i < n; i++) {
            res = Math.max(res, dp[i][i] * dp[n][n - i - 1]);
        }
        return res;

=======

        int n = s.length();
        int[] dp = new int[1 << n];
        for (int i = 0; i < 1 << n; i++) {
            String sub = "";
            for (int j = 0; j < n; j++) {
                if (((i >> j) & 1) == 1) {
                    sub += s.charAt(j);
                }
            }
            if (isPalindromic(sub)) {
                dp[i] = sub.length();
            }
        }
        int ans = 0;
        for (int i = 0; i < 1 << n; i++) {
            for (int j = i + 1; j < 1 << n; j++) {
                if ((i & j) == 0) {
                    ans = Math.max(ans, dp[i] * dp[j]);
                }
            }
        }
        return ans;
    }
    private boolean isPalindromic(String s) {
        int n = s.length();
        for (int i = 0; i < n / 2; i++) {
            if (s.charAt(i) != s.charAt(n - i - 1)) {
                return false;
            }
        }
        return true;

=======

        int n = s.length();
        int[] dp = new int[1 << n];
        for (int mask = 0; mask < 1 << n; mask++) {
            if (isPalindrome(s, mask)) {
                dp[mask] = Integer.bitCount(mask);
            }
            for (int submask = mask; submask > 0; submask = (submask - 1) & mask) {
                dp[mask] = Math.max(dp[mask], dp[submask] * dp[mask - submask]);
            }
        }
        return dp[(1 << n) - 1];
    }

    private boolean isPalindrome(String s, int mask) {
        int i = 0, j = s.length() - 1;
        while (i < j) {
            while (i < j && ((mask >> i) & 1) == 0) i++;
            while (i < j && ((mask >> j) & 1) == 0) j--;
            if (s.charAt(i++) != s.charAt(j--)) return false;
        }
        return true;

=======

        int n = s.length();
        char[] str = s.toCharArray();
        int[][] dp = new int[n][n];
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < n - i; j++) {
                if (str[j] == str[i + j]) {
                    dp[j][i + j] = dp[j + 1][i + j - 1] + 2;
                } else {
                    dp[j][i + j] = Math.max(dp[j + 1][i + j], dp[j][i + j - 1]);
                }
            }
        }
        int res = 1;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (dp[0][i] + dp[i + 1][j - 1] + dp[j][n - 1] > res) {
                    res = dp[0][i] + dp[i + 1][j - 1] + dp[j][n - 1];
                }
            }
        }
        return res;

=======

        int n = s.length();
        int[] dp = new int[1 << n];
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                int mask = 0;
                for (int k = i; k <= j; ++k) {
                    mask |= 1 << k;
                }
                if (isPalindrome(s, i, j)) {
                    dp[mask] = j - i + 1;
                }
            }
        }
        for (int i = 0; i < (1 << n); ++i) {
            for (int j = 0; j < n; ++j) {
                if (((i >> j) & 1) == 1) {
                    dp[i] = Math.max(dp[i], dp[i ^ (1 << j)]);
                }
            }
        }
        int ans = 0;
        for (int i = 1; i < (1 << n); ++i) {
            if (dp[i] * dp[((1 << n) - 1) ^ i] > ans) {
                ans = dp[i] * dp[((1 << n) - 1) ^ i];
            }
        }
        return ans;
    }
    private boolean isPalindrome(String s, int i, int j) {
        while (i < j) {
            if (s.charAt(i++) != s.charAt(j--)) {
                return false;
            }
        }
        return true;

=======

        int n = s.length();
        int[] dp = new int[1 << n];
        int[] mask = new int[1 << n];
        for (int i = 0; i < (1 << n); i++) {
            mask[i] = getMask(s, i);
            if (mask[i] == 0) {
                dp[i] = Integer.bitCount(i);
            }
        }
        for (int i = 0; i < (1 << n); i++) {
            for (int j = i; j > 0; j = (j - 1) & i) {
                if (mask[i] == 0) {
                    dp[i] = Math.max(dp[i], dp[j] * dp[i ^ j]);
                }
            }
        }
        return dp[(1 << n) - 1];
    }

    private int getMask(String s, int i) {
        int mask = 0;
        for (int j = 0; j < s.length(); j++) {
            if ((i & (1 << j)) != 0) {
                mask ^= 1 << (s.charAt(j) - 'a');
            }
        }
        return mask;

=======

        int n = s.length();
        int[] dp = new int[1 << n];
        int[] pal = new int[1 << n];
        for (int i = 0; i < (1 << n); i++) {
            int l = 0, r = n - 1;
            while (l < r) {
                while (l < n && (i & (1 << l)) == 0) {
                    l++;
                }
                while (r >= 0 && (i & (1 << r)) == 0) {
                    r--;
                }
                if (l < r) {
                    if (s.charAt(l) != s.charAt(r)) {
                        pal[i] = 0;
                        break;
                    } else {
                        pal[i] = (l == r ? 1 : 2) + pal[i ^ (1 << l) ^ (1 << r)];
                    }
                    l++;
                    r--;
                }
            }
            if (l == r) {
                pal[i] = 1;
            }
        }
        for (int i = 0; i < (1 << n); i++) {
            for (int j = i; j != 0; j = (j - 1) & i) {
                dp[i] = Math.max(dp[i], pal[j] * pal[i ^ j]);
            }
        }
        return dp[(1 << n) - 1];

=======

        int n=s.length();
        int[] dp=new int[1<<n];
        Arrays.fill(dp,-1);
        dp[0]=0;
        for(int mask=0;mask<(1<<n);mask++){
            int count=Integer.bitCount(mask);
            if(dp[mask]==-1) continue;
            for(int i=0;i<n;i++){
                if((mask&(1<<i))==0){
                    dp[mask|(1<<i)]=Math.max(dp[mask|(1<<i)],dp[mask]+(isPalindrome(s,mask,count)?count+1:0));
                }
            }
        }
        int ans=0;
        for(int mask=0;mask<(1<<n);mask++){
            ans=Math.max(ans,dp[mask]*dp[(1<<n)-1-mask]);
        }
        return ans;
    }
    boolean isPalindrome(String s,int mask,int count){
        int i=0,j=count-1;
        while(i<j){
            while(i<count && (mask&(1<<i))==0) i++;
            while(j>=0 && (mask&(1<<j))==0) j--;
            if(s.charAt(i)!=s.charAt(j)) return false;
            i++;j--;
        }
        return true;
