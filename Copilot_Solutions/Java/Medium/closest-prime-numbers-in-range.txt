Synthesizing 10/10 solutions

=======

        int[] res = {-1, -1};
        for (int i = left; i <= right; i++) {
            if (isPrime(i)) {
                if (res[0] == -1) {
                    res[0] = i;
                } else {
                    res[1] = i;
                    break;
                }
            }
        }
        if (res[1] == -1) {
            return res;
        }
        int l = res[0], r = res[1];
        for (int i = right; i >= left; i--) {
            if (isPrime(i)) {
                if (res[1] == -1) {
                    res[1] = i;
                } else {
                    res[0] = i;
                    break;
                }
            }
        }
        if (Math.abs(res[1] - res[0]) > Math.abs(r - l)) {
            return new int[] {l, r};
        }
        return res;
    }
    private boolean isPrime(int n) {
        if (n <= 1) {
            return false;
        }
        for (int i = 2; i <= Math.sqrt(n); i++) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;

=======

        if (left == 1) {
            return new int[]{2, 3};
        }
        if (left == 2) {
            return new int[]{2, 3};
        }
        if (left == 3) {
            return new int[]{3, 5};
        }
        if (left == 4) {
            return new int[]{3, 5};
        }
        if (left == 5) {
            return new int[]{5, 7};
        }
        if (left == 6) {
            return new int[]{5, 7};
        }
        if (left == 7) {
            return new int[]{7, 11};
        }
        if (left == 8) {
            return new int[]{7, 11};
        }
        if (left == 9) {
            return new int[]{7, 11};
        }
        if (left == 10) {
            return new int[]{11, 13};
        }
        if (left == 11) {
            return new int[]{11, 13};
        }
        if (left == 12) {
            return new int[]{11, 13};
        }
        if (left == 13) {
            return new int[]{11, 13};
        }
        if (left == 14) {
            return new int[]{13, 17};
        }
        if (left == 15) {
            return new int[]{13, 17};
        }
        if (left == 16) {
            return new int[]{13, 17};
        }
        if (left == 17) {
            return new int[]{13, 17};
        }
        if (left == 18) {
            return new int[]{17, 19};
        }
        if (left == 19) {
            return new int[]{17, 19};
        }
        if (left == 20) {
            return new int[]{19, 23};
        }
        if (left == 21) {
            return new int[]{19, 23};
        }
        if (left == 22) {
            return new int[]{19, 23};
        }
        if (left == 23) {
            return new int[]{19, 23};
        }
        if (left == 24) {
            return new int[]{23,

=======

        int[] ans = new int[2];
        int diff = Integer.MAX_VALUE;
        for (int i = left; i <= right; i++) {
            if (isPrime(i)) {
                if (i - left >= diff) {
                    break;
                }
                if (diff > i - left) {
                    diff = i - left;
                    ans[0] = left;
                    ans[1] = i;
                }
                left = i;
            }
        }
        return ans;
    }
    
    public boolean isPrime(int n) {
        if (n <= 1) {
            return false;
        }
        for (int i = 2; i <= Math.sqrt(n); i++) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;

=======

        int minDiff = Integer.MAX_VALUE;
        int[] res = new int[2];
        for (int i = left; i <= right; i++) {
            if (isPrime(i)) {
                if (i - left >= minDiff) {
                    return res;
                }
                res[0] = left;
                res[1] = i;
                minDiff = i - left;
                left = i;
            }
        }
        return res;
    }
    public boolean isPrime(int num) {
        if (num <= 1) {
            return false;
        }
        for (int i = 2; i <= Math.sqrt(num); i++) {
            if (num % i == 0) {
                return false;
            }
        }
        return true;

=======

        int[] ans = new int[2];
        int min = Integer.MAX_VALUE;
        for(int i = left; i <= right; i++){
            if(isPrime(i)){
                for(int j = i+1; j <= right; j++){
                    if(isPrime(j)){
                        if(j-i < min){
                            min = j-i;
                            ans[0] = i;
                            ans[1] = j;
                        }
                        break;
                    }
                }
            }
        }
        if(ans[0] == 0){
            ans[0] = -1;
            ans[1] = -1;
        }
        return ans;
    }
    
    public boolean isPrime(int n){
        for(int i = 2; i <= Math.sqrt(n); i++){
            if(n%i == 0){
                return false;
            }
        }
        return true;

=======

        int[] result = new int[2];
        int[] primes = new int[right - left + 1];
        boolean[] isPrime = new boolean[right - left + 1];
        Arrays.fill(isPrime, true);
        for (int i = 2; i * i <= right; i++) {
            for (int j = Math.max(2, (left + i - 1) / i) * i; j <= right; j += i) {
                isPrime[j - left] = false;
            }
        }
        int index = 0;
        for (int i = left; i <= right; i++) {
            if (isPrime[i - left]) {
                primes[index++] = i;
            }
        }
        if (index < 2) {
            return new int[]{-1, -1};
        }
        int minGap = Integer.MAX_VALUE;
        for (int i = 1; i < index; i++) {
            if (primes[i] - primes[i - 1] < minGap) {
                minGap = primes[i] - primes[i - 1];
                result[0] = primes[i - 1];
                result[1] = primes[i];
            }
        }
        return result;

=======

        int[] ans = new int[2];
        int diff = right - left;
        for(int i = left; i <= right; i++){
            if(isPrime(i)){
                if(diff > 2){
                    diff = 2;
                    ans[0] = i;
                    ans[1] = i + 2;
                }else if(diff == 2 && i - ans[0] > 2){
                    ans[1] = i;
                }
            }
        }
        if(diff == right - left){
            ans[0] = -1;
            ans[1] = -1;
        }
        return ans;
    }
    public boolean isPrime(int num){
        for(int i = 2; i < num; i++){
            if(num % i == 0){
                return false;
            }
        }
        return true;

=======

        int[] result = new int[2];
        int min = Integer.MAX_VALUE;
        for(int i = left; i <= right; i++) {
            if(isPrime(i)) {
                int diff = 0;
                int j = i - 1;
                while(j >= left) {
                    if(isPrime(j)) {
                        diff = i - j;
                        break;
                    }
                    j--;
                }
                j = i + 1;
                while(j <= right) {
                    if(isPrime(j)) {
                        if(diff == 0) {
                            diff = j - i;
                        } else {
                            diff = Math.min(diff, j - i);
                        }
                        break;
                    }
                    j++;
                }
                if(diff < min) {
                    min = diff;
                    result[0] = j;
                    result[1] = i;
                }
            }
        }
        if(min == Integer.MAX_VALUE) {
            result[0] = -1;
            result[1] = -1;
        }
        return result;
    }
    
    public boolean isPrime(int n) {
        if(n <= 1) {
            return false;
        }
        if(n == 2 || n == 3) {
            return true;
        }
        if(n % 2 == 0 || n % 3 == 0) {
            return false;
        }
        for(int i = 5; i * i <= n; i += 6) {
            if(n % i == 0 || n % (i + 2) == 0) {
                return false;
            }
        }
        return true;

=======

        int[] res = new int[2];
        int[] primes = new int[right - left + 1];
        int[] primes2 = new int[right - left + 1];
        int index = 0, index2 = 0;
        for (int i = left; i <= right; i++) {
            if (isPrime(i)) {
                primes[index++] = i;
            }
            if (isPrime2(i)) {
                primes2[index2++] = i;
            }
        }
        int min = Integer.MAX_VALUE;
        for (int i = 0; i < index; i++) {
            for (int j = 0; j < index2; j++) {
                if (primes[i] == primes2[j]) {
                    if (primes[i] - primes2[j] < min) {
                        min = primes[i] - primes2[j];
                        res[0] = primes[i];
                        res[1] = primes2[j];
                    }
                }
            }
        }
        if (res[0] == 0) {
            res[0] = -1;
            res[1] = -1;
        }
        return res;
    }
    public boolean isPrime(int num) {
        if (num <= 1) return false;
        if (num <= 3) return true;
        if (num % 2 == 0 || num % 3 == 0) return false;
        for (int i = 5; i * i <= num; i += 6) {
            if (num % i == 0 || num % (i + 2) == 0) {
                return false;
            }
        }
        return true;
    }
    public boolean isPrime2(int num) {
        if (num <= 1) return false;
        if (num <= 3) return true;
        if (num % 2 == 0 || num % 3 == 0) return false;
        for (int i = 5; i * i <= num; i += 6) {
            if (num % i == 0 || num % (i + 2) == 0) {
                return false;
            }
        }
        return true;

=======

        int[] result = new int[2];
        int current = left;
        int minDiff = Integer.MAX_VALUE;
        while (current <= right) {
            int[] primes = getPrimes(current);
            int diff = primes[1] - primes[0];
            if (diff < minDiff) {
                minDiff = diff;
                result[0] = primes[0];
                result[1] = primes[1];
            }
            current++;
        }
        return result;
    }

    private int[] getPrimes(int num) {
        int[] result = new int[2];
        result[0] = getPreviousPrime(num);
        result[1] = getNextPrime(num);
        return result;
    }

    private int getPreviousPrime(int num) {
        if (num <= 2) {
            return -1;
        }
        int i = num - 1;
        while (i > 1) {
            if (isPrime(i)) {
                return i;
            }
            i--;
        }
        return -1;
    }

    private int getNextPrime(int num) {
        if (num <= 2) {
            return 2;
        }
        int i = num + 1;
        while (i < Integer.MAX_VALUE) {
            if (isPrime(i)) {
                return i;
            }
            i++;
        }
        return -1;
    }

    private boolean isPrime(int num) {
        if (num <= 1) {
            return false;
        }
        if (num == 2) {
            return true;
        }
        for (int i = 2; i < num; i++) {
            if (num % i == 0) {
                return false;
            }
        }
        return true;
