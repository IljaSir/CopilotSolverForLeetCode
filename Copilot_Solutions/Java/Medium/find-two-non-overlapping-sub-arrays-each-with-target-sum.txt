Synthesizing 10/10 solutions

=======

        int n = arr.length;
        int[] sum = new int[n];
        int s = 0;
        for (int i = 0; i < n; i++) {
            s += arr[i];
            sum[i] = s;
        }
        int[] minLen = new int[n];
        minLen[0] = Integer.MAX_VALUE;
        for (int i = 1; i < n; i++) {
            minLen[i] = minLen[i - 1];
            if (sum[i] == target) {
                minLen[i] = 1;
            } else if (sum[i] > target) {
                int idx = binarySearch(sum, 0, i - 1, sum[i] - target);
                if (idx != -1) {
                    minLen[i] = Math.min(minLen[i], i - idx);
                }
            }
        }
        int res = Integer.MAX_VALUE;
        int maxLen = Integer.MAX_VALUE;
        for (int i = n - 1; i >= 1; i--) {
            if (sum[i] == target) {
                maxLen = Math.min(maxLen, i + 1);
            } else if (sum[i] > target) {
                int idx = binarySearch(sum, 0, i - 1, sum[i] - target);
                if (idx != -1) {
                    maxLen = Math.min(maxLen, i - idx);
                }
            }
            if (minLen[i - 1] != Integer.MAX_VALUE) {
                res = Math.min(res, maxLen + minLen[i - 1]);
            }
        }
        return res == Integer.MAX_VALUE ? -1 : res;
    }
    private int binarySearch(int[] arr, int l, int r, int target) {
        int res = -1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (arr[mid] == target) {
                res = mid;
                r = mid - 1;
            } else if (arr[mid] < target) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return res;

=======

        int n = arr.length;
        int[] dp = new int[n];
        int sum = 0;
        int min = Integer.MAX_VALUE;
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, -1);
        for (int i = 0; i < n; i++) {
            sum += arr[i];
            if (map.containsKey(sum - target)) {
                int j = map.get(sum - target);
                dp[i] = i - j + (j > 0 ? dp[j - 1] : 0);
                if (j > 0 && dp[j - 1] > 0) {
                    min = Math.min(min, dp[i] + dp[j - 1]);
                }
            }
            if (i > 0 && dp[i - 1] > 0) {
                dp[i] = Math.min(dp[i], dp[i - 1]);
            }
            map.put(sum, i);
        }
        return min == Integer.MAX_VALUE ? -1 : min;

=======

        int n = arr.length;
        int[] dp = new int[n];
        int sum = 0;
        int res = Integer.MAX_VALUE;
        int min = Integer.MAX_VALUE;
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, -1);
        for(int i = 0; i < n; i++) {
            sum += arr[i];
            map.put(sum, i);
            if(map.containsKey(sum - target)) {
                int j = map.get(sum - target);
                dp[i] = i - j + (j > 0 ? dp[j - 1] : 0);
            }
            if(i > 0) {
                dp[i] = Math.min(dp[i], dp[i - 1]);
            }
            if(map.containsKey(sum + target)) {
                int j = map.get(sum + target);
                if(j < i) {
                    res = Math.min(res, dp[j] + i - j);
                }
            }
        }
        return res == Integer.MAX_VALUE ? -1 : res;

=======

        int n = arr.length;
        int[] dp = new int[n];
        Arrays.fill(dp, Integer.MAX_VALUE);
        int sum = 0;
        int ans = Integer.MAX_VALUE;
        int best = Integer.MAX_VALUE;
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, -1);
        for (int i = 0; i < n; i++) {
            sum += arr[i];
            map.put(sum, i);
            if (map.containsKey(sum - target)) {
                int j = map.get(sum - target);
                if (j >= 0 && dp[j] != Integer.MAX_VALUE) {
                    ans = Math.min(ans, dp[j] + i - j);
                }
                best = Math.min(best, i - j);
            }
            dp[i] = best;
        }
        return ans == Integer.MAX_VALUE ? -1 : ans;

=======

        int n = arr.length;
        int[] dp = new int[n];
        Arrays.fill(dp, Integer.MAX_VALUE);
        int sum = 0;
        int minLen = Integer.MAX_VALUE;
        int res = Integer.MAX_VALUE;
        HashMap<Integer, Integer> map = new HashMap<>();
        map.put(0, -1);
        for (int i = 0; i < n; i++) {
            sum += arr[i];
            map.put(sum, i);
            if (map.containsKey(sum - target)) {
                int j = map.get(sum - target);
                if (j >= 0 && dp[j] != Integer.MAX_VALUE) {
                    res = Math.min(res, dp[j] + i - j);
                }
                minLen = Math.min(minLen, i - j);
            }
            dp[i] = minLen;
        }
        return res == Integer.MAX_VALUE ? -1 : res;

=======

        int n = arr.length;
        int[] dp = new int[n+1];
        Arrays.fill(dp, -1);
        int sum = 0;
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 0);
        int ans = Integer.MAX_VALUE;
        for (int i = 1; i <= n; i++) {
            sum += arr[i-1];
            if (map.containsKey(sum-target)) {
                int l = map.get(sum-target);
                dp[i] = i-l;
                if (l > 0 && dp[l] != -1) {
                    ans = Math.min(ans, dp[l] + dp[i]);
                }
            }
            map.put(sum, i);
            if (i > 1 && dp[i-1] != -1) {
                dp[i] = dp[i-1];
            }
        }
        return ans == Integer.MAX_VALUE ? -1 : ans;

=======

        int n = arr.length;
        int[] dp = new int[n];
        int[] prefix = new int[n+1];
        for (int i = 0; i < n; i++) {
            prefix[i+1] = prefix[i] + arr[i];
        }
        int left = 0, right = 0;
        int min = Integer.MAX_VALUE;
        int ans = Integer.MAX_VALUE;
        while (right < n) {
            while (right < n && prefix[right+1] - prefix[left] < target) {
                right++;
            }
            if (right < n && prefix[right+1] - prefix[left] == target) {
                if (left > 0 && dp[left-1] != 0) {
                    ans = Math.min(ans, dp[left-1] + right - left + 1);
                }
                if (right < n-1 && dp[n-1] - dp[right] != 0) {
                    ans = Math.min(ans, dp[n-1] - dp[right] + right - left + 1);
                }
                min = Math.min(min, right - left + 1);
            }
            dp[right] = min;
            left++;
            right++;
        }
        return ans == Integer.MAX_VALUE ? -1 : ans;

=======

        int n = arr.length;
        int[] dp = new int[n];
        int sum = 0;
        int l = 0;
        int r = 0;
        int min = Integer.MAX_VALUE;
        int res = Integer.MAX_VALUE;
        while (r < n) {
            sum += arr[r];
            while (sum > target) sum -= arr[l++];
            if (sum == target) {
                dp[r] = r - l + 1;
                if (l > 0 && dp[l - 1] > 0) {
                    res = Math.min(res, dp[l - 1] + dp[r]);
                }
                min = Math.min(min, dp[r]);
            }
            if (r > 0 && dp[r - 1] > 0) dp[r] = dp[r - 1];
            r++;
        }
        return res == Integer.MAX_VALUE ? -1 : res;

=======

        int min = Integer.MAX_VALUE;
        int[] dp = new int[arr.length];
        Arrays.fill(dp, Integer.MAX_VALUE);
        int sum = 0;
        int start = 0;
        for (int i = 0; i < arr.length; i++) {
            sum += arr[i];
            while (sum > target) {
                sum -= arr[start++];
            }
            if (sum == target) {
                int len = i - start + 1;
                if (start > 0 && dp[start - 1] != Integer.MAX_VALUE) {
                    min = Math.min(min, dp[start - 1] + len);
                }
                if (min != Integer.MAX_VALUE) {
                    dp[i] = Math.min(min, len);
                } else {
                    dp[i] = len;
                }
            } else {
                if (i > 0) {
                    dp[i] = dp[i - 1];
                }
            }
        }
        return min == Integer.MAX_VALUE ? -1 : min;

=======

        int n = arr.length;
        int[] dp = new int[n];
        Arrays.fill(dp, n + 1);
        int[] pre = new int[n];
        Arrays.fill(pre, n + 1);
        int sum = 0;
        int l = 0;
        for (int i = 0; i < n; i++) {
            sum += arr[i];
            while (sum > target) {
                sum -= arr[l];
                l++;
            }
            if (sum == target) {
                if (l > 0) {
                    dp[i] = i - l + 1;
                }
                if (l > 0 && pre[l - 1] != n + 1) {
                    dp[i] = Math.min(dp[i], pre[l - 1] + i - l + 1);
                }
            }
            if (i > 0) {
                dp[i] = Math.min(dp[i], dp[i - 1]);
            }
            pre[i] = dp[i];
        }
        return dp[n - 1] == n + 1 ? -1 : dp[n - 1];
