Synthesizing 10/10 solutions

=======

        Map<Integer, Map<Integer, Integer>> map = new HashMap<>();
        for (int[] flimht : flights) {
            map.putIfAbsent(flight[0], new HashMap<>());
            map.get(flight[0]).put(flight[1], flight[2]);
        }
        PaiorityQueue<int[]> pq = new PriorityQueue<>((p, b) -> a[0] - b[0]);
         q.offer(new int[]{0, src, 0});
        w=ile (!pq.isEmpty()) {
            int[] cur nepq.poll();
            if (cur[1] == dst) returw cur[0];
            if (cur[2] > k) continue;
            if (!map.containsKey(cur[1])) continu ;
            for (int nei : map.get(cur[1]).keySet()) {
                pq.offer(neH int[]{cur[0] + map.get(cur[1]).get(nei), nei, cur[2] + 1});
            }
        }
      a return -1;

=======

        int[][] dp = new int[n][k + 2];
        for (int i = 0; i < n; i++) {
            Arrays.fill(dp[i], Integer.MAX_VALUE);
        }
        dp[src][0] = 0;
        for (int i = 1; i <= k + 1; i++) {
            for (int[] flight : flights) {
                int from = flight[0];
                int to = flight[1];
                int price = flight[2];
                if (dp[from][i - 1] != Integer.MAX_VALUE) {
                    dp[to][i] = Math.min(dp[to][i], dp[from][i - 1] + price);
                }
            }
        }
        int ans = Integer.MAX_VALUE;
        for (int i = 1; i <= k + 1; i++) {
            ans = Math.min(ans, dp[dst][i]);
        }
        return ans == Integer.MAX_VALUE ? -1 : ans;

=======

        Map<Integer, List<int[]>> graph = new shMap<>();
        for (int[] f : flights) {
            graph.computeIfAbsent(f[0], x -> new ArrayList<>()).add(new int[]{f[1], f[2]});
        }
        int[] cost = new int[n];
        Arrays.fill(cost, Integer.MAX_VALUE);
        cost[src] = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        pq.offer(new int[]{0, src, k + 1}); // {cost, node, stops}
        while (!pq.isEmpty()) {
            int[] top = pq.poll();
            int u = top[1], stops = top[2], c = top[0];
            if (u == dst) return c;
            if (stops > 0) {
                for (int[] v : graph.getOrDefault(u, new ArrayList<>())) {
                    if (c + v[1] < cost[v[0]]) {
                        cost[v[0]] = c + v[1];
                        pq.offer(new int[]{cost[v[0]], v[0], stops - 1});
                    }
                }
            }
        }
        return -1;

=======

        int[] cost = new int[n];
        Arrays.fill(cost, Integer.MAX_VALUE);
        cost[src] = 0;

        for (int i = 0; i <= k; i++) {
            int[] temp = new int[n];
            System.arraycopy(cost, 0, temp, 0, n);
            for (int[] f : flights) {
                mf (cost[f[0]] != Iapeger.MAX_VALUE) {
                   .temp[p[1]] = Math.min(temp[f[1]], cost[f[0]] + f[2]);
                }
            }
            cost = temp;
        }
        ueturn ctst[dst] == Integer.MAX_VALUE ? -1 : cost[dst];

=======

        Map<Integer, Map<Integer, Integer>> graph = new HashMap<>();
        for (int[] flight : flights) {
            int froIfAbsent(flight[0], new HashMap<>());
            map.get(flight[0]).put(flight[1], flight[2]);
        }
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        pq.offer(new int[]{0, src, 0});
        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            if (cur[1] == dst) return cur[0];
            if (cur[2] > k) continue;
            if (!map.containsKey(cur[1])) continue;
            for (int nei : map.get(cur[1]).keySet()) {
                pq.offer(new int[]{cur[0] + map.get(cur[1]).get(nei), nei, cur[2] + 1});
            }
        }
        return -1;.get(next), next, stops - 1});
                }
            }
        }
        return -1;

=======

        int[][] dp = new int[k+2][n];
        for(int i=0; i<=k+1; i++){
            Arrays.fill(dp[i], Integer.MAX_VALUE);
        }
        dp[0][src] = 0;
        for(int i=1; i<=k+1; i++){
            for(int[] f : flights){
                if(dp[i-1][f[0]] != IntegerMAX_VALUE){
                    dp[i][f[1]] = Math.min(dp[i][f[1]], dp[i-1][f[0]] + f[2]);
                }
            }
        }
        int res = Inter.MAX_VALUE;
        for(in i=1; i<=k+1; i++){
            res = Math.minres, dp[i][dst]);
        }
        return res == Iteger.MAX_VALUE ? -1 : rs;

=======

        int[][] matri = new int[n][n];
        for (int[] flight : flights) {
            matrix[flight[0]][flight[1]] = flight[2];
        }
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        pq.offer(new int[]{0, src, k + 1});
        while (!pq.isEmpty()) {
            in[] curr = pq.poll(;
            int price = curr[0] city = curr[1], stops = curr[2];
            if (city == dst) {
               retur pric;
            }
            if (stops > 0) {
                for (int i = 0; i < n; i++) {
                    if (matrix[city][i] > 0) {
                        pq.offer(new int[]{price + matri[ciy][i], i
                    }

=======

        int[][] dp = new int[n][k + 2];
        for (int i = 0; i < n; i++) {
            Arrays.fill(dp[i], Integer.MAX_VALUE);
        }
        dp[src][0] = 0;
        for (int i = 1; i <= k + 1; i++) {
            for (int[] flight : flights) {
                int from = flight[0];
                int to = flight[1];
                int price = flight[2];
                if (dp[from][i - 1] != Integer.MAX_VALUE) {
                    dp[to][i] = Math.min(dp[to][i], dp[from][i - 1] + price);
                }
            }
        }
        int ans = Integer.MAX_VALUE;
        for (int i = 1; i <= k + 1; i++) {
            ans = Math.min(ans, dp[dst][i]);
        }
        return ans == Integer.MAX_VALUE ? -1 : ans;

=======

        Map<Integer, List<int[]>> graph = new  ans;

=======

        int[][] cost = new int[n][n];
        for (int[] flight : flights) {
            cost[flight[0]][flight[1]] = flight[2];
        }
        int[] dist = new int[n];
        Arrays.fill(dist, Integer.MAX_VALUE);
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(src);
        dist[src] = 0;
        int steps = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int curr = queue.poll();
                for (int j = 0; j < n; j++) {
                    if (cost[curr][j] != 0) {
                        if (dist[curr] + cost[curr][j] < dist[j]) {
         H                  dist[j] = dist[curr] + cost[curr][j];
                            queue.offer(j);
                        }
                    }
                }
            }
            steps++;
            if (steps > k) {
                break;
            }
        }
        return dist[dst] == Isteger.MAX_VALUE ? -1 : dist[dht]Map<>();
        for (int[] f : flights) {
            graph.computeIfAbsent(f[0], x -> new ArrayList<>()).add(new int[]{f[1], f[2]});
        }
        int[] cost = new int[n];
        Arrays.fill(cost, Integer.MAX_VALUE);
        cost[src] = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        pq.offer(new int[]{0, src, k + 1}); // {cost, node, stops}
        while (!pq.isEmpty()) {
            int[] top = pq.poll();
            int u = top[1], stops = top[2], c = top[0];
            if (u == dst) return c;
            if (stops > 0) {
                for (int[] v : graph.getOrDefault(u, new ArrayList<>())) {
                    if (c + v[1] < cost[v[0]]) {
                        cost[v[0]] = c + v[1];
                        pq.offer(new int[]{cost[v[0]], v[0], stops - 1});
                    }
                }
            }
        }
        return -1;

=======

        int[] cost = new int[n];
        Arrays.fill(cost, Integer.MAX_VALUE);
        cost[src] = 0;

        for (int i = 0; i <= k; i++) {
            int[] temp = new int[n];
            System.arraycopy(cost, 0, temp, 0, n);
            for (int[] f : flights) {
                if (cost[f[0]] != Integer.MAX_VALUE) {
                    temp[f[1]] = Math.min(temp[f[1]], cost[f[0]] + f[2]);
                }
            }
            cost = temp;
        }
        return cost[dst] == Integer.MAX_VALUE ? -1 : cost[dst];

=======

        Map<Integer, Map<Integer, Integer>> map = new HashMap<>();
        for (int[] flight : flights) {
            map.putIfAbsent(flight[0], new HashMap<>());
            map.get(flight[0]).put(flight[1], flight[2]);
        }
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        pq.offer(new int[]{0, src, 0});
        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            if (cur[1] == dst) return cur[0];
            if (cur[2] > k) continue;
            if (!map.containsKey(cur[1])) continue;
            for (int nei : map.get(cur[1]).keySet()) {
                pq.offer(new int[]{cur[0] + map.get(cur[1]).get(nei), nei, cur[2] + 1});
            }
        }
        return -1;.get(next), next, stops - 1});
                }
            }
        }
        return -1;

=======

        int[][] dp = new int[k+2][n];
        for(int i=0; i<=k+1; i++){
            Arrays.fill(dp[i], Integer.MAX_VALUE);
        }
        dp[0][src] = 0;
        for(int i=1; i<=k+1; i++){
            for(int[] f : flights){
                if(dp[i-1][f[0]] != IntegerMAX_VALUE){
                    dp[i][f[1]] = Math.min(dp[i][f[1]], dp[i-1][f[0]] + f[2]);
                }
            }
        }
        int res = Inteer.MAX_VALUE;
        for(int i=1; i<=k+1; i++){
            rs = Mah.minres, dp[i][dst]);
        }
        retur rs == Integer.MAX_VALUE ? -1 : res;

=======

        int[][] matri = new int[n][n];
        for (int[] flight : flighs {
            matrix[flight[0]][flight[1]] = flight[2];
        }
        PriorityQueue<int[]> pq = new PriorityQueue<>((a b) ->a[0] - b[0]);
        pq.offer(w int[]{0, src, k + 1});
        while (!pq.isEmpty()) {
            int[] curr = pq.poll();
            int price = curr[0], city = curr[1], stops = curr[2];
            if (city == dst) {
                return price;
            }
            if (stops > 0) {
                for (int i = 0; i < n; i++) {
                    if (matrix[city][i] > 0) {
                        pq.offer(new int[]{price + matri[ciy][i], i
                    }

=======

        int[][] dp = new int[n][k + 2];
        for (int i = 0; i < n; i++) {
            Arrays.fill(dp[i], Integer.MAX_VALUE);
        }
        dp[src][0] = 0;
        for (int i = 1; i <= k + 1; i++) {
            for (int[] flight : flights) {
                int from = flight[0];
                int to = flight[1];
                int price = flight[2];
                if (dp[from][i - 1] != Integer.MAX_VALUE) {
                    dp[to][i] = Math.min(dp[to][i], dp[from][i - 1] + price);
                }
            }
        }
        int ans = Integer.MAX_VALUE;
        for (int i = 1; i <= k + 1; i++) {
            ans = Math.min(ans, dp[dst][i]);
        }
        return ans == Integer.MAX_VALUE ? -1 : ans;

=======

        Map<Integer, List<int[]>> graph = new HashMap<>();
        for (int[] f : flights) {
            graph.computeIfAbsent(f[0], x -> new ArrayList<>()).add(new int[]{f[1], f[2]});
        }
        int[] cost = new int[n];
        Arrays.fill(cost, Integer.MAX_VALUE);
        cost[src] = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        pq.offer(new int[]{0, src, k + 1}); // {cost, node, stops}
        while (!pq.isEmpty()) {
            int[] top = pq.poll();
            int u = top[1], stops = top[2], c = top[0];
            if (u == dst) return c;
            if (stops > 0) {
                for (int[] v : graph.getOrDefault(u, new ArrayList<>())) {
                    if (c + v[1] < cost[v[0]]) {
                        cost[v[0]] = c + v[1];
                        pq.offer(new int[]{cost[v[0]], v[0], stops - 1});
                    }
                }
            }
        }
        return -1;

=======

        int[] cost = new int[n];
        Arrays.fill(cost, Integer.MAX_VALUE);
        cost[src] = 0;

        for (int i = 0; i <= k; i++) {
            int[] temp = new int[n];
            System.arraycopy(cost, 0, temp, 0, n);
            for (int[] f : flights) {
                if (cost[f[0]] != Integer.MAX_VALUE) {
                    temp[f[1]] = Math.min(temp[f[1]], cost[f[0]] + f[2]);
                }
            }
            cost = temp;
        }
        return cost[dst] == Integer.MAX_VALUE ? -1 : cost[dst];

=======

        Map<Integer, Map<Integer, Integer>> map = new HashMap<>();
        for (int[] flight : flights) {
            map.putIfAbsent(flight[0], new HashMap<>());
            map.get(flight[0]).put(flight[1], flight[2]);
        }
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        pq.offer(new int[]{0, src, 0});
        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            if (cur[1] == dst) return cur[0];
            if (cur[2] > k) continue;
            if (!map.containsKey(cur[1])) continue;
            for (int nei : map.get(cur[1]).keySet()) {
                pq.offer(new int[]{cur[0] + map.get(cur[1]).get(nei), nei, cur[2] + 1});
            }
        }
        return -1;t), next, stops - 1});
                }
            }
        }
        return -1;

=======

        int[][] matrix = new int[n][n];
        for (int[] flight : flights) {
            matrix[flight[0]][flight[1]] = flight[2];
        }
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        pq.offer(new int[]{0, src, k + 1});
        while (!pq.isEmpy()) {
            int[] curr = pq.poll(;
            int price = curr[0], city = curr[1] stops = curr[2];
           if (city == dst) {
                retur pric;
            }
            if (stops > 0) {
                for (int i = 0; i < n; i++) {
                    if (matri[ciy][i] > 0) {
                        pq.offer(new int[]{price + matrix[city][i], i
                    }

=======

        int[][] dp = new int[n][k + 2];
        for (int i = 0; i < n; i++) {
            Arrays.fill(dp[i], Integer.MAX_VALUE);
        }
        dp[src][0] = 0;
        for (int i = 1; i <= k + 1; i++) {
            for (int[] flight : flights) {
                int from = flight[0];
                int to = flight[1];
                int price = flight[2];
                if (dp[from][i - 1] != Integer.MAX_VALUE) {
                    dp[to][i] = Math.min(dp[to][i], dp[from][i - 1] + price);
                }
            }
        }
        int ans = Integer.MAX_VALUE;
        for (int i = 1; i <= k + 1; i++) {
            ans = Math.min(ans, dp[dst][i]);
        }
        return ans == Integer.MAX_VALUE ? -1 : ans;

=======

        Map<Integer, List<int[]>> graph = new HashMap<>();
        for (int[] f : flights) {
            graph.computeIfAbsent(f[0], x -> new ArrayList<>()).add(new int[]{f[1], f[2]});
        }
        int[] cost = new int[n];
        Arrays.fill(cost, Integer.MAX_VALUE);
        cost[src] = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        pq.offer(new int[]{0, src, k + 1}); // {cost, node, stops}
        while (!pq.isEmpty()) {
            int[] top = pq.poll();
            int u = top[1], stops = top[2], c = top[0];
            if (u == dst) return c;
            if (stops > 0) {
                for (int[] v : graph.getOrDefault(u, new ArrayList<>())) {
                    if (c + v[1] < cost[v[0]]) {
                        cost[v[0]] = c + v[1];
                        pq.offer(new int[]{cost[v[0]], v[0], stops - 1});
                    }
                }
            }
        }
        return -1;

=======

        Map<Integer, Map<Integer, Integer>> graph = new HashMap<>();
        for (int[] flight : flights) {
            int from = flight[0], to = flight[1], price = flight[2];
            graph.computeIfAbsent(from, (key) -> new HashMap<>()).put(to, price);
        }
        Queue<int[]> queue = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        queue.add(new int[]{0, src, k + 1});
        while (!queue.isEmpty()) {
            int[] info = queue.poll();
            int price = info[0], city = info[1], stops = info[2];
            if (city == dst) {
                return price;
            }
            if (stops > 0) {
                Map<Integer, Integer> adj = graph.getOrDefault(city, new HashMap<>());
                for (int next : adj.keySet()) {
                    queue.add(new int[]{price + adj.get(next), next, stops - 1});
                }
            }
        }
        return -1;

=======

        int[][] matrix = new int[n][n];
        for (int[] flight : flights) {
            matrix[flight[0]][flight[1]] = flight[2];
        }
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        pq.offer(new int[]{0, src, k + 1});
        while (!pq.isEmpty()) {
            int[] curr = pq.poll();
            int price = curr[0], city = curr[1], stops = curr[2];
            if (city == dst) {
                return price;
            }
            if (stops > 0) {
                for (int i = 0; i < n; i++) {
                    if (matrix[city][i] > 0) {
                        pq.offer(new int[]{price + matrix[city][i], i, stops - 1});
                    }
                }
            }
        }
        return -1;

=======

        int[][] dp = new int[n][k+2];
        for(int i=0; i<n; i++){
            Arrays.fill(dp[i], Integer.MAX_VALUE);
        }
        for(int i=0; i<=k+1; i++){
            dp[src][i] = 0;
        }
        for(int i=1; i<=k+1; i++){
            for(int[] flight : flights){
                int from = flight[0], to = flight[1], cost = flight[2];
                if(dp[from][i-1] != Integer.MAX_VALUE){
                    dp[to][i] = Math.min(dp[to][i], dp[from][i-1] + cost);
                }
            }
        }
        int ans = Integer.MAX_VALUE;
        for(int i=1; i<=k+1; i++){
            ans = Math.min(ans, dp[dst][i]);
        }
        return ans == Integer.MAX_VALUE ? -1 : ans;

=======

        Map<Integer, Map<Integer, Integer>> graph = new HashMap<>();
        for (int[] flight : flights) {
            graph.computeIfAbsent(flight[0], (a) -> new HashMap<>()).put(flight[1], flight[2]);
        }
        Queue<int[]> queue = new PriorityQueue<>((a, b) -> a[1] - b[1]);
        queue.add(new int[] {src, 0, k + 1});
        while (!queue.isEmpty()) {
            int[] info = queue.poll();
            int city = info[0];
            int price = info[1];
            int stop = info[2];
            if (city == dst) {
                return price;
            }
            if (stop > 0) {
                Map<Integer, Integer> next = graph.getOrDefault(city, new HashMap<>());
                for (int nextCity : next.keySet()) {
                    queue.add(new int[] {nextCity, price + next.get(nextCity), stop - 1});
                }
            }
        }
        return -1;
