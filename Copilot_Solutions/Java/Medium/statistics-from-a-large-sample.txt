Synthesizing 10/10 solutions

=======

        int min = -1;
        int max = -1;
        double mean = 0;
        double median = 0;
        int mode = 0;
        int total = 0;
        int sum = 0;
        int modeCount = 0;
        int medianCount = 0;
        int median1 = 0;
        int median2 = 0;
        for (int i = 0; i < count.length; i++) {
            int c = count[i];
            if (c == 0) {
                continue;
            }
            if (min == -1) {
                min = i;
            }
            max = i;
            sum += i * c;
            total += c;
            if (c > modeCount) {
                modeCount = c;
                mode = i;
            }
            if (total >= (total + 1) / 2) {
                medianCount++;
                if (medianCount == 1) {
                    median1 = i;
                } else if (medianCount == 2) {
                    median2 = i;
                }
            }
        }
        mean = (double) sum / total;
        if (medianCount == 1) {
            median = median1;
        } else {
            median = (median1 + median2) / 2.0;
        }
        return new double[] {min, max, mean, median, mode};

=======

        double[] result = new double[5];
        int min = 0;
        int max = 255;
        while(count[min] == 0) min++;
        while(count[max] == 0) max--;
        result[0] = min;
        result[1] = max;
        int sum = 0;
        int mode = 0;
        int maxCount = 0;
        int median = 0;
        int medianCount = 0;
        int medianIndex = 0;
        for(int i = min; i <= max; i++) {
            sum += count[i] * i;
            if(count[i] > maxCount) {
                maxCount = count[i];
                mode = i;
            }
            medianCount += count[i];
        }
        result[2] = sum * 1.0 / (max - min + 1);
        result[4] = mode;
        int medianIndex1 = 0;
        int medianIndex2 = 0;
        if(medianCount % 2 == 0) {
            medianIndex1 = medianCount / 2;
            medianIndex2 = medianIndex1 + 1;
        } else {
            medianIndex1 = medianIndex2 = medianCount / 2 + 1;
        }
        int i = min;
        while(medianIndex1 > 0) {
            medianIndex1 -= count[i];
            i++;
        }
        medianIndex1 = i - 1;
        if(medianIndex1 == medianIndex2) {
            result[3] = medianIndex1;
        } else {
            i = min;
            while(medianIndex2 > 0) {
                medianIndex2 -= count[i];
                i++;
            }
            medianIndex2 = i - 1;
            result[3] = (medianIndex1 + medianIndex2) / 2.0;
        }
        return result;

=======

        double min = 0, max = 0, mean = 0, median = 0, mode = 0;
        double sum = 0;
        int total = 0;
        int modeCount = 0;
        int modeIndex = 0;
        boolean isFirst = true;
        for(int i = 0; i < count.length; i++) {
            total += count[i];
            sum += count[i] * i;
            if(count[i] > modeCount) {
                modeCount = count[i];
                modeIndex = i;
            }
            if(count[i] > 0 && isFirst) {
                min = i;
                isFirst = false;
            }
            if(count[i] > 0) {
                max = i;
            }
        }
        mean = sum / total;
        int half = total / 2;
        int countSoFar = 0;
        for(int i = 0; i < count.length; i++) {
            countSoFar += count[i];
            if(countSoFar > half) {
                if(total % 2 == 1) {
                    median = i;
                } else {
                    median = (i + getPrevNonZero(count, i)) / 2.0;
                }
                break;
            }
        }
        mode = modeIndex;
        return new double[]{min, max, mean, median, mode};
    }
    private int getPrevNonZero(int[] count, int index) {
        for(int i = index - 1; i >= 0; i--) {
            if(count[i] > 0) {
                return i;
            }
        }
        return 0;

=======

        double[] ans = new double[5];
        int min = -1, max = -1, mode = -1;
        long sum = 0;
        int total = 0;
        for (int i = 0; i < count.length; i++) {
            if (count[i] > 0) {
                if (min == -1) min = i;
                max = i;
                sum += i * count[i];
                total += count[i];
                if (mode == -1 || count[i] > count[mode]) mode = i;
            }
        }
        ans[0] = min;
        ans[1] = max;
        ans[2] = 1.0 * sum / total;
        if (total % 2 == 1) {
            int i = 0;
            while (count[i] == 0) i++;
            int j = total / 2;
            while (j > 0) {
                j -= count[i];
                i++;
            }
            ans[3] = i - 1;
        } else {
            int i = 0;
            while (count[i] == 0) i++;
            int j = total / 2;
            while (j > 0) {
                j -= count[i];
                i++;
            }
            ans[3] = i - 1;
            while (count[i] == 0) i++;
            ans[3] = (ans[3] + i) / 2.0;
        }
        ans[4] = mode;
        return ans;

=======

        double[] res = new double[5];
        int sum = 0, max = 0, mode = 0;
        for(int i = 0; i < 256; i++){
            if(count[i] > 0){
                if(count[i] > max){
                    max = count[i];
                    mode = i;
                }
                sum += i * count[i];
            }
        }
        res[0] = findMin(count);
        res[1] = findMax(count);
        res[2] = sum / (double)sumCount(count);
        res[3] = findMedian(count);
        res[4] = mode;
        return res;
    }
    private int findMin(int[] count){
        for(int i = 0; i < count.length; i++){
            if(count[i] > 0) return i;
        }
        return -1;
    }
    private int findMax(int[] count){
        for(int i = count.length - 1; i >= 0; i--){
            if(count[i] > 0) return i;
        }
        return -1;
    }
    private int sumCount(int[] count){
        int sum = 0;
        for(int i = 0; i < count.length; i++){
            sum += count[i];
        }
        return sum;
    }
    private double findMedian(int[] count){
        int sum = sumCount(count);
        if(sum % 2 == 1){
            int mid = sum / 2 + 1;
            int cur = 0;
            for(int i = 0; i < count.length; i++){
                cur += count[i];
                if(cur >= mid) return i;
            }
        }else{
            int mid1 = sum / 2;
            int mid2 = mid1 + 1;
            int cur = 0;
            double res = 0;
            for(int i = 0; i < count.length; i++){
                cur += count[i];
                if(cur == mid1 || cur == mid2){
                    res += i;
                }
                if(cur > mid2) return res / 2;
            }
        }
        return -1;

=======

        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
        double mean = 0.0, median = 0.0, mode = 0.0;
        int sum = 0, n = 0, modeCount = 0;
        for (int i = 0; i < count.length; i++) {
            if (count[i] > 0) {
                min = Math.min(min, i);
                max = Math.max(max, i);
                sum += i * count[i];
                n += count[i];
                if (count[i] > modeCount) {
                    modeCount = count[i];
                    mode = i;
                }
            }
        }
        mean = (double) sum / n;
        int m1 = -1, m2 = -1;
        for (int i = 0; i < count.length; i++) {
            if (count[i] > 0) {
                m1 = m2;
                m2 = i;
            }
            if (count[i] > 0 && n % 2 == 1 && m1 == -1 && count[i] >= (n + 1) / 2) {
                median = i;
                break;
            }
            if (count[i] > 0 && n % 2 == 0 && m1 != -1 && m2 != -1 && count[i] >= n / 2) {
                median = (m1 + m2) / 2.0;
                break;
            }
        }
        return new double[]{min, max, mean, median, mode};

=======

        double[] result = new double[5];
        int N = 0;
        int max = 0;
        for (int i = 0; i < count.length; i++) {
            if (count[i] > 0) {
                if (result[0] == 0) {
                    result[0] = i;
                }
                result[1] = i;
                result[2] += i * count[i];
                N += count[i];
                if (count[i] > max) {
                    result[4] = i;
                    max = count[i];
                }
            }
        }
        result[2] /= N;
        int mid = N / 2;
        int sum = 0;
        for (int i = 0; i < count.length; i++) {
            sum += count[i];
            if (sum > mid) {
                result[3] = i;
                if (N % 2 == 0 && sum == mid + 1) {
                    for (int j = i + 1; j < count.length; j++) {
                        if (count[j] > 0) {
                            result[3] += j;
                            result[3] /= 2;
                            break;
                        }
                    }
                }
                break;
            }
        }
        return result;

=======

        double[] ans = new double[5];
        int mode = 0;
        int n = 0;
        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;
        int sum = 0;
        for (int i = 0; i < count.length; i++) {
            if (count[i] > 0) {
                min = Math.min(min, i);
                max = Math.max(max, i);
                sum += i * count[i];
                if (count[i] > count[mode]) {
                    mode = i;
                }
                n += count[i];
            }
        }
        ans[0] = min;
        ans[1] = max;
        ans[2] = (double) sum / n;
        ans[4] = mode;
        int m = 0;
        int i = 0;
        while (m < n / 2) {
            m += count[i++];
        }
        if (n % 2 == 1) {
            ans[3] = i - 1;
        } else {
            int j = i;
            while (count[j] == 0) {
                j++;
            }
            ans[3] = (double) (i + j - 2) / 2;
        }
        return ans;

=======

        int min = 0, max = 0, mode = 0;
        double mean = 0, median = 0;
        double sum = 0, num = 0;
        int maxCount = 0, countSum = 0;
        int i = 0;
        while (i < count.length && count[i] == 0) {
            i++;
        }
        min = i;
        i = count.length - 1;
        while (i >= 0 && count[i] == 0) {
            i--;
        }
        max = i;
        for (i = 0; i < count.length; i++) {
            if (count[i] > 0) {
                sum += i * count[i];
                num += count[i];
                if (count[i] > maxCount) {
                    mode = i;
                    maxCount = count[i];
                }
            }
        }
        mean = sum / num;
        int j = 0;
        while (countSum < num / 2) {
            countSum += count[j++];
        }
        if (num % 2 == 0) {
            median = j;
            while (countSum < num / 2 + 1) {
                countSum += count[j++];
            }
            median = (median + j - 1) / 2.0;
        } else {
            median = j - 1;
        }
        return new double[]{min, max, mean, median, mode};

=======

        double[] res = new double[5];
        int max = 0, min = 0, mode = 0;
        int sum = 0, cnt = 0;
        boolean flag = false;
        for (int i = 0; i < count.length; i++) {
            if (count[i] > 0) {
                if (!flag) {
                    min = i;
                    flag = true;
                }
                max = i;
                sum += count[i] * i;
                cnt += count[i];
                if (count[i] > count[mode]) mode = i;
            }
        }
        res[0] = min;
        res[1] = max;
        res[2] = (double) sum / cnt;
        if (cnt % 2 == 0) {
            int c = 0;
            for (int i = 0; i < count.length; i++) {
                c += count[i];
                if (c == cnt / 2) {
                    int j = i + 1;
                    while (count[j] == 0) j++;
                    res[3] = (double) (i + j) / 2;
                    break;
                } else if (c > cnt / 2) {
                    res[3] = i;
                    break;
                }
            }
        } else {
            int c = 0;
            for (int i = 0; i < count.length; i++) {
                c += count[i];
                if (c > cnt / 2) {
                    res[3] = i;
                    break;
                }
            }
        }
        res[4] = mode;
        return res;
