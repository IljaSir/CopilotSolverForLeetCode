Synthesizing 10/10 solutions

=======

        int ans = 0;
        for (int i = 30; i >= 0; i--) {
            if ((num1 & 1 << i) != (num2 & 1 << i)) {
                ans |= 1 << i;
            }
        }
        return ans;

=======

        int x = 0;
        int mask = 1;
        while (mask <= num2) {
            if ((num1 & mask) != (num2 & mask)) {
                x |= mask;
            }
            mask <<= 1;
        }
        return x;

=======

        return num1 ^ num2 ^ ((num1 ^ num2) | ((num1 ^ num2) - 1));

=======

        int xor = num1 ^ num2;
        int bit = 1;
        int res = 0;
        while (xor > 0) {
            if ((xor & 1) == 1) {
                res |= bit;
            }
            bit <<= 1;
            xor >>= 1;
        }
        return res;

=======

        int x = num1 ^ num2;
        int mask = (1 << 30);
        while ((mask & x) == 0) {
            mask >>= 1;
        }
        return num2 | mask;

=======

        int x = 1;
        int res = 0;
        while (x <= num2) {
            if ((num1 & x) != (num2 & x)) {
                res |= x;
            }
            x <<= 1;
        }
        return res;

=======

        int x = num1 ^ num2;
        int n = 0;
        while (x != 0) {
            n += x & 1;
            x >>= 1;
        }
        int res = 0;
        while (n > 0) {
            res = (res << 1) + 1;
            n--;
        }
        return res ^ num1;

=======

        int x = num1 ^ num2;
        int mask = 1 << 30;
        while (mask != 0 && (x & mask) == 0) {
            mask >>= 1;
        }
        return (num2 & ~mask) | (num1 & mask);

=======

        int n = num2;
        int k = 1;
        while (n > 0) {
            n >>= 1;
            k <<= 1;
        }
        return num1 & (k - 1);

=======

        int x = num2 ^ num1;
        int n = Integer.bitCount(x);
        return num1 ^ ((1 << n) - 1);
