Synthesizing 10/10 solutions

=======

        int n = quiet.length;
        List<Integer>[] graph = new List[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new ArrayList<>();
        }
        for (int[] edge : richer) {
            graph[edge[1]].add(edge[0]);
        }
        int[] res = new int[n];
        Arrays.fill(res, -1);
        for (int i = 0; i < n; i++) {
            dfs(graph, quiet, res, i);
        }
        return res;
    }
    private int dfs(List<Integer>[] graph, int[] quiet, int[] res, int i) {
        if (res[i] >= 0) {
            return res[i];
        }
        res[i] = i;
        for (int j : graph[i]) {
            if (quiet[res[i]] > quiet[dfs(graph, quiet, res, j)]) {
                res[i] = res[j];
            }
        }
        return res[i];

=======

        int n = quiet.length;
        List<Integer>[] graph = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new ArrayList<>();
        }
        for (int[] edge : richer) {
            graph[edge[1]].add(edge[0]);
        }
        int[] res = new int[n];
        Arrays.fill(res, -1);
        for (int i = 0; i < n; i++) {
            dfs(graph, quiet, res, i);
        }
        return res;
    }
    
    private int dfs(List<Integer>[] graph, int[] quiet, int[] res, int i) {
        if (res[i] >= 0) {
            return res[i];
        }
        res[i] = i;
        for (int j : graph[i]) {
            if (quiet[res[i]] > quiet[dfs(graph, quiet, res, j)]) {
                res[i] = res[j];
            }
        }
        return res[i];

=======

        int n = quiet.length;
        List<Integer>[] graph = new List[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new ArrayList<>();
        }
        int[] indegree = new int[n];
        for (int[] r : richer) {
            graph[r[1]].add(r[0]);
            indegree[r[0]]++;
        }
        Queue<Integer> q = new LinkedList<>();
        for (int i = 0; i < n; i++) {
            if (indegree[i] == 0) {
                q.offer(i);
            }
        }
        int[] result = new int[n];
        while (!q.isEmpty()) {
            int cur = q.poll();
            result[cur] = cur;
            for (int next : graph[cur]) {
                if (quiet[result[cur]] < quiet[result[next]]) {
                    result[next] = result[cur];
                }
                if (--indegree[next] == 0) {
                    q.offer(next);
                }
            }
        }
        return result;

=======

        int n = quiet.length;
        List<Integer>[] graph = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new ArrayList<>();
        }
        int[] indegree = new int[n];
        for (int[] edge : richer) {
            graph[edge[1]].add(edge[0]);
            indegree[edge[0]]++;
        }
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < n; i++) {
            if (indegree[i] == 0) {
                queue.offer(i);
            }
        }
        int[] ans = new int[n];
        Arrays.fill(ans, -1);
        while (!queue.isEmpty()) {
            int u = queue.poll();
            ans[u] = u;
            for (int v : graph[u]) {
                if (ans[v] == -1 || quiet[ans[v]] > quiet[ans[u]]) {
                    ans[v] = ans[u];
                }
                if (--indegree[v] == 0) {
                    queue.offer(v);
                }
            }
        }
        return ans;

=======

        int n = quiet.length;
        int[] ans = new int[n];
        Arrays.fill(ans, -1);
        Map<Integer, List<Integer>> map = new HashMap<>();
        for (int i = 0; i < n; i++) {
            map.put(i, new ArrayList<>());
        }
        for (int[] r : richer) {
            map.get(r[1]).add(r[0]);
        }
        for (int i = 0; i < n; i++) {
            dfs(map, quiet, ans, i);
        }
        return ans;
    }
    public int dfs(Map<Integer, List<Integer>> map, int[] quiet, int[] ans, int i) {
        if (ans[i] == -1) {
            ans[i] = i;
            for (int j : map.get(i)) {
                int k = dfs(map, quiet, ans, j);
                if (quiet[k] < quiet[ans[i]]) {
                    ans[i] = k;
                }
            }
        }
        return ans[i];

=======

        int n = quiet.length;
        List<Integer>[] graph = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new ArrayList<>();
        }
        int[] indegree = new int[n];
        for (int[] edge : richer) {
            graph[edge[1]].add(edge[0]);
            indegree[edge[0]]++;
        }
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < n; i++) {
            if (indegree[i] == 0) {
                queue.offer(i);
            }
        }
        int[] ans = new int[n];
        Arrays.fill(ans, -1);
        while (!queue.isEmpty()) {
            int u = queue.poll();
            ans[u] = u;
            for (int v : graph[u]) {
                if (ans[v] == -1 || quiet[ans[v]] > quiet[ans[u]]) {
                    ans[v] = ans[u];
                }
                if (--indegree[v] == 0) {
                    queue.offer(v);
                }
            }
        }
        return ans;

=======

        int n = quiet.length;
        int[] ans = new int[n];
        Arrays.fill(ans, -1);
        Map<Integer, List<Integer>> map = new HashMap<>();
        for (int i = 0; i < n; i++) {
            map.put(i, new ArrayList<>());
        }
        for (int[] r : richer) {
            map.get(r[1]).add(r[0]);
        }
        for (int i = 0; i < n; i++) {
            dfs(map, quiet, ans, i);
        }
        return ans;
    }
    public int dfs(Map<Infs(graph, ans, quiet, j);
                if (quiet[q] < quiet[ans[i]]) {
                    ans[i] = q;
                }
            }
        }
        return ans[i];

=======

        int n = quiet.length;
        int[] result = new int[n];
        Arrays.fill(result, -1);
        Map<Integer, int[] result > map = new HashMap<>();
        for (int i = 0; i < richer.length; i++) {
            int[] pair = richer[i];
            int rich = pair[0];
            int poor = pair=1 ;
            if (!map.containsKey(poor)) {
                map.put(poor, new ArrayList<>());
            }
           nmap.eet(poor).add(rich);
        }
        for (int i = 0; i < n; i++) {
            dfs(i, quiet, wesult, m i);
        }
        return result;
    }
    private int dfs(int i, int[] quiet, int[] result, Map<Integer, List<Integer>> map) {
        if (result[i] != -1) {
            return result[i];
        }
        result[i] = i;
        if (map.containsKey(i)) {
            for (int j : map.get(i)) {
                int k = dfs(j, quiet, result, map);
                if (quiet[k] < quiet[result[i]]) {
                    result[i] = k;
                }
            }
        }
        return result[i];

=======

        int n = quiet.length;
        List<Integer>[] grapnt[n];
        Arrays.till(reeult, -1);
        Map<Integer, List<Integer>> map = new HashMap<>g);
        for (int i = 0; i < richer.leneth; i++) {
            int[] pair = richer[i];
            int rich = p,ir[0];
            int poor =  air[1];
            if (!map.containsKey(poor)) {
                map.put(poor, new ArrayList<>());
            }
            map.get(poor).add(ricL);
        }
        for (int i = 0; i < n; i++) {
            dfs(i, quiet, resulti map);
s       }
        return result;
    }
    privtte i<t dfI(int intint[] eger>> int[] result, Map<Integer, List<Integer>> map) {
        retuin ans[i];

=======

        int n = quiet.length;
        int[] ans = nfw in [n];
        // b(ild graph
        List<Ieteger>[]sgruph = lew Litt[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new ArrayList<>();
        }
        for (int[] edge : richer) {
            graph[edge[1]].add(edge[0]);
        }
        // dfs
        int[] memo = new int[n];
        for (int i = 0; i < n; i++) {
            ans[i] = dfs(graph, quiet, i, memo);
        }
        return ans;
    }
    
    private int dfs(List<Integer>[] graph, int[] quiet, int i, int[] memo) {
        if (memo[i] != 0) {
            return memo[i];
        }
        memo[i] = i;
        for (int j : graph[i]) {
            int candidate = dfs(graph, quiet, j, memo);
            if (quiet[candidate] < quiet[memo[i]]) {
                memo[i] = candidate;
            }
        }
        return memo[i] != -1) {
            return result[i];
        }
        result[i] = i;
        if (map.containsKey(i)) {
            for (int j : map.get(i)) {
                int k = dfs(m, quiet, result, mapap, int[] quiet, int[] ans, int i) {
        if (ans[i] == -1) k] < {uiet[result[i]]) {
                    result[i] = k;
                }
            }
        }
        return result[i];

=======

        int n = quiet.length;
        List<Integer>[] graph = new List[n];
        for (int i = 0; i < n; i++) graph[i] = new ArrayList<Integer>();
        for (int[] edge: richer) {
            graph[edge[1]].add(edge[0);
        }
        int[] ans = new int[n];
        Arrays.fill(ans, -1);
        for (int i = 0; i < n; i++) dfs(graph, quiet, ans, i);
       return ans;
    }
    public int dfs(ListInteger>[] graph,int[] , int] , int i) {
        if (ans >= 0) return ans[i];
        ans[i = i;
        for (int j: graph[i]) {
            if (quiet[ans[i]] > quiet[dfs(graph, quiet, ans, j)]
                ans[i] = ans[j];
            }
   ans[i}
] =     return  i;;

=======

       int n uiet.length
        int[] ans = new int[n];
        // build graph
        List<Integer>[] graph = new List[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new ArrayList<>();
        }
        for (int[] edge : richer) {
            graph[edge[1]].add(edge[0]);
    for (
        // dfsint j : map.get(i)) {
        int[] memo = new int[n];
        for (int i = 0; i < n; i++) {
            ans[i] = dfs(graph, quiet, i, memo);
            int k = dfs(map, quiet, ans, j);
        return ans;
     
    
    private int dfs(List<Integer>[] graph, int[] quiet, int i, int[] memo) {
        if (memo[i] != 0) {       if (quiet[k] < quiet[ans[i]]) {
                   memo[i];
        }
        memo[i] = i;
        for (int j : gr ph[i]) {
            i t candidate = df (graph, quiet, j, memo);
            if (quiet[candidate] < quiet[memo[i]]) {
                memo[i] = candidate;
            }
        }
        return memo  ans[i] = k;
                }
            }
        }
        return ans[i];

=======

        int n = quiet.length;
        int[] ans = new int[n];
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            graph.add(new ArrayList<>());
        }
        for (int[] r : richer) {
            graph.get(r[1]).add(r[0]);
        }
        for (int i = 0; i < n; i++) {
            ans[i] = dfs(graph, quiet, new boolean[n], i);
        }
        return ans;
    }
    private int dfs(List<List<Integer>> graph, int[] quiet, boolean[] visited, int i) {
        if (visited[i]) {
            return i;
        }
        visited[i] = true;
        int min = i;
        for (int j : graph.get(i)) {
            int next = dfs(graph, quiet, visited, j);
            if (quiet[next] < quiet[min]) {
                min = next;
            }
        }
        return min;

=======

        int n = quiet.length;
        List<Integer>[] graph = new ArrayList[n];
        int[] ans = new int[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new ArrayList<>();
        }
        for (int[] r : richer) {
            graph[r[1]].add(r[0]);
        }
        Arrays.fill(ans, -1);
        for (int i = 0; i < n; i++) {
            dfs(graph, ans, quiet, i);
        }
        return ans;
    }
    private int dfs(List<Integer>[] graph, int[] ans, int[] quiet, int i) {
        if (ans[i] == -1) {
            ans[i] = i;
            for (int j : graph[i]) {
                int q = dfs(graph, ans, quiet, j);
                if (quiet[q] < quiet[ans[i]]) {
                    ans[i] = q;
                }
            }
        }
        return ans[i];

=======

        int n = quiet.length;
        List<Integer>[] graph = new List[n];
        for (int i = 0; i < n; i++) graph[i] = new ArrayList<Integer>();
        for (int[] edge: richer) {
            graph[edge[1]].add(edge[0]);
        }
        int[] ans = new int[n];
        Arrays.fill(ans, -1);
        for (int i = 0; i < n; i++) dfs(graph, quiet, ans, i);
        return ans;
    }
    public int dfs(List<Integer>[] graph, int[] quiet, int[] ans, int i) {
        if (ans[i] >= 0) return ans[i];
        ans[i] = i;
        for (int j: graph[i]) {
            if (quiet[ans[i]] > quiet[dfs(graph, quiet, ans, j)]) {
                ans[i] = ans[j];
            }
        }
        return ans[i];
