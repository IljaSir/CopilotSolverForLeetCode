Synthesizing 10/10 solutions

=======

        int[] map = new int[26];
        for (char c : tasks) {
            map[c - 'A']++;
        }
        Arrays.sort(map);
        int time = 0;
        while (map[25] > 0) {
            int i = 0;
            while (i <= n) {
                if (map[25] == 0) break;
                if (i < 26 && map[25 - i] > 0) {
                    map[25 - i]--;
                }
                time++;
                i++;
            }
            Arrays.sort(map);
        }
        return time;

=======

        int[] count = new int[26];
        for (char c : tasks) {
            count[c - 'A']++;
        }
        Arrays.sort(count);
        int i = 25;
        while (i >= 0 && count[i] == count[25]) i--;
        return Math.max(tasks.length, (count[25] - 1) * (n + 1) + 25 - i);

=======

        int[] map = new int[26];
        for (char c : tasks) {
            map[c - 'A']++;
        }
        Arrays.sort(map);
        int i = 25;
        while (i >= 0 && map[i] == map[25]) {
            i--;
        }
        return Math.max(tasks.length, (map[25] - 1) * (n + 1) + 25 - i);

=======

        int[] count = new int[26];
        for (char c : tasks) {
            count[c - 'A']++;
        }
        Arrays.sort(count);
        int maxVal = count[25] - 1, idleSlots = maxVal * n;
        for (int i = 24; i >= 0 && count[i] > 0; i--) {
            idleSlots -= Math.min(count[i], maxVal);
        }
        return idleSlots > 0 ? idleSlots + tasks.length : tasks.length;

=======

        int[] count = new int[26];
        int max = 0;
        for (char c : tasks) {
            count[c - 'A']++;
            max = Math.max(max, count[c - 'A']);
        }
        int maxCount = 0;
        for (int i : count) {
            if (i == max) {
                maxCount++;
            }
        }
        return Math.max(tasks.length, (max - 1) * (n + 1) + maxCount);

=======

        int[] count = new int[26];
        for (char task : tasks) {
            count[task - 'A']++;
        }
        Arrays.sort(count);
        int maxVal = count[25] - 1;
        int idleSlots = maxVal * n;
        for (int i = 24; i >= 0 && count[i] > 0; i--) {
            idleSlots -= Math.min(count[i], maxVal);
        }
        return idleSlots > 0 ? idleSlots + tasks.length : tasks.length;

=======

        int[] map = new int[26];
        for (char c : tasks) {
            map[c - 'A']++;
        }
        Arrays.sort(map);
        int max = map[25] - 1;
        int idle = max * n;
        for (int i = 24; i >= 0 && map[i] > 0; i--) {
            idle -= Math.min(map[i], max);
        }
        return idle > 0 ? idle + tasks.length : tasks.length;

=======

        int[] map = new int[26];
        int max = 0;
        int maxCount = 0;
        for (char c : tasks) {
            map[c - 'A']++;
            if (map[c - 'A'] > max) {
                max = map[c - 'A'];
                maxCount = 1;
            } else if (map[c - 'A'] == max) {
                maxCount++;
            }
        }
        return Math.max((max - 1) * (n + 1) + maxCount, tasks.length);

=======

        int[] counts = new int[26];
        for (char c : tasks) {
            counts[c - 'A']++;
        }
        Arrays.sort(counts);
        int max = counts[25];
        int maxCount = 1;
        for (int i = 24; i >= 0; i--) {
            if (counts[i] == max) {
                maxCount++;
            } else {
                break;
            }
        }
        int partCount = max - 1;
        int partLength = n - (maxCount - 1);
        int emptySlots = partCount * partLength;
        int availableTasks = tasks.length - max * maxCount;
        int idles = Math.max(0, emptySlots - availableTasks);
        return tasks.length + idles;

=======

        int[] cnt = new int[26];
        for (char c : tasks) {
            cnt[c - 'A']++;
        }
        Arrays.sort(cnt);
        int maxCnt = cnt[25];
        int maxCntNum = 1;
        for (int i = 24; i >= 0; i--) {
            if (cnt[i] == maxCnt) {
                maxCntNum++;
            } else {
                break;
            }
        }
        return Math.max(tasks.length, (maxCnt - 1) * (n + 1) + maxCntNum);
