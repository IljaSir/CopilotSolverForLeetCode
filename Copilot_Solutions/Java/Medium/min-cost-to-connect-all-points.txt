Synthesizing 10/10 solutions

=======

        int n = points.length;
        int[][] dist = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int d = Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1]);
                dist[i][j] = dist[j][i] = d;
            }
        }
        
        int[] minDist = new int[n];
        Arrays.fill(minDist, Integer.MAX_VALUE);
        minDist[0] = 0;
        boolean[] visited = new boolean[n];
        int res = 0;
        for (int i = 0; i < n; i++) {
            int u = -1;
            for (int v = 0; v < n; v++) {
                if (!visited[v] && (u == -1 || minDist[u] > minDist[v])) {
                    u = v;
                }
            }
            res += minDist[u];
            visited[u] = true;
            for (int v = 0; v < n; v++) {
                if (!visited[v] && dist[u][v] < minDist[v]) {
                    minDist[v] = dist[u][v];
                }
            }
        }
        return res;

=======

        int n = points.length;
        int[][] dist = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                dist[i][j] = dist[j][i] = Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1]);
            }
        }
        int[] minDist = new int[n];
        Arrays.fill(minDist, Integer.MAX_VALUE);
        boolean[] visited = new boolean[n];
        minDist[0] = 0;
        int ans = 0;
        for (int i = 0; i < n; i++) {
            int u = -1;
            for (int j = 0; j < n; j++) {
                if (!visited[j] && (u == -1 || minDist[j] < minDist[u])) {
                    u = j;
                }
            }
            ans += minDist[u];
            visited[u] = true;
            for (int v = 0; v < n; v++) {
                if (!visited[v]) {
                    minDist[v] = Math.min(minDist[v], dist[u][v]);
                }
            }
        }
        return ans;

=======

        int n = points.length;
        int[][] dist = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                dist[i][j] = dist[j][i] = Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1]);
            }
        }
        boolean[] visited = new boolean[n];
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        int res = 0;
        pq.offer(new int[]{0, 0});
        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            int d = cur[0], i = cur[1];
            if (visited[i]) {
                continue;
            }
            visited[i] = true;
            res += d;
            for (int j = 0; j < n; j++) {
                if (!visited[j]) {
                    pq.offer(new int[]{dist[i][j], j});
                }
            }
        }
        return res;

=======

        int n = points.length;
        int[][] dist = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                dist[i][j] = dist[j][i] = Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1]);
            }
        }
        int[] minDist = new int[n];
        Arrays.fill(minDist, Integer.MAX_VALUE);
        boolean[] visited = new boolean[n];
        int res = 0;
        minDist[0] = 0;
        for (int i = 0; i < n; i++) {
            int u = -1;
            for (int j = 0; j < n; j++) {
                if (!visited[j] && (u == -1 || minDist[j] < minDist[u])) {
                    u = j;
                }
            }
            visited[u] = true;
            res += minDist[u];
            for (int v = 0; v < n; v++) {
                if (!visited[v]) {
                    minDist[v] = Math.min(minDist[v], dist[u][v]);
                }
            }
        }
        return res;

=======

        int n = points.length;
        UnionFind uf = new UnionFind(n);
        List<int[]> edges = new ArrayList<>();
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                edges.add(new int[]{dist(points, i, j), i, j});
            }
        }
        Collections.sort(edges, (a, b) -> a[0] - b[0]);
        int ret = 0, num = 1;
        for (int[] edge: edges) {
            int d = edge[0], x = edge[1], y = edge[2];
            if (uf.unite(x, y)) {
                ret += d;
                num += 1;
                if (num == n) {
                    break;
                }
            }
        }
        return ret;
    }

    public int dist(int[][] points, int i, int j) {
        return Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1]);
    }
}

=======

        int n = points.length;
        int[][] edges = new int[n * (n - 1) / 2][3];
        int k = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                edges[k][0] = Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1]);
                edges[k][1] = i;
                edges[k][2] = j;
                k++;
            }
        }
        Arrays.sort(edges, (a, b) -> a[0] - b[0]);
        UnionFind uf = new UnionFind(n);
        int res = 0;
        for (int[] edge : edges) {
            if (uf.union(edge[1], edge[2])) {
                res += edge[0];
            }
        }
        return res;
    }
}

=======

        int n = points.length;
        int[] dist = new int[n];
        boolean[] visited = new boolean[n];
        int res = 0;
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[0] = 0;
        for (int i = 0; i < n; i++) {
            int u = -1;
            for (int j = 0; j < n; j++) {
                if (!visited[j] && (u == -1 || dist[j] < dist[u])) {
                    u = j;
                }
            }
            res += dist[u];
            visited[u] = true;
            for (int v = 0; v < n; v++) {
                if (!visited[v]) {
                    dist[v] = Math.min(dist[v], Math.abs(points[u][0] - points[v][0]) + Math.abs(points[u][1] - points[v][1]));
                }
            }
        }
        return res;

=======

        int n = points.length;
        int[] cost = new int[n];
        boolean[] visited = new boolean[n];
        Arrays.fill(cost, Integer.MAX_VALUE);
        cost[0] = 0;
        int res = 0;
        for (int i = 0; i < n; ++i) {
            int min = Integer.MAX_VALUE, minIdx = -1;
            for (int j = 0; j < n; ++j) {
                if (!visited[j] && cost[j] < min) {
                    min = cost[j];
                    minIdx = j;
                }
            }
            visited[minIdx] = true;
            res += min;
            for (int j = 0; j < n; ++j) {
                if (!visited[j]) {
                    cost[j] = Math.min(cost[j], Math.abs(points[j][0] - points[minIdx][0]) + Math.abs(points[j][1] - points[minIdx][1]));
                }
            }
        }
        return res;

=======

        int N = points.length;
        int[] dist = new int[N];
        boolean[] used = new boolean[N];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[0] = 0;
        int ans = 0;
        for (int i = 0; i < N; ++i) {
            int x = -1;
            for (int y = 0; y < N; ++y)
                if (!used[y] && (x == -1 || dist[y] < dist[x]))
                    x = y;
            used[x] = true;
            ans += dist[x];
            for (int y = 0; y < N; ++y)
                dist[y] = Math.min(dist[y], Math.abs(points[x][0] - points[y][0]) + Math.abs(points[x][1] - points[y][1]));
        }
        return ans;

=======

        int n = points.length;
        int[] dist = new int[n];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[0] = 0;
        boolean[] visited = new boolean[n];
        int result = 0;
        for (int i = 0; i < n; i++) {
            int min = Integer.MAX_VALUE;
            int index = -1;
            for (int j = 0; j < n; j++) {
                if (!visited[j] && dist[j] < min) {
                    min = dist[j];
                    index = j;
                }
            }
            visited[index] = true;
            result += min;
            for (int j = 0; j < n; j++) {
                if (!visited[j]) {
                    dist[j] = Math.min(dist[j], Math.abs(points[j][0] - points[index][0]) + Math.abs(points[j][1] - points[index][1]));
                }
            }
        }
        return result;
