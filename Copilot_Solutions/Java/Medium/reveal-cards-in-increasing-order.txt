Synthesizing 10/10 solutions (Duplicates hidden)

=======

        Arrays.sort(deck);
        int[] result = new int[deck.length];
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < deck.length; i++) {
            queue.add(i);
        }
        for (int i = 0; i < deck.length; i++) {
            result[queue.poll()] = deck[i];
            if (!queue.isEmpty()) {
                queue.add(queue.poll());
            }
        }
        return result;

=======

        int n = deck.length;
        int[] res = new int[n];
        Arrays.sort(deck);
        Queue<Integer> q = new LinkedList<>();
        for (int i = 0; i < n; i++) {
            q.offer(i);
        }
        for (int i = 0; i < n; i++) {
            res[q.poll()] = deck[i];
            if (!q.isEmpty()) {
                q.offer(q.poll());
            }
        }
        return res;

=======

        Arrays.sort(deck);
        int n = deck.length;
        int[] res = new int[n];
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < n; i++) {
            queue.offer(i);
        }
        for (int card : deck) {
            res[queue.poll()] = card;
            if (!queue.isEmpty()) {
                queue.offer(queue.poll());
            }
        }
        return res;

=======

        Arrays.sort(deck);
        int n = deck.length;
        int[] ans = new int[n];
        Queue<Integer> q = new LinkedList<>();
        for (int i = 0; i < n; i++) {
            q.add(i);
        }
        for (int i = 0; i < n; i++) {
            ans[q.poll()] = deck[i];
            if (!q.isEmpty()) {
                q.add(q.poll());
            }
        }
        return ans;

=======

        Arrays.sort(deck);
        int n = deck.length;
        int[] ans = new int[n];
        Queue<Integer> q = new LinkedList<>();
        for (int i = 0; i < n; i++) {
            q.offer(i);
        }
        for (int i = 0; i < n; i++) {
            ans[q.poll()] = deck[i];
            if (!q.isEmpty()) {
                q.offer(q.poll());
            }
        }
        return ans;

=======

        int[] res = new int[deck.length];
        Arrays.sort(deck);
        Deque<Integer> queue = new LinkedList<>();
        for (int i = 0; i < deck.length; i++) {
            queue.add(i);
        }
        for (int card : deck) {
            res[queue.pollFirst()] = card;
            if (!queue.isEmpty()) {
                queue.add(queue.pollFirst());
            }
        }
        return res;

=======

        int n = deck.length;
        int[] res = new int[n];
        Queue<Integer> q = new LinkedList<Integer>();
        for (int i = 0; i < n; i++) {
            q.add(i);
        }
        Arrays.sort(deck);
        for (int i = 0; i < n; i++) {
            res[q.poll()] = deck[i];
            if (!q.isEmpty()) {
                q.add(q.poll());
            }
        }
        return res;

=======

        int n = deck.length;
        int[] ans = new int[n];
        Arrays.fill(ans, -1);
        Arrays.sort(deck);
        int i = 0;
        for (int card: deck) {
            i = findNextEmptySlot(ans, i);
            ans[i] = card;
        }
        return ans;
    }
    
    private int findNextEmptySlot(int[] ans, int i) {
        int n = ans.length;
        int count = 0;
        while (count < 2) {
            if (ans[i] == -1) count++;
            i = (i + 1) % n;
        }
        return i;

=======

        int[] result = new int[deck.length];
        Arrays.sort(deck);
        int index = 0;
        for(int i = 0; i < deck.length; i++){
            if(i % 2 == 0){
                result[index] = deck[i];
                index++;
            }else{
                result[deck.length - i/2 - 1] = deck[i];
            }
        }
        return result;
