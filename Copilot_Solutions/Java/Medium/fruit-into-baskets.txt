Synthesizing 10/10 solutions

=======

        int left = 0;
        int right = 0;
        int max = 0;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        while (right < fruits.length) {
            map.put(fruits[right], map.getOrDefault(fruits[right], 0) + 1);
            while (map.size() > 2) {
                map.put(fruits[left], map.get(fruits[left]) - 1);
                if (map.get(fruits[left]) == 0) {
                    map.remove(fruits[left]);
                }
                left++;
            }
            max = Math.max(max, right - left + 1);
            right++;
        }
        return max;

=======

        int n = fruits.length;
        int[] count = new int[n];
        int res = 0;
        int i = 0;
        for (int j = 0; j < n; j++) {
            if (count[fruits[j]]++ == 0) {
                i++;
            }
            while (i > 2) {
                if (--count[fruits[j - i + 1]] == 0) {
                    i--;
                }
            }
            res = Math.max(res, j - i + 2);
        }
        return res;

=======

        int max = 0;
        int i = 0;
        int j = 0;
        int k = 0;
        while (j < fruits.length) {
            if (fruits[j] == fruits[i]) {
                j++;
                continue;
            }
            if (k == 0) {
                k = fruits[j];
                j++;
                continue;
            }
            if (fruits[j] == k) {
                j++;
                continue;
            }
            max = Math.max(max, j - i);
            i = j - 1;
            while (i >= 0 && fruits[i] == fruits[i - 1]) {
                i--;
            }
            k = 0;
        }
        return Math.max(max, j - i);

=======

        int max = 0;
        int start = 0;
        int end = 0;
        int first = -1;
        int second = -1;
        while (end < fruits.length) {
            if (fruits[end] == first || fruits[end] == second) {
                end++;
            } else if (first == -1) {
                first = fruits[end];
                end++;
            } else if (second == -1) {
                second = fruits[end];
                end++;
            } else {
                max = Math.max(max, end - start);
                start = end - 1;
                while (start > 0 && fruits[start] == fruits[start - 1]) {
                    start--;
                }
                first = fruits[start];
                second = fruits[end];
                end++;
            }
        }
        max = Math.max(max, end - start);
        return max;

=======

        int n = fruits.length;
        int max = 0;
        int i = 0;
        int j = 0;
        int first = -1;
        int second = -1;
        while (j < n) {
            if (fruits[j] == first || fruits[j] == second) {
                j++;
            } else if (first == -1) {
                first = fruits[j];
                j++;
            } else if (second == -1) {
                second = fruits[j];
                j++;
            } else {
                max = Math.max(max, j - i);
                first = fruits[j - 1];
                second = fruits[j];
                i = j - 1;
                while (i >= 0 && fruits[i] == first) {
                    i--;
                }
                i++;
            }
        }
        return Math.max(max, j - i);

=======

        int n = fruits.length;
        if (n <= 2) return n;
        int[] count = new int[n];
        int res = 0, i = 0;
        for (int j = 0; j < n; j++) {
            count[fruits[j]]++;
            while (i < j && count[fruits[i]] == 0) {
                count[fruits[i]]--;
                i++;
            }
            res = Math.max(res, j - i + 1);
        }
        return res;

=======

        int result = 0;
        int last = -1;
        int lastCount = 0;
        int count = 0;
        for (int i = 0; i < fruits.length; i++) {
            if (fruits[i] == last) {
                lastCount++;
            } else {
                lastCount = 1;
                last = fruits[i];
            }
            if (count > 0 && fruits[i] != fruits[i - 1]) {
                count = lastCount;
            } else {
                count++;
            }
            result = Math.max(result, count + lastCount - 1);
        }
        return result;

=======

        int max = 0;
        int i = 0;
        int j = 0;
        int count = 0;
        int[] basket = new int[fruits.length];
        while (j < fruits.length) {
            if (basket[fruits[j]] == 0) {
                count++;
            }
            basket[fruits[j]]++;
            while (count > 2) {
                basket[fruits[i]]--;
                if (basket[fruits[i]] == 0) {
                    count--;
                }
                i++;
            }
            max = Math.max(max, j - i + 1);
            j++;
        }
        return max;

=======

        int ans = 0;
        int i = 0;
        int j = 0;
        int n = fruits.length;
        HashMap<Integer, Integer> map = new HashMap<>();
        while (j < n) {
            int cur = fruits[j];
            map.put(cur, map.getOrDefault(cur, 0) + 1);
            while (map.size() > 2) {
                int left = fruits[i];
                map.put(left, map.get(left) - 1);
                if (map.get(left) == 0) {
                    map.remove(left);
                }
                i++;
            }
            ans = Math.max(ans, j - i + 1);
            j++;
        }
        return ans;

=======

        int count = 0;
        int maxCount = 0;
        int maxFruit = 0;
        int previousFruit = -1;
        int secondFruit = -1;
        for (int i = 0; i < fruits.length; i++) {
            if (fruits[i] == previousFruit || fruits[i] == secondFruit) {
                count++;
            } else if (secondFruit == -1) {
                secondFruit = fruits[i];
                count++;
            } else {
                count = 1;
                previousFruit = secondFruit;
                secondFruit = fruits[i];
            }
            if (fruits[i] == secondFruit) {
                maxFruit = secondFruit;
            } else {
                maxFruit = previousFruit;
            }
            maxCount = Math.max(maxCount, count);
        }
        return maxCount;
