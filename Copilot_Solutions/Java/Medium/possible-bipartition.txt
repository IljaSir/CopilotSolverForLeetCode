Synthesizing 10/10 solutions

=======

        int[][] graph = new int[n][n];
        for (int[] d : dislikes) {
            graph[d[0] - 1][d[1] - 1] = 1;
            graph[d[1] - 1][d[0] - 1] = 1;
        }
        int[] group = new int[n];
        for (int i = 0; i < n; i++) {
            if (group[i] == 0 && !dfs(graph, group, i, 1)) {
                return false;
            }
        }
        return true;
    }
    private boolean dfs(int[][] graph, int[] group, int i, int g) {
        if (group[i] != 0) {
            return group[i] == g;
        }
        group[i] = g;
        for (int j = 0; j < graph.length; j++) {
            if (graph[i][j] == 1 && !dfs(graph, group, j, -g)) {
                return false;
            }
        }
        return true;

=======

        List<Integer>[] graph = new ArrayList[n + 1];
        for (int i = 1; i <= n; i++) {
            graph[i] = new ArrayList<>();
        }
        for (int[] edge : dislikes) {
            graph[edge[0]].add(edge[1]);
            graph[edge[1]].add(edge[0]);
        }
        int[] colors = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            if (colors[i] == 0 && !dfs(graph, colors, i, 1)) {
                return false;
            }
        }
        return true;
    }
    public boolean dfs(List<Integer>[] graph, int[] colors, int node, int color) {
        if (colors[node] != 0) {
            return colors[node] == color;
        }
        colors[node] = color;
        for (int neighbor : graph[node]) {
            if (!dfs(graph, colors, neighbor, -color)) {
                return false;
            }
        }
        return true;

=======

        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            graph.add(new ArrayList<>());
        }
        for (int[] edge : dislikes) {
            graph.get(edge[0] - 1).add(edge[1] - 1);
            graph.get(edge[1] - 1).add(edge[0] - 1);
        }
        int[] color = new int[n];
        for (int i = 0; i < n; i++) {
            if (color[i] == 0 && !dfs(graph, color, 1, i)) {
                return false;
            }
        }
        return true;
    }
    private boolean dfs(List<List<Integer>> graph, int[] color, int c, int i) {
        if (color[i] != 0) {
            return color[i] == c;
        }
        color[i] = c;
        for (int j : graph.get(i)) {
            if (!dfs(graph, color, -c, j)) {
                return false;
            }
        }
        return true;

=======

        Map<Integer, Set<Integer>> graph = new HashMap<>();
        for (int[] dislike : dislikes) {
            graph.putIfAbsent(dislike[0], new HashSet<>());
            graph.putIfAbsent(dislike[1], new HashSet<>());
            graph.get(dislike[0]).add(dislike[1]);
            graph.get(dislike[1]).add(dislike[0]);
        }
        int[] groups = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            if (groups[i] == 0 && !dfs(graph, groups, i, 1)) {
                return false;
            }
        }
        return true;
    }
    
    private boolean dfs(Map<Integer, Set<Integer>> graph, int[] groups, int node, int group) {
        if (groups[node] != 0) {
            return groups[node] == group;
        }
        groups[node] = group;
        if (graph.containsKey(node)) {
            for (int neighbor : graph.get(node)) {
                if (!dfs(graph, groups, neighbor, -group)) {
                    return false;
                }
            }
        }
        return true;

=======

        int[][] graph = new int[n+1][n+1];
        for (int[] d : dislikes) {
            graph[d[0]][d[1]] = 1;
            graph[d[1]][d[0]] = 1;
        }
        int[] group = new int[n+1];
        for (int i = 1; i <= n; i++) {
            if (group[i] == 0 && !dfs(graph, group, i, 1)) {
                return false;
            }
        }
        return true;
    }
    private boolean dfs(int[][] graph, int[] group, int i, int g) {
        if (group[i] != 0) {
            return group[i] == g;
        }
        group[i] = g;
        for (int j = 1; j < graph.length; j++) {
            if (graph[i][j] == 1 && !dfs(graph, group, j, -g)) {
                return false;
            }
        }
        return true;

=======

        List<Integer>[] graph = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            graph[i] = new ArrayList<>();
        }
        for (int[] d : dislikes) {
            graph[d[0]].add(d[1]);
            graph[d[1]].add(d[0]);
        }
        int[] colors = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            if (colors[i] == 0 && !dfs(graph, colors, i, 1)) {
                return false;
            }
        }
        return true;
    }
    private boolean dfs(List<Integer>[] graph, int[] colors, int node, int color) {
        if (colors[node] != 0) {
            return colors[node] == color;
        }
        colors[node] = color;
        for (int nei : graph[node]) {
            if (!dfs(graph, colors, nei, -color)) {
                return false;
            }
        }
        return true;

=======

        if (dislikes.length == 0) return true;
        List<Integer>[] graph = new List[n + 1];
        for (int i = 1; i <= n; i++) {
            graph[i] = new ArrayList<>();
        }
        for (int[] edge : dislikes) {
            graph[edge[0]].add(edge[1]);
            graph[edge[1]].add(edge[0]);
        }
        int[] visited = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            if (visited[i] == 0 && !dfs(graph, visited, i, 1)) {
                return false;
            }
        }
        return true;
    }
    
    private boolean dfs(List<Integer>[] graph, int[] visited, int node, int color) {
        if (visited[node] != 0) {
            return color == visited[node];
        }
        visited[node] = color;
        for (int nei : graph[node]) {
            if (!dfs(graph, visited, nei, -color)) {
                return false;
            }
        }
        return true;

=======

        int[] group = new int[n+1];
        List<Integer>[] graph = new ArrayList[n+1];
        for (int i = 0; i <= n; i++) {
            graph[i] = new ArrayList<>();
        }
        for (int[] d : dislikes) {
            graph[d[0]].add(d[1]);
            graph[d[1]].add(d[0]);
        }
        for (int i = 1; i <= n; i++) {
            if (group[i] == 0 && !dfs(graph, group, i, 1)) {
                return false;
            }
        }
        return true;
    }
    public boolean dfs(List<Integer>[] graph, int[] group, int cur, int g) {
        if (group[cur] != 0) {
            return group[cur] == g;
        }
        group[cur] = g;
        for (int next : graph[cur]) {
            if (!dfs(graph, group, next, -g)) {
                return false;
            }
        }
        return true;

=======

        int[] group = new int[n + 1];
        Arrays.fill(group, -1);
        Map<Integer, Set<Integer>> dislikeMap = new HashMap<>();
        for (int[] dislike : dislikes) {
            dislikeMap.computeIfAbsent(dislike[0], k -> new HashSet<>()).add(dislike[1]);
            dislikeMap.computeIfAbsent(dislike[1], k -> new HashSet<>()).add(dislike[0]);
        }
        for (int i = 1; i <= n; i++) {
            if (group[i] == -1 && !dfs(dislikeMap, group, i, 0)) {
                return false;
            }
        }
        return true;
    }

    private boolean dfs(Map<Integer, Set<Integer>> dislikeMap, int[] group, int i, int g) {
        if (group[i] != -1) {
            return group[i] == g;
        }
        group[i] = g;
        if (!dislikeMap.containsKey(i)) {
            return true;
        }
        for (int j : dislikeMap.get(i)) {
            if (!dfs(dislikeMap, group, j, 1 - g)) {
                return false;
            }
        }
        return true;

=======

        int[] group = new int[n+1];
        Arrays.fill(group, 0);
        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i <= n; i++) {
            adj.add(new ArrayList<>());
        }
        for (int[] dislike : dislikes) {
            adj.get(dislike[0]).add(dislike[1]);
            adj.get(dislike[1]).add(dislike[0]);
        }
        for (int i = 1; i <= n; i++) {
            if (group[i] == 0 && !dfs(adj, group, 1, i)) {
                return false;
            }
        }
        return true;
    }
    private boolean dfs(List<List<Integer>> adj, int[] group, int g, int i) {
        if (group[i] != 0) {
            return group[i] == g;
        }
        group[i] = g;
        for (int j : adj.get(i)) {
            if (!dfs(adj, group, -g, j)) {
                return false;
            }
        }
        return true;
