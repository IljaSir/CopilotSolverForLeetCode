Synthesizing 10/10 solutions

=======

        int n = nums.length;
        int[] mod = new int[n + 1];
        for (int i = 0; i < n; i++) {
            mod[i + 1] = (mod[i] + nums[i]) % p;
        }
        int ans = 0;
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i <= n; i++) {
            if (i >= k) {
                map.put(mod[i - k], map.getOrDefault(mod[i - k], 0) - 1);
            }
            ans += map.getOrDefault(mod[i], 0);
            map.put(mod[i], map.getOrDefault(mod[i], 0) + 1);
        }
        return ans;

=======

        int n = nums.length;
        int[] prefix = new int[n + 1];
        for (int i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] + nums[i];
        }
        Map<Integer, Integer> count = new HashMap<>();
        int res = 0;
        for (int i = 0; i <= n; i++) {
            int x = prefix[i] % p;
            if (i - k - 1 >= 0) {
                int y = prefix[i - k - 1] % p;
                count.put(y, count.getOrDefault(y, 0) - 1);
                if (count.get(y) == 0) {
                    count.remove(y);
                }
            }
            res += count.getOrDefault(x, 0);
            count.put(x, count.getOrDefault(x, 0) + 1);
        }
        return res;

=======

        int n = nums.length;
        int ans = 0;
        for (int i = 0; i < n; i++) {
            int cnt = 0;
            for (int j = i; j < n; j++) {
                if (nums[j] % p == 0) {
                    cnt++;
                }
                if (cnt > k) {
                    break;
                }
                ans++;
            }
        }
        return ans;

=======

        int n = nums.length;
        int[] mod = new int[n];
        for (int i = 0; i < n; i++) {
            mod[i] = nums[i] % p;
        }
        int[] prefix = new int[n + 1];
        for (int i = 0; i < n; i++) {
            prefix[i + 1] = (prefix[i] + mod[i]) % p;
        }
        int[] count = new int[p];
        count[0] = 1;
        int res = 0;
        for (int i = 1; i <= n; i++) {
            int cur = prefix[i];
            int left = Math.max(0, i - k);
            res += count[cur];
            count[cur]++;
            count[prefix[left]]--;
        }
        return res;

=======

        int n = nums.length;
        int[] r = new int[n];
        for (int i = 0; i < n; i++) {
            r[i] = nums[i] % p;
        }
        int[] c = new int[p];
        int[] d = new int[p];
        int l = 0;
        int s = 0;
        int t = 0;
        int count = 0;
        for (int i = 0; i < n; i++) {
            while (l <= i && c[r[i]] >= k) {
                c[r[l]]--;
                if (c[r[l]] == 0) {
                    t -= d[r[l]];
                }
                s -= r[l];
                l++;
            }
            c[r[i]]++;
            s += r[i];
            d[r[i]]++;
            t += d[r[i]];
            count += t;
        }
        return count;

=======

        int[] mod = new int[p];
        int sum = 0;
        int count = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            int modVal = sum % p;
            if (modVal < 0) {
                modVal += p;
            }
            if (modVal == 0) {
                count++;
            }
            if (i >= k) {
                sum -= nums[i - k];
            }
            count += mod[modVal];
            mod[modVal]++;
        }
        return count;

=======

        int n = nums.length;
        int ans = 0;
        for (int i = 0; i < n; i++) {
            int[] cnt = new int[p];
            int total = 0;
            for (int j = i; j < n; j++) {
                if (cnt[nums[j] % p] == 0) {
                    total++;
                }
                cnt[nums[j] % p]++;
                if (total <= k) {
                    ans++;
                } else {
                    break;
                }
            }
        }
        return ans;

=======

        int ans = 0;
        int n = nums.length;
        int[] dp = new int[n + 1];
        for (int i = 0; i < n; ++i) {
            dp[i + 1] = dp[i] + (nums[i] % p == 0 ? 1 : 0);
        }
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j <= n; ++j) {
                if (dp[j] - dp[i] <= k) {
                    ans++;
                }
            }
        }
        return ans;

=======

        int[] dp = new int[nums.length + 1];
        dp[0] = 1;
        int[] mod = new int[p];
        int sum = 0;
        int res = 0;
        for (int i = 0; i < nums.length; i++) {
            sum = (sum + nums[i]) % p;
            int index = (sum - k + p) % p;
            res += mod[index];
            mod[sum]++;
            if (i >= k - 1) {
                mod[(sum - nums[i - k + 1] + p) % p]--;
            }
        }
        return res;

=======

        int n = nums.length;
        int[] res = new int[n];
        int[] pre = new int[n];
        int[] rem = new int[n];
        int[] cnt = new int[p];
        for (int i = 0; i < n; ++i) {
            rem[i] = nums[i] % p;
            pre[i] = (i > 0 ? pre[i - 1] : 0) + rem[i];
            cnt[pre[i] % p]++;
        }
        for (int i = 0; i < n; ++i) {
            if (i >= k) {
                cnt[pre[i - k - 1] % p]--;
            }
            res[i] = cnt[pre[i] % p];
        }
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            ans += res[i];
            if (rem[i] == 0) {
                ans++;
            }
        }
        return ans;
