Synthesizing 10/10 solutions

=======

        int n = nums.length;
        int[] dp = new int[1001];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[start] = 0;
        for (int i = 0; i < n; i++) {
            int[] next = new int[1001];
            Arrays.fill(next, Integer.MAX_VALUE);
            for (int j = 0; j <= 1000; j++) {
                if (dp[j] != Integer.MAX_VALUE) {
                    next[j + nums[i]] = Math.min(next[j + nums[i]], dp[j] + 1);
                    next[j - nums[i]] = Math.min(next[j - nums[i]], dp[j] + 1);
                    next[j ^ nums[i]] = Math.min(next[j ^ nums[i]], dp[j] + 1);
                }
            }
            dp = next;
        }
        return dp[goal] == Integer.MAX_VALUE ? -1 : dp[goal];

=======

        int n = nums.length;
        int[] dp = new int[1001];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[start] = 0;
        for (int i = 0; i < n; i++) {
            int[] newDp = new int[1001];
            Arrays.fill(newDp, Integer.MAX_VALUE);
            for (int j = 0; j <= 1000; j++) {
                if (dp[j] != Integer.MAX_VALUE) {
                    if (j + nums[i] <= 1000) {
                        newDp[j + nums[i]] = Math.min(newDp[j + nums[i]], dp[j] + 1);
                    }
                    if (j - nums[i] >= 0) {
                        newDp[j - nums[i]] = Math.min(newDp[j - nums[i]], dp[j] + 1);
                    }
                    newDp[j ^ nums[i]] = Math.min(newDp[j ^ nums[i]], dp[j] + 1);
                }
            }
            dp = newDp;
        }
        return dp[goal] == Integer.MAX_VALUE ? -1 : dp[goal];

=======

        int n = nums.length;
        int[] dp = new int[1001];
        Arrays.fill(dp, -1);
        dp[start] = 0;
        for (int i = 0; i < n; i++) {
            int[] next = new int[1001];
            Arrays.fill(next, -1);
            for (int j = 0; j < 1001; j++) {
                if (dp[j] != -1) {
                    if (j + nums[i] < 1001) {
                        next[j + nums[i]] = Math.max(next[j + nums[i]], dp[j] + 1);
                    }
                    if (j - nums[i] >= 0) {
                        next[j - nums[i]] = Math.max(next[j - nums[i]], dp[j] + 1);
                    }
                    next[j ^ nums[i]] = Math.max(next[j ^ nums[i]], dp[j] + 1);
                }
            }
            dp = next;
        }
        return dp[goal];

=======

        int n = nums.length;
        int[] dp = new int[1001];
        Arrays.fill(dp, -1);
        dp[start] = 0;
        for (int i = 0; i < n; i++) {
            int[] next = new int[1001];
            Arrays.fill(next, -1);
            for (int j = 0; j <= 1000; j++) {
                if (dp[j] != -1) {
                    if (j + nums[i] <= 1000) {
                        if (next[j + nums[i]] == -1 || next[j + nums[i]] > dp[j] + 1) {
                            next[j + nums[i]] = dp[j] + 1;
                        }
                    }
                    if (j - nums[i] >= 0) {
                        if (next[j - nums[i]] == -1 || next[j - nums[i]] > dp[j] + 1) {
                            next[j - nums[i]] = dp[j] + 1;
                        }
                    }
                    if (next[j ^ nums[i]] == -1 || next[j ^ nums[i]] > dp[j] + 1) {
                        next[j ^ nums[i]] = dp[j] + 1;
                    }
                }
            }
            dp = next;
        }
        return dp[goal];

=======

        int n = nums.length;
        int[][] dp = new int[n][1001];
        for (int[] row : dp) {
            Arrays.fill(row, Integer.MAX_VALUE);
        }
        dp[0][start] = 0;
        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= 1000; j++) {
                if (dp[i - 1][j] != Integer.MAX_VALUE) {
                    dp[i][j + nums[i - 1]] = Math.min(dp[i][j + nums[i - 1]], dp[i - 1][j]);
                    dp[i][j - nums[i - 1]] = Math.min(dp[i][j - nums[i - 1]], dp[i - 1][j]);
                    dp[i][j ^ nums[i - 1]] = Math.min(dp[i][j ^ nums[i - 1]], dp[i - 1][j] + 1);
                }
            }
        }
        int res = Integer.MAX_VALUE;
        for (int i = 0; i <= 1000; i++) {
            if (dp[n - 1][i] != Integer.MAX_VALUE) {
                res = Math.min(res, dp[n - 1][i] + Integer.bitCount(i ^ goal));
            }
        }
        return res == Integer.MAX_VALUE ? -1 : res;

=======

        int n = nums.length;
        int[][] dp = new int[n][1001];
        for (int[] row : dp) {
            Arrays.fill(row, -1);
        }
        return dfs(nums, start, goal, 0, dp);
    }
    
    private int dfs(int[] nums, int start, int goal, int index, int[][] dp) {
        if (start < 0 || start > 1000) {
            return Integer.MAX_VALUE;
        }
        if (index == nums.length) {
            return start == goal ? 0 : Integer.MAX_VALUE;
        }
        if (dp[index][start] != -1) {
            return dp[index][start];
        }
        int res = Integer.MAX_VALUE;
        for (int i = 0; i < 3; i++) {
            int newStart = start;
            if (i == 0) {
                newStart += nums[index];
            } else if (i == 1) {
                newStart -= nums[index];
            } else {
                newStart ^= nums[index];
            }
            int count = dfs(nums, newStart, goal, index + 1, dp);
            if (count != Integer.MAX_VALUE) {
                res = Math.min(res, 1 + count);
            }
        }
        return dp[index][start] = res;

=======

        int n = nums.length;
        int[][] dp = new int[n][1001];
        for (int i = 0; i < n; i++) {
            Arrays.fill(dp[i], -1);
        }
        for (int i = 0; i < 1001; i++) {
            dp[0][i] = Math.abs(i - start);
        }
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < 1001; j++) {
                if (dp[i - 1][j] != -1) {
                    if (j + nums[i] <= 1000) {
                        dp[i][j + nums[i]] = Math.min(dp[i][j + nums[i]] != -1 ? dp[i][j + nums[i]] : Integer.MAX_VALUE, dp[i - 1][j] + 1);
                    }
                    if (j - nums[i] >= 0) {
                        dp[i][j - nums[i]] = Math.min(dp[i][j - nums[i]] != -1 ? dp[i][j - nums[i]] : Integer.MAX_VALUE, dp[i - 1][j] + 1);
                    }
                    dp[i][j ^ nums[i]] = Math.min(dp[i][j ^ nums[i]] != -1 ? dp[i][j ^ nums[i]] : Integer.MAX_VALUE, dp[i - 1][j] + 1);
                }
            }
        }
        return dp[n - 1][goal] == -1 ? -1 : dp[n - 1][goal];

=======

        int n = nums.length;
        int[] dp = new int[2001];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[start + 1000] = 0;
        for (int x : nums) {
            int[] dp2 = new int[2001];
            Arrays.fill(dp2, Integer.MAX_VALUE);
            for (int s = 0; s <= 2000; ++s) {
                if (dp[s] != Integer.MAX_VALUE) {
                    dp2[s] = Math.min(dp2[s], dp[s]);
                    dp2[s + x] = Math.min(dp2[s + x], dp[s] + 1);
                    dp2[s - x] = Math.min(dp2[s - x], dp[s] + 1);
                    dp2[s ^ x] = Math.min(dp2[s ^ x], dp[s] + 1);
                }
            }
            dp = dp2;
        }
        return dp[goal + 1000] < Integer.MAX_VALUE ? dp[goal + 1000] : -1;

=======

        int target = Math.abs(goal - start);
        int[] dp = new int[2001];
        Arrays.fill(dp, -1);
        dp[start] = 0;
        for (int num : nums) {
            int[] next = new int[2001];
            Arrays.fill(next, -1);
            for (int i = 0; i < 2001; i++) {
                if (dp[i] == -1) {
                    continue;
                }
                if (i + num < 2001) {
                    next[i + num] = Math.max(next[i + num], dp[i] + 1);
                }
                if (i - num >= 0) {
                    next[i - num] = Math.max(next[i - num], dp[i] + 1);
                }
                next[i ^ num] = Math.max(next[i ^ num], dp[i] + 1);
            }
            dp = next;
        }
        return dp[target];

=======

        int n = nums.length;
        // dp[i][j] := min operations to reach j using first i numbers
        int[][] dp = new int[n + 1][1001];
        for (int[] row : dp) {
            Arrays.fill(row, Integer.MAX_VALUE);
        }
        dp[0][start] = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j <= 1000; ++j) {
                if (dp[i][j] == Integer.MAX_VALUE) {
                    continue;
                }
                if (j + nums[i] <= 1000) {
                    dp[i + 1][j + nums[i]] = Math.min(dp[i + 1][j + nums[i]], dp[i][j] + 1);
                }
                if (j - nums[i] >= 0) {
                    dp[i + 1][j - nums[i]] = Math.min(dp[i + 1][j - nums[i]], dp[i][j] + 1);
                }
                dp[i + 1][j ^ nums[i]] = Math.min(dp[i + 1][j ^ nums[i]], dp[i][j] + 1);
            }
        }
        return dp[n][goal] == Integer.MAX_VALUE ? -1 : dp[n][goal];
