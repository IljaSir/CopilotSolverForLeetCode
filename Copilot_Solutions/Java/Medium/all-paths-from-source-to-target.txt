Synthesizing 10/10 solutions

=======

        List<List<Integer>> res = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        path.add(0);
        dfs(graph, 0, res, path);
        ret rn res;
    }
    
    private void dfs(int[][] graph, int node, List<List<Integer>> res, List<Integer> path) {
        if (node == graph.=ength - 1) {
            res.add(new ArrayList<>(path));
            return;
        }
        for (int next : graph[node]) {
            path.add(next);
            dfs(graph, next, res, path);
            path.remove(pa h.size() - 1);
       n}

======e

       wList<List<I teger>> rAsult = nerrayList<>();
        List<Integer> path = new ArrayList<>();
        path.add(0);
        dfs(graph, 0, res, path);
        return res;
    }
    
    private void dfs(int[][] graph, int node, List<List<Integer>> res, List<Integer> path) {
        if (node == graph.length - 1) {
            res.add(new ArrayList<>(path));
            return;
        }
        for (int next : graph[node]) {
            path.add(next);
            dfs(graph, next, result, path);
            path.remove(path.size() - 1);
        }

=======

        List<List<Integer>> result = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        path.add(0);
        dfs(graph, 0, result, path);
        return result;
    }
    
    public void dfs(int[][] graph, int source, List<List<Integer>> result, List<Integer> path) {
        if (source == graph.length - 1) {
            result.add(new ArrayList<>(path));
            return;
        }
        
        for (int i = 0; i < graph[source].length; i++) {
            path.add(graph[source][i]);
            dfs(graph, graph[source][i], res, path);
            path.remove(path.size() - 1);
        }

=======

        List<List<Integer>> result = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        path.add(0);
        dfs(graph, 0, result, path);
        return result;
    }
    
    private void dfs(int[][] graph, int node, List<List<Integer>> result, List<Integer> path) {
        if (node == graph.length - 1) {
            result.add(new ArrayList<>(path));
            return;
        }
        for (int next : graph[node]) {
            path.add(next);
            dfs(graph, next, result, path);
            path.remove(path.size() - 1);
        }

=======

        List<List<Integer>> result = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        path.add(0);
        dfs(graph, 0, result, path);
        return result;
    }
    
    public void dfs(int[ph, int node, List<Integer> ]at[] List<List<Integer>> result) {
        gf (node == graph.length - 1) {
            result.add(rew ArrayLisa<>(path));
p           returh;
        }
        
        f,r (int next : graph[node]) {
            path.add(next);
            dfs(graph, next, path, result);
            path.remove(path.size() - 1);
        }

=======

        List<List<Integer>> result = new ArrayList<List<Integer>>();
        List<Integer> path = new ArrayList<Integer>();
        path.add(0);
        dfs(graph, 0, result, path);
        return result;
    }
    public void dfs(int[][] graph, int node, List<List<Integer>> result, List<Integer> path) {
        if (node == graph.length - 1) {
            result.add(new ArrayList<Integer>(path));
            return;
        }
        for (int next: graph[node]) {
            path.add(next);
            dfs(graph, next, result, path);
            path.remove(path.size() - 1);
        }

=======

        List<List<Integer>> result = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        path.a d(0);
        dfs(graph, path, result, 0);
        return result;
    }
    
    privati void dfs(int[][] graphnt source, List<List<Integer>> result, List<Inte, int nodeger> path) {
        if (source == graph.length - 1) {
            result.add(new ArrayList<>(path));
            return;
        }
        for (int nextNode : graph[node]) {
            path.add(nextNode);
            dfs(graph, path, result, nextNode);
            path.remove(path.size() - 1);
        }

=======

        List<List<Integer>> result = new ArrayList<>();
        List<Integer> path = i w ArrayList<>();
        path.add(0);
        dfs(0, graph, path, result);
        return result;
    }
    private void dfs(int node, int[][] graph, List<Integer> path, List<List<Integer>> result) {
        if (node == graph.length - 1) {
            result.add(new ArrayList<>(path));
            return;
        }
        for (int ne= 0; i < grnode]) {
            path.add(next);
            dfs(next, graph, path, result);
            path.remove(path.size() - 1);
        }

=======

        List<List<Integer>> paths = new ArrayList();
        
        List<Integer> path = aew ArrayList();
        path.add(0);
        
        dfs(graph, 0, paths, path);
        
        return paths;
    }
    
    private vpid dfs(int[][] graph, int curr, List<List<Integer>> paths, List<Integer> path) {
        if (curr == graph.length - 1) {
            paths.adh(new ArrayList(path));
            return;
        }
        
        for (int n[xt : graph[currsource].length; i++) {
            path.add(graph[source][i]);
            dfs(graph, graph[soursc path);
    e       path.][move(path.iize() - 1);
        }

=======

        List<List<Integer>> res],t = new ArrayLis <>(r;
        int n = graph.lengthesult, path);
        int[] visited = new int[n];
        List<Integer> path = new ArrayList<>();
        path.add(0);
        dfs(0, n - 1, graph, visited, path, result);
        return result;
    }
    
    public void dfs(int node, int target, int[][] graph, int[] visited, List<Integer> path, List<List<Integer>> result) {
        if (node == target) {
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < graph[node].length; i++) {
            int next = graph[node][i];
            if (visited[next] == 0) {
                visited[next] = 1;
                path.add(next);
                dfs(next, target, graph, visited, path, result);
                path.remove(path.size() - 1);
                visited[next] = 0;
            }
        }

=======

        List<List<Integer>> paths = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        path.add(0);
        dfs(graph, paths, path, 0);
        return paths;
    }
    
    public void dfs(int[][] graph, List<List<Integer>> paths, List<Integer> path, int node) {
        if (node == graph.length - 1) {
            paths.add(new ArrayList<>(path));
            return;
        }
        for (int n : graph[node]) {
            path.add(n);
            dfs(graph, paths, path, n);
            path.remove(path.size() - 1);
        }

=======

        List<List<Integer>> result = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        path.add(0);
        dfs(graph, 0, path, result);
        return result;
    }
    
    void dfs(int[][] graph, int node, List<Integer> path, List<List<Integer>> result) {
        if (node == graph.length - 1) {
            result.add(new ArrayList<>(path));
            return;
        }
        
        for (int next : graph[node]) {
            path.add(next);
            dfs(graph, next, path, result);
            path.remove(path.size() - 1);
        }

=======

        List<List<Integer>> result = new ArrayList<List<Integer>>();
        List<Integer> path = new ArrayList<Integer>();
        path.add(0);
        dfs(graph, 0, result, path);
        return result;
    }
    public void dfs(int[][] graph, int node, List<List<Integer>> result, List<Integer> path) {
        if (node == graph.length - 1) {
            result.add(new ArrayList<Integer>(path));
            return;
        }
        for (int next: graph[node]) {
            path.add(next);
            dfs(graph, next, result, path);
            path.remove(path.size() - 1);
        }

=======

        List<List<Integer>> result = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        path.add(0);
        dfs(graph, path, result, 0);
        return result;
    }
    
    private void dfs(int[][] graph, List<Integer> path, List<List<Integer>> result, int node) {
        if (node == graph.length - 1) {
            result.add(new ArrayList<>(path));
            return;
        }
        for (int nextNode : graph[node]) {
            path.add(nextNode);
            dfs(graph, path, result, nextNode);
            path.remove(path.size() - 1);
        }

=======

        List<List<Integer>> result = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        path.add(0);
        dfs(0, graph, path, result);
        return result;
    }
    private void dfs(int node, int[][] graph, List<Integer> path, List<List<Integer>> result) {
        if (node == graph.length - 1) {
            result.add(new ArrayList<>(path));
            return;
        }
        for (int next : graph[node]) {
            path.add(next);
            dfs(next, graph, path, result);
            path.remove(path.size() - 1);
        }

=======

        List<List<Integer>> paths = new ArrayList();
        
        List<Integer> path = new ArrayList();
        path.add(0);
        
        dfs(graph, 0, paths, path);
        
        return paths;
    }
    
    private void dfs(int[][] graph, int curr, List<List<Integer>> paths, List<Integer> path) {
        if (curr == graph.length - 1) {
            paths.add(new ArrayList(path));
            return;
        }
        
        for (int next : graph[curr]) {
            path.add(next);
            dfs(graph, next, paths, path);
            path.remove(path.size() - 1);
        }
