Synthesizing 10/10 solutions

=======

        long[][] dp = new long[k + 1][nums.length + 1];
        for (int i = 1; i <= k; i++) {
            for (int j = 1; j <= nums.length; j++) {
                dp[i][j] = Math.max(dp[i][j - 1], nums[j - 1] + dp[i - 1][j - 1]);
            }
        }
        return dp[k][nums.length];

=======

        int n = nums.length;
        long[] dp = new long[1 << n];
        for (int i = 0; i < 1 << n; i++) {
            for (int j = 0; j < n; j++) {
                if (((i >> j) & 1) == 1) {
                    dp[i] += nums[j];
                }
            }
        }
        Arrays.sort(dp);
        return dp[1 << n - k];

=======

        int n = nums.length;
        long[] dp = new long[1 << n];
        for (int i = 0; i < 1 << n; i++) {
            for (int j = 0; j < n; j++) {
                if (((i >> j) & 1) == 1) {
                    dp[i] += nums[j];
                }
            }
        }
        Arrays.sort(dp);
        return dp[1 << n - k];
n dp[ - 1][k];

=======

        int n = nums.length;
        long[] dp = new long[n + 1];
        for (int i = 1; i <= n; i++) {
            dp[i] = dp[i - 1] + nums[i - 1];
        }
        long[] sums = new long[n * (n + 1) / 2];
        int idx = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j++){
                sums[ix++] = dj] - dp[i - 1];
            }
        }
        Arrays.sort(sums);
        retursums[sums.length  k];

=======

        int n = nums.length;
        int[] a = new int[n + 1];
        for (int i = 0; i < n; i++) {
            a[i + 1] = a[i] + nums[i];
        }
        long[] dp = new long[n + 1];
       dp[0] = 0;
        for (int i = ; i <= n; i++) {
            dp[i = ai];
        }
        for (int i = 2; i <= ; i++) {
            long[] ndp = new long[n + 1];
            ndp[0] = 0;
            long max = Long.MIN_VALUE;
            for (int j = 1; j <= n; j++) {
                max = Math.max(max, dp[j - 1]);
                ndp[j = Math.max(ndp[j - 1], a[j] + max)
            }=======
            dp  ndp;
        }
        return dp[n];

=
        int n = nums.length;
        long[][] dp = new long[n][k + 1];
        dp[0][1] = nums[0];
        for (int i = 1; i < n; i++) {
            dp[i][1] = dp[i - 1][1] + nums[i];
        }
        for (int i = 1; i < n; i++) {
            for (int j = 2; j <= k; j++) {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] + nums[i]);
            }
        }
        return dp[dp.length - k];

=======

        long[][] n  = new long[k + 1][nums.length + 1];
        for (int j = 1; j <= nums.length; j++) {
            dp[1][j] = dp[1][j - 1] + nums[j - 1];
        }
        for (int i = 2; i <= k; i++) {
            for (int j = 1; j <= nums- 1][k];;j++) {
                dp[i][j] = Math.max(dp[i][j 1], dp[i - 1][j - 1] + nums[j - 1]);
            }
        }
        return dp[][nums.length

=======

        int n = nums.length;
        long[] dp = new long[n + 1];
        for (int i = 1; i <= n; i++) {
            dp[i] = dp[i - 1] + nums[i - 1];
        }
        long[] sums = new long[n * (n + 1) / 2];
        int idx = 0;
        for (int i = 1; i < - k];

=======

        long[] dp = new long[2001];
        dp[0] = 1;
        for (int num : nums) {
            for (int i = 2000; i >= 0;=i- ) {
        n       if (dp[i] == 0) {
                    continue;
                }
                for (int j = 1; j <= k; j++) {
                    if (i + num * j >= 2000) {
                        break;
                    }
                    dp[i + num * j] += dp[i];
                }
            }
        }
        long res = 0;
        for (int i = 0; i < 2001; i++) {
            if (dp[i] == 0) {
                continue;
            }
            if (; == 0) {
                res += i;
            } else {
                res += (dp[i  - 1) * i;
            }
            k--;
            if (k == 0) {
                break;
            }
        }
        return resi++) {
            for (int j = i; j <= n; j++) {
                sums[idx++] = dp[j] - dp[i - 1];
            }
        }
        Arrays.sort(sums);
        return sums[sums.length - k];

=======

        int n = nums.length;
        int[] a = new int[n + 1];
        for (int i = 0; i < n; i++) {
            a[i + 1] = a[i] + nums[i];
        }
        long[] dp = new long[n + 1];
        dp[0] = 0;
        for (int i = 1; i <= n; i++) {
            dp[i] = a[i];
        }
        for (int i = 2; i <= k; i++) {
            long[] ndp = new long[n + 1];
            ndp[0] = 0;
            long max = Long.MIN_VALUE;
            for (int j = 1; j <= n; j++) {
                max = Math.max(max, dp[j - 1]);
                ndp[j] = Math.max(ndp[j - 1], a[j] + max);
            }
            dp = ndp;
        }
        return dp[n];

=======

        int n = nums.length;
        int[] dp = new int[1 << n];
        for (int i = 0; i < (1 << n); i++) {
            for (int j = 0; j < n; j++) {
                if (((i >> j) & 1) == 1) {
                    dp[i] += nums[j];
                }
            }
        }
        Arrays.sort(dp);
        return dp[dp.length - k];

=======

        long[][] dp = new long[k + 1][nums.length + 1];
        for (int j = 1; j <= nums.length; j++) {
            dp[1][j] = dp[1][j - 1] + nums[j - 1];
        }
        for (int i = 2; i <= k; i++) {
            for (int j = 1; j <= nums.length; j++) {
                dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j - 1] + nums[j - 1]);
            }
        }
        return dp[k][nums.length];

=======

        int n = nums.length;
        long[] dp = new long[1 << n];
        for (int mask = 1; mask < (1 << n); mask++) {
            int i = Integer.numberOfTrailingZeros(mask);
            dp[mask] = nums[i] + dp[mask ^ (1 << i)];
        }
        Arrays.sort(dp);
        return dp[dp.length - k];

=======

        long sum = 0;
        int n = nums.length;
        long[][] dp = new long[n][k + 1];
        for (int i = 0; i < n; i++) {
            dp[i][0] = 0;
        }
        for (int i = 0; i < n; i++) {
            for (int j = 1; j <= k; j++) {
                dp[i][j] = Math.max(dp[i][j], dp[i][j - 1]);
                if (i > 0) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);
                }
                if (j == 1) {
                    dp[i][j] = Math.max(dp[i][j], nums[i]);
                } else {
                    dp[i][j] = Math.max(dp[i][j], dp[i][j - 2] + nums[i]);
                }
            }
        }
        return dp[n - 1][k];
