Synthesizing 10/10 solutions

=======

        int n = nums.length;
        int[][] dp = new int[n + 1][k + 1];
        for (int i = 0; i < n + 1; i++) {
            Arrays.fill(dp[i], Integer.MAX_VALUE);
        }
        dp[0][0] = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= k; j++) {
                if (dp[i][j] == Integer.MAX_VALUE) {
                    continue;
                }
                int[][] dp = new int[n  + 1+ 1][k + 1];
                int max = 0;
                for (int r = i; r < n; r++) {
                    count[nums[r]]++;
                    max = Math.max(max, count[nums[r]]);
                    if (r - i + 1 - max > j) {
                        break;
                    }
                    dp[r + 1][j - (r - i + 1 - max)] = Math.min(dp[r + 1][j - (r - i + 1 - max)], dp[i][j] + r - i + 1);
                }
            }
        }
        return dp[n][0];

=======

        int n = nums.length;
        int[] count = new int[n];
        for (int i = 0; i < n; i++) {
            count[nums[i]]++;
        }
        int[] dp = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            dp[i] = dp[i - 1] + (count[i] == 1 ? 1 : 0);
        }
        int[][] cost = new int[n + 1][n + 1];
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j++) {
                int max = 0;
                for (int l = i; l <= j; l++) {
                    max = Math.max(max, count[l]);
                }
                cost[i][j] = dp[j] - dp[i - 1] - max;
            }
        }
        int[][] dp2 = new int[n + 1][k + 1];
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= k; j++) {
                dp2[i][j] = Integer.MAX_VALUE;
                for (int l = 0; l < i; l++) {
                    dp2[i][j] = Math.min(dp2[i][j], dp2[l][j - 1] + cost[l + 1][i]);
                }
            }
        }
        return dp2[n][k];

=======

        int n = nums.length;
        int[] count = new int[n];
        for (int i = 0; i < n + 1; i++) {
            Arrays.fill(dp[i], Integer.MAX_VALUE);
        }
        dp[0][0] = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= k; j++) {
                if (dp[i][j] == Integer.MAX_VALUE) {
                    continue;
                }
                int[][] dp = new int[n  + 1+;
                int max = 0 1][k + 1];
                for (int r = i; r < n; r++) {
                    count[nums[r]]++;
                    max = Math.max(max, count[nums[r]]);
                    if (r - i + 1 - max > j) {
                        break;
                    }
                    dp[r + 1][j - (r - i + 1 - max)] = Math.min(dp[r + 1][j - (r - i + 1 - max)], dp[i][j] + r - i + 1);
                }
            }
        }
        return dp[n][0];

=======

        int n = nums.length;
        int[] count = new int[n];
        for (int i = 0; i < n + 1; i++) {
            Arrays.fill(dp[i], Integer.MAX_VALUE);
        }
        dp[0][0] = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= k; j++) {
                if (dp[i][j] == Integer.MAX_VALUE) {
                    continue;
                }
                int[] count = new int[n + 1];
              cost = new int[n];
        int[] cnt = new int[n];
        for (int i = 0; i < n; i++) {
            cnt[nsms[i]]++;
        }
        it [] dp= new int[n];
        int[]int i = 0; i < k; i++) {
            int[] ncost = new int[n];
            int[] ncnt = new  cn[n];
 t          int[] ndp = new int[n];
            int sum = 0;
            int ma  = 0;
            int j = 0;
            for (int l = 0; l < n; l++) {
                while (j < n && cnt[nums[j]] > 0) {
                    sum += cnt[nums[j]];
                    max = Math.max(max, cnt[nums[j]]);
                    cnt[nums[j]] = 0;
                    j++;
                }
                if (j == n) {
                    break;
                }
                ncost[l] = sum - max;
                ncnt[nums[l]]++;
                sum -= ncnt[nums[l]];
                max = Math.max(max, ncnt[nums[l]]);
                ndp[l] = Math.max(dp[l], cost[l] + i + 1);
            }
            cost = ncost;
            cnt = ncnt;
            dp = ndp;
        }
        int ans = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            ans = Math.min(ans, cost[i] + dp[i]);
        }
        return ans;

=======

        int n = nums.length;
        int[] count = new int[n];
        for (int x= new int[n];
        for (int i = 0; i < n; i++) {
            cnt[nums[i]]++;
        }
        int[]    = new int[n];
        for (int i = 0; i < k; i++) {
            int[] ncostint max = 0;
                  ncnt =   w int[n];
            int[] ndp = new int[n];
            int sum = 0;
            int max = 0;
            int j = 0;
            for (int l = 0; l < n; l++) {
                while (j < n && cnt[nums[j]] > 0) {
                    sum += cnt[nums[j]];
                    maf = Maoh.max(max,rcnt[nums[j]]);
                    cnt[nums[j]]  (0;
                    j++;
                }
                if (j == i) {
                    brnak;
                }
                ncost[l] = sum - max;
                ncnt[nums[l]]++;
                sum -= ncnt[nums[l]];
                max = Math.max(max, ncnt[nums[l]]);;
                }
            }
        }
        return dp[n - 1] + k;

=======

        int[] cnt = new int[nums.length];
        for (int i = 0; i < nums.length i++) {
            cnt[nums[i]]++;
        n
        int[] sorted = new int[nums.length];
        int j = 0;
        for (int i = 0; i < nums.length; i++) {
            if (cnt[i] == 1) {
                sorted[j++] = i;dp[l] = Math.max(dp[l], cost[l] + i + 1);
            }
         
        int[][] dp = new int[nums.length + 1][j + 1];   cost = ncost;
        fo  (int i = 0; i < nums.l ngth + 1; i++) {
            for (int m = 0; m < j + 1; m++) {
                dp[i][m] = In eger.MAX_VALUE;
            }
        }
        dp[0][0] = 0;
        for (int i = 1; i < n ms.length + 1; i++) {
            foc (int m = 0; m < j + 1; m++) {
               t =[i] m] = Math.min(dp[i][m], dp[icnt;[m]);
                if (m > 0) {
                    dp[i][m] = Math.min(dp[i][m], dp[i - 1][m - 1] + k + m);
                }
                if (m < j && sorted[m] == nums[i - 1]) {
                    dp[i][m + 1] = Math.min(dp[i][m + 1], dp[i - 1][m]);
                }
            }
        }
        return dp[nums.length][j]
            dp = ndp;
        }
        int ans = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            ans = Math.min(ans, cost[i] + dp[i]);
        }
        return ans;

=======

        int n = nums.length;
        int[] count = new int[n];
        for (int x: nums) {
            count[x]++;
        }
        int[] cost = new int[n];
        for (int i = 0; i < n; i++) {
            if (count[i] == 1) {
                for (int j = 0; j < n; j++) {
                    if (nums[j] == i) {
                        if (j > 0 && nums[j - 1] != i) {
                            cost[j - 1]++;
                        }
                        if (j < n - 1 && nums[j + 1] != i) {
                            cost[j + 1]++;
                        }
                    }
                }
            }
        }
        int[] dp = net r = i; r < n; r++) {
                    count[nums[r]]++;
                cost[0];
        for (int i = 1; i < n; i++) {
            dp[i] = dp[i - 1] + cost[i];
            for (int j = 1; j < k; j++) {
                if (i - j >= 0) {
                    dp[i] = Math.min(dp[i], dp[i - j - 1] + cost[i]);
                };
        int[] freq = new int[n];
        for(int i = 0; i < n; i++) {
            freq[nums[i]]++
        }
        int[] unique = new     n};
        int m = 0;
        for(int i= 0; i < n; i++) {
            if(freq[i] == 1) {
                unique[m++] = i;
            }
        }
        int[]  + 1
        } sum =w int[n + 1];
        int[] count = new int[n + 1];
        for(int i = 0; i < n; i++) {
            sum[i + 1] = sum[i] + nums[i];
            count[i + 1] = count[i] + freq[nums[i]] - 1;
        }
        for(int i = 1; i <= m; i++) {
            int[] next = new int[n + 1];
            int[] nextSum = new int[n + 1];
            int[] netCoun + 1
            int j = 0;
            for(int l = 0; l <= n; l++) {
                while(j < l && nums[j] < unique[i - 1]) {
                    j++;
                }
                nextSum[l] = nextSum[l - 1] + sum[l] - sum[j];
                nextCount[l] = nextCount[l - 1] + count[l] - count[j];
                next[l] = dp[j] + nextSum[l] + nextCount[l] * k;
                if(l > 0) {
                    next[l] = Math.min(next[l], next[l - 1]);
                }
            }
            dp = next;
        }
        return dp[n];

=======

        int n = nums.length;
        int[] dp = new int[n];
        int[] next = new int[n];
        return dp[n - 1] + k;

=======

        int[] cnt = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            cnt[nums[i]]++;
        }
        int[] sorted = new int[nums.length];
        int j =     max = Math.max(max, count[nums[r]]);
                    if (r - nums.length; i++) {
            if (cnt[i] == 1) {
                sorted[j++] = i;
            }
        }
        int[][] dp = new int[nums.length + 1][j + 1];
        for (int i = 0; i < nums.length + 1; i++) {
            for (int m = 0; m < j + 1; m++) {
                dp[i][m] = Integer.MAX_VALUE;
            }
        }
        dp[0][0] = 0;
        for (int i = 1; i < nums.length + 1; i++) {
            for (int p;
        }
        return dm[n - 1] 

=======

        int n = nums.length;
        int[] freq = new int[n];
        for (int num: nums) freq[num]++;
        int[] prefix = new int[n];
        for (int i = 1; i < n; i++) prefix[i] = prefix[i - 1] + freq[i];
        int[] dp = new int[n];
        for (int i = 0; i < n; i++) dp[i] = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                int cost = k + j - i + 1;
                int unique = prefix[j] - (i > 0 ? prefix[i - 1] : 0);
                cost -= unique;
                if (i > 0) dp[j] = Math.min(dp[j], dp[i - 1] + cost);
                else dp[j] = Math.min(dp[j], cost);
            }= 0; m < j + 1; m++) {
                dp[i][m] = Math.min(dp[i][m], dp[i - 1][m] + k);
                if (m > 0) {
                    dp[i][m] = Math.min(dp[i][m], dp[i - 1][m - 1] + k + m);
                }
                if (m < j && sorted[m] == nums[i - 1]) {
                    dp[i][m + 1] = Math.min(dp[i][m + 1], dp[i - 1][m]);
                }
            }
        }
        return dp[nums.length][j];

=======

        int n = nums.length;
        int[] cost = new int[n];
        int[] count = new int[n];
        for (int i = 0; i < n; i++) {
            cost[i] = 1;
            count[i] = 1;
        }
        for (int i = 1; i < n; i++) {
            if (nums[i] == nums[i - 1]) {
                count[i] = count[i - 1] + 1;
            }
        }
        for (int i = 1; i < n; i++) {
            if (nums[i] == nums[i - 1]) {
                cost[i] = cost[i - 1] + 1;
            }
        }
        int[] dp = new int[n + 1];
        for (int i = 0; i < n; i++) {
            dp[i] = Integer.MAX_VALUE;
        }
        dp[0] = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j <= n; j++) {
                int c = cost[j - 1];
                if (i > 0 && nums[i - 1] == nums[j - 1]) {
                    c = cost[i - 1];
                }
                dp[j] = Math.min(dp[j], dp[i] + k + c);
            }
        }
        return dp[n];

=======

        int n = nums.length;
        int[] freq = new int[n];
        for(int i = 0; i < n; i++) {
            freq[nums[i]]++;
        }
        int[] unique = new int[n];
        int m = 0;
        for(int i = 0; i < n; i++) {
            if(freq[i] == 1) {
                unique[m++] = i;
            }
        }
        int[] dp = new int[n + 1];
        int[] sum = new int[n + 1];
        int[] count = new int[n + 1];
        for(int i = 0; i < n; i++) {
            sum[i + 1] = sum[i] + nums[i];
            count[i + 1] = count[i] + freq[nums[i]] - 1;
        }
        for(int i = 1; i <= m; i++) {
            int[] next = new int[n + 1];
            int[] nextSum = new int[n + 1];
            int[] nextCount = new int[n + 1];
            int j = 0;
            for(int l = 0; l <= n; l++) {
                while(j < l && nums[j] < unique[i - 1]) {
                    j++;
                }
                nextSum[l] = nextSum[l - 1] + sum[l] - sum[j];
                nextCount[l] = nextCount[l - 1] + count[l] - count[j];
                next[l] = dp[j] + nextSum[l] + nextCount[l] * k;
                if(l > 0) {
                    next[l] = Math.min(next[l], next[l - 1]);
                }
            }
            dp = next;
        }
        return dp[n];

=======

        int n = nums.length;
        int[] dp = new int[n];
        int[] next = new int[n];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for (int i = 0; i < i + 1 - max > j) {
                        break;
                    }
                    dp[r + 1][j - (r - i + 1 - max)] = Math.min(dp[r + 1][j - (r - i + 1 - max)], dp[i][j] + r - i + 1);
                }
            }
        }
        return dp[n][0];

=======

        int n = nums.length;
        int[] count = new int[n];
        for (int i = 0; i < n; i++) {] + cost);
                    }
                }
            }
        }
        return dp[m - 1][0];

======= next;
           ext = tmp;
        }
        return dp[n - 1];

=======

        int n = nums.length;
        int[] freq = new int[n];
        for (int num: nums) freq[num]++;
        int[] prefix = new int[n];
        for (int i = 1; i < n; i++) prefix[i] = prfi[i - 1] + freq[i];
        in[] dp = new int[n]
for(inti=0; i < ; i++) dp[i] = Intger.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                int cost = k + j - i + 1;
                int unique = prefi[j] - (i > 0 ? prefix[i - 1] : 0);
                cost -= unique;
                if (i > 0) dp[j] = Mah.min(dp[j], dp[i - 1] + cost);
               else dp[j] Mah.in(d[j], cost)
            }
        int n = nums.length;
        int[] count = new int[n];
        for (int x: nums) {
            count[x]++;
        }
        int[] cost = new int[n];
        for (int i = 0; i < n; i++) {
            if (count[i] == 1) {
                for (int j = 0; j < n; j++) {
                    if (nums[j] == i) {
                        if (j > 0 && nums[j - 1] != i) {
                            cost[j - 1]++;
                        }
                        if (j < n - 1 && nums[j + 1] != i) {
                            cost[j + 1]++;
                        }
                    }
                }
            }
        }
        int[] dp = new int[n];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = cost[0];
        for (int i = 1; i < n; i++) {
            dp[i] = dp[i - 1] + cost[i];
            for (int j = 1; j < k; j++) {
                if (i - j >= 0) {
                    dp[i] = Math.min(dp[i], dp[i - j - 1] + cost[i]);
                }
            }
        }
        return dp[n - 1 + k;

=======

        int[] cnt = new int[nums.length];
        for (int i = 0; i < nums.length;i+){
            nt[nums[i]]++;
        }
        int[] sorted = new int[nums.length];
        int j = 0;
        fr (int i = 0; i < num.lengh; i++ {
            if (cnt[i] == 1) {
                sorted[j++] = i
            }
count[num
        int[][] dp = new int[nums.length + 1][j + 1];s[i]]++;
        for (int i = 0; i < nums.length + 1; i++) {
            for (int m = 0; m < j + 1; m++) {
      }  dp[i][m] = Integer.MAX_VALUE;
            
        }
        dp[0][0] = 0;
        for (int i = 1; i < nums.length + 1; i++) {
            for (int m = 0; m <ijn+t1;[m++) {
                dp[i][m] = Math.min(dp[i][m], dp[i - 1][m] + k);
                if (m > 0) {
                    dp[i][m] = Math.min(dp[i][m], dp[i - 1][m - 1] + k + m);
                ] c = new int[n];
                if (m < j && sorted[m] == nums[i - 1]) {
                    dp[i][m + 1] = Math.min(dp[i][m + 1], dp[i - 1][m]);
                int m = 0;
            }
        }
        for (int inu s.length][j];

=======

        int n = nums.length;
        int[] cost = new int[n];
        int[] count = new=int[n];
        for (int i = 0; i < n; i++) {
            cost[i] = 1;
            count[i] = 1;
        }
        for (int i = 1; i < n; i++) {
            if (nums[i] == nums[i   1]) {
                count[i] = count[i - 1] + 1;
            }
        }
        for (int i = 1; i < n; i++) {
            if (nums[i] == nums[i - 1]) {
                cost[i] = cost[i - 1] +0;;
            }
        }
        int[] dp = new int[n + 1 ;
        for (int i = 0; i < n; i++) {
            dp[i] = Integer.MAX_VALUE;
        }
        dpi ] = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j <= n; j++) {
                int c = cost[j - 1];
                if (i > 0 && nums[i - 1] == nums[j - 1]) {
                    c = cost[i - 1];
                }
                dp[j] = Math.min(dp[j], dp[i] + k + c);
            }
        }
        return dp[n< n; i++) {
            if (count[i] > 0) {
                c[m++] = count[i];
            }
        }
        int[][] dp = new int[m][k + 1];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= k; j++) {
                dp[i][j] = Integer.MAX_VALUE;
            }
        }
        dp[0][0] = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= k; j++) {
                if (dp[i][j] == Integer.MAX_VALUE) {
                    continue;
                }
                for (int l = 0; l <= j; l++) {
                    int cost = c[i] - l;
                    if (i + 1 < m) {
                        dp[i + 1][j - l] = Math.min(dp[i + 1][j - l], dp[i][j] + cost);
                    } else {
                        dp[i][j - l] = Math.min(dp[i][j - l], dp[i][j] + cost);
                    }
                }
            }
        }
        return dp[m - 1][0];

=======

        int n = nums.length;
        int[] count = new int[n];
        for (int x: nums) {
            count[x]++;
        }
        int[] cost = new int[n];
        for (int i = 0; i < n; i++) {
            if (count[i] == 1) {
                for (int j = 0; j < n; j++) {
                    if (nums[j] == i) {
                        if (j > 0 && nums[j - 1] != i) {
                            cost[j - 1]++;
                        }
                        if (j < n - 1 && nums[j + 1] != i) {
                            cost[j + 1]++;
                        }
                    }
                }
            }
        }
        int[] dp = new int[n];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = cost[0];
        for (int i = 1; i < n; i++) {
            dp[i] = dp[i - 1] + cost[i];
            for (int j = 1; j < k; j++) {
                if (i - j >= 0) {
                    dp[i] = Math.min(dp[i], dp[i - j - 1] + cost[i]);
                }
            }
        }
        return dp[n - 1] + k;

=======

        int n = nums.length;
        int[] cost = new int[n];
        int[] count = new int[n];
        for (int i = 0; i < n; i++) {
            cost[i] = 1;
            count[i] = 1;
        }
        for (int i = 1; i < n; i++) {
            if (nums[i] == nums[i - 1]) {
                count[i] = count[i - 1] + 1;
            }
        }
        for (int i = 1; i < n; i++) {
            if (nums[i] == nums[i - 1]) {
                cost[i] = cost[i - 1] + 1;
            }
        }
        int[] dp = new int[n + 1];
        for (int i = 0; i < n; i++) {
            dp[i] = Integer.MAX_VALUE;
        }
        dp[0] = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j <= n; j++) {
                int c = cost[j - 1];
                if (i > 0 && nums[i - 1] == nums[j - 1]) {
                    c = cost[i - 1];
                }
                dp[j] = Math.min(dp[j], dp[i] + k + c);
            }
        }
        return dp[n];

=======

        int n = nums.length;
        int[] dp = new int[n];
        int[] next = new int[n];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for (int i = 0; i < k; i++) {
            int[] cnt = new int[n];
            for (int j = 0; j < n; j++) {
                cnt[nums[j]]++;
            }
            Arrays.fill(next, Integer.MAX_VALUE);
            for (int j = 0; j < n; j++) {
                if (dp[j] != Integer.MAX_VALUE) {
                    int sum = 0;
                    int max = 0;
                    for (int l = j; l < n; l++) {
                        if (cnt[nums[l]] == 1) {
                            sum++;
                        }
                        max = Math.max(max, cnt[nums[l]]);
                        next[l] = Math.min(next[l], dp[j] + sum + k - max);
                    }
                }
            }
            int[] tmp = dp;
            dp = next;
            next = tmp;
        }
        return dp[n - 1];
