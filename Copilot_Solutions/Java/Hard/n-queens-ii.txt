Synthesizing 10/10 solutions

=======

        int[] res = {0};
        boolean[] col = new boolean[n];
        boolean[] dia1 = new boolean[2 * n - 1];
        boolean[] dia2 = new boolean[2 * n - 1];
        dfs(n, 0, res, col, dia1, dia2);
        return res[0];
    }
    private void dfs(int n, int row, int[] res, boolean[] col, boolean[] dia1, boolean[] dia2) {
        if (row == n) {
            res[0]++;
            return;
        }
        for (int i = 0; i < n; i++) {
            if (!col[i] && !dia1[row + i] && !dia2[row - i + n - 1]) {
                col[i] = true;
                dia1[row + i] = true;
                dia2[row - i + n - 1] = true;
                dfs(n, row + 1, res, col, dia1, dia2);
                col[i] = false;
                dia1[row + i] = false;
                dia2[row - i + n - 1] = false;
            }
        }

=======

        int[] result = new int[1];
        boolean[] cols = new boolean[n];
        boolean[] d1 = new boolean[2 * n - 1];
        boolean[] d2 = new boolean[2 * n - 1];
        dfs(result, cols, d1, d2, 0, n);
        return result[0];
    }
    private void dfs(int[] result, boolean[] cols, boolean[] d1, boolean[] d2, int row, int n) {
        if (row == n) {
            result[0]++;
            return;
        }
        for (int col = 0; col < n; col++) {
            int id1 = row + col;
            int id2 = row - col + n - 1;
            if (cols[col] || d1[id1] || d2[id2]) {
                continue;
            }
            cols[col] = true;
            d1[id1] = true;
            d2[id2] = true;
            dfs(result, cols, d1, d2, row + 1, n);
            cols[col] = false;
            d1[id1] = false;
            d2[id2] = false;
        }

=======

        int[] queens = new int[n];
        Arrays.fill(queens, -1);
        return totalNQueens(queens, 0);
    }

    private int totalNQueens(int[] queens, int row) {
        if (row == queens.length) {
            return 1;
        }
        int total = 0;
        for (int col = 0; col < queens.length; col++) {
            if (isValid(queens, row, col)) {
                queens[row] = col;
                total += totalNQueens(queens, row + 1);
                queens[row] = -1;
            }
        }
        return total;
    }

    private boolean isValid(int[] queens, int row, int col) {
        for (int i = 0; i < row; i++) {
            if (queens[i] == col || Math.abs(queens[i] - col) == Math.abs(i - row)) {
                return false;
            }
        }
        return true;

=======

        int[] res = new int[1];
        int[] queens = new int[n];
        Arrays.fill(queens, -1);
        dfs(queens, 0, res);
        return res[0];
    }
    private void dfs(int[] queens, int row, int[] res) {
        if (row == queens.length) {
            res[0]++;
            return;
        }
        for (int i = 0; i < queens.length; i++) {
            if (isValid(queens, row, i)) {
                queens[row] = i;
                dfs(queens, row + 1, res);
                queens[row] = -1;
            }
        }
    }
    private boolean isValid(int[] queens, int row, int col) {
        for (int i = 0; i < row; i++) {
            if (queens[i] == col || Math.abs(queens[i] - col) == Math.abs(i - row)) {
                return false;
            }
        }
        return true;

=======

        int[] queens = new int[n];
        Arrays.fill(queens, -1);
        return totalNQueens(queens, 0);
    }
    public int totalNQueens(int[] queens, int row) {
        int n = queens.length;
        if (row == n) {
            return 1;
        }
        int count = 0;
        for (int col = 0; col < n; col++) {
            if (isValid(queens, row, col)) {
                queens[row] = col;
                count += totalNQueens(queens, row + 1);
            }
        }
        return count;
    }
    public boolean isValid(int[] queens, int row, int col) {
        for (int i = 0; i < row; i++) {
            if (queens[i] == col) {
                return false;
            }
            if (Math.abs(queens[i] - col) == Math.abs(i - row)) {
                return false;
            }
        }
        return true;

=======

        int[] result = new int[1];
        int[] queens = new int[n];
        Arrays.fill(queens, -1);
        placeQueen(queens, 0, result);
        return result[0];
    }
    
    private void placeQueen(int[] queens, int row, int[] result) {
        if (row == queens.length) {
            result[0]++;
            return;
        }
        
        for (int col = 0; col < queens.length; col++) {
            if (isValid(queens, row, col)) {
                queens[row] = col;
                placeQueen(queens, row + 1, result);
            }
        }
    }
    
    private boolean isValid(int[] queens, int row, int col) {
        for (int i = 0; i < row; i++) {
            if (queens[i] == col) {
                return false;
            }
            
            if (Math.abs(queens[i] - col) == Math.abs(i - row)) {
                return false;
            }
        }
        
        return true;

=======

        int[] result = new int[1];
        backtrack(result, new int[n], 0, n);
        return result[0];
    }
    
    private void backtrack(int[] result, int[] queens, int row, int n) {
        if (row == n) {
            result[0]++;
            return;
        }
        for (int col = 0; col < n; col++) {
            if (isValid(queens, row, col)) {
                queens[row] = col;
                backtrack(result, queens, row + 1, n);
            }
        }
    }
    
    private boolean isValid(int[] queens, int row, int col) {
        for (int i = 0; i < row; i++) {
            if (queens[i] == col || Math.abs(queens[i] - col) == Math.abs(i - row)) {
                return false;
            }
        }
        return true;

=======

        int[] result = new int[1];
        int[] queens = new int[n];
        for (int i = 0; i < n; i++) {
            queens[i] = -1;
        }
        solveNQueens(0, queens, result);
        return result[0];
    }
    private void solveNQueens(int row, int[] queens, int[] result) {
        int n = queens.length;
        if (row == n) {
            result[0]++;
            return;
        }
        for (int col = 0; col < n; col++) {
            if (isValid(row, col, queens)) {
                queens[row] = col;
                solveNQueens(row + 1, queens, result);
                queens[row] = -1;
            }
        }
    }
    private boolean isValid(int row, int col, int[] queens) {
        for (int i = 0; i < row; i++) {
            if (queens[i] == col || Math.abs(queens[i] - col) == row - i) {
                return false;
            }
        }
        return true;

=======

        if (n < 1) {
            return 0;
        }
        int[] result = new int[]{0};
        totalNQueens(n, 0, 0, 0, 0, result);
        return result[0];
    }
    public void totalNQueens(int n, int row, int col, int ld, int rd, int[] result) {
        if (row >= n) {
            result[0]++;
            return;
        }
        int bits = (~(col | ld | rd)) & ((1 << n) - 1);
        while (bits > 0) {
            int p = bits & -bits;
            totalNQueens(n, row + 1, col | p, (ld | p) << 1, (rd | p) >> 1, result);
            bits = bits & (bits - 1);
        }

=======

        if (n <= 0) {
            return 0;
        }
        int[] result = new int[1];
        int[] queens = new int[n];
        placeQueens(queens, 0, n, result);
        return result[0];
    }

    private void placeQueens(int[] queens, int row, int n, int[] result) {
        if (row == n) {
            result[0]++;
            return;
        }
        for (int col = 0; col < n; col++) {
            if (isValid(queens, row, col)) {
                queens[row] = col;
                placeQueens(queens, row + 1, n, result);
            }
        }
    }

    private boolean isValid(int[] queens, int row, int col) {
        for (int i = 0; i < row; i++) {
            if (queens[i] == col) {
                return false;
            }
            if (row - i == Math.abs(col - queens[i])) {
                return false;
            }
        }
        return true;
