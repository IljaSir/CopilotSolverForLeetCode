Synthesizing 10/10 solutions

=======

        int[] count = new int[batchSize];
        int ans = 0;
        for (int g : groups) {
            if (g % batchSize == 0) {
                ans++;
            } else {
                count[g % batchSize]++;
            }
        }
        int max = 0;
        for (int i = 1; i < batchSize; i++) {
            max = Math.max(max, Math.min(count[i], count[batchSize - i]));
        }
        ans += max;
        if (count[0] > 0) {
            ans++;
        }
        return ans;

=======

        int[] count = new int[batchSize];
        int ans = 0;
        for (int g : groups) {
            if (g % batchSize == 0) {
                ans++;
            } else {
                count[g % batchSize]++;
            }
        }
        for (int i = 1; i < batchSize; i++) {
            int j = batchSize - i;
            if (i < j) {
                ans += Math.min(count[i], count[j]);
            } else if (i == j) {
                ans += count[i] / 2;
            }
        }
        int[] dp = new int[batchSize];
        Arrays.fill(dp, -1);
        dp[0] = 0;
        for (int i = 1; i < batchSize; i++) {
            for (int j = 1; j <= count[i]; j++) {
                int[] next = dp.clone();
                for (int k = 0; k < batchSize; k++) {
                    if (dp[k] != -1) {
                        int r = (k + j * i) % batchSize;
                        next[r] = Math.max(next[r], dp[k] + (r == 0 ? 1 : 0));
                    }
                }
                dp = next;
            }
        }
        return ans + dp[0];

=======

        int n = groups.length;
        int[] cnt = new int[batchSize];
        for (int i = 0; i < n; i++) {
            cnt[groups[i] % batchSize]++;
        }
        int res = 0;
        res += cnt[0];
        cnt[0] = 0;
        for (int i = 1; i < batchSize; i++) {
            int j = batchSize - i;
            int min = Math.min(cnt[i], cnt[j]);
            res += min;
            cnt[i] -= min;
            cnt[j] -= min;
        }
        int[] dp = new int[batchSize];
        dp[0] = 1;
        for (int i = 1; i < batchSize; i++) {
            if (cnt[i] > 0) {
                int[] next = new int[batchSize];
                for (int j = 0; j < batchSize; j++) {
                    if (dp[j] > 0) {
                        for (int k = 1; k <= cnt[i]; k++) {
                            next[(j + i * k) % batchSize] = Math.max(next[(j + i * k) % batchSize], dp[j] + k);
                        }
                    }
                }
                dp = next;
            }
        }
        return res + dp[0] - 1;

=======

        int n = groups.length;
        int[] cnt = new int[batchSize];
        int ans = 0;
        for (int i = 0; i < n; i++) {
            if (groups[i] % batchSize == 0) {
                ans++;
            } else {
                cnt[groups[i] % batchSize]++;
            }
        }
        int[] dp = new int[batchSize];
        for (int i = 1; i < batchSize; i++) {
            for (int j = 0; j < batchSize; j++) {
                dp[j] = cnt[i] + (j == i ? 0 : dp[(j + batchSize - i) % batchSize]);
            }
            for (int j = 0; j < batchSize; j++) {
                cnt[j] = dp[j];
            }
        }
        return ans + cnt[0];

=======

        int[] count = new int[batchSize];
        int res = 0;
        for (int i : groups) {
            if (i % batchSize == 0) {
                res++;
            } else {
                count[i % batchSize]++;
            }
        }
        for (int i = 1; i < batchSize; i++) {
            int j = batchSize - i;
            if (i == j) {
                res += count[i] / 2;
            } else {
                res += Math.min(count[i], count[j]);
            }
        }
        return res;

=======

        int[] count = new int[batchSize];
        int res = 0;
        for (int g : groups) {
            count[g % batchSize]++;
        }
        res += count[0];
        count[0] = 0;
        for (int i = 1; i < batchSize; i++) {
            int j = (batchSize - i) % batchSize;
            if (i < j) {
                continue;
            }
            int min = Math.min(count[i], count[j]);
            res += min;
            count[i] -= min;
            count[j] -= min;
        }
        int[] dp = new int[batchSize];
        dp[0] = 1;
        for (int i = 1; i < batchSize; i++) {
            if (count[i] > 0) {
                int[] next = new int[batchSize];
                for (int j = 0; j < batchSize; j++) {
                    if (dp[j] > 0) {
                        next[(j + i) % batchSize] = dp[j];
                    }
                }
                for (int j = 1; j < batchSize; j++) {
                    if (next[j] > 0) {
                        next[j] += count[i] - 1;
                    }
                }
                dp = next;
            }
        }
        for (int i = 1; i < batchSize; i++) {
            res = Math.max(res, dp[i]);
        }
        return res;

=======

        int n = groups.length;
        int[] cnt = new int[batchSize];
        int ans = 0;
        for (int g : groups) {
            if (g % batchSize == 0) {
                ans++;
            } else {
                cnt[g % batchSize]++;
            }
        }
        int[] dp = new int[batchSize];
        Arrays.fill(dp, -1);
        dp[0] = 0;
        for (int i = 1; i < batchSize; i++) {
            if (cnt[i] > 0) {
                for (int j = 0; j < batchSize; j++) {
                    if (dp[j] >= 0) {
                        dp[j] = cnt[i];
                    } else if (j > i && dp[j - i] > 0) {
                        dp[j] = dp[j - i] - 1;
                    }
                }
            }
        }
        return ans + dp[0];

=======

        int[] count = new int[batchSize];
        int res = 0;
        for (int g : groups) {
            int mod = g % batchSize;
            if (mod == 0) {
                res++;
            } else {
                count[mod]++;
            }
        }
        int[] dp = new int[batchSize];
        for (int i = 1; i < batchSize; i++) {
            for (int j = 0; j < batchSize; j++) {
                int next = (j + i) % batchSize;
                dp[next] = Math.max(dp[next], dp[j] + count[i]);
            }
        }
        return res + dp[0];

=======

        int[] remainders = new int[batchSize];
        int res = 0;
        for (int g : groups) {
            if (g % batchSize == 0) {
                res++;
            } else {
                remainders[g % batchSize]++;
            }
        }
        int[] dp = new int[batchSize];
        for (int i = 1; i < batchSize; i++) {
            dp[i] = Integer.MIN_VALUE;
        }
        for (int i = 1; i < batchSize; i++) {
            if (remainders[i] == 0) {
                continue;
            }
            int[] next = new int[batchSize];
            for (int j = 0; j < batchSize; j++) {
                if (dp[j] == Integer.MIN_VALUE) {
                    continue;
                }
                int r = (j + i) % batchSize;
                next[r] = Math.max(next[r], dp[j] + (r == 0 ? 1 : 0));
                if (remainders[i] > 1) {
                    next[j] = Math.max(next[j], dp[j]);
                }
            }
            next[i] = Math.max(next[i], remainders[i]);
            dp = next;
        }
        return res + dp[0];

=======

        int[] count = new int[batchSize];
        for (int g : groups) {
            count[g % batchSize]++;
        }
        int res = count[0];
        count[0] = 0;
        int[] memo = new int[batchSize];
        Arrays.fill(memo, -1);
        return res + dfs(count, 0, memo);
    }

    private int dfs(int[] count, int remain, int[] memo) {
        if (memo[remain] != -1) {
            return memo[remain];
        }
        int max = 0;
        for (int i = 1; i < count.length; i++) {
            if (count[i] > 0) {
                count[i]--;
                max = Math.max(max, dfs(count, (remain + i) % count.length, memo) + (remain + i) % count.length == 0 ? 1 : 0);
                count[i]++;
            }
        }
        return memo[remain] = max;
