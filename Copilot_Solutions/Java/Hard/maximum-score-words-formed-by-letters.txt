Synthesizing 10/10 solutions

=======

        int[] count = new int[26];
        for (char c : letters) {
            count[c - 'a']++;
        }
        return dfs(words, count, score, 0);
    }

    private int dfs(String[] words, int[] count, int[] score, int i) {
        if (i == words.length) {
            return 0;
        }
        int max = 0;
        int[] copy = Arrays.copyOf(count, count.length);
        int score1 = dfs(words, count, score, i + 1);
        int score2 = 0;
        boolean valid = true;
        for (char c : words[i].toCharArray()) {
            if (count[c - 'a'] == 0) {
                valid = false;
                break;
            }
            count[c - 'a']--;
            score2 += score[c - 'a'];
        }
        if (valid) {
            score2 += dfs(words, count, score, i + 1);
        }
        max = Math.max(max, Math.max(score1, score2));
        System.arraycopy(copy, 0, count, 0, count.length);
        return max;

=======

        int[] freq = new int[26];
        for (char c : letters) {
            freq[c - 'a']++;
        }
        return dfs(words, freq, score, 0);
    }
    
    private int dfs(String[] words, int[] freq, int[] score, int idx) {
        if (idx == words.length) {
            return 0;
        }
        int res = dfs(words, freq, score, idx + 1);
        int[] freqCopy = Arrays.copyOf(freq, freq.length);
        int scoreCopy = 0;
        for (char c : words[idx].toCharArray()) {
            if (freqCopy[c - 'a'] > 0) {
                freqCopy[c - 'a']--;
                scoreCopy += score[c - 'a'];
            } else {
                scoreCopy = -1;
                break;
            }
        }
        if (scoreCopy != -1) {
            res = Math.max(res, scoreCopy + dfs(words, freqCopy, score, idx + 1));
        }
        return res;

=======

        int[] freq = new int[26];
        for (char c : letters) {
            freq[c - 'a']++;
        }
        return dfs(words, 0, freq, score);
    }
    private int dfs(String[] words, int index, int[] freq, int[] score) {
        if (index == words.length) {
            return 0;
        }
        int max = 0;
        int[] freqCopy = Arrays.copyOf(freq, freq.length);
        int scoreCopy = 0;
        for (char c : words[index].toCharArray()) {
            if (freqCopy[c - 'a'] == 0) {
                scoreCopy = 0;
                break;
            } else {
                freqCopy[c - 'a']--;
                scoreCopy += score[c - 'a'];
            }
        }
        max = Math.max(max, scoreCopy + dfs(words, index + 1, freqCopy, score));
        max = Math.max(max, dfs(words, index + 1, freq, score));
        return max;

=======

        int[] letterCount = new int[26];
        for (char c : letters) {
            letterCount[c - 'a']++;
        }
        return dfs(words, letterCount, score, 0);
    }
    
    private int dfs(String[] words, int[] letterCount, int[] score, int index) {
        if (index == words.length) {
            return 0;
        }
        int[] curCount = new int[26];
        int scoreWith = 0;
        boolean valid = true;
        for (char c : words[index].toCharArray()) {
            curCount[c - 'a']++;
            if (curCount[c - 'a'] > letterCount[c - 'a']) {
                valid = false;
                break;
            }
            scoreWith += score[c - 'a'];
        }
        int without = dfs(words, letterCount, score, index + 1);
        if (!valid) {
            return without;
        }
        for (int i = 0; i < 26; i++) {
            letterCount[i] -= curCount[i];
        }
        int with = scoreWith + dfs(words, letterCount, score, index + 1);
        for (int i = 0; i < 26; i++) {
            letterCount[i] += curCount[i];
        }
        return Math.max(with, without);

=======

        Map<Character, Integer> letterMap = new HashMap<>();
        for (char c: letters) {
            letterMap.put(c, letterMap.getOrDefault(c, 0) + 1);
        }
        return dfs(words, 0, letterMap, score);
    }
    
    private int dfs(String[] words, int index, Map<Character, Integer> letterMap, int[] score) {
        if (index == words.length) {
            return 0;
        }
        int ans = dfs(words, index + 1, letterMap, score);
        String word = words[index];
        Map<Character, Integer> wordMap = new HashMap<>();
        int wordScore = 0;
        for (int i = 0; i < word.length(); i++) {
            char c = word.charAt(i);
            wordMap.put(c, wordMap.getOrDefault(c, 0) + 1);
            wordScore += score[c - 'a'];
        }
        boolean valid = true;
        for (Map.Entry<Character, Integer> entry: wordMap.entrySet()) {
            char c = entry.getKey();
            int count = entry.getValue();
            if (letterMap.getOrDefault(c, 0) < count) {
                valid = false;
                break;
            }
        }
        if (valid) {
            for (Map.Entry<Character, Integer> entry: wordMap.entrySet()) {
                char c = entry.getKey();
                int count = entry.getValue();
                letterMap.put(c, letterMap.get(c) - count);
            }
            ans = Math.max(ans, wordScore + dfs(words, index + 1, letterMap, score));
            for (Map.Entry<Character, Integer> entry: wordMap.entrySet()) {
                char c = entry.getKey();
                int count = entry.getValue();
                letterMap.put(c, letterMap.get(c) + count);
            }
        }
        return ans;

=======

        int[] letterCount = new int[26];
        for (char c : letters) {
            letterCount[c - 'a']++;
        }
        return backtrack(words, letterCount, score, 0);
    }
    private int backtrack(String[] words, int[] letterCount, int[] score, int start) {
        int maxScore = 0;
        for (int i = start; i < words.length; i++) {
            int[] wordCount = new int[26];
            int wordScore = 0;
            for (char c : words[i].toCharArray()) {
                wordCount[c - 'a']++;
                wordScore += score[c - 'a'];
            }
            if (!canForm(wordCount, letterCount)) {
                continue;
            }
            for (int j = 0; j < 26; j++) {
                letterCount[j] -= wordCount[j];
            }
            maxScore = Math.max(maxScore, wordScore + backtrack(words, letterCount, score, i + 1));
            for (int j = 0; j < 26; j++) {
                letterCount[j] += wordCount[j];
            }
        }
        return maxScore;
    }
    private boolean canForm(int[] wordCount, int[] letterCount) {
        for (int i = 0; i < 26; i++) {
            if (wordCount[i] > letterCount[i]) {
                return false;
            }
        }
        return true;

=======

        int[] letterCount = new int[26];
        for (char c: letters) {
            letterCount[c - 'a']++;
        }
        return backtrack(words, letterCount, score, 0);
    }
    
    private int backtrack(String[] words, int[] letterCount, int[] score, int start) {
        int maxScore = 0;
        for (int i = start; i < words.length; i++) {
            int[] wordCount = new int[26];
            int wordScore = 0;
            for (char c: words[i].toCharArray()) {
                wordCount[c - 'a']++;
                if (wordCount[c - 'a'] > letterCount[c - 'a']) {
                    wordScore = 0;
                    break;
                }
                wordScore += score[c - 'a'];
            }
            if (wordScore > 0) {
                for (int j = 0; j < 26; j++) {
                    letterCount[j] -= wordCount[j];
                }
                maxScore = Math.max(maxScore, wordScore + backtrack(words, letterCount, score, i + 1));
                for (int j = 0; j < 26; j++) {
                    letterCount[j] += wordCount[j];
                }
            }
        }
        return maxScore;

=======

        int[] charCount = new int[26];
        for (char c : letters) {
            charCount[c - 'a']++;
        }
        int[] wordScore = new int[words.length];
        for (int i = 0; i < words.length; i++) {
            for (char c : words[i].toCharArray()) {
                wordScore[i] += score[c - 'a'];
            }
        }
        return maxScoreWordsHelper(words, charCount, wordScore, 0);
    }
    private int maxScoreWordsHelper(String[] words, int[] charCount, int[] wordScore, int index) {
        if (index == words.length) {
            return 0;
        }
        int maxScore = 0;
        int[] newCharCount = Arrays.copyOf(charCount, charCount.length);
        boolean isValid = true;
        for (char c : words[index].toCharArray()) {
            if (newCharCount[c - 'a'] == 0) {
                isValid = false;
                break;
            }
            newCharCount[c - 'a']--;
        }
        if (isValid) {
            maxScore = Math.max(maxScore, wordScore[index] + maxScoreWordsHelper(words, newCharCount, wordScore, index + 1));
        }
        maxScore = Math.max(maxScore, maxScoreWordsHelper(words, charCount, wordScore, index + 1));
        return maxScore;

=======

        int[] letterCount = new int[26];
        for (char c : letters) {
            letterCount[c - 'a']++;
        }
        return dfs(words, 0, letterCount, score);
    }
    private int dfs(String[] words, int start, int[] letterCount, int[] score) {
        int max = 0;
        for (int i = start; i < words.length; i++) {
            int[] newLetterCount = new int[26];
            int curScore = 0;
            for (char c : words[i].toCharArray()) {
                newLetterCount[c - 'a']++;
                if (newLetterCount[c - 'a'] > letterCount[c - 'a']) {
                    curScore = 0;
                    break;
                }
                curScore += score[c - 'a'];
            }
            if (curScore > 0) {
                for (int j = 0; j < 26; j++) {
                    letterCount[j] -= newLetterCount[j];
                }
                max = Math.max(max, curScore + dfs(words, i + 1, letterCount, score));
                for (int j = 0; j < 26; j++) {
                    letterCount[j] += newLetterCount[j];
                }
            }
        }
        return max;

=======

        int[] letterCounts = new int[26];
        for (char c : letters) {
            letterCounts[c - 'a']++;
        }
        return backtrack(words, letterCounts, score, 0);
    }
    
    private int backtrack(String[] words, int[] letterCounts, int[] score, int start) {
        int maxScore = 0;
        for (int i = start; i < words.length; i++) {
            int scoreForWord = getScore(words[i], score, letterCounts);
            if (scoreForWord > 0) {
                maxScore = Math.max(maxScore, scoreForWord + backtrack(words, letterCounts, score, i+1));
            }
        }
        return maxScore;
    }
    
    private int getScore(String word, int[] score, int[] letterCounts) {
        int[] wordCounts = new int[26];
        for (char c : word.toCharArray()) {
            wordCounts[c - 'a']++;
        }
        int totalScore = 0;
        for (int i = 0; i < 26; i++) {
            if (wordCounts[i] > letterCounts[i]) {
                return 0;
            }
            totalScore += score[i] * wordCounts[i];
        }
        for (int i = 0; i < 26; i++) {
            letterCounts[i] -= wordCounts[i];
        }
        return totalScore;
