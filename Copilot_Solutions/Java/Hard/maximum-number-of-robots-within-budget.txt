Synthesizing 10/10 solutions

=======

        int n = chargeTimes.length;
        long[] sum = new long[n + 1];
        for (int i = 1; i <= n; i++) {
            sum[i] = sum[i - 1] + runningCosts[i - 1];
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            int l = i + 1;
            int r = n;
            while (l < r) {
                int m = (l + r + 1) >> 1;
                long cost = chargeTimes[i] + (sum[m] - sum[i]) * (m - i);
                if (cost > budget) {
                    r = m - 1;
                } else {
                    l = m;
                }
            }
            ans = Math.max(ans, l - i + 1);
        }
        return ans;

=======

        int n = chargeTimes.length;
        int[] order = new int[n];
        for (int i = 0; i < n; i++) {
            order[i] = i;
        }
        Arrays.sort(order, (a, b) -> chargeTimes[a] - chargeTimes[b]);
        int[] charge = new int[n];
        int[] run = new int[n];
        for (int i = 0; i < n; i++) {
            charge[i] = chargeTimes[order[i]];
            run[i] = runningCosts[order[i]];
        }
        int[] prefix = new int[n];
        for (int i = 0; i < n; i++) {
            prefix[i] = run[i];
            if (i > 0) {
                prefix[i] += prefix[i - 1];
            }
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            int j = i;
            while (j < n) {
                long cost = charge[i] + (long) (j - i + 1) * prefix[j];
                if (cost <= budget) {
                    ans = Math.max(ans, j - i + 1);
                }
                j++;
            }
        }
        return ans;

=======

        int n = chargeTimes.length;
        int maxCharge = 0;
        for (int i = 0; i < n; i++) {
            maxCharge = Math.max(maxCharge, chargeTimes[i]);
        }
        int l = 0, r = n;
        while (l < r) {
            int mid = (l + r + 1) >> 1;
            long cost = 0;
            for (int i = 0; i < mid; i++) {
                cost += runningCosts[i];
            }
            cost += (long) mid * maxCharge;
            if (cost <= budget) {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        int ans = l;
        long cost = 0;
        for (int i = 0; i < ans; i++) {
            cost += runningCosts[i];
        }
        cost += (long) ans * maxCharge;
        for (int i = ans - 1; i >= 0; i--) {
            cost -= runningCosts[i];
            cost += chargeTimes[i];
            if (cost > budget) {
                break;
            }
            ans = i;
        }
        return n - ans;

=======

        int n = chargeTimes.length;
        long[][] dp = new long[n][n];
        for (int i = 0; i < n; i++) {
            dp[i][i] = chargeTimes[i] + runningCosts[i];
            for (int j = i + 1; j < n; j++) {
                dp[i][j] = dp[i][j - 1] + runningCosts[j];
            }
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            int l = 0, r = n - i;
            while (l < r) {
                int m = l + r + 1 >> 1;
                if (dp[i][i + m - 1] <= budget) {
                    l = m;
                } else {
                    r = m - 1;
                }
            }
            ans = Math.max(ans, l);
        }
        return ans;

=======

        int n = chargeTimes.length;
        int[] maxChargeTimes = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            maxChargeTimes[i] = Math.max(maxChargeTimes[i - 1], chargeTimes[i - 1]);
        }
        int[] minRunningCosts = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            minRunningCosts[i] = minRunningCosts[i - 1] + runningCosts[i - 1];
        }
        int ans = 0;
        for (int i = 1; i <= n; i++) {
            int left = i, right = n;
            while (left < right) {
                int mid = (left + right + 1) / 2;
                long cost = (long) maxChargeTimes[i] + (long) minRunningCosts[mid] - (long) minRunningCosts[i - 1];
                if (cost <= budget) {
                    left = mid;
                } else {
                    right = mid - 1;
                }
            }
            if ((long) maxChargeTimes[i] + (long) minRunningCosts[left] - (long) minRunningCosts[i - 1] <= budget) {
                ans = Math.max(ans, left - i + 1);
            }
        }
        return ans;

=======

        int n = chargeTimes.length;
        int[][] dp = new int[n + 1][n + 1];
        int max = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                long cost = chargeTimes[i - 1] + (long) runningCosts[i - 1] * j;
                if (cost <= budget) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    max = Math.max(max, dp[i][j]);
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return max;

=======

        int n = chargeTimes.length;
        int[] maxCharge = new int[n];
        int[] sumRunning = new int[n];
        maxCharge[0] = chargeTimes[0];
        sumRunning[0] = runningCosts[0];
        for (int i = 1; i < n; i++) {
            maxCharge[i] = Math.max(maxCharge[i - 1], chargeTimes[i]);
            sumRunning[i] = sumRunning[i - 1] + runningCosts[i];
        }
        int max = 0;
        for (int i = 0; i < n; i++) {
            long cost = (long)maxCharge[i] + (long)sumRunning[i];
            if (cost > budget) {
                break;
            }
            int left = 0;
            int right = i;
            while (left < right) {
                int mid = (left + right + 1) / 2;
                cost = (long)maxCharge[i] + (long)sumRunning[i] - (long)sumRunning[mid] + (long)sumRunning[mid - 1] + (long)maxCharge[mid - 1];
                if (cost <= budget) {
                    left = mid;
                } else {
                    right = mid - 1;
                }
            }
            max = Math.max(max, i - left + 1);
        }
        return max;

=======

        int n = chargeTimes.length;
        int[] chargeTimesSorted = new int[n];
        System.arraycopy(chargeTimes, 0, chargeTimesSorted, 0, n);
        Arrays.sort(chargeTimesSorted);
        int[] runningCostsSorted = new int[n];
        for (int i = 0; i < n; i++) {
            runningCostsSorted[i] = runningCosts[Arrays.binarySearch(chargeTimes, chargeTimesSorted[i])];
        }
        int[] prefixSum = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            prefixSum[i] = prefixSum[i - 1] + runningCostsSorted[i - 1];
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            int lo = 1, hi = n - i;
            while (lo <= hi) {
                int mid = (lo + hi) / 2;
                if (chargeTimesSorted[i] + prefixSum[i + mid] <= budget) {
                    ans = Math.max(ans, mid);
                    lo = mid + 1;
                } else {
                    hi = mid - 1;
                }
            }
        }
        return ans;

=======

        int n = chargeTimes.length;
        int max = 0;
        for (int i = 0; i < n; i++) {
            int count = 0;
            long cost = 0;
            for (int j = i; j < n; j++) {
                cost += runningCosts[j];
                if (chargeTimes[j] > chargeTimes[i]) {
                    cost += chargeTimes[j] - chargeTimes[i];
                    count++;
                }
                if (cost > budget) {
                    break;
                }
                max = Math.max(max, count);
            }
        }
        return max;

=======

        int n = chargeTimes.length;
        long[] dp = new long[n+1];
        int res = 0;
        for (int i = 1; i <= n; i++) {
            long cost = chargeTimes[i-1] + runningCosts[i-1];
            if (cost <= budget) {
                res = Math.max(res, 1);
                dp[i] = cost;
            }
            for (int j = i-1; j >= 1; j--) {
                cost += runningCosts[j-1];
                if (cost > budget) break;
                if (dp[j] + chargeTimes[i-1] <= budget) {
                    dp[i] = Math.max(dp[i], dp[j] + chargeTimes[i-1]);
                    res = Math.max(res, i-j+1);
                }
            }
        }
        return res;
