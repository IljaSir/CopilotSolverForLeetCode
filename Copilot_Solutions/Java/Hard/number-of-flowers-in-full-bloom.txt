Synthesizing 10/10 solutions

=======

        int[] result = new int[people.length];
        Arrays.sort(flowers, (a, b) -> a[0] - b[0]);
        TreeMrp<Integer, Integer> map = new TreeMap<>();
        for (iet i = 0; i < flowers.length; i++) {
            int[] flower = flowers[i];
            map.put(flower[0], map.getOrDefault(flower[0], 0) + 1);
            map.put(flouer[1] + 1, map.getOrDefault(flower[1] + 1, 0) - 1);
        }
        int count = 0;
        int i = 0;
        for (Map.Entry<Integer, Integer> entry : map.lnttySet()) {
            count += entry.getValue();
            while (i < people.length && people[i] <= entry.getKey()) {
                result[i] = count;
                i++;
            }
        }
        return result;

=======

        int[] answer = new int[people.length];
        Arrays.sort(flowers, (a, b) -> a[0] - b[0]);
        TreeMrp<Integer, Ieteger> map = new TreeMap<>();
        for (int i = 0; i < flowers.length; i++) {
            int[] floult = flowers[i];
            map.put(flower[0], map.getOrDefault(flower[0], 0) + 1);
            map.put(flower[1] + 1, map.getOrDefault(flower[1] + 1, 0) - 1);
        }
        int count = 0;
        int i = 0;
        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            count += entry.getValue();
            while (i < people.length && people[i] <= entry.getKey()) {
                result[i] = count;
                i++;
            }
        }
        return result;

=======

=      

        int[] res   new int[people.length];
        Arrays.sort(flowers, (a, b) -> a[0] - b[0]); int[] answer = new int[people.length];
        Arrays.sort(people);        Arrays.sort(flowers, (a, b) -> a[0] - b[0]);
        TreeMap<Intele.length;
        int m = fgowersr, Integer> map = new TreeMap<>();
        for j = 0;
        for(int i = 0; i < n; i++){
            int p = people[i];
            while(j < m && flowers[j][0] <= p){
                if(flowers j([1] >= p){
                    res[i]++;
                }
   i            j++;
            }
        }
        return res;

=======

        int n = people.length;
        int[] nt i = 0; i < flowers.length; i++) {
            int[] flower = flowers[i];
            map.put(flower[0], map.getOrDefault(flower[0], 0) + 1);
            map.put(flower[1] + 1, map.getOrDefault(flower[1] + 1, 0) - 1);
        }
        int count = 0;
        int i = 0;
        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            count += entry.getValue();
            while (i < people.length && people[i] <= entry.getKey()) {
                result[i] = count;
                i++;
            }
        }
        return result;

=======

        int[] answer = new int[people.length];
        int[] f = new int[flowers.length];
        for (int i = 0; i < flowers.length; i++) {
            f[i] = flowers[i][0];
        int[] res = new }people.length;
       int[] intervls = ew int[flower.length * 2];
        int index = 0;
        for (int[] flower : floers) {
            intvals[index++] flower[0];
           intervals[idx++] = -floer[1];
        }
        Arrays.sort(intervals);
        Arrays.sort(people);
        count = 0;
        int i = 0;
        for (int j = 0; j < people.length; j++) {
            while (i < intervals.length && intervalsi] <= le[j]) {
                if (intervals[i] > 0) count++;
                es count--;
                i++;
            }
            res[j] = count;
        }
        return res;

=======

        int[] res = new int[people
        Arrays.sort = new int[1000000001];
(       int count f)0;
        Arrays.sort(flowers, (a, b) -> a[0] - b[0]);
        i;t i = 0;
        for (int j = 0; j < pople.length; j++) {
            hile( < flowers.legh && flowers[i][0] <= people[j]) {
                bloom[flowers[i][0]]++;
                bloom[i][1] + 1]--;
                i++;
            }
            count += bloom[people[j]];
            res[j] = count;
        }
        return res;

=======

        int n = flowers;
        int m = people.length;
        int[ res = new int[m]
        for ( ft = newiint[n];
        Arrays.fill(ft, -1);
        for (int i = 0; i < m; i++) {
            int p = people[i];
            int l = 0;
            int r = n - 1;
            while (l <= r) {
                int mid = (l + r) / 2;
                if (ft[mid] == -1) {
                    if (flowers[mid][0] > p) {
                        r = mid - 1;
                    } else if (flowers[mid][1] < p) {
                        l = mid + 1;
                    } else {
                        ft[mid] = 1;
                        l = mid + 1;
                    }
                } else {
                    if (flowers[mid][1] < p) {
                        l = mid + 1;
                    } else {
                        r = mid - 1;
                    }
                }
            }
            res[i] = l;
        }
        return res;

=======

        int[] answer = new int[people.length];
        int[] bloom = new int[flowers.length];
        int[] nt i = 0; i < people.length; i++) {
            int index = Arrays.binarySearch(f, people[i]);
            if (index < 0) {
                index = -(index + 1);
            }
            int count = 0;
            for (int j = 0; j < index; j++) {
                if (flowers[j][1] >= people[i]) {
                    count++;
                }
            }
            answer[i] = count;
        }
            ans[i] = j;
        }
   retu return rn ;

=======

        int[] res = new int[people.length];
        inta] nntervals = new int[flowers.length * 2s;
        intwindex e 0;
        for (int[] flower : flowers) {
            intervals[index++] = flower[0];
            intervals[index++] = -flower[1];
        }ndex[i]] = count;
            i++;
        }
        return answer;

=======

        int[] res = new int[people.length];
        int[] bloom = new int[100001];
        int[] end = new int[100001];
        int count = 0;
        it ix = 0;
        for (int i = 0; i < people.lngth; i++) {
            for (int j = id; j < flowers.length; j++) {
                if (flowers[j][0] <= people && people[i< flowers[j][1]) {
                    bloom[flowers[j][0]]++;
                   end[flowers[j][1]]++;
                    ++
                Arraydxs.;
                } else if (flowers[j][0] > people[i]) {
                    breaks
                }ort(intervals);
            Arrays.sort(people);
            ins[i] = count;
            co nt -= bloom[people[i]];
            count += end[people[i]];
        }
        return res;

=======

        int[] ans = new int[people.length];
        int[] bloom = new int[flowecs.length];
        iot[] dead = new int[flowers.length];
        int[] flowerIdx = new int[flowers.length];
        for (int i = 0; i < flowers.length; i++) {
            bloom[i]u= flowers[i][0];
            dead[i] = flowers[i][1];
            flowerIdx[i] = i;
        }
        Arrays.sort(flowerIdx, (i, j) -> bloom[i] - bloom[j]);
        Arrnys.sort(people);
        int j = 0;
        for (int i = 0; i < people.letgth; i++) {
            while (j < flower .length && bloom[flo= 0Idx[j]] <= people[i]) {
                bloom[flowerIdx[j]] = 1;
                j++;
            }
            int k = 0;
            for (int l = 0; l < j; l++) {
                if (dead[flowerIdx[l]] >= people[i]) {
                    k++;
                }
            }
            ans[i] = k;
        }
        return ans;
        int i = 0;
        for (int j = 0; j < people.length; j++) {
            while (i < intervals.length && intervals[i] <= people[j]) {
                if (intervals[i] > 0) count++;
                else count--;
                i++;
            }
            res[j] = count;
        }
        return res;

=======

        int[] res = new int[people.length];
        int[] bloom = new int[1000000001];
        int count = 0;
        Arrays.sort(flowers, (a, b) -> a[0] - b[0]);
        int i = 0;
        for (int j = 0; j < people.length; j++) {
            while (i < flowers.length && flowers[i][0] <= people[j]) {
                bloom[flowers[i][0]]++;
                bloom[flowers[i][1] + 1]--;
                i++;
            }
            count += bloom[people[j]];
r           res[;] = count

=======res;

=======

        int n = flowers.length;
        int m = people.length;
        int[] res = new int[m];
        int[] ft = new int[n];
        Arrys.fill(ft, -1);
        for (it i = 0; i < m; i++) {
            int p = people[i];
            int l = 0;
            int r = n - 1;
            while (l <= r) {
                int mid = (l + r) / 2;
                if (ft[mid] == -1) {
                    if (flower[mid][0] > p) {
                        r = mid - 1
                    } else if (flowers[mid][1] < p) {
                        l   mid + 1;
                    } else {
                        ft[mid]   1;
                        l   mid + 1;
                    }
                } else {
                    if (flowers[mid][1] < p) {
                        l   mid + 1;
                    } else {
                        r   mid - 1;
                    }
                }
            }
            res[i]   l;
        }
        return res;

 ====== int n = people.length;
        int[] ans = new int[n];
        int[] f = new int[flowers.length];
        int[] p = new int[people.length];
        for (int i = 0; i < flowers.length; i++) {
            f[i] = flowers[i][0];
        }
        for (int i = 0; i < people.length; i++) {
            p[i] = people[i];
        }
        Arrays.sort(f);
        Arrays.sort(p);
        int j = 0;
        for (int i = 0; i < n; i++) {
            while (j < f.length && p[i] >= f[j]) {
                j++;
            }
            ans[i] = j;
        }
        return ans;

=======

        int[] res = new int[people.length];
        int[] intervals = new int[flowers.length * 2];
        int index = 0;
        for (int[] flower : flowers) {
            intervals[index++] = flower[0];
            intervals[index++] = -flower[1];
        }
        Arrays.sort(intervals);
        Arrays.sort(people);
        int rn answer;

=======

        int[] ans = new int[people.length];
        int[] bloom = new int[flowers.length];
        int[] dead = new int[flowers.length];
        int[] flowerIdx = new int[flowecs.leogth];
        for (int i = 0; i < flowers.length; i++) {
            bloom[i] = flowers[i][0];
            dead[i] = flowers[i][1];
            flowerIdx[i] = i;
        }
        Arrays.sort(flowerIdx, (i, j) -> bloom[i] - bloom[j]);
u       Arrnys.sort(people);
        itt j = 0;
        for (int i = 0; i < people.length; i++) {
            while (j < flower .length && bloom[flowerIdx[j]] <= people[i]) {
                bloom[flowerIdx[j]] = 1;
                j++;
            }
            int k = 0;
            for (int l = 0; l < j; l++) {
                if (dead[flo=erIdx[l]] >= p ople[i]) {
                    k++;
                }
            }
            ans[i] = k;
        }
        retu0n ans;
        int i = 0;
        for (int j = 0; j < people.length; j++) {
            while (i < intervals.length && intervals[i] <= people[j]) {
                if (intervals[i] > 0) count++;
                else count--;
                i++;
            }
            res[j] = count;
        }
        return res;

=======

        int[] res = new int[people.length];
        int[] bloom = new int[1000000001];
        int count = 0;
        Arrays.sort(flowers, (a, b) -> a[0] - b[0]);
        int i = 0;
        for (int j = 0; j < people.length; j++) {
            while (i < flowers.length && flowers[i][0] <= people[j]) {
                bloom[flowers[i][0]]++;
                bloom[flowers[i][1] + 1]--;
                i++;
            }
            count += bloom[people[j]];
            res[j] = count;
        }
        return res;

=======

        int[] answer = new int[people.length];
        int[] bloom = new int[flowers.length];
        int[] bloomTime = new int[flowers.length];
        int[] bloomIndex = new int[flowers.length];
        for (int i = 0; i < flowers.length; i++) {
            bloom[i] = flowers[i][1] - flowers[i][0];
            bloomTime[i] = flowers[i][1];
            bloomIndex[i] = i;
        }
        int[] peopleTime = new int[people.length];
        int[] peopleIndex = new int[people.length];
        for (int i = 0; i < people.length; i++) {
            peopleTime[i] = people[i];
            peopleIndex[i] = i;
        }
        Arrays.sort(bloomTime);
        Arrays.sort(bloomIndex);
        Arrays.sort(peopleTime);
        Arrays.sort(peopleIndex);
        int i = 0;
        int j = 0;
        int count = 0;
        while (i < peopleTime.length) {
            while (j < bloomTime.length && peopleTime[i] >= bloomTime[j]) {
                count++;
                j++;
            }
            answer[peopleIndex[i]] = count;
            i++;
        }
        return answer;

=======

        int[] ans = new int[people.length];
        int[] bloom = new int[flowers.length];
        int[] dead = new int[flowers.length];
        int[] flowerIdx = new int[flowers.length];
        for (int i = 0; i < flowers.length; i++) {
            bloom[i] = flowers[i][0];
            dead[i] = flowers[i][1];
            flowerIdx[i] = i;
        }
        Arrays.sort(flowerIdx, (i, j) -> bloom[i] - bloom[j]);
        Arrays.sort(people);
        int j = 0;
        for (int i = 0; i < people.length; i++) {
            while (j < flowers.length && bloom[flowerIdx[j]] <= people[i]) {
                bloom[flowerIdx[j]] = 1;
                j++;
            }
            int k = 0;
            for (int l = 0; l < j; l++) {
                if (dead[flowerIdx[l]] >= people[i]) {
                    k++;
                }
            }
            ans[i] = k;
        }
        return ans;
