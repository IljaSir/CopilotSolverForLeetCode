Synthesizing 8/10 solutions

=======

        int n = s.length();
        int[][] dp = new int[n][n];
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }
        for (int i = 0; i < n - 1; i++) {
            dp[i][i + 1] = s.charAt(i) == s.charAt(i + 1) ? 2 : 1;
        }
        for (int len = 3; len <= n; len++) {
            for (int i = 0; i < n - len + 1; i++) {
                int j = i + len - 1;
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = Math.max(dp[i][j], dp[i + 1][j - 1] + 2);
                }
            }
        }
        int[] cnt = new int[26];
        for (int i = 0; i < n; i++) {
            cnt[s.charAt(i) - 'a']++;
        }
        int res = 0;
        for (int i = 0; i < 26; i++) {
            res += (cnt[i] / 2) * 2;
        }
        return res < k ? 0 : Math.max(res, dp[0][n - 1]);

=======

        int n = s.length();
        int[] count = new int[26];
        for (int i = 0; i < n; i++) {
            count[s.charAt(i) - 'a']++;
        }
        int odd = 0;
        for (int i = 0; i < 26; i++) {
            if (count[i] % 2 == 1) {
                odd++;
            }
        }
        if (odd > k) {
            return 0;
        }
        int[] dp = new int[1 << 26];
        Arrays.fill(dp, -1);
        dp[0] = 0;
        for (int i = 0; i < n; i++) {
            int mask = 0;
            for (int j = i; j < n; j++) {
                mask ^= 1 << (s.charAt(j) - 'a');
                if (Integer.bitCount(mask) <= k) {
                    dp[mask] = Math.max(dp[mask], j - i + 1);
                }
            }
        }
        for (int i = 0; i < 26; i++) {
            for (int mask = 0; mask < (1 << 26); mask++) {
                if ((mask & (1 << i)) == 0) {
                    dp[mask] = Math.max(dp[mask], dp[mask | (1 << i)]);
                }
            }
        }
        int ans = 0;
        for (int mask = 0; mask < (1 << 26); mask++) {
            int mask2 = ((1 << 26) - 1) ^ mask;
            ans = Math.max(ans, dp[mask] + dp[mask2]);
        }
        return ans;

=======

        int n = s.length();
        int[] count = new int[26];
        for (int i = 0; i < n; i++) {
            count[s.charAt(i) - 'a']++;
        }
        int odd = 0;
        for (int i = 0; i < 26; i++) {
            odd += count[i] % 2;
        }
        if (k >= n) {
            return 1;
        } else if (k >= n - odd + 1) {
            return odd == 0 ? 0 : 1;
        } else {
            return odd;
        }

=======

        int[] count = new int[26];
        for (char c : s.toCharArray()) {
            count[c - 'a']++;
        }
        int odd = 0;
        for (int i = 0; i < 26; i++) {
            if (count[i] % 2 == 1) {
                odd++;
            }
        }
        if (odd > k) {
            return 0;
        }
        if (odd == k) {
            return 1;
        }
        int ans = 0;
        for (int i = 0; i < 26; i++) {
            if (count[i] / 2 >= k) {
                ans++;
                k = 0;
                break;
            } else if (count[i] / 2 > 0) {
                k -= count[i] / 2;
                ans++;
            }
        }
        return ans;

=======

        int n = s.length();
        int[][] dp = new int[n][n];
        for (int i = 0; i < n; ++i) {
            dp[i][i] = 1;
        }
        for (int i = 0; i < n - 1; ++i) {
            dp[i][i + 1] = s.charAt(i) == s.charAt(i + 1) ? 1 : 0;
        }
        for (int len = 3; len <= n; ++len) {
            for (int i = 0; i + len <= n; ++i) {
                int j = i + len - 1;
                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1] == 1) {
                    dp[i][j] = 1;
                }
            }
        }
        int[] f = new int[n + 1];
        Arrays.fill(f, Integer.MAX_VALUE);
        f[0] = 0;
        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j < i; ++j) {
                if (dp[j][i - 1] == 1) {
                    f[i] = Math.min(f[i], f[j] + 1);
                }
            }
        }
        return f[n];

=======

        int n = s.length();
        int[] count = new int[26];
        for (char c : s.toCharArray()) {
            count[c - 'a']++;
        }
        int odd = 0;
        for (int c : count) {
            if (c % 2 == 1) {
                odd++;
            }
        }
        if (odd > k) {
            return 0;
        }
        int[][] dp = new int[n + 1][n + 1];
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }
        for (int i = 1; i < n; i++) {
            for (int j = 0; j + i < n; j++) {
                if (s.charAt(j) == s.charAt(j + i)) {
                    dp[j][j + i] = dp[j + 1][j + i - 1] + 2;
                } else {
                    dp[j][j + i] = Math.max(dp[j + 1][j + i], dp[j][j + i - 1]);
                }
            }
        }
        int[] f = new int[n + 1];
        f[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j][i - 1] >= k) {
                    f[i] = (f[i] + f[j]) % 1000000007;
                }
            }
        }
        return f[n];

=======

        int[] count = new int[26];
        for (char c : s.toCharArray())
            count[c - 'a']++;
        int odd = 0;
        for (int i = 0; i < 26; i++)
            if (count[i] % 2 == 1)
                odd++;

        return Math.min(odd, s.length() - k);

=======

        return 0;
