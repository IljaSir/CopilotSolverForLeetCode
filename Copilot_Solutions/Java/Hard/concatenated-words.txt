Synthesizing 10/10 solutions

=======

        List<String> result = new ArrayList<>();
        Set<String> set = new HashSet<>();
        for (String word : words) {
            set.add(word);
        }
        for (String word : words) {
            set.remove(word);
            if (canForm(word, set)) {
                result.add(word);
            }
            set.add(word);
        }
        return result;
    }

    private boolean canForm(String word, Set<String> set) {
        if (set.isEmpty()) {
            return false;
        }
        boolean[] dp = new boolean[word.length() + 1];
        dp[0] = true;
        for (int i = 1; i <= word.length(); i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && set.contains(word.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[word.length()];

=======

        List<String> result = new ArrayList<>();
        Set<String> wordSet = new HashSet<>();
        for (String word : words) {
            wordSet.add(word);
        }
        for (String word : words) {
            if (word.length() == 0) {
                continue;
            }
            if (canForm(word, wordSet)) {
                result.add(word);
            }
        }
        return result;
    }
    
    private boolean canForm(String word, Set<String> wordSet) {
        if (wordSet.isEmpty()) {
            return false;
        }
        boolean[] dp = new boolean[word.length() + 1];
        dp[0] = true;
        for (int i = 1; i <= word.length(); i++) {
            for (int j = 0; j < i; j++) {
                if (!dp[j]) {
                    continue;
                }
                if (wordSet.contains(word.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[word.length()];

=======

        List<String> res = new ArrayList<>();
        Set<String> set = new HashSet<>();
        for (String word : words) {
            set.add(word);
        }
        for (String word : words) {
            if (word.length() == 0) {
                continue;
            }
            if (isConcatenated(word, set)) {
                res.add(word);
            }
        }
        return res;
    }

    private boolean isConcatenated(String word, Set<String> set) {
        int n = word.length();
        boolean[] dp = new boolean[n + 1];
        dp[0] = true;
        for (int i = 0; i < n; i++) {
            if (dp[i]) {
                for (int j = i + 1; j <= n; j++) {
                    if (set.contains(word.substring(i, j))) {
                        dp[j] = true;
                        if (j == n) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;

=======

        Arrays.sort(words, (a, b) -> a.length() - b.length());
        Set<String> dict = new HashSet<>();
        List<String> ans = new ArrayList<>();
        for (String word : words) {
            if (wordBreak(word, dict)) {
                ans.add(word);
            }
            dict.add(word);
        }
        return ans;
    }

    public boolean wordBreak(String s, Set<String> dict) {
        if (s.length() == 0) {
            return false;
        }
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && dict.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];

=======

        TrieNode root = new TrieNode();
        for (String word : words) {
            if (word.length() == 0) {
                continue;
            }
            TrieNode node = root;
            for (int i = 0; i < word.length(); i++) {
                char c = word.charAt(i);
                if (node.children[c - 'a'] == null) {
                    node.children[c - 'a'] = new TrieNode();
                }
                node = node.children[c - 'a'];
            }
            node.word = word;
        }
        List<String> result = new ArrayList<>();
        for (String word : words) {
            if (word.length() == 0) {
                continue;
            }
            if (dfs(word, 0, root, 0)) {
                result.add(word);
            }
        }
        return result;
    }
    private boolean dfs(String word, int index, TrieNode root, int count) {
        TrieNode node = root;
        for (int i = index; i < word.length(); i++) {
            char c = word.charAt(i);
            if (node.children[c - 'a'] == null) {
                return false;
            }
            node = node.children[c - 'a'];
            if (node.word != null) {
                if (i == word.length() - 1) {
                    return count >= 1;
                }
                if (dfs(word, i + 1, root, count + 1)) {
                    return true;
                }
            }
        }
        return false;

=======

        Set<String> set = new HashSet<>();
        List<String> result = new ArrayList<>();
        Arrays.sort(words, (a, b) -> a.length() - b.length());
        for (String word : words) {
            if (wordBreak(word, set)) {
                result.add(word);
            }
            set.add(word);
        }
        return result;
    }
    private boolean wordBreak(String word, Set<String> set) {
        if (set.isEmpty()) {
            return false;
        }
        boolean[] dp = new boolean[word.length() + 1];
        dp[0] = true;
        for (int i = 1; i <= word.length(); i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && set.contains(word.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[word.length()];

=======

        List<String> res = new ArrayList<>();
        Set<String> set = new HashSet<>(Arrays.asList(words));
        for (String word : words) {
            set.remove(word);
            if (dfs(word, set)) {
                res.add(word);
            }
            set.add(word);
        }
        return res;
    }
    private boolean dfs(String word, Set<String> set) {
        if (set.contains(word)) {
            return true;
        }
        for (int i = 1; i < word.length(); i++) {
            if (set.contains(word.substring(0, i)) && dfs(word.substring(i), set)) {
                return true;
            }
        }
        return false;

=======

        List<String> result = new ArrayList<>();
        Set<String> wordSet = new HashSet<>(Arrays.asList(words));
        for (String word : words) {
            wordSet.remove(word);
            if (canBreak(word, wordSet)) {
                result.add(word);
            }
            wordSet.add(word);
        }
        return result;
    }

    private boolean canBreak(String word, Set<String> wordSet) {
        if (wordSet.isEmpty()) {
            return false;
        }
        int length = word.length();
        boolean[] dp = new boolean[length + 1];
        dp[0] = true;
        for (int i = 1; i <= length; i++) {
            for (int j = 0; j < i; j++) {
                if (!dp[j]) {
                    continue;
                }
                if (wordSet.contains(word.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[length];

=======

        List<String> result = new ArrayList<>();
        Arrays.sort(words, Comparator.comparingInt(String::length));
        Set<String> set = new HashSet<>();
        for (String word : words) {
            if (canForm(word, set)) {
                result.add(word);
            }
            set.add(word);
        }
        return result;
    }

    private boolean canForm(String word, Set<String> set) {
        if (set.isEmpty()) {
            return false;
        }
        boolean[] dp = new boolean[word.length() + 1];
        dp[0] = true;
        for (int i = 0; i < word.length(); i++) {
            if (!dp[i]) {
                continue;
            }
            for (int j = i + 1; j <= word.length(); j++) {
                if (set.contains(word.substring(i, j))) {
                    dp[j] = true;
                }
            }
            if (dp[word.length()]) {
                return true;
            }
        }
        return false;

=======

        List<String> result = new ArrayList<>();
        Set<String> wordSet = new HashSet<>(Arrays.asList(words));
        for (String word : words) {
            if (word.length() == 0) continue;
            if (isConcatenated(word, wordSet)) {
                result.add(word);
            }
        }
        return result;
    }
    
    private boolean isConcatenated(String word, Set<String> wordSet) {
        if (wordSet.contains(word)) return true;
        for (int i = 1; i < word.length(); i++) {
            String left = word.substring(0, i);
            String right = word.substring(i);
            if (wordSet.contains(left) && isConcatenated(right, wordSet)) {
                return true;
            }
        }
        return false;
