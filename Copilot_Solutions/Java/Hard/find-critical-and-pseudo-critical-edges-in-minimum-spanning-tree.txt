Synthesizing 10/10 solutions (Duplicates hidden)

=======

        int m = edges.length;
        for (int i = 0; i < m; ++i) {
            edges[i] = new int[]{edges[i][0], edges[i][1], edges[i][2], i};
        }
        Arrays.sort(edges, (a, b) -> a[2] - b[2]);
        UnionFind uf_std = new UnionFind(n);
        int value = 0;
        for (int i = 0; i < m; ++i) {
            if (uf_std.unite(edges[i][0], edges[i][1])) {
                value += edges[i][2];
            }
        }
        List<List<Integer>> ans = new ArrayList<>();
        for (int i = 0; i < 2; ++i) {
            ans.add(new ArrayList<Integer>());
        }
        for (int i = 0; i < m; ++i) {
            UnionFind uf = new UnionFind(n);
            int v = 0;
            for (int j = 0; j < m; ++j) {
                if (i != j && uf.unite(edges[j][0], edges[j][1])) {
                    v += edges[j][2];
                }
            }
            if (uf.setCount != 1 || (uf.setCount == 1 && v > value)) {
                ans.get(0).add(edges[i][3]);
                continue;
            }
            uf = new UnionFind(n);
            uf.unite(edges[i][0], edges[i][1]);
            v = edges[i][2];
            for (int j = 0; j < m; ++j) {
                if (i != j && uf.unite(edges[j][0], edges[j][1])) {
                    v += edges[j][2];
                }
            }
            if (v == value) {
                ans.get(1).add(edges[i][3]);
            }
        }
        return ans;
    }
}

=======

        int m = edges.length;
        for (int i = 0; i < m; ++i) {
            edges[i] = new int[]{edges[i][0], edges[i][1], edges[i][2], i};
        }
        Arrays.sort(edges, (a, b) -> a[2] - b[2]);
        UnionFind uf_std = new UnionFind(n);
        int value = 0;
        for (int i = 0; i < m; ++i) {
            if (uf_std.unite(edges[i][0], edges[i][1])) {
                value += edges[i][2];
            }
        }

        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        for (int i = 0; i < 2; ++i) {
            ans.add(new ArrayList<Integer>());
        }

        for (int i = 0; i < m; ++i) {
            UnionFind uf = new UnionFind(n);
            int v = 0;
            for (int j = 0; j < m; ++j) {
                if (i != j && uf.unite(edges[j][0], edges[j][1])) {
                    v += edges[j][2];
                }
            }
            if (uf.setCount != 1 || (uf.setCount == 1 && v > value)) {
                ans.get(0).add(edges[i][3]);
                continue;
            }

            uf = new UnionFind(n);
            uf.unite(edges[i][0], edges[i][1]);
            v = edges[i][2];
            for (int j = 0; j < m; ++j) {
                if (i != j && uf.unite(edges[j][0], edges[j][1])) {
                    v += edges[j][2];
                }
            }
            if (v == value) {
                ans.get(1).add(edges[i][3]);
            }
        }

        return ans;
    }
}

=======

        int m = edges.length;
        for (int i = 0; i < m; ++i) {
            edges[i] = new int[]{edges[i][0], edges[i][1], edges[i][2], i};
        }
        Arrays.sort(edges, (a, b) -> a[2] - b[2]);
        UnionFind uf_std = new UnionFind(n);
        int value = 0;
        for (int i = 0; i < m; ++i) {
            if (uf_std.unite(edges[i][0], edges[i][1])) {
                value += edges[i][2];
            }
        }
        List<List<Integer>> ans = new ArrayList<>();
        for (int i = 0; i < 2; ++i) {
            ans.add(new ArrayList<>());
        }
        for (int i = 0; i < m; ++i) {
            UnionFind uf = new UnionFind(n);
            int v = 0;
            for (int j = 0; j < m; ++j) {
                if (i != j && uf.unite(edges[j][0], edges[j][1])) {
                    v += edges[j][2];
                }
            }
            if (uf.setCount != 1 || (uf.setCount == 1 && v > value)) {
                ans.get(0).add(edges[i][3]);
                continue;
            }
            uf = new UnionFind(n);
            uf.unite(edges[i][0], edges[i][1]);
            v = edges[i][2];
            for (int j = 0; j < m; ++j) {
                if (i != j && uf.unite(edges[j][0], edges[j][1])) {
                    v += edges[j][2];
                }
            }
            if (v == value) {
                ans.get(1).add(edges[i][3]);
            }
        }
        return ans;
    }
}

=======

        int m = edges.length;
        for (int i = 0; i < m; i++) {
            edges[i] = new int[]{edges[i][0], edges[i][1], edges[i][2], i};
        }
        Arrays.sort(edges, (a, b) -> a[2] - b[2]);
        UnionFind uf_std = new UnionFind(n);
        int value = 0;
        for (int i = 0; i < m; i++) {
            if (uf_std.unite(edges[i][0], edges[i][1])) {
                value += edges[i][2];
            }
        }
        List<List<Integer>> ans = new ArrayList<>();
        for (int i = 0; i < 2; i++) {
            ans.add(new ArrayList<>());
        }
        for (int i = 0; i < m; i++) {
            UnionFind uf = new UnionFind(n);
            int v = 0;
            for (int j = 0; j < m; j++) {
                if (i != j && uf.unite(edges[j][0], edges[j][1])) {
                    v += edges[j][2];
                }
            }
            if (uf.setCount != 1 || (uf.setCount == 1 && v > value)) {
                ans.get(0).add(edges[i][3]);
                continue;
            }
            uf = new UnionFind(n);
            uf.unite(edges[i][0], edges[i][1]);
            v = edges[i][2];
            for (int j = 0; j < m; j++) {
                if (i != j && uf.unite(edges[j][0], edges[j][1])) {
                    v += edges[j][2];
                }
            }
            if (v == value) {
                ans.get(1).add(edges[i][3]);
            }
        }
        return ans;
    }
}

=======

        int m = edges.length;
        for (int i = 0; i < m; i++) {
            edges[i] = new int[]{edges[i][0], edges[i][1], edges[i][2], i};
        }
        Arrays.sort(edges, Comparator.comparingInt(a -> a[2]));
        UnionFind uf_std = new UnionFind(n);
        int value = 0;
        for (int i = 0; i < m; i++) {
            if (uf_std.unite(edges[i][0], edges[i][1])) {
                value += edges[i][2];
            }
        }
        List<List<Integer>> ans = new ArrayList<>();
        for (int i = 0; i < 2; i++) {
            ans.add(new ArrayList<>());
        }
        for (int i = 0; i < m; i++) {
            UnionFind uf = new UnionFind(n);
            int v = 0;
            for (int j = 0; j < m; j++) {
                if (i != j && uf.unite(edges[j][0], edges[j][1])) {
                    v += edges[j][2];
                }
            }
            if (uf.setCount != 1 || (uf.setCount == 1 && v > value)) {
                ans.get(0).add(edges[i][3]);
                continue;
            }
            uf = new UnionFind(n);
            uf.unite(edges[i][0], edges[i][1]);
            v = edges[i][2];
            for (int j = 0; j < m; j++) {
                if (i != j && uf.unite(edges[j][0], edges[j][1])) {
                    v += edges[j][2];
                }
            }
            if (v == value) {
                ans.get(1).add(edges[i][3]);
            }
        }
        return ans;
    }
}

=======

        for (int i = 0; i < edges.length; i++) {
            edges[i] = new int[]{edges[i][2], edges[i][0], edges[i][1], i};
        }
        Arrays.sort(edges, (a, b) -> a[0] - b[0]);
        int mstValue = mst(n, edges, -1, -1);
        List<List<Integer>> res = new ArrayList<>();
        res.add(new ArrayList<>());
        res.add(new ArrayList<>());
        for (int i = 0; i < edges.length; i++) {
            if (mstValue != mst(n, edges, i, -1)) {
                res.get(0).add(edges[i][3]);
            } else if (mstValue == mst(n, edges, -1, i)) {
                res.get(1).add(edges[i][3]);
            }
        }
        return res;
    }
    
    private int mst(int n, int[][] edges, int skip, int use) {
        int[] parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
        int value = 0, count = 0;
        if (use >= 0) {
            value += edges[use][0];
            count++;
            union(parent, edges[use][1], edges[use][2]);
        }
        for (int i = 0; i < edges.length; i++) {
            if (i == skip) {
                continue;
            }
            int u = edges[i][1], v = edges[i][2];
            if (find(parent, u) != find(parent, v)) {
                union(parent, u, v);
                value += edges[i][0];
                count++;
            }
        }
        return count == n - 1 ? value : Integer.MAX_VALUE;
    }
    
    private int find(int[] parent, int i) {
        if (parent[i] != i) {
            parent[i] = find(parent, parent[i]);
        }
        return parent[i];
    }
    
    private void union(int[] parent, int i, int j) {
        parent[find(parent, i)] = find(parent, j);

=======

        List<List<Integer>> result = new ArrayList<>();
        List<Integer> critical = new ArrayList<>();
        List<Integer> pseudoCritical = new ArrayList<>();
        result.add(critical);
        result.add(pseudoCritical);
        int[] parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
        int[] rank = new int[n];
        for (int i = 0; i < n; i++) {
            rank[i] = 1;
        }
        for (int i = 0; i < edges.length; i++) {
            edges[i] = new int[]{edges[i][0], edges[i][1], edges[i][2], i};
        }
        Arrays.sort(edges, new Comparator<int[]>(){
            public int compare(int[] a, int[] b) {
                return a[2] - b[2];
            }
        });
        int minWeight = 0;
        for (int i = 0; i < edges.length; i++) {
            int[] edge = edges[i];
            int x = find(parent, edge[0]);
            int y = find(parent, edge[1]);
            if (x != y) {
                union(parent, rank, x, y);
                minWeight += edge[2];
            }
        }
        for (int i = 0; i < edges.length; i++) {
            int[] edge = edges[i];
            int x = find(parent, edge[0]);
            int y = find(parent, edge[1]);
            if (x != y) {
                union(parent, rank, x, y);
                if (minWeight + edge[2] == minWeight(n, edges, i)) {
                    pseudoCritical.add(edge[3]);
                }
            }
            else {
                if (minWeight == minWeight(n, edges, i)) {
                    critical.add(edge[3]);
                }
            }
        }
        return result;
    }
    public int minWeight(int n, int[][] edges, int exclude) {
        int[] parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
        int[] rank = new int[n];
        for (int i = 0; i < n; i++) {
            rank[i] = 1;
        }
        int

=======

        for(int i=0; i<edges.length; i++){
            edges[i][3] = i;
        }
        Arrays.sort(edges, (a, b) -> a[2] - b[2]);
        int min = getMSTWeight(n, edges, -1, -1);
        List<List<Integer>> result = new ArrayList<>();
        result.add(new ArrayList<>());
        result.add(new ArrayList<>());
        for(int i=0; i<edges.length; i++){
            if(getMSTWeight(n, edges, i, -1) > min){
                result.get(0).add(edges[i][3]);
            }else if(getMSTWeight(n, edges, -1, i) == min){
                result.get(1).add(edges[i][3]);
            }
        }
        return result;
    }
    
    private int getMSTWeight(int n, int[][] edges, int exclude, int include){
        UnionFind uf = new UnionFind(n);
        int weight = 0;
        if(include >= 0){
            weight += edges[include][2];
            uf.union(edges[include][0], edges[include][1]);
        }
        for(int i=0; i<edges.length; i++){
            if(i == exclude) continue;
            if(uf.union(edges[i][0], edges[i][1])){
                weight += edges[i][2];
            }
        }
        if(uf.count != 1) return Integer.MAX_VALUE;
        return weight;
    }
    
    class UnionFind{
        int[] parents;
        int count;
        
        public UnionFind(int n){
            parents = new int[n];
            for(int i=0; i<n; i++){
                parents[i] = i;
            }
            count = n;
        }
        
        public int find(int i){
            if(parents[i] != i){
                parents[i] = find(parents[i]);
            }
            return parents[i];
        }
        
        public boolean union(int i, int j){
            int x = find(i);
            int y = find(j);
            if(x == y) return false;
            parents[x] = y;
            count--;
            return true;
        }

=======

        int[] parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
        int[] rank = new int[n];
        int[][] edgesWithIndex = new int[edges.length][4];
        for (int i = 0; i < edges.length; i++) {
            edgesWithIndex[i] = new int[] {edges[i][0], edges[i][1], edges[i][2], i};
        }
        Arrays.sort(edgesWithIndex, (a, b) -> a[2] - b[2]);
        int mst = kruskal(parent, rank, edgesWithIndex, -1);
        List<List<Integer>> res = new ArrayList<>();
        res.add(new ArrayList<>());
        res.add(new ArrayList<>());
        for (int i = 0; i < edgesWithIndex.length; i++) {
            if (mst != kruskal(parent, rank, edgesWithIndex, i)) {
                res.get(0).add(edgesWithIndex[i][3]);
            } else if (mst == kruskal(parent, rank, edgesWithIndex, i, edgesWithIndex[i][3])) {
                res.get(1).add(edgesWithIndex[i][3]);
            }
        }
        return res;
    }
    
    private int kruskal(int[] parent, int[] rank, int[][] edgesWithIndex, int skip) {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
        int res = 0;
        int count = 0;
        for (int i = 0; i < edgesWithIndex.length; i++) {
            if (i == skip) {
                continue;
            }
            int[] edge = edgesWithIndex[i];
            int x = find(parent, edge[0]);
            int y = find(parent, edge[1]);
            if (x == y) {
                continue;
            }
            res += edge[2];
            count++;
            if (rank[x] > rank[y]) {
                parent[y] = x;
            } else if (rank[y] > rank[x]) {
                parent[x] = y;
            } else {
                parent[y] = x;
                rank[x]++;
            }
        }
        return count == parent.length
