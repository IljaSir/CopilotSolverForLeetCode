Synthesizing 8/10 solutions

=======

        int m = grid.length;
        int n = grid[0].length;
        int[] player = new int[2];
        int[] box = new int[2];
        int[] target = new int[2];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 'S') {
                    player[0] = i;
                    player[1] = j;
                } else if (grid[i][j] == 'B') {
                    box[0] = i;
                    box[1] = j;
                } else if (grid[i][j] == 'T') {
                    target[0] = i;
                    target[1] = j;
                }
            }
        }
        Queue<int[]> queue = new LinkedList<>();
        queue.add(new int[]{player[0], player[1], box[0], box[1], 0});
        Set<String> visited = new HashSet<>();
        visited.add(player[0] + " " + player[1] + " " + box[0] + " " + box[1]);
        while (!queue.isEmpty()) {
            int[] cur = queue.poll();
            if (cur[0] == target[0] && cur[1] == target[1]) {
                return cur[4];
            }
            int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
            for (int[] direction : directions) {
                int px = cur[0] + direction[0];
                int py = cur[1] + direction[1];
                if (px < 0 || px >= m || py < 0 || py >= n || grid[px][py] == '#') {
                    continue;
                }
                int bx = cur[2];
                int by = cur[3];
                if (px == bx && py == by) {
                    bx += direction[0];
                    by += direction[1];
                    if (bx < 0 || bx >= m || by < 0 || by >= n || grid[bx][by] == '#') {
                        continue;
                    }
                }
                String key = px + " " + py + " " + bx + " " + by;

=======

        int m = grid.length, n = grid[0].length;
        int[] player = new int[2], box = new int[2], target = new int[2];
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == 'S') {
                    player[0] = i;
                    player[1] = j;
                } else if (grid[i][j] == 'B') {
                    box[0] = i;
                    box[1] = j;
                } else if (grid[i][j] == 'T') {
                    target[0] = i;
                    target[1] = j;
                }
            }
        }
        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        Queue<int[]> queue = new LinkedList<>();
        Set<String> visited = new HashSet<>();
        queue.offer(new int[]{player[0], player[1], box[0], box[1]});
        visited.add(player[0] + "_" + player[1] + "_" + box[0] + "_" + box[1]);
        int res = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; ++i) {
                int[] cur = queue.poll();
                if (cur[2] == target[0] && cur[3] == target[1]) return res;
                for (int[] dir : dirs) {
                    int x = cur[0] + dir[0], y = cur[1] + dir[1];
                    if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == '#') continue;
                    int bx = cur[2], by = cur[3];
                    if (x == bx && y == by) {
                        bx += dir[0];
                        by += dir[1];
                        if (bx < 0 || bx >= m || by < 0 || by >= n || grid[bx][by] == '#') continue;
                    }
                    if (visited.add(x + "_" + y + "_" + bx + "_" + by)) {
                        queue

=======

        int m = grid.length;
        int n = grid[0].length;
        int[] box = new int[2];
        int[] target = new int[2];
        int[] player = new int[2];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 'B') {
                    box[0] = i;
                    box[1] = j;
                }
                if (grid[i][j] == 'T') {
                    target[0] = i;
                    target[1] = j;
                }
                if (grid[i][j] == 'S') {
                    player[0] = i;
                    player[1] = j;
                }
            }
        }
        Queue<int[]> q = new LinkedList<>();
        q.offer(new int[]{box[0], box[1], player[0], player[1]});
        Set<String> visited = new HashSet<>();
        visited.add(box[0] + " " + box[1] + " " + player[0] + " " + player[1]);
        int step = 0;
        while (!q.isEmpty()) {
            int size = q.size();
            for (int i = 0; i < size; i++) {
                int[] cur = q.poll();
                int bx = cur[0];
                int by = cur[1];
                int px = cur[2];
                int py = cur[3];
                if (bx == target[0] && by == target[1]) {
                    return step;
                }
                for (int j = 0; j < 4; j++) {
                    int dx = bx - px;
                    int dy = by - py;
                    int nbx = bx + dx;
                    int nby = by + dy;
                    int npx = bx;
                    int npy = by;
                    if (nbx < 0 || nbx >= m || nby < 0 || nby >= n || grid[nbx][nby] == '#') {
                        continue;
                    }
                    if (npx < 0 || npx >= m || npy < 0 || npy >= n || grid[npx][npy] == '#') {
                        continue;
                    }
                    if (visited.add

=======

        int m = grid.length;
        int n = grid[0].length;
        int[] start = new int[2];
        int[] end = new int[2];
        int[] box = new int[2];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 'S') {
                    start[0] = i;
                    start[1] = j;
                } else if (grid[i][j] == 'T') {
                    end[0] = i;
                    end[1] = j;
                } else if (grid[i][j] == 'B') {
                    box[0] = i;
                    box[1] = j;
                }
            }
        }
        return bfs(grid, start, end, box);
    }

    private int bfs(char[][] grid, int[] start, int[] end, int[] box) {
        int m = grid.length;
        int n = grid[0].length;
        int[][][][] visited = new int[m][n][m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < m; k++) {
                    for (int l = 0; l < n; l++) {
                        visited[i][j][k][l] = Integer.MAX_VALUE;
                    }
                }
            }
        }
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{start[0], start[1], box[0], box[1]});
        visited[start[0]][start[1]][box[0]][box[1]] = 0;
        while (!queue.isEmpty()) {
            int[] curr = queue.poll();
            int x = curr[0];
            int y = curr[1];
            int bx = curr[2];
            int by = curr[3];
            if (bx == end[0] && by == end[1]) {
                return visited[x][y][bx][by];
            }
            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                int nbx

=======

        int m = grid.length;
        int n = grid[0].length;
        int[] player = null;
        int[] box = null;
        int[] target = null;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 'S') {
                    player = new int[]{i, j};
                } else if (grid[i][j] == 'B') {
                    box = new int[]{i, j};
                } else if (grid[i][j] == 'T') {
                    target = new int[]{i, j};
                }
            }
        }
        int[][] dirs = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{player[0], player[1], box[0], box[1]});
        Set<String> visited = new HashSet<>();
        visited.add(player[0] + "_" + player[1] + "_" + box[0] + "_" + box[1]);
        int step = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            while (size-- > 0) {
                int[] cur = queue.poll();
                if (cur[2] == target[0] && cur[3] == target[1]) {
                    return step;
                }
                for (int[] dir : dirs) {
                    int x = cur[0] + dir[0];
                    int y = cur[1] + dir[1];
                    if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == '#') {
                        continue;
                    }
                    if (x == cur[2] && y == cur[3]) {
                        int bx = cur[2] + dir[0];
                        int by = cur[3] + dir[1];
                        if (bx < 0 || bx >= m || by < 0 || by >= n || grid[bx][by] == '#') {
                            continue;
                        }
                        if (!visited.contains(x + "_" + y + "_" + bx + "_" + by)) {
                            queue.offer(new int[]{x, y, bx,

=======

        int m = grid.length, n = grid[0].length;
        int[] box = new int[2], target = new int[2], player = new int[2];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 'B') {
                    box[0] = i;
                    box[1] = j;
                } else if (grid[i][j] == 'T') {
                    target[0] = i;
                    target[1] = j;
                } else if (grid[i][j] == 'S') {
                    player[0] = i;
                    player[1] = j;
                }
            }
        }
        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{box[0], box[1], player[0], player[1]});
        Set<String> visited = new HashSet<>();
        visited.add(box[0] + "," + box[1] + "," + player[0] + "," + player[1]);
        int res = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int[] cur = queue.poll();
                if (cur[0] == target[0] && cur[1] == target[1]) {
                    return res;
                }
                for (int[] dir : dirs) {
                    int x = cur[0] + dir[0], y = cur[1] + dir[1];
                    int px = cur[0] - dir[0], py = cur[1] - dir[1];
                    if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == '#') {
                        continue;
                    }
                    if (x == cur[2] && y == cur[3]) {
                        if (px == target[0] && py == target[1]) {
                            return res + 1;
                        }
                        if (px < 0 || px >= m || py < 0 || py >= n || grid[px

=======

        int m = grid.length, n = grid[0].length;
        int[] start = new int[2], box = new int[2], target = new int[2];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 'S') {
                    start[0] = i;
                    start[1] = j;
                } else if (grid[i][j] == 'B') {
                    box[0] = i;
                    box[1] = j;
                } else if (grid[i][j] == 'T') {
                    target[0] = i;
                    target[1] = j;
                }
            }
        }
        int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        Queue<int[]> q = new LinkedList<>();
        int[][][] seen = new int[m][n][4];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                Arrays.fill(seen[i][j], Integer.MAX_VALUE);
            }
        }
        for (int i = 0; i < 4; i++) {
            int[] next = new int[]{box[0] + dirs[i][0], box[1] + dirs[i][1]};
            if (next[0] >= 0 && next[0] < m && next[1] >= 0 && next[1] < n && grid[next[0]][next[1]] != '#') {
                seen[box[0]][box[1]][i] = 0;
                q.offer(new int[]{box[0], box[1], i});
            }
        }
        while (!q.isEmpty()) {
            int[] cur = q.poll();
            int x = cur[0], y = cur[1], dir = cur[2];
            if (x == target[0] && y == target[1]) {
                return seen[x][y][dir];
            }
            for (int i = 0; i < 4; i++) {
                int[] next = new int[]{x + dirs[i][0], y + dirs[i][1]};

=======

        int m = grid.length, n = grid[0].length;
        int[] box = null;
        int[] target = null;
        int[] player = null;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 'B') {
                    box = new int[]{i, j};
                } else if (grid[i][j] == 'T') {
                    target = new int[]{i, j};
                } else if (grid[i][j] == 'S') {
                    player = new int[]{i, j};
                }
            }
        }
        Queue<int[]> q = new LinkedList<>();
        Set<String> visited = new HashSet<>();
        q.offer(new int[]{player[0], player[1], box[0], box[1]});
        visited.add(player[0] + "," + player[1] + "," + box[0] + "," + box[1]);
        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int ans = 0;
        while (!q.isEmpty()) {
            int size = q.size();
            for (int i = 0; i < size; i++) {
                int[] cur = q.poll();
                if (cur[2] == target[0] && cur[3] == target[1]) {
                    return ans;
                }
                for (int[] dir : dirs) {
                    int x = cur[0] + dir[0];
                    int y = cur[1] + dir[1];
                    if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == '#') {
                        continue;
                    }
                    if (x == cur[2] && y == cur[3]) {
                        int bx = cur[2] + dir[0];
                        int by = cur[3] + dir[1];
                        if (bx < 0 || bx >= m || by < 0 || by >= n || grid[bx][by] == '#') {
                            continue;
                        }
                        if (!visited.contains(x + "," + y + "," + bx + "," + by)) {
                            q.offer(new int[]{x, y, bx
