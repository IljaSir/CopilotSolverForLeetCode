Synthesizing 10/10 solutions

=======

        int n = board.size();
        int[][] dp = new int[n][n];
        int[][] count = new int[n][n];
        dp[n - 1][n - 1] = 0;
        count[n - 1][n - 1] = 1;
        for (int i = n - 2; i >= 0; i--) {
            if (board.get(i).charAt(n - 1) == 'X') {
                break;
            }
            dp[i][n - 1] = dp[i + 1][n - 1] + board.get(i).charAt(n - 1) - '0';
            count[i][n - 1] = 1;
        }
        for (int i = n - 2; i >= 0; i--) {
            if (board.get(n - 1).charAt(i) == 'X') {
                break;
            }
            dp[n - 1][i] = dp[n - 1][i + 1] + board.get(n - 1).charAt(i) - '0';
            count[n - 1][i] = 1;
        }
        for (int i = n - 2; i >= 0; i--) {
            for (int j = n - 2; j >= 0; j--) {
                if (board.get(i).charAt(j) == 'X') {
                    continue;
                }
                int max = Math.max(dp[i + 1][j], Math.max(dp[i][j + 1], dp[i + 1][j + 1]));
                if (max == dp[i + 1][j]) {
                    count[i][j] += count[i + 1][j];
                }
                if (max == dp[i][j + 1]) {
                    count[i][j] += count[i][j + 1];
                }
                if (max == dp[i + 1][j + 1]) {
                    count[i][j] += count[i + 1][j + 1];
                }
                dp[i][j] = max + board.get(i).charAt(j) - '0';
                count[i][j] %= 1000000007;
            }
        }
        return new int[]{dp[0][0], count[0][0]};

=======

        int n = board.size();
        int[][] dp = new int[n][n];
        int[][] count = new int[n][n];
        count[n - 1][n - 1] = 1;
        int mod = 1000000007;
        for (int i = n - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                if (board.get(i).charAt(j) == 'X') {
                    continue;
                }
                if (i == n - 1 && j == n - 1) {
                    continue;
                }
                int max = 0;
                if (i + 1 < n) {
                    max = Math.max(max, dp[i + 1][j]);
                }
                if (j + 1 < n) {
                    max = Math.max(max, dp[i][j + 1]);
                }
                if (i + 1 < n && j + 1 < n) {
                    max = Math.max(max, dp[i + 1][j + 1]);
                }
                dp[i][j] = max + (board.get(i).charAt(j) - '0');
                if (i + 1 < n && dp[i + 1][j] == max) {
                    count[i][j] = (count[i][j] + count[i + 1][j]) % mod;
                }
                if (j + 1 < n && dp[i][j + 1] == max) {
                    count[i][j] = (count[i][j] + count[i][j + 1]) % mod;
                }
                if (i + 1 < n && j + 1 < n && dp[i + 1][j + 1] == max) {
                    count[i][j] = (count[i][j] + count[i + 1][j + 1]) % mod;
                }
            }
        }
        return new int[]{dp[0][0], count[0][0]};

=======

        int n = board.size();
        int[][] dp = new int[n][n];
        int[][] paths = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = Integer.MIN_VALUE;
                paths[i][j] = 0;
            }
        }
        paths[n - 1][n - 1] = 1;
        dp[n - 1][n - 1] = 0;
        for (int i = n - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                if (board.get(i).charAt(j) == 'X') {
                    continue;
                }
                int max = 0;
                int ways = 0;
                for (int[] dir : new int[][]{{0, 1}, {1, 0}, {1, 1}}) {
                    int ni = i + dir[0];
                    int nj = j + dir[1];
                    if (ni < 0 || ni >= n || nj < 0 || nj >= n) {
                        continue;
                    }
                    if (dp[ni][nj] == Integer.MIN_VALUE) {
                        continue;
                    }
                    if (dp[ni][nj] > max) {
                        max = dp[ni][nj];
                        ways = paths[ni][nj];
                    } else if (dp[ni][nj] == max) {
                        ways = (ways + paths[ni][nj]) % 1000000007;
                    }
                }
                if (board.get(i).charAt(j) != 'E') {
                    max += board.get(i).charAt(j) - '0';
                }
                dp[i][j] = max;
                paths[i][j] = ways;
            }
        }
        return new int[]{dp[0][0], paths[0][0]};

=======

        int n = board.size();
        int[][] score = new int[n][n];
        int[][] paths = new int[n][n];
        paths[n - 1][n - 1] = 1;
        int mod = 1000000007;
        for (int i = n - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                if (board.get(i).charAt(j) == 'X') {
                    score[i][j] = -1;
                    continue;
                }
                if (i == n - 1 && j == n - 1) {
                    continue;
                }
                int maxScore = 0;
                int maxPaths = 0;
                if (i + 1 < n && score[i + 1][j] != -1) {
                    int s = score[i + 1][j];
                    int p = paths[i + 1][j];
                    if (s > maxScore) {
                        maxScore = s;
                        maxPaths = p;
                    } else if (s == maxScore) {
                        maxPaths += p;
                    }
                }
                if (j + 1 < n && score[i][j + 1] != -1) {
                    int s = score[i][j + 1];
                    int p = paths[i][j + 1];
                    if (s > maxScore) {
                        maxScore = s;
                        maxPaths = p;
                    } else if (s == maxScore) {
                        maxPaths += p;
                    }
                }
                if (i + 1 < n && j + 1 < n && score[i + 1][j + 1] != -1) {
                    int s = score[i + 1][j + 1];
                    int p = paths[i + 1][j + 1];
                    if (s > maxScore) {
                        maxScore = s;
                        maxPaths = p;
                    } else if (s == maxScore) {
                        maxPaths += p;
                    }
                }
                score[i][j] = maxScore + (board.get(i).charAt(j) - '0');
                paths[i][j] = maxPaths % mod;
            }
        }
        if (score[0][0] == 0) {
            return

=======

        int n = board.size();
        int[][] dp = new int[n][n];
        int[][] paths = new int[n][n];
        paths[n-1][n-1] = 1;
        int mod = 1000000007;
        int max = 0;
        for (int i = n - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                if (board.get(i).charAt(j) == 'X') continue;
                int val = 0;
                if (board.get(i).charAt(j) >= '1' && board.get(i).charAt(j) <= '9') {
                    val = board.get(i).charAt(j) - '0';
                }
                if (i == n - 1 && j == n - 1) {
                    dp[i][j] = val;
                    paths[i][j] = 1;
                    continue;
                }
                int[] dir = new int[]{-1, 0, -1};
                int[] dir2 = new int[]{0, -1, -1};
                for (int k = 0; k < 3; k++) {
                    int x = i + dir[k];
                    int y = j + dir2[k];
                    if (x >= 0 && y >= 0 && dp[x][y] + val > dp[i][j]) {
                        dp[i][j] = dp[x][y] + val;
                        paths[i][j] = paths[x][y];
                    } else if (x >= 0 && y >= 0 && dp[x][y] + val == dp[i][j]) {
                        paths[i][j] = (paths[i][j] + paths[x][y]) % mod;
                    }
                }
            }
        }
        return new int[]{dp[0][0], paths[0][0]};

=======

        int n = board.size();
        int[][] dp = new int[n][n];
        int[][] paths = new int[n][n];
        int mod = 1000000007;
        dp[n-1][n-1] = 0;
        paths[n-1][n-1] = 1;
        for(int i = n-2; i>=0; i--){
            if(board.get(i).charAt(n-1) != 'X'){
                dp[i][n-1] = dp[i+1][n-1] + board.get(i).charAt(n-1) - '0';
                paths[i][n-1] = 1;
            }
        }
        for(int j = n-2; j>=0; j--){
            if(board.get(n-1).charAt(j) != 'X'){
                dp[n-1][j] = dp[n-1][j+1] + board.get(n-1).charAt(j) - '0';
                paths[n-1][j] = 1;
            }
        }
        for(int i = n-2; i>=0; i--){
            for(int j = n-2; j>=0; j--){
                if(board.get(i).charAt(j) == 'X') continue;
                int max = Math.max(dp[i+1][j], Math.max(dp[i][j+1], dp[i+1][j+1]));
                if(max == dp[i+1][j]) paths[i][j] = (paths[i][j] + paths[i+1][j])%mod;
                if(max == dp[i][j+1]) paths[i][j] = (paths[i][j] + paths[i][j+1])%mod;
                if(max == dp[i+1][j+1]) paths[i][j] = (paths[i][j] + paths[i+1][j+1])%mod;
                dp[i][j] = max + board.get(i).charAt(j) - '0';
            }
        }
        return new int[]{dp[0][0], paths[0][0]};

=======

        int n = board.size();
        int[][] dp = new int[n][n];
        int[][] path = new int[n][n];
        int mod = 1000000007;
        dp[n - 1][n - 1] = 0;
        path[n - 1][n - 1] = 1;
        for (int i = n - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                if (board.get(i).charAt(j) == 'X') {
                    dp[i][j] = -1;
                } else if (i == n - 1 && j == n - 1) {
                    continue;
                } else {
                    int max = -1;
                    int p = 0;
                    if (i < n - 1) {
                        max = dp[i + 1][j];
                        p = path[i + 1][j];
                    }
                    if (j < n - 1 && dp[i][j + 1] > max) {
                        max = dp[i][j + 1];
                        p = path[i][j + 1];
                    }
                    if (i < n - 1 && j < n - 1 && dp[i + 1][j + 1] > max) {
                        max = dp[i + 1][j + 1];
                        p = path[i + 1][j + 1];
                    }
                    if (max == -1) {
                        dp[i][j] = -1;
                    } else {
                        dp[i][j] = max + (board.get(i).charAt(j) == 'E' ? 0 : board.get(i).charAt(j) - '0');
                        path[i][j] = p;
                    }
                }
            }
        }
        return new int[]{Math.max(dp[0][0], 0), dp[0][0] == -1 ? 0 : path[0][0] % mod};

=======

        int n = board.size();
        int[][] dp = new int[n + 1][n + 1];
        int[][] cnt = new int[n + 1][n + 1];
        int[][] dirs = {{1, 0}, {0, 1}, {1, 1}};
        int mod = (int)1e9 + 7;
        dp[n - 1][n - 1] = 0;
        cnt[n - 1][n - 1] = 1;
        for (int i = n - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                if (board.get(i).charAt(j) == 'X') continue;
                for (int[] dir : dirs) {
                    int x = i + dir[0];
                    int y = j + dir[1];
                    if (x >= 0 && x < n && y >= 0 && y < n && cnt[x][y] > 0) {
                        if (dp[x][y] + board.get(i).charAt(j) - '0' > dp[i][j]) {
                            dp[i][j] = dp[x][y] + board.get(i).charAt(j) - '0';
                            cnt[i][j] = cnt[x][y];
                        } else if (dp[x][y] + board.get(i).charAt(j) - '0' == dp[i][j]) {
                            cnt[i][j] += cnt[x][y];
                            cnt[i][j] %= mod;
                        }
                    }
                }
            }
        }
        int[] res = new int[2];
        res[0] = dp[0][0];
        res[1] = cnt[0][0];
        if (board.get(0).charAt(0) != 'S') {
            res[0] += board.get(0).charAt(0) - '0';
        }
        return res;

=======

        int M = board.size();
        int N = M;
        int[][][] dp = new int[M][N][2];
        for (int i = 0; i < M; i++) {
            for (int j = 0; j < N; j++) {
                dp[i][j][0] = Integer.MIN_VALUE;
                dp[i][j][1] = 0;
            }
        }
        dp[M - 1][N - 1][0] = 0;
        dp[M - 1][N - 1][1] = 1;
        for (int i = M - 1; i >= 0; i--) {
            for (int j = N - 1; j >= 0; j--) {
                if (i == M - 1 && j == N - 1) {
                    continue;
                }
                if (board.get(i).charAt(j) == 'X') {
                    continue;
                }
                int max = Integer.MIN_VALUE;
                int count = 0;
                for (int x = i + 1; x >= i && x >= i - 1; x--) {
                    for (int y = j + 1; y >= j && y >= j - 1; y--) {
                        if (x >= M || y >= N) {
                            continue;
                        }
                        if (dp[x][y][0] > max) {
                            max = dp[x][y][0];
                            count = dp[x][y][1];
                        } else if (dp[x][y][0] == max) {
                            count = (count + dp[x][y][1]) % 1000000007;
                        }
                    }
                }
                if (max != Integer.MIN_VALUE) {
                    if (board.get(i).charAt(j) != 'E') {
                        max += board.get(i).charAt(j) - '0';
                    }
                    dp[i][j][0] = max;
                    dp[i][j][1] = count;
                }
            }
        }
        return dp[0][0];

=======

        int m = board.size(), n = board.get(0).length();
        int[][] dp = new int[m][n];
        int[][] paths = new int[m][n];
        int[] res = new int[2];
        int mod = (int)1e9 + 7;
        dp[m - 1][n - 1] = 0;
        paths[m - 1][n - 1] = 1;
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                if (board.get(i).charAt(j) == 'X') continue;
                if (i == m - 1 && j == n - 1) continue;
                int max = Math.max(Math.max(i + 1 < m ? dp[i + 1][j] : 0, j + 1 < n ? dp[i][j + 1] : 0), i + 1 < m && j + 1 < n ? dp[i + 1][j + 1] : 0);
                dp[i][j] = max;
                if (i + 1 < m && dp[i + 1][j] == max) paths[i][j] = (paths[i][j] + paths[i + 1][j]) % mod;
                if (j + 1 < n && dp[i][j + 1] == max) paths[i][j] = (paths[i][j] + paths[i][j + 1]) % mod;
                if (i + 1 < m && j + 1 < n && dp[i + 1][j + 1] == max) paths[i][j] = (paths[i][j] + paths[i + 1][j + 1]) % mod;
                if (Character.isDigit(board.get(i).charAt(j))) dp[i][j] += board.get(i).charAt(j) - '0';
            }
        }
        res[0] = dp[0][0];
        res[1] = paths[0][0];
        return res;
