Synthesizing 6/10 solutions

=======

        Stack<Map<String, Integer>> stack = new Stack<>();
        stack.push(new HashMap<>());
        return evaluate(expression, stack);
    }
    
    private int evaluate(String expression, Stack<Map<String, Integer>> stack) {
        if (expression.charAt(0) != '(') {
            if (Character.isDigit(expression.charAt(0)) || expression.charAt(0) == '-') {
                return Integer.parseInt(expression);
            }
            for (int i = stack.size() - 1; i >= 0; i--) {
                if (stack.get(i).containsKey(expression)) {
                    return stack.get(i).get(expression);
                }
            }
        }
        Map<String, Integer> map = new HashMap<>();
        int start = expression.charAt(1) == 'm' ? 6 : 5;
        int count = 0;
        for (int i = start; i < expression.length(); i++) {
            char c = expression.charAt(i);
            if (c == '(') {
                count++;
            } else if (c == ')') {
                count--;
            }
            if (count == 0 && (c == ' ' || i == expression.length() - 1)) {
                int val = evaluate(expression.substring(start, i), stack);
                if (expression.charAt(1) == 'a') {
                    map.put("a", map.getOrDefault("a", 0) + val);
                } else if (expression.charAt(1) == 'm') {
                    map.put("m", map.getOrDefault("m", 1) * val);
                } else {
                    map.put(expression.substring(start - 1, start), val);
                }
                start = i + 2;
            }
        }
        if (map.containsKey("a")) {
            return map.get("a");
        }
        if (map.containsKey("m")) {
            return map.get("m");
        }
        stack.push(map);
        int val = evaluate(expression.substring(start, expression.length() - 1), stack);
        stack.pop();
        return val;

=======

        return evaluate(expression, new HashMap<>());
    }

    private int evaluate(String expression, Map<String, Integer> map) {
        if (expression.charAt(0) != '(') {
            if (Character.isDigit(expression.charAt(0)) || expression.charAt(0) == '-')
                return Integer.parseInt(expression);
            return map.get(expression);
        }
        List<String> tokens = parse(expression.substring(expression.charAt(1) == 'm' ? 6 : 5, expression.length() - 1));
        Map<String, Integer> newMap = new HashMap<>(map);
        if (expression.startsWith("(let")) {
            for (int i = 0; i < tokens.size() - 2; i += 2)
                newMap.put(tokens.get(i), evaluate(tokens.get(i + 1), newMap));
            return evaluate(tokens.get(tokens.size() - 1), newMap);
        }
        int ans = evaluate(tokens.get(0), newMap);
        for (int i = 1; i < tokens.size(); i++)
            ans += expression.startsWith("(add") ? evaluate(tokens.get(i), newMap) : ans * evaluate(tokens.get(i), newMap);
        return ans;
    }

    private List<String> parse(String s) {
        List<String> res = new ArrayList<>();
        int i = 0, n = s.length();
        while (i < n) {
            if (s.charAt(i) == '(') {
                int count = 1;
                while (count > 0) {
                    i++;
                    if (s.charAt(i) == '(')
                        count++;
                    else if (s.charAt(i) == ')')
                        count--;
                }
                res.add(s.substring(i - count + 1, i + 1));
            } else {
                int j = i + 1;
                while (j < n && s.charAt(j) != ' ')
                    j++;
                res.add(s.substring(i, j));
                i = j;
            }
            i++;
        }
        return res;

=======

        return evaluate(expression, new HashMap<String, Integer>());
    }
    private int evaluate(String expression, Map<String, Integer> parent) {
        Map<String, Integer> map = new HashMap<String, Integer>(parent);
        if (expression.charAt(0) != '(') {
            if (Character.isDigit(expression.charAt(0)) || expression.charAt(0) == '-') {
                return Integer.parseInt(expression);
            }
            return map.get(expression);
        }
        int i = 0;
        List<String> tokens = new ArrayList<String>();
        while (i < expression.length()) {
            if (expression.charAt(i) == '(') {
                int j = i + 1, count = 1;
                while (count > 0) {
                    if (expression.charAt(j) == '(') {
                        count++;
                    } else if (expression.charAt(j) == ')') {
                        count--;
                    }
                    j++;
                }
                tokens.add(evaluate(expression.substring(i, j), map) + "");
                i = j - 1;
            } else if (expression.charAt(i) != ' ') {
                int j = i + 1;
                while (j < expression.length() && expression.charAt(j) != ' ') {
                    j++;
                }
                tokens.add(expression.substring(i, j));
                i = j - 1;
            }
            i++;
        }
        if (tokens.get(0).equals("add")) {
            return Integer.parseInt(tokens.get(1)) + Integer.parseInt(tokens.get(2));
        } else if (tokens.get(0).equals("mult")) {
            return Integer.parseInt(tokens.get(1)) * Integer.parseInt(tokens.get(2));
        } else {
            for (int j = 1; j < tokens.size() - 1; j += 2) {
                map.put(tokens.get(j), Integer.parseInt(tokens.get(j + 1)));
            }
            return Integer.parseInt(tokens.get(tokens.size() - 1));
        }

=======

        return evaluate(expression, new HashMap<String, Integer>());
    }
    private int evaluate(String expression, Map<String, Integer> scope) {
        if (expression.charAt(0) != '(') {
            return isNumber(expression) ? Integer.parseInt(expression) : scope.get(expression);
        }
        List<String> tokens = tokenize(expression.substring(expression.charAt(1) == 'm' ? 6 : 5, expression.length() - 1));
        if (expression.startsWith("(add")) {
            return evaluate(tokens.get(0), scope) + evaluate(tokens.get(1), scope);
        } else if (expression.startsWith("(mult")) {
            return evaluate(tokens.get(0), scope) * evaluate(tokens.get(1), scope);
        } else {
            Map<String, Integer> newScope = new HashMap<String, Integer>(scope);
            for (int i = 0; i < tokens.size() - 1; i += 2) {
                newScope.put(tokens.get(i), evaluate(tokens.get(i + 1), newScope));
            }
            return evaluate(tokens.get(tokens.size() - 1), newScope);
        }
    }
    private List<String> tokenize(String expression) {
        List<String> tokens = new ArrayList<String>();
        int balance = 0;
        int prev = 0;
        for (int i = 0; i < expression.length(); i++) {
            if (expression.charAt(i) == '(') {
                balance++;
            } else if (expression.charAt(i) == ')') {
                balance--;
            } else if (expression.charAt(i) == ' ' && balance == 0) {
                tokens.add(expression.substring(prev, i));
                prev = i + 1;
            }
        }
        tokens.add(expression.substring(prev, expression.length()));
        return tokens;
    }
    private boolean isNumber(String s) {
        if (s.length() == 0) {
            return false;
        }
        for (int i = 0; i < s.length(); i++) {
            if (i == 0 && s.charAt(i) == '-') {
                continue;
            }
            if (s.charAt(i) < '0' || s.charAt(i) > '9') {
                return false;
            }
        }
        return true;

=======

        return evaluate(expression, new HashMap<>());
    }

    private int evaluate(String expression, Map<String, Integer> map) {
        if (expression.startsWith("(")) {
            String[] tokens = expression.substring(1, expression.length() - 1).split(" ");
            if (tokens[0].equals("let")) {
                Map<String, Integer> newMap = new HashMap<>(map);
                for (int i = 1; i < tokens.length - 2; i += 2) {
                    newMap.put(tokens[i], evaluate(tokens[i + 1], newMap));
                }
                return evaluate(tokens[tokens.length - 1], newMap);
            } else if (tokens[0].equals("add")) {
                return evaluate(tokens[1], map) + evaluate(tokens[2], map);
            } else {
                return evaluate(tokens[1], map) * evaluate(tokens[2], map);
            }
        } else {
            return map.containsKey(expression) ? map.get(expression) : Integer.parseInt(expression);
        }

=======

        return evaluate(expression, new HashMap<>());
    }
    public int evaluate(String expression, Map<String, Integer> parentScope) {
        if (expression.charAt(0) != '(') {
            // number or variable
            if (Character.isDigit(expression.charAt(0)) || expression.charAt(0) == '-') {
                return Integer.parseInt(expression);
            }
            return parentScope.get(expression);
        }
        Map<String, Integer> scope = new HashMap<>(parentScope);
        int start = expression.charAt(1) == 'm' ? 6 : 5;
        int i = start;
        List<String> tokens = new ArrayList<>();
        while (i < expression.length() - 1) {
            if (expression.charAt(i) == '(') {
                int j = i + 1;
                int count = 1;
                while (count > 0) {
                    if (expression.charAt(j) == '(') {
                        count++;
                    } else if (expression.charAt(j) == ')') {
                        count--;
                    }
                    j++;
                }
                tokens.add(expression.substring(i, j));
                i = j;
            } else {
                int j = i + 1;
                while (j < expression.length() && expression.charAt(j) != ' ') {
                    j++;
                }
                tokens.add(expression.substring(i, j));
                i = j;
            }
            while (i < expression.length() - 1 && expression.charAt(i) == ' ') {
                i++;
            }
        }
        if (expression.charAt(1) == 'm') {
            // mult
            return evaluate(tokens.get(0), scope) * evaluate(tokens.get(1), scope);
        } else if (expression.charAt(1) == 'a') {
            // add
            return evaluate(tokens.get(0), scope) + evaluate(tokens.get(1), scope);
        } else {
            // let
            for (int j = 0; j < tokens.size() - 2; j += 2) {
                scope.put(tokens.get(j), evaluate(tokens.get(j + 1), scope));
            }
            return evaluate(tokens.get(tokens.size() - 1), scope);
        }
