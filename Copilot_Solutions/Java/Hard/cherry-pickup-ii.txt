Synthesizing 10/10 solutions

=======

        int m = grid.length;
        int n = grid[0].length;
        int[][][] dp = new int[m][n][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < n; k++) {
                    dp[i][j][k] = -1;
                }
            }
        }
        dp[0][0][n - 1] = grid[0][0] + grid[0][n - 1];
        for (int i = 1; i < m; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < n; k++) {
                    if (dp[i - 1][j][k] == -1) {
                        continue;
                    }
                    for (int d1 = -1; d1 <= 1; d1++) {
                        for (int d2 = -1; d2 <= 1; d2++) {
                            int x1 = j + d1;
                            int x2 = k + d2;
                            if (x1 >= 0 && x1 < n && x2 >= 0 && x2 < n) {
                                dp[i][x1][x2] = Math.max(dp[i][x1][x2], dp[i - 1][j][k] + grid[i][x1] + (x1 == x2 ? 0 : grid[i][x2]));
                            }
                        }
                    }
                }
            }
        }
        int res = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                res = Math.max(res, dp[m - 1][i][j]);
            }
        }
        return res;

=======

        int m = grid.length;
        int n = grid[0].length;
        int[][][] dp = new int[m][n][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < n; k++) {
                    dp[i][j][k] = -1;
                }
            }
        }
        dp[0][0][n - 1] = grid[0][0] + grid[0][n - 1];
        for (int i = 1; i < m; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < n; k++) {
                    if (j > i || k > i || n - 1 - j > i || n - 1 - k > i) continue;
                    int max = -1;
                    for (int p = j - 1; p <= j + 1; p++) {
                        for (int q = k - 1; q <= k + 1; q++) {
                            if (p < 0 || q < 0 || p >= n || q >= n) continue;
                            max = Math.max(max, dp[i - 1][p][q]);
                        }
                    }
                    if (max >= 0) {
                        dp[i][j][k] = max + grid[i][j] + grid[i][k];
                        if (j == k) dp[i][j][k] -= grid[i][j];
                    }
                }
            }
        }
        int res = 0;
        for (int j = 0; j < n; j++) {
            for (int k = 0; k < n; k++) {
                res = Math.max(res, dp[m - 1][j][k]);
            }
        }
        return res;

=======

        int rows = grid.length;
        int cols = grid[0].length;
        int[][][] dp = new int[rows][cols][cols];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                for (int k = 0; k < cols; k++) {
                    dp[i][j][k] = -1;
                }
            }
        }
        dp[0][0][cols - 1] = grid[0][0] + (cols - 1 == 0 ? 0 : grid[0][cols - 1]);
        for (int i = 1; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                for (int k = 0; k < cols; k++) {
                    for (int j1 = j - 1; j1 <= j + 1; j1++) {
                        for (int k1 = k - 1; k1 <= k + 1; k1++) {
                            if (j1 >= 0 && j1 < cols && k1 >= 0 && k1 < cols) {
                                dp[i][j][k] = Math.max(dp[i][j][k], dp[i - 1][j1][k1]);
                            }
                        }
                    }
                    if (dp[i][j][k] >= 0) {
                        dp[i][j][k] += grid[i][j] + (j == k ? 0 : grid[i][k]);
                    }
                }
            }
        }
        int res = 0;
        for (int j = 0; j < cols; j++) {
            for (int k = 0; k < cols; k++) {
                res = Math.max(res, dp[rows - 1][j][k]);
            }
        }
        return res;

=======

        int m = grid.length, n = grid[0].length;
        int[][] dp = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = grid[0][i] + grid[0][j];
            }
        }
        for (int i = 1; i < m; i++) {
            int[][] next = new int[n][n];
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < n; k++) {
                    next[j][k] = -1;
                }
            }
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < n; k++) {
                    if (dp[j][k] == -1) continue;
                    int val = dp[j][k];
                    if (j > 0) {
                        next[j - 1][k] = Math.max(next[j - 1][k], val + (k == j - 1 ? 0 : grid[i][j - 1]));
                    }
                    next[j][k] = Math.max(next[j][k], val + (k == j ? 0 : grid[i][j]));
                    if (j < n - 1) {
                        next[j + 1][k] = Math.max(next[j + 1][k], val + (k == j + 1 ? 0 : grid[i][j + 1]));
                    }
                    if (k > 0) {
                        next[j][k - 1] = Math.max(next[j][k - 1], val + (j == k - 1 ? 0 : grid[i][k - 1]));
                    }
                    next[j][k] = Math.max(next[j][k], val + (j == k ? 0 : grid[i][k]));
                    if (k < n - 1) {
                        next[j][k + 1] = Math.max(next[j][k + 1], val + (j == k + 1 ? 0 : grid[i][k + 1]));
                    }
                }
            }
            dp = next;
        }
        int res = 0;

=======

        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[n][n];
        for (int i = m - 1; i >= 0; i--) {
            int[][] dp2 = new int[n][n];
            for (int p1 = 0; p1 < n; p1++) {
                for (int p2 = 0; p2 < n; p2++) {
                    int max = 0;
                    for (int d1 = -1; d1 <= 1; d1++) {
                        for (int d2 = -1; d2 <= 1; d2++) {
                            int n1 = p1 + d1, n2 = p2 + d2;
                            if (n1 >= 0 && n1 < n && n2 >= 0 && n2 < n) {
                                max = Math.max(max, dp[n1][n2]);
                            }
                        }
                    }
                    dp2[p1][p2] = max + grid[i][p1] + (p1 == p2 ? 0 : grid[i][p2]);
                }
            }
            dp = dp2;
        }
        return dp[0][n - 1];

=======

        int m = grid.length;
        int n = grid[0].length;
        int[][][] dp = new int[m][n][n];
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                for(int k = 0; k < n; k++){
                    dp[i][j][k] = -1;
                }
            }
        }
        dp[0][0][n - 1] = grid[0][0] + grid[0][n - 1];
        for(int i = 1; i < m; i++){
            for(int j = 0; j < n; j++){
                for(int k = 0; k < n; k++){
                    for(int j1 = j - 1; j1 <= j + 1; j1++){
                        for(int k1 = k - 1; k1 <= k + 1; k1++){
                            if(j1 >= 0 && j1 < n && k1 >= 0 && k1 < n){
                                dp[i][j][k] = Math.max(dp[i][j][k], dp[i - 1][j1][k1]);
                            }
                        }
                    }
                    if(dp[i][j][k] >= 0){
                        dp[i][j][k] += grid[i][j] + grid[i][k];
                        if(j == k){
                            dp[i][j][k] -= grid[i][j];
                        }
                    }
                }
            }
        }
        int res = 0;
        for(int j = 0; j < n; j++){
            for(int k = 0; k < n; k++){
                res = Math.max(res, dp[m - 1][j][k]);
            }
        }
        return res;

=======

        int n = grid.length;
        int m = grid[0].length;
        int[][][] dp = new int[n][m][m];
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                for(int k = 0; k < m; k++) {
                    dp[i][j][k] = -1;
                }
            }
        }
        dp[0][0][m - 1] = grid[0][0] + grid[0][m - 1];
        int res = 0;
        for(int i = 1; i < n; i++) {
            for(int j = 0; j < m; j++) {
                for(int k = 0; k < m; k++) {
                    if(dp[i - 1][j][k] == -1) continue;
                    for(int d1 = -1; d1 <= 1; d1++) {
                        for(int d2 = -1; d2 <= 1; d2++) {
                            int nj = j + d1;
                            int nk = k + d2;
                            if(nj < 0 || nj >= m || nk < 0 || nk >= m) continue;
                            dp[i][nj][nk] = Math.max(dp[i][nj][nk], dp[i - 1][j][k] + grid[i][nj] + (nj == nk ? 0 : grid[i][nk]));
                            if(i == n - 1) res = Math.max(res, dp[i][nj][nk]);
                        }
                    }
                }
            }
        }
        return res;

=======

        int m = grid.length, n = grid[0].length;
        int[][] dp = new int[n][n];
        for (int[] d : dp) Arrays.fill(d, Integer.MIN_VALUE);
        dp[0][n - 1] = grid[0][0] + grid[0][n - 1];
        for (int i = 1; i < m; i++) {
            int[][] temp = new int[n][n];
            for (int[] t : temp) Arrays.fill(t, Integer.MIN_VALUE);
            for (int j = 0; j < n; j++) {
                for (int k = j; k < n; k++) {
                    if (grid[i][j] == -1 || grid[i][k] == -1) continue;
                    int val = grid[i][j];
                    if (j != k) val += grid[i][k];
                    for (int p = j - 1; p <= j + 1; p++) {
                        for (int q = k - 1; q <= k + 1; q++) {
                            if (p >= 0 && p < n && q >= 0 && q < n) {
                                temp[j][k] = Math.max(temp[j][k], dp[p][q] + val);
                            }
                        }
                    }
                }
            }
            dp = temp;
        }
        int res = 0;
        for (int[] d : dp) res = Math.max(res, Arrays.stream(d).max().getAsInt());
        return res;

=======

        int m = grid.length;
        int n = grid[0].length;
        int[][][] dp = new int[m][n][n];
        for (int[][] d : dp) {
            for (int[] d2 : d) {
                Arrays.fill(d2, Integer.MIN_VALUE);
            }
        }
        dp[0][0][n - 1] = grid[0][0] + grid[0][n - 1];
        for (int i = 1; i < m; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < n; k++) {
                    for (int j2 = j - 1; j2 <= j + 1; j2++) {
                        for (int k2 = k - 1; k2 <= k + 1; k2++) {
                            if (j2 >= 0 && j2 < n && k2 >= 0 && k2 < n) {
                                dp[i][j][k] = Math.max(dp[i][j][k], dp[i - 1][j2][k2]);
                            }
                        }
                    }
                    if (dp[i][j][k] >= 0) {
                        dp[i][j][k] += grid[i][j];
                        if (j != k) {
                            dp[i][j][k] += grid[i][k];
                        }
                    }
                }
            }
        }
        int ans = 0;
        for (int j = 0; j < n; j++) {
            for (int k = 0; k < n; k++) {
                ans = Math.max(ans, dp[m - 1][j][k]);
            }
        }
        return ans;

=======

        int rows = grid.length;
        int cols = grid[0].length;
        int[][][] dp = new int[rows][cols][cols];
        for (int[][] d : dp) {
            for (int[] a : d) {
                Arrays.fill(a, -1);
            }
        }
        dp[0][0][cols - 1] = grid[0][0] + grid[0][cols - 1];
        for (int i = 1; i < rows; i++) {
            for (int j1 = 0; j1 < cols; j1++) {
                for (int j2 = 0; j2 < cols; j2++) {
                    int[] d = new int[]{-1, 0, 1};
                    for (int k1 : d) {
                        for (int k2 : d) {
                            int j3 = j1 + k1;
                            int j4 = j2 + k2;
                            if (j3 >= 0 && j3 < cols && j4 >= 0 && j4 < cols) {
                                dp[i][j1][j2] = Math.max(dp[i][j1][j2], dp[i - 1][j3][j4] + (j1 == j2 ? grid[i][j1] : grid[i][j1] + grid[i][j2]));
                            }
                        }
                    }
                }
            }
        }
        return dp[rows - 1][0][cols - 1];
