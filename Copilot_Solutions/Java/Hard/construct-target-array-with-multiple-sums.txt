Synthesizing 10/10 solutions

=======

        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);
        long sum = 0;
        for (int i : target) {
            sum += i;
            pq.offer(i);
        }
        while (true) {
            int max = pq.poll();
            sum -= max;
            if (max == 1 || sum == 1) {
                return true;
            }
            if (max < sum || sum == 0 || max % sum == 0) {
                return false;
            }
            max %= sum;
            sum += max;
            pq.offer(max);
        }

=======

        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);
        long sum = 0;
        for (int i : target) {
            sum += i;
            pq.offer(i);
        }
        while (true) {
            int curr = pq.poll();
            sum -= curr;
            if (curr == 1 || sum == 1) return true;
            if (curr < sum || sum == 0 || curr % sum == 0) return false;
            curr %= sum;
            sum += curr;
            pq.offer(curr);
        }

=======

        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);
        long sum = 0;
        for (int i : target) {
            sum += i;
            pq.offer(i);
        }
        while (pq.peek() != 1) {
            int x = pq.poll();
            sum -= x;
            if (x <= sum || sum < 1) {
                return false;
            }
            x %= sum;
            sum += x;
            pq.offer(x);
        }
        return true;

=======

        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);
        long sum = 0;
        for (int num : target) {
            sum += num;
            maxHeap.offer(num);
        }
        while (!maxHeap.isEmpty()) {
            int max = maxHeap.poll();
            sum -= max;
            if (max == 1 || sum == 1) {
                return true;
            }
            if (max < sum || sum == 0 || max % sum == 0) {
                return false;
            }
            max %= sum;
            sum += max;
            maxHeap.offer(max);
        }
        return true;

=======

        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);
        long sum = 0;
        for (int n : target) {
            pq.add(n);
            sum += n;
        }
        while (true) {
            int n = pq.poll();
            sum -= n;
            if (n == 1 || sum == 1) return true;
            if (n < sum || sum == 0 || n % sum == 0) return false;
            n %= sum;
            sum += n;
            pq.add(n);
        }

=======

        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);
        long total = 0;
        for (int num : target) {
            pq.offer(num);
            total += num;
        }
        while (true) {
            int num = pq.poll();
            total -= num;
            if (num == 1 || total == 1) {
                return true;
            }
            if (num < total || total == 0 || num % total == 0) {
                return false;
            }
            num %= total;
            total += num;
            pq.offer(num);
        }

=======

        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
        long sum = 0;
        for (int i = 0; i < target.length; i++) {
            pq.add(target[i]);
            sum += target[i];
        }
        while (true) {
            int max = pq.poll();
            sum -= max;
            if (max == 1 || sum == 1) {
                return true;
            }
            if (max < sum || sum == 0 || max % sum == 0) {
                return false;
            }
            max %= sum;
            sum += max;
            pq.add(max);
        }

=======

        int n = target.length;
        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
        long sum = 0;
        for (int i = 0; i < n; i++) {
            sum += target[i];
            pq.add(target[i]);
        }
        while (true) {
            int cur = pq.poll();
            sum -= cur;
            if (cur == 1 || sum == 1) {
                return true;
            }
            if (cur < sum || sum == 0 || cur % sum == 0) {
                return false;
            }
            cur %= sum;
            sum += cur;
            pq.add(cur);
        }

=======

        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
        long sum = 0;
        for (int i : target) {
            pq.offer(i);
            sum += i;
        }
        while (true) {
            int max = pq.poll();
            sum -= max;
            if (max == 1 || sum == 1) return true;
            if (max < sum || sum == 0 || max % sum == 0) return false;
            max %= sum;
            sum += max;
            pq.offer(max);
        }

=======

        int n = target.length;
        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(n, (a, b) -> b - a);
        long sum = 0;
        for (int i = 0; i < n; i++) {
            sum += target[i];
            pq.add(target[i]);
        }
        while (true) {
            int x = pq.poll();
            sum -= x;
            if (x == 1 || sum == 1) {
                return true;
            }
            if (x < sum || sum == 0 || x % sum == 0) {
                return false;
            }
            x %= sum;
            sum += x;
            pq.add(x);
        }
