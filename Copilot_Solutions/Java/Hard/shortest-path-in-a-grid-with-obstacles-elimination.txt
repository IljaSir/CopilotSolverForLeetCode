Synthesizing 10/10 solutions

=======

        int m = grid.length;
        int n = grid[0].length;
        int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        Queue<int[]> q = new LinkedList<>();
        q.add(new int[]{0, 0, 0});
        boolean[][] visited = new boolean[m][n];
        visited[0][0] = true;
        int step = 0;
        while (!q.isEmpty()) {
            int size = q.size();
            for (int i = 0; i < size; i++) {
                int[] cur = q.poll();
                int x = cur[0];
                int y = cur[1];
                int obs = cur[2];
                if (x == m - 1 && y == n - 1) {
                    return step;
                }
                for (int[] dir : dirs) {
                    int nx = x + dir[0];
                    int ny = y + dir[1];
                    if (nx < 0 || nx >= m || ny < 0 || ny >= n) {
                        continue;
                    }
                    int nobs = obs + grid[nx][ny];
                    if (nobs > k || visited[nx][ny]) {
                        continue;
                    }
                    q.add(new int[]{nx, ny, nobs});
                    visited[nx][ny] = true;
                }
            }
            step++;
        }
        return -1;

=======

        int m = grid.length, n = grid[0].length;
        if (m == 1 && n == 1) return 0;
        if (k >= m + n - 3) return m + n - 2;
        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        Queue<int[]> q = new LinkedList<>();
        q.offer(new int[]{0, 0, k});
        boolean[][][] visited = new boolean[m][n][k + 1];
        visited[0][0][k] = true;
        int step = 0;
        while (!q.isEmpty()) {
            int size = q.size();
            for (int i = 0; i < size; i++) {
                int[] cur = q.poll();
                int x = cur[0], y = cur[1], remain = cur[2];
                for (int[] dir : dirs) {
                    int nx = x + dir[0], ny = y + dir[1];
                    if (nx < 0 || nx >= m || ny < 0 || ny >= n) continue;
                    if (nx == m - 1 && ny == n - 1) return step + 1;
                    if (grid[nx][ny] == 0 && !visited[nx][ny][remain]) {
                        q.offer(new int[]{nx, ny, remain});
                        visited[nx][ny][remain] = true;
                    } else if (grid[nx][ny] == 1 && remain > 0 && !visited[nx][ny][remain - 1]) {
                        q.offer(new int[]{nx, ny, remain - 1});
                        visited[nx][ny][remain - 1] = true;
                    }
                }
            }
            step++;
        }
        return -1;

=======

        int m = grid.length;
        int n = grid[0].length;
        if (m == 1 && n == 1) {
            return 0;
        }
        boolean[][][] visited = new boolean[m][n][k+1];
        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{0, 0, k});
        visited[0][0][k] = true;
        int steps = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int[] cur = queue.poll();
                int x = cur[0];
                int y = cur[1];
                int obs = cur[2];
                for (int[] dir : dirs) {
                    int nx = x + dir[0];
                    int ny = y + dir[1];
                    if (nx < 0 || nx >= m || ny < 0 || ny >= n) {
                        continue;
                    }
                    if (nx == m - 1 && ny == n - 1) {
                        return steps + 1;
                    }
                    if (grid[nx][ny] == 1) {
                        if (obs > 0 && !visited[nx][ny][obs-1]) {
                            queue.offer(new int[]{nx, ny, obs-1});
                            visited[nx][ny][obs-1] = true;
                        }
                    } else {
                        if (!visited[nx][ny][obs]) {
                            queue.offer(new int[]{nx, ny, obs});
                            visited[nx][ny][obs] = true;
                        }
                    }
                }
            }
            steps++;
        }
        return -1;

=======

        int m = grid.length;
        int n = grid[0].length;
        int[][][] dp = new int[m][n][k+1];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                Arrays.fill(dp[i][j], Integer.MAX_VALUE);
            }
        }
        dp[0][0][0] = 0;
        Queue<int[]> q = new LinkedList<>();
        q.add(new int[]{0, 0, 0});
        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        while (!q.isEmpty()) {
            int[] cur = q.poll();
            int x = cur[0];
            int y = cur[1];
            int z = cur[2];
            for (int[] dir : dirs) {
                int nx = x + dir[0];
                int ny = y + dir[1];
                if (nx < 0 || nx >= m || ny < 0 || ny >= n) continue;
                int nz = z + grid[nx][ny];
                if (nz > k || dp[nx][ny][nz] <= dp[x][y][z] + 1) continue;
                dp[nx][ny][nz] = dp[x][y][z] + 1;
                q.add(new int[]{nx, ny, nz});
            }
        }
        int res = Integer.MAX_VALUE;
        for (int i = 0; i <= k; i++) {
            res = Math.min(res, dp[m-1][n-1][i]);
        }
        return res == Integer.MAX_VALUE ? -1 : res;

=======

        int m = grid.length;
        int n = grid[0].length;
        int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        boolean[][] visited = new boolean[m][n];
        Queue<int[]> queue = new LinkedList<>();
        queue.add(new int[]{0, 0, 0});
        visited[0][0] = true;
        int steps = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int[] cur = queue.poll();
                int r = cur[0];
                int c = cur[1];
                int obs = cur[2];
                if (r == m - 1 && c == n - 1) {
                    return steps;
                }
                for (int[] dir : dirs) {
                    int nr = r + dir[0];
                    int nc = c + dir[1];
                    if (nr < 0 || nr >= m || nc < 0 || nc >= n) {
                        continue;
                    }
                    int nobs = obs + grid[nr][nc];
                    if (nobs > k || visited[nr][nc]) {
                        continue;
                    }
                    queue.add(new int[]{nr, nc, nobs});
                    visited[nr][nc] = true;
                }
            }
            steps++;
        }
        return -1;

=======

        int m = grid.length, n = grid[0].length;
        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        Queue<int[]> queue = new LinkedList<>();
        boolean[][][] visited = new boolean[m][n][k + 1];
        queue.offer(new int[]{0, 0, 0});
        visited[0][0][0] = true;
        int step = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int[] cur = queue.poll();
                int x = cur[0], y = cur[1], obstacles = cur[2];
                if (x == m - 1 && y == n - 1) {
                    return step;
                }
                for (int[] dir : dirs) {
                    int nx = x + dir[0];
                    int ny = y + dir[1];
                    if (nx < 0 || nx >= m || ny < 0 || ny >= n) {
                        continue;
                    }
                    int nObstacles = obstacles + grid[nx][ny];
                    if (nObstacles > k || visited[nx][ny][nObstacles]) {
                        continue;
                    }
                    queue.offer(new int[]{nx, ny, nObstacles});
                    visited[nx][ny][nObstacles] = true;
                }
            }
            step++;
        }
        return -1;

=======

        int m = grid.length;
        int n = grid[0].length;
        if (m == 1 && n == 1) {
            return 0;
        }
        int[][][] visited = new int[m][n][k + 1];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                Arrays.fill(visited[i][j], Integer.MAX_VALUE);
            }
        }
        visited[0][0][0] = 0;
        int[][] directions = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[] {0, 0, 0});
        int steps = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            steps++;
            for (int i = 0; i < size; i++) {
                int[] cur = queue.poll();
                for (int[] dir : directions) {
                    int nextX = cur[0] + dir[0];
                    int nextY = cur[1] + dir[1];
                    if (nextX < 0 || nextX >= m || nextY < 0 || nextY >= n) {
                        continue;
                    }
                    int nextK = cur[2] + grid[nextX][nextY];
                    if (nextK > k || steps >= visited[nextX][nextY][nextK]) {
                        continue;
                    }
                    if (nextX == m - 1 && nextY == n - 1) {
                        return steps;
                    }
                    visited[nextX][nextY][nextK] = steps;
                    queue.offer(new int[] {nextX, nextY, nextK});
                }
            }
        }
        return -1;

=======

        int m = grid.length;
        int n = grid[0].length;
        int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        boolean[][][] visited = new boolean[m][n][k + 1];
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{0, 0, 0});
        int step = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int[] cur = queue.poll();
                int r = cur[0];
                int c = cur[1];
                int obs = cur[2];
                if (r == m - 1 && c == n - 1) {
                    return step;
                }
                for (int j = 0; j < 4; j++) {
                    int nr = r + dir[j][0];
                    int nc = c + dir[j][1];
                    if (nr >= 0 && nr < m && nc >= 0 && nc < n) {
                        int nobs = obs + grid[nr][nc];
                        if (nobs <= k && !visited[nr][nc][nobs]) {
                            queue.offer(new int[]{nr, nc, nobs});
                            visited[nr][nc][nobs] = true;
                        }
                    }
                }
            }
            step++;
        }
        return -1;

=======

        int m = grid.length;
        int n = grid[0].length;
        int[][] dirs = new int[][]{{0,1}, {0,-1}, {1,0}, {-1,0}};
        boolean[][][] visited = new boolean[m][n][k+1];
        Queue<int[]> queue = new LinkedList<>();
        queue.add(new int[]{0,0,0});
        visited[0][0][0] = true;
        int steps = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int[] cur = queue.poll();
                if (cur[0] == m - 1 && cur[1] == n - 1) {
                    return steps;
                }
                for (int[] dir : dirs) {
                    int nextX = cur[0] + dir[0];
                    int nextY = cur[1] + dir[1];
                    int nextK = cur[2];
                    if (nextX < 0 || nextX >= m || nextY < 0 || nextY >= n) {
                        continue;
                    }
                    if (grid[nextX][nextY] == 1) {
                        nextK++;
                    }
                    if (nextK > k || visited[nextX][nextY][nextK]) {
                        continue;
                    }
                    queue.add(new int[]{nextX, nextY, nextK});
                    visited[nextX][nextY][nextK] = true;
                }
            }
            steps++;
        }
        return -1;

=======

        int m = grid.length, n = grid[0].length;
        int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};
        int[][][] memo = new int[m][n][k+1];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                for (int l = 0; l <= k; l++) {
                    memo[i][j][l] = Integer.MAX_VALUE;
                }
            }
        }
        Queue<int[]> q = new LinkedList<>();
        q.offer(new int[]{0,0,0});
        memo[0][0][0] = 0;
        while (!q.isEmpty()) {
            int[] cur = q.poll();
            int x = cur[0], y = cur[1], l = cur[2];
            if (x == m - 1 && y == n - 1) return memo[x][y][l];
            for (int[] d : dir) {
                int i = x + d[0], j = y + d[1];
                if (i < 0 || i >= m || j < 0 || j >= n) continue;
                int nextL = l + grid[i][j];
                if (nextL > k || memo[i][j][nextL] <= memo[x][y][l] + 1) continue;
                memo[i][j][nextL] = memo[x][y][l] + 1;
                q.offer(new int[]{i,j,nextL});
            }
        }
        return -1;
