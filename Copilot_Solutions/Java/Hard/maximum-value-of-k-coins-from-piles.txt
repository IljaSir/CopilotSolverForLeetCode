Synthesizing 9/10 solutions

=======

        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < piles.size(); i++) {
            List<Integer> pile = piles.get(i);
            for (int j = 0; j < pile.size(); j++) {
                list.add(pile.get(j));
            }
        }
        Collections.sort(list);
        int n = list.size();
        int i = 0;
        int j = n - 1;
        int ans = 0;
        while (k > 0) {
            ans += list.get(j);
            k--;
            j--;
            if (k > 0) {
                i++;
                k--;
            }
        }
        return ans;

=======

        int n = piles.size();
        int m = piles.get(0).size();
        int[][] dp = new int[n][k + 1];
        for (int i = 0; i < n; i++) {
            int[] p = new int[m];
            for (int j = 0; j < m; j++) {
                p[j] = piles.get(i).get(j);
            }
            Arrays.sort(p);
            for (int j = 1; j <= k; j++) {
                if (i == 0) {
                    dp[i][j] = dp[i][j - 1] + p[m - j * 2];
                } else {
                    dp[i][j] = Math.max(dp[i][j - 1] + p[m - j * 2], dp[i - 1][j]);
                }
            }
        }
        return dp[n - 1][k];

=======

        int n = piles.size();
        int m = piles.get(0).size();
        int[][] dp = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                dp[i][j] = piles.get(i).get(j);
            }
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 1; j < m; j++) {
                dp[i][j] += dp[i][j - 1];
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                int left = 0;
                int right = 0;
                if (j - 1 >= 0) {
                    left = dp[i][j - 1];
                }
                if (j + 1 < m) {
                    right = dp[i][m - 1] - dp[i][j + 1];
                }
                int sum = left + right;
                if (j % 2 == 0) {
                    ans += sum;
                }
            }
        }
        return ans;
    }
}

=======

        int n = piles.size();
        int m = piles.get(0).size();
        int[][] dp = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (j == 0) {
                    dp[i][j] = piles.get(i).get(j);
                } else {
                    dp[i][j] = dp[i][j - 1] + piles.get(i).get(j);
                }
            }
        }
        int[][] f = new int[n][k + 1];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= k; j++) {
                if (j == 0) {
                    f[i][j] = 0;
                } else {
                    f[i][j] = Integer.MIN_VALUE;
                    for (int l = 0; l <= j; l++) {
                        if (i == 0) {
                            if (l % 2 == 1) {
                                f[i][j] = Math.max(f[i][j], dp[i][m - 1] - dp[i][l - 1]);
                            }
                        } else {
                            if (l % 2 == 1) {
                                f[i][j] = Math.max(f[i][j], f[i - 1][j - l] + dp[i][m - 1] - dp[i][l - 1]);
                            }
                        }
                    }
                }
            }
        }
        return f[n - 1][k];

=======

        int n = piles.size();
        int m = piles.get(0).size();
        int[][] dp = new int[n][m];
        for (int i = 0; i < n; i++) {
            List<Integer> p = piles.get(i);
            int sum = 0;
            for (int j = m - 1; j >= 0; j--) {
                sum += p.get(j);
                dp[i][j] = sum;
            }
        }
        int[][] f = new int[n][k + 1];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= k; j++) {
                f[i][j] = -1;
            }
        }
        return dfs(dp, f, 0, k);
    }
    int dfs(int[][] dp, int[][] f, int i, int k) {
        if (k == 0) return 0;
        if (i >= dp.length) return 0;
        if (f[i][k] != -1) return f[i][k];
        int res = 0;
        for (int j = 0; j <= k; j++) {
            res = Math.max(res, dfs(dp, f, i + 1, k - j) + dp[i][j]);
        }
        return f[i][k] = res;

=======

        int n = piles.size();
        int m = piles.get(0).size();
        int[][] dp = new int[n + 1][k + 1];
        int ans = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= k; j++) {
                int take = 0;
                if (j - m >= 0) {
                    take = dp[i - 1][j - m];
                }
                if (j >= 1) {
                    take += piles.get(i - 1).get(m - j);
                }
                dp[i][j] = Math.max(dp[i - 1][j], take);
                if (j == k) {
                    ans = Math.max(ans, dp[i][j]);
                }
            }
        }
        return ans;

=======

        int n = piles.size();
        int m = piles.get(0).size();
        int[] coins = new int[n * m];
        int index = 0;
        for (List<Integer> pile : piles) {
            for (int coin : pile) {
                coins[index++] = coin;
            }
        }
        Arrays.sort(coins);
        int total = 0;
        for (int i = coins.length - 2; i >= coins.length - k; i -= 2) {
            total += coins[i];
        }
        return total;

=======

        int[] coins = new int[piles.size() * 3];
        int i = 0;
        for (List<Integer> pile : piles) {
            for (int c : pile) {
                coins[i++] = c;
            }
        }
        Arrays.sort(coins);
        int ans = 0;
        for (i = coins.length - 2; k > 0; i -= 2, k--) {
            ans += coins[i];
        }
        return ans;

=======

        int n = piles.size();
        int m = piles.get(0).size();
        int[][] dp = new int[n][k+1];
        for(int i = 0; i < n; i++){
            for(int j = 0; j <= k; j++){
                dp[i][j] = -1;
            }
        }
        return maxValueOfCoins(piles, 0, 0, k, dp);
    }
    private int maxValueOfCoins(List<List<Integer>> piles, int i, int j, int k, int[][] dp){
        if(k == 0){
            return 0;
        }
        if(i >= piles.size()){
            return 0;
        }
        if(dp[i][k] != -1){
            return dp[i][k];
        }
        List<Integer> pile = piles.get(i);
        int ans = 0;
        int n = pile.size();
        if(j < n){
            ans = Math.max(ans, pile.get(j) + maxValueOfCoins(piles, i, j+1, k-1, dp));
        }
        if(j < n - 1){
            ans = Math.max(ans, pile.get(n - 1 - j) + maxValueOfCoins(piles, i+1, j, k-1, dp));
        }
        dp[i][k] = ans;
        return ans;
