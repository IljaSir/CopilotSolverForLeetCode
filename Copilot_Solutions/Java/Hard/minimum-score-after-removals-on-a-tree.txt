Synthesizing 9/10 solutions

=======

        int n = nums.length;
        int[][] g = new int[n][n];
        for (int[] e : edges) {
            g[e[0]][e[1]] = g[e[1]][e[0]] = 1;
        }
        int[] xor = new int[n];
        for (int i = 0; i < n; i++) {
            xor[i] = nums[i];
        }
        int[] min = new int[n];
        Arrays.fill(min, Integer.MAX_VALUE);
        int[] max = new int[n];
        dfs(0, -1, g, xor, min, max);
        int res = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (g[i][j] == 1) {
                    res = Math.min(res, Math.min(min[i] ^ max[j], min[j] ^ max[i]));
                }
            }
        }
        return res;
    }
    
    void dfs(int u, int p, int[][] g, int[] xor, int[] min, int[] max) {
        for (int v = 0; v < g.length; v++) {
            if (v != p && g[u][v] == 1) {
                dfs(v, u, g, xor, min, max);
                xor[u] ^= xor[v];
            }
        }
        min[u] = Math.min(min[u], xor[u]);
        max[u] = Math.max(max[u], xor[u]);

=======

        int n = nums.length;
        int[] parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
        for (int[] edge : edges) {
            int u = edge[0], v = edge[1];
            int pu = find(parent, u), pv = find(parent, v);
            if (pu != pv) {
                parent[pu] = pv;
            }
        }
        int[] xor = new int[n];
        for (int i = 0; i < n; i++) {
            xor[find(parent, i)] ^= nums[i];
        }
        int[] min = new int[n];
        int[] max = new int[n];
        Arrays.fill(min, Integer.MAX_VALUE);
        Arrays.fill(max, Integer.MIN_VALUE);
        for (int i = 0; i < n; i++) {
            if (xor[i] > 0) {
                min[i] = Math.min(min[i], xor[i]);
                max[i] = Math.max(max[i], xor[i]);
            }
        }
        int res = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            if (xor[i] > 0) {
                for (int j = i + 1; j < n; j++) {
                    if (xor[j] > 0) {
                        res = Math.min(res, Math.abs(max[i] - min[j]));
                        res = Math.min(res, Math.abs(max[j] - min[i]));
                    }
                }
            }
        }
        return res;
    }
    
    private int find(int[] parent, int u) {
        if (u != parent[u]) {
            parent[u] = find(parent, parent[u]);
        }
        return parent[u];

=======

        int n = nums.length;
        int[] parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
        for (int[] edge : edges) {
            int u = edge[0], v = edge[1];
            int pu = find(parent, u), pv = find(parent, v);
            if (pu != pv) {
                parent[pu] = pv;
            }
        }
        int root = find(parent, 0);
        int[] xor = new int[n];
        for (int i = 0; i < n; i++) {
            xor[find(parent, i)] ^= nums[i];
        }
        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            if (xor[i] > 0 && find(parent, i) == root) {
                min = Math.min(min, xor[i]);
                max = Math.max(max, xor[i]);
            }
        }
        return max - min;
    }
    private int find(int[] parent, int u) {
        if (parent[u] != u) {
            parent[u] = find(parent, parent[u]);
        }
        return parent[u];

=======

        int n = nums.length;
        int[] p = new int[n];
        for (int i = 0; i < n; i++) {
            p[i] = i;
        }
        for (int[] e : edges) {
            int a = e[0];
            int b = e[1];
            int pa = find(p, a);
            int pb = find(p, b);
            if (pa != pb) {
                p[pa] = pb;
            }
        }
        int[] cnt = new int[n];
        int[] xor = new int[n];
        for (int i = 0; i < n; i++) {
            int pi = find(p, i);
            cnt[pi]++;
            xor[pi] ^= nums[i];
        }
        int min = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            if (cnt[i] > 1) {
                min = Math.min(min, xor[i]);
            }
        }
        return min;
    }
    
    int find(int[] p, int i) {
        if (p[i] != i) {
            p[i] = find(p, p[i]);
        }
        return p[i];

=======

        int n = nums.length;
        int[] parents = new int[n];
        for (int i = 0; i < n; i++) {
            parents[i] = i;
        }
        for (int[] edge : edges) {
            int pa = find(parents, edge[0]);
            int pb = find(parents, edge[1]);
            if (pa != pb) {
                parents[pa] = pb;
            }
        }
        int[] xor = new int[n];
        for (int i = 0; i < n; i++) {
            xor[find(parents, i)] ^= nums[i];
        }
        int[] min = new int[n];
        int[] max = new int[n];
        Arrays.fill(min, Integer.MAX_VALUE);
        Arrays.fill(max, Integer.MIN_VALUE);
        for (int i = 0; i < n; i++) {
            if (xor[i] == 0) {
                continue;
            }
            int p = find(parents, i);
            min[p] = Math.min(min[p], xor[i]);
            max[p] = Math.max(max[p], xor[i]);
        }
        int best = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            if (min[i] == Integer.MAX_VALUE) {
                continue;
            }
            for (int j = 0; j < n; j++) {
                if (min[j] == Integer.MAX_VALUE || i == j) {
                    continue;
                }
                best = Math.min(best, max[i] + max[j] - min[i] - min[j]);
            }
        }
        return best;
    }
    
    private int find(int[] parents, int i) {
        if (parents[i] != i) {
            parents[i] = find(parents, parents[i]);
        }
        return parents[i];

=======

        int n = nums.length;
        int[] root = new int[n];
        for (int i = 0; i < n; i++) {
            root[i] = i;
        }
        for (int[] e : edges) {
            int x = e[0];
            int y = e[1];
            int rx = find(root, x);
            int ry = find(root, y);
            if (rx != ry) {
                root[rx] = ry;
            }
        }
        int[] cnt = new int[n];
        int[] xor = new int[n];
        for (int i = 0; i < n; i++) {
            int r = find(root, i);
            cnt[r]++;
            xor[r] ^= nums[i];
        }
        int res = Integer.MAX_VALUE;
        for (int[] e : edges) {
            int x = e[0];
            int y = e[1];
            int rx = find(root, x);
            int ry = find(root, y);
            if (rx == ry) {
                continue;
            }
            int c1 = cnt[rx];
            int c2 = cnt[ry];
            int x1 = xor[rx];
            int x2 = xor[ry];
            res = Math.min(res, (c1 * x2 ^ c2 * x1) - (c1 * c2 * (x1 ^ x2)));
        }
        return res;
    }
    int find(int[] root, int x) {
        if (root[x] != x) {
            root[x] = find(root, root[x]);
        }
        return root[x];

=======

        int n = nums.length;
        int[] roots = new int[n];
        for (int i = 0; i < n; i++) {
            roots[i] = i;
        }
        for (int[] edge : edges) {
            int root0 = findRoot(roots, edge[0]);
            int root1 = findRoot(roots, edge[1]);
            if (root0 != root1) {
                roots[root0] = root1;
            }
        }
        int[] xor = new int[n];
        for (int i = 0; i < n; i++) {
            xor[findRoot(roots, i)] ^= nums[i];
        }
        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            if (roots[i] == i) {
                min = Math.min(min, xor[i]);
                max = Math.max(max, xor[i]);
            }
        }
        return max - min;
    }
    
    private int findRoot(int[] roots, int i) {
        while (i != roots[i]) {
            roots[i] = roots[roots[i]];
            i = roots[i];
        }
        return i;

=======

        int n = nums.length;
        int[] p = new int[n];
        for (int i = 0; i < n; ++i) p[i] = i;
        for (int[] e : edges) {
            int u = e[0], v = e[1];
            int pu = find(p, u), pv = find(p, v);
            if (pu != pv) p[pu] = pv;
        }
        Map<Integer, List<Integer>> map = new HashMap<>();
        for (int i = 0; i < n; ++i) {
            int pi = find(p, i);
            map.putIfAbsent(pi, new ArrayList<>());
            map.get(pi).add(nums[i]);
        }
        int res = Integer.MAX_VALUE;
        for (List<Integer> list : map.values()) {
            int cur = 0;
            for (int x : list) cur ^= x;
            res = Math.min(res, cur);
        }
        return res;

=======

        int n = nums.length;
        int[] roots = new int[n];
        for (int i = 0; i < n; i++) {
            roots[i] = i;
        }
        for (int[] e : edges) {
            int root1 = find(roots, e[0]);
            int root2 = find(roots, e[1]);
            if (root1 != root2) {
                roots[root1] = root2;
            }
        }
        int[] xor = new int[n];
        for (int i = 0; i < n; i++) {
            xor[find(roots, i)] ^= nums[i];
        }
        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            if (roots[i] == i) {
                min = Math.min(min, xor[i]);
                max = Math.max(max, xor[i]);
            }
        }
        return max - min;
    }
    private int find(int[] roots, int i) {
        while (roots[i] != i) {
            roots[i] = roots[roots[i]];
            i = roots[i];
        }
        return i;
