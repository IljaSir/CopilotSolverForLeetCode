Synthesizing 10/10 solutions

=======

        int n = grid.length;
        int[][] dist = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dist[i][j] = Integer.MAX_VALUE;
            }
        }
        dist[0][0] = grid[0][0];
        Queue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        pq.offer(new int[] {0, 0, grid[0][0]});
        int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            int x = cur[0], y = cur[1], d = cur[2];
            if (x == n - 1 && y == n - 1) {
                return d;
            }
            for (int[] dir : dirs) {
                int nx = x + dir[0], ny = y + dir[1];
                if (nx >= 0 && nx < n && ny >= 0 && ny < n) {
                    int nd = Math.max(d, grid[nx][ny]);
                    if (nd < dist[nx][ny]) {
                        dist[nx][ny] = nd;
                        pq.offer(new int[] {nx, ny, nd});
                    }
                }
            }
        }
        return -1;

=======

        int n = grid.length;
        int[][] dist = new int[n][n];
        for (int i = 0; i < n; i++) {
            Arrays.fill(dist[i], Integer.MAX_VALUE);
        }
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        pq.offer(new int[]{grid[0][0], 0, 0});
        dist[0][0] = grid[0][0];
        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            int d = cur[0], x = cur[1], y = cur[2];
            if (x == n - 1 && y == n - 1) {
                return d;
            }

            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i], ny = y + dy[i];
                if (nx >= 0 && nx < n && ny >= 0 && ny < n) {
                    int max = Math.max(d, grid[nx][ny]);
                    if (max < dist[nx][ny]) {
                        dist[nx][ny] = max;
                        pq.offer(new int[]{dist[nx][ny], nx, ny});
                    }
                }
            }
        }
        return -1;

=======

        int n = grid.length;
        int[][] times = new int[n][n];
        for (int i = 0; i < n; i++) {
            Arrays.fill(times[i], Integer.MAX_VALUE);
        }
        times[0][0] = grid[0][0];
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        pq.add(new int[]{0, 0, grid[0][0]});
        int[][] dir = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            int r = cur[0], c = cur[1], t = cur[2];
            if (r == n - 1 && c == n - 1) {
                return t;
            }
            for (int[] d : dir) {
                int nr = r + d[0], nc = c + d[1];
                if (nr >= 0 && nr < n && nc >= 0 && nc < n) {
                    int nt = Math.max(t, grid[nr][nc]);
                    if (nt < times[nr][nc]) {
                        times[nr][nc] = nt;
                        pq.add(new int[]{nr, nc, nt});
                    }
                }
            }
        }
        return -1;

=======

        int n = grid.length;
        int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> grid[a[0]][a[1]] - grid[b[0]][b[1]]);
        pq.offer(new int[]{0, 0});
        boolean[][] visited = new boolean[n][n];
        int time = 0;
        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            time = Math.max(time, grid[cur[0]][cur[1]]);
            if (cur[0] == n - 1 && cur[1] == n - 1) {
                return time;
            }
            for (int[] dir : dirs) {
                int row = cur[0] + dir[0];
                int col = cur[1] + dir[1];
                if (row < 0 || row >= n || col < 0 || col >= n || visited[row][col]) {
                    continue;
                }
                visited[row][col] = true;
                pq.offer(new int[]{row, col});
            }
        }
        return -1;

=======

        int n = grid.length;
        int lo = 0, hi = n * n - 1;
        while (lo < hi) {
            int mid = (lo + hi) / 2;
            if (canReach(grid, mid)) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        return lo;
    }

    private boolean canReach(int[][] grid, int t) {
        int n = grid.length;
        boolean[][] visited = new boolean[n][n];
        visited[0][0] = true;
        Queue<int[]> queue = new LinkedList<>();
        queue.add(new int[] {0, 0});
        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        while (!queue.isEmpty()) {
            int[] cur = queue.poll();
            int x = cur[0], y = cur[1];
            if (x == n - 1 && y == n - 1) {
                return true;
            }
            for (int[] dir : dirs) {
                int nx = x + dir[0], ny = y + dir[1];
                if (nx >= 0 && nx < n && ny >= 0 && ny < n && !visited[nx][ny] && grid[nx][ny] <= t) {
                    visited[nx][ny] = true;
                    queue.add(new int[] {nx, ny});
                }
            }
        }
        return false;

=======

        int n = grid.length;
        int[][] directions = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int left = 0, right = n * n - 1;
        while (left < right) {
            int mid = (left + right) / 2;
            boolean[][] visited = new boolean[n][n];
            if (dfs(grid, visited, directions, 0, 0, mid)) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }

    private boolean dfs(int[][] grid, boolean[][] visited, int[][] directions, int x, int y, int t) {
        int n = grid.length;
        if (x == n - 1 && y == n - 1) {
            return true;
        }
        visited[x][y] = true;
        for (int[] direction : directions) {
            int nx = x + direction[0], ny = y + direction[1];
            if (nx >= 0 && nx < n && ny >= 0 && ny < n && !visited[nx][ny] && grid[nx][ny] <= t) {
                if (dfs(grid, visited, directions, nx, ny, t)) {
                    return true;
                }
            }
        }
        return false;

=======

        int n = grid.length;
        int[][] visited = new int[n][n];
        int[][] directions = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[2] - b[2]);
        pq.offer(new int[]{0, 0, grid[0][0]});
        visited[0][0] = 1;
        while(!pq.isEmpty()) {
            int[] curr = pq.poll();
            int i = curr[0];
            int j = curr[1];
            int currTime = curr[2];
            if(i == n - 1 && j == n - 1) {
                return currTime;
            }
            for(int[] dir : directions) {
                int nextI = i + dir[0];
                int nextJ = j + dir[1];
                if(nextI < 0 || nextI >= n || nextJ < 0 || nextJ >= n || visited[nextI][nextJ] == 1) {
                    continue;
                }
                visited[nextI][nextJ] = 1;
                pq.offer(new int[]{nextI, nextJ, Math.max(currTime, grid[nextI][nextJ])});
            }
        }
        return -1;

=======

        int n = grid.length;
        int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};
        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->a[0]-b[0]);
        pq.add(new int[]{grid[0][0],0,0});
        boolean[][] visited = new boolean[n][n];
        int res = 0;
        while(!pq.isEmpty()){
            int[] cur = pq.poll();
            res = Math.max(res,cur[0]);
            visited[cur[1]][cur[2]] = true;
            if(cur[1]==n-1 && cur[2]==n-1) return res;
            for(int[] d:dir){
                int x = cur[1]+d[0];
                int y = cur[2]+d[1];
                if(x>=0 && x<n && y>=0 && y<n && !visited[x][y]){
                    pq.add(new int[]{grid[x][y],x,y});
                }
            }
        }
        return -1;

=======

        int n = grid.length;
        int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int t = 0;
        int[][] visited = new int[n][n];
        while (true) {
            if (grid[0][0] <= t) {
                visited[0][0] = 1;
                Queue<int[]> q = new LinkedList();
                q.offer(new int[]{0, 0});
                while (!q.isEmpty()) {
                    int[] cur = q.poll();
                    if (cur[0] == n - 1 && cur[1] == n - 1) return t;
                    for (int[] dir : dirs) {
                        int nx = cur[0] + dir[0];
                        int ny = cur[1] + dir[1];
                        if (nx >= 0 && nx < n && ny >= 0 && ny < n && visited[nx][ny] == 0 && grid[nx][ny] <= t) {
                            visited[nx][ny] = 1;
                            q.offer(new int[]{nx, ny});
                        }
                    }
                }
            }
            t++;
        }

=======

        if (grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        int n = grid.length;
        int[][] d = new int[n][n];
        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        for (int i = 0; i < n; i++) {
            Arrays.fill(d[i], Integer.MAX_VALUE);
        }
        d[0][0] = grid[0][0];
        Queue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        pq.add(new int[]{0, 0, grid[0][0]});
        while (!pq.isEmpty()) {
            int[] top = pq.poll();
            int x = top[0], y = top[1], t = top[2];
            if (x == n - 1 && y == n - 1) {
                return d[x][y];
            }
            for (int[] dir : dirs) {
                int nx = x + dir[0], ny = y + dir[1];
                if (nx >= 0 && nx < n && ny >= 0 && ny < n && Math.max(t, grid[nx][ny]) < d[nx][ny]) {
                    d[nx][ny] = Math.max(t, grid[nx][ny]);
                    pq.add(new int[]{nx, ny, d[nx][ny]});
                }
            }
        }
        return -1;
