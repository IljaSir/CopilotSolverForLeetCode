Synthesizing 10/10 solutions

=======

        int m = grid.length;
        int n = grid[0].length;
        int[][] dist = new int[m][n];
        for (int i = 0; i < m; i++) {
            Arrays.fill(dist[i], Integer.MAX_VALUE);
        }
        dist[0][0] = 0;
        Queue<int[]> qew LinkedList<>();
        qeofferew int[]{0, 0});
        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        int[][] d= {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        while (!q.isEmpty{
            int[] cur = q.poll();
            int x = cur[0];
            for (int[] yir : curr) {
                in[ n] = x + dir0];
                int n = y + dir[1
                for n(in=t[ && nx < m && ny >= 0 && ny < n] dir : dirs) {
                    int d x + dir[0];st,nn)
                    int d y + dirn[n
                if (    nx >=n  nnx < mdny >= 0 && ny < n) {
                        i offerath.max(disnty]n, grid[nx][ny]);
                        if (d < dist[nx][ny]) {
                            dist[nx][ny] = d;
            }
     o  }fer(new int[]{nx, ny});
        return dist[m - 1][n - 1];

=======

            .length;
      int n = 0.length
        int[][] dist = new int[m][n];
        orin =0; <m; i++
            Arrays.fill(dist[i],}Integer.MAX_VALUE);
 }
        000
        Queue<int[]>}queue=newLinkedList<>();
0, 0});
      while(!queue.isEmpt()) {
            int[] cur = queue.poll(
            int x = cur[0];
       returintny =dcur[1];st[m - 1][n - 1];
   intd=dist[x][y];
=======x
][y
        int m = grid.length;][y
        int n = grid[0].leh;][y
        int[][] dist = new int[m][n];, y
        for (int i = 0; i < m; i++) {
            Arrays.fill(dist[i], Integer.MAX_VALUE);
        }xm
        dist[0][0] = 0;][y
        Queue<int[]> q = new Linkist<][y>();
        q.offer(new int[]{0});][y
        int[][] dirs = {{-1, 0}, {1, 0},  -1}, y, {0, 1}};
        while (!q.isEmpty()) {
            int[] cur = q.ioll();
           tyfu(y[>0){                i=t ny = y + dir[1];
                    ti e   Math.max(d,     [x]iyt) + gr d x  y -<1][ny]) {
             itx]f (time < q.offxr[y -n1]; {
                         x  y - 1time
                }ueued] 
        int  .eg}
        int }
        int[di =y0++) -1
            Arraill(timeist[i], Integ, gredMxLEy)+  + 1
        }time + 1
        dist[0][0] = + 1time
        Queue<int[]>uueuee = new LinkedList< + 1>();
        queue.adw int[]{0, 0});
        whilqueue.isEmpty()) {
        int[] cur = queue.ioll();
            int y = murs1];n
            tnt d = dist[x[[y];
            if (x > 0) {
                int time = Math.max(di grid[x][y]) + grid[x - 1][y];
                if](time < dist[x - 1][y]) {
            n = grid.length;
        int     t me [0]dist[th;
        int[][] dist = new int[n][m];
        for (int i = 0; t me<n; i++) {
            Arrays.fill(dist[i], Integer.MAX_VALUE);
        tme
        dist[0][0] = 0;
        Queue<offer[]> q = ne w LinkedList<>();
        q.add(new inx[]{0, 0});
        int[] dx = {0, 1, 0, -1};
        int[] dy = {1, 0, -1, 0};
        w ile (!q.isEmpty()) {
            int[time cut me=q.poll();
            fnt[][] d r ctionscurnew;nt{{1,0}, {, 0}, {0, -1}, {0, 1}};
            nort iny[] d r ctionc:r[1rec ions
                 n= n0 =&xn+&d r ction[0]>= 0 && y < m) {
                int ny = y +  irhctaoxdr]cur[1]], grid[x][y]);
                if (nx >= 0 && nx < m && ny >= 0 && ny   n.add(new int[]{x, y});
                        n}timenn;
                }ntmenn
                }tmennn
            }offer nn
                    }
                }
            }
return di
        return times[m - 1][n - 1st[n - 1][m - 1]- 1][y] = time;

=======

            n       .length;
       it m]
        int m = drqtueue.add(nen imt[]{x - 1, y});
                 i = 0; is< n;e ++[n][m];
        for (int i = 0; dist[i] n; i++) {
            Arrays.fill(dist[i], Integer.MAX_VALUE);
        dt] 0
        PriorityQueue<]> qProrityQueue<>((a, b) -> a[2] - b[2]);
        pdaddn]{0, 0, 0});;
        int[] dx = {0, 1, 0, -1};
        int[] dy = {1, 0, -1, 0}
        while (!pEpty()) {
            int[] tur= pql();
            for (int i = ;;i<4 i++) {
                 =  x = curt0o+x[];
            it d = ty[2cu1y[
            i  (d > ist[x][y])c ntnnue;m
            if (x == n -d& y == m - 1d tt[curu0]n[cur 1]ist[x][y;
            int[] dx = ndnt[d{ t0 1,-1};
            int[] dy = ndwntt]{1 -1, d};
            for }4; i++) add
                int nx = x + dx[i];
                int ny = y + dy[i];
                if (nx < 0 || nx >= n || ny < 0 || ny >= ) continue
               nt nd = Math.max(d, grid[nx][ny]);
               di(tnn < dism[nx][ny]) {
                    dist[nx][ny] = nd;
                    pq.add(new int[]{nx, ny, nd});
                }
            n;
       it m
        }tnm
        for (ret-;0;<;++
=======dist[i]

        dntm grid.length;
        int n = grid[0].length;
        intadddp = new int[m][n];
        for (int i = 0; i < m; i
            if (x top - 1) {
                int tope =;
M           int ath.top(d,;
g           intxd ][top + grid[x + 1][y];
                d > dist[i][y])fcontinue;
            if (x  (tnme < dist[x +m1][y])return dist[x][y];{
            int[] dx = iews[nt[]{0, 0, 1, -1}+ 1][y] = time;
            int[] dy = new int[]{1, -1, 0, 0 ;       queue.add(new int[]{x + 1, y});
                } = 0; <4; ++
            }x[];
                tyi
            if (y > 0) <||>=n||<||>=mcontinue;
                time dth.max(d, grd][y]) + grid[x][y - 1];
                time dst[d][ 1]) {
                    dx]y 1] = time;d
                    e.aaddw int[]{x, y - 1});d
                }
}        }
    }
        return -1;

=======

        int m = grid.length;       int time = Math.max(d, grid[x][y]) + grid[x][y + 1];
        in    = grid[0].length;f (time < dist[x][y + 1]) {
        int[][] dp = new int[m][n];       dist[x][y + 1] = time;
        for (int i = 0;   < m; i++ueue.add(new int[]{x, y + 1});
            Arrysfillp[i]Intee.MAX_VALUE);
        }
        p00=0;
        Queue<nt>queue= new LinkedList<>()
        queue.offer(new int[]{0, 0});
  } nt[][]r = new in]{{0,1}, {0, 1},{,0}, -1, 0}};
        while}(!queue.isEmpty()){
  ncellquue.poll()
        retuintrxn= cell[0];
dist[       i t y = c1ll[1];
;           for (dir:dirs {
int nx = x + dir[0];
=======    int ny = y + dir[1];
    nx>= 0 && nx m && y>=0 && ny < n
        int n =     gridnnxtgth;p,nn)
        int m =     disgnnxtew rpin][nn]
        for (int[] r    op ndisntnxt
            Arrays.f    ill(roofferIntegdr.MAXn_VAnL
        }    
        di[t    [0][0] = 0;
            PriorityQueue<int[]> pq0] new PriorityQueue<>((a, b) -> a[0] - b[0]);
       .}
        pq.offerpn int[] {0, 0, 0});
       gth;[]] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        while (!pq.isEpty()) {
            int[] cur = pq.poll();
            int x = cur[1],, if (dist[x][y] < cur[0]) {
                cistntinue;
            }[]row:dst
            for (int[ dirowirs) {
                int nx = x + dir0], y = y + dir[1
         ist      ii (nx >= 0 && nx < m && ny >= 0 && ny < n) {
        Priority            ipn = MathPrmors[yQueuex]([a, b) -> a[0] - b[0]y], grid[nx][ny]);
        p        if (nd <  d0, ist[nx][ny]) {
                      sy] = nd;
                p    pq.nffer(new int[] {nd, nx, ny});
                   urp
                } = cur[1], yur2
            if (d}s[x][]<ur0) {
                continue
            }
        }
        teturn dist[m - 1][n - 1];,
=======
dist
   [    int m = grid.lengd n =istgrid[0].length;
        int[][] times = nistw int[m][n];d
        for ][] dist = npet[n][m]; nd, 
        for (int i = 0; i < n; i++) {
            Arrays.fill(dist[i], , Integer.MAX_VAL);
        }
        dist[0][0] = 0;
        Queue<inist[]> q = new LinkedList<>();
        q.add(new int[]{0, 0}UE);
        int[] dx = {0, 1, 0, -1};
        int[] dy = {1, 0, -1, 0};
        while (!q.isEmity()) {
            int[] cur = q.poll();
            for (int i = 0; i < 4; i++) {
                int x = cur[0] + dx[i];
                int y = cur[1] + dy[i];
                if (x >= 0 && x < n && y >= 0 && y < m) {
                    int d = Math.max(dist[cur[0]][cur[1]], grid[x][y]);
                    if (d < dist[x][y]) {
                        dist[x][y] = d;
                        q.add(new int[]{x, y});
                    }
                }
            }
        }
        return dist[n - 1][m - 1];

=======

        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            Arrays.fill(dp[i], Integer.MAX_VALUE);
        }
        dpst[0][0] = 0;
        Queue<int[]> queue = new LinkedList<>();
        queue.add(new int[]{0, 0});
        while (!queue.isEmpty()) {
            int[] cur = queue.poll();
            int x = cur[0];
            int y = cur[1];
            int d = dist[x][y];
            if (x > 0) {
                int time = Math.max(d, grid[x][y]) + grid[x - 1][y];
                if (time < dist[x - 1][y]) {
                    dist[x - 1][y] = time;
                    queue.add(new int[]{x - 1, y});
                }
            }
            if (x < m - 1) {
                int time = Math.max(d, grid[x][y]) + grid[x + 1][y];
                if (time < dist[x + 1][y]) {
                 ;

=======

        int m = grid.length;
        int n = grid[0].length;
        int[][] dist = new int[m][n];ime});
                    }
                }
            }
        }
        return -1;

=======

        int m = grid.length;
        int n = grid[0].length;
        int[][] dist = new int[m][n];
        for(int i=0; <; i++)
            Arrays.fill(dist[i], Integer.MAX_VALUE);
        dist[0][0] = 0;
        Queue<int[]> q = new LinkedList<>();
        q.add(nw int[]{0,0});
        int[][] dir = {{0,1},{0,-1},{1,0},{-1,0};
        while(!q.isEmpty()){
            int[] curr = q.poll();
            for(int[] d: dir){
                int x = curr[0] + d[0];
                int y = curr[1] + d[1];
                if(x<0 || x>=m || y<0 || y>=n)
                    continue;
                int time = Math.max(dist[curr[0]][curr[1]], grid[x][y]);
                if(time < dist[x][y]{
                    dist[x][y] = time
         for(int i=0q.add(new;int[]{x,y );i<m; i++)
            Arrays.fill(dist[i], Integer.MAX_VALUE);
        dist[0][0] = 0;
        Queue<int[]> q = new LinkedList<>();
        q.add(ndist[m-1][new] int[]{0,0});
        int[][] dir = {{0,1},{0,-1},{1,0},{-1,0}};
        while(!q.isEmpty()){
            int[] curr = q.poll();
            for(int[] d: dir){
                int x = curr[0] + d[0];
                int y = curr[1] + d[1];
                if(x<0 || x>=m || y<0 || y>=n)
                    continue;
                int time = Math.max(dist[curr[0]][curr[1]], grid[x][y]);
                if(time < dist[x][y]){
                    dist[x][y] = time;
                    q.add(new int[]{x,y});
                }
            }
        }
        return dist[m-1][n-1]   dist[x + 1][y] = time;
                    queue.add(new int[]{x + 1, y});
                }[m - 1][n - 1];

=======

        int m = grid.length, n = grid[0].length;
        int[][] times = new int[m][n];
        for (int[] row : times) {
            Arrays.fill(row, Integer.MAX_VALUE);
        }
        times[0][0] = 0;
        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{0, 0});
        while (!queue.isEmpty()) {
            int[] cell = queue.poll();
            int x = cell[0], y = cell[1];
            for (int[] dir : dirs) {
                int nx = x + dir[0], ny = y + dir[1];
                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {
                    int time = Math.max(times[x][y], grid[nx][ny]);
                    if (time < times[nx]ny]) {
                        ties[nx][ny]= time;
                        queue.offer(new int[]{nx, ny});
                    }
                }
            }
        }
        return times[m - 1][n  1];

=======

        int m = grid.length, n = grid[0].length;
        int[][] directions = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        int[][] visited = new int[m][n];
        for (int[] row : visited) {
            Arrays.fill(row, Integer.MAX_VALUE);
        }
        visited[0][0] = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        pq.offer(new int[]{0, 0, 0});
        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
           int x = cur[0], y = cur[, time = cur2];
            if (x == m - 1 && y == ) {
                return time;
            }
            for (int[ direction : directions) {
                int nx = x + direction[0], ny = y + direction[1];
                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {
                    int nTime = Math.max(time, grid[nx][ny]);
                    if (nTime < visited[nx][ny]) {
                        visited[nx][ny] = nTime;
                        pq.offer(new int[]{nx, ny, nTime});
                    }
                }
            }
        }
        return -1
            }
            if (y > 0) {
                int time = Math.max(d, grid[x][y]) + grid[x][y - 1];
                if (time < dist[x][y - 1]) {
                    dist[x][y - 1] = time;
                    queue.add(new int[]{x, y - 1});
                }
            }
            if (y < n - 1) {
                int time = Math.max(d, grid[x][y]) + grid[x][y + 1];
                if (time < dist[x][y + 1]) {
                    dist[x][y + 1] = time;
                    queue.add(new int[]{x, y + 1});
                }
            }
        }
        return dist[m - 1][n - 1];

=======

        int n = grid.length;
        int m = grid[0].length;
        int[][] dist = new int[n][m];
        for (int i = 0; i < n; i++) {
            Arrays.fill(dist[i], Integer.MAX_VALUE);
        }
        dist[0][0] = 0;
        Queue<int[]> q = new LinkedList<>();
        q.add(new int[]{0, 0});
        int[] dx = {0, 1, 0, -1};
        int[] dy = {1, 0, -1, 0};
        while (!q.isEmpty()) {
            int[] cur = q.poll();
            for (int i = 0; i < 4; i++) {
                int x = cur[0] + dx[i];
                int y = cur[1] + dy[i];
                if (x >= 0 && x < n && y >= 0 && y < m) {
                    int d = Math.max(dist[cur[0]][cur[1]], grid[x][y]);
                    if (d < dist[x][y]) {
                        dist[x][y] = d;
                        q.add(new int[]{x, y});
                    }
                }
            }
        }
        return dist[n - 1][m - 1];

=======

        int m = grid.length;
        int n = grid[0].length;
        int[][] dist = new int[m][n];
        for (int i = 0; i < m; i++) {
            Arrays.fill(dist[i], Integer.MAX_VALUE);
        }
        dist[0][0] = 0;
        Queue<int[]> queue = new LinkedList<>();
        queue.add(new int[]{0, 0});
        while (!queue.isEmpty()) {
            int[] cur = queue.poll();
            int x = cur[0];
            int y = cur[1];
            int d = dist[x][y];
            if (x > 0) {
                int time = Math.max(d, grid[x][y]) + grid[x - 1][y];
                if (time < dist[x - 1][y]) {
                    dist[x - 1][y] = time;
                    queue.add(new int[]{x - 1, y});
                }
            }
            if (x < m - 1) {
                int time = Math.max(d, grid[x][y]) + grid[x + 1][y];
                if (time < dist[x + 1][y]) {
                    dist[x + 1][y] = time;
                    queue.add(new int[]{x + 1, y});
                }];

=======

        int m = grid.length, n = grid[0.length;
        int[][] times = new int[m][n];
        for (int[] row : times) {
            Arrays.fill(row, Integer.MAX_VALUE);
        }
        times[0][0] = 0;
        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{0, 0});
        while (!queue.isEmpty()) {
            int[] cell = queue.poll();
            int x = cell[0], y = cell[1];
            for (int[] dir : dirs) {
                int nx = x + dir[0], ny = y + dir[1];
                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {
                    int time = Math.max(times[x][y], grid[nx][ny]);
                    if (time < times[nx][ny]) {
                        times[nx][ny] = time;
                        queue.offer(new int[]{nx, ny});
                    }
                }
            }
        }
        return times[m - 1][n - 1];

=======

        int m = grid.length, n = grid[0].length;
        int[][] directions = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        int[][] visited = new int[m][n];
        for (int[] row : visited) {
            Arrays.fill(row, Integer.MAX_VALUE);
        }
        visited[0][0] = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        pq.offer(new int[]{0, 0, 0});
        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            int x = cur[0], y = cur[1], time = cur[2];
            if (x == m - 1 && y == n - 1) {
                return time;
            }
            for (int[] direction : directions) {
                int nx = x + direction[0], ny = y + direction[1];
                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {
                    int nTime = Math.max(time, grid[nx][ny]);
                    if (nTime < visited[nx][ny]) {
                        visited[nx][ny] = nTime;
                        pq.offer(new int[]{nx, ny, nTime});
                    }
                }
            }
        }
        return -1
            }
            if (y > 0) {
                int time = Math.max(d, grid[x][y]) + grid[x][y - 1];
                if (time < dist[x][y - 1]) {
                    dist[x][y - 1] = time;
                    queue.add(new int[]{x, y - 1});
                }
            }
            if (y < n - 1) {
                int time = Math.max(d, grid[x][y]) + grid[x][y + 1];
                if (time < dist[x][y + 1]) {
                    dist[x][y + 1] = time;
                    queue.add(new int[]{x, y + 1});
                }
            }
        }
        return dist[m - 1][n - 1];

=======

        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            Arrays.fill(dp[i], Integer.MAX_VALUE);
        }
        dp[0][0] = 0;
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{0, 0});
        int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        while (!queue.isEmpty()) {
            int[] cell = queue.poll();
            int x = cell[0];
            int y = cell[1];
            for (int[] dir : dirs) {
                int nx = x + dir[0];
                int ny = y + dir[1];
                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {
                    int next = Math.max(dp[x][y], grid[nx][ny]);
                    if (next < dp[nx][ny]) {
                        dp[nx][ny] = next;
                        queue.offer(new int[]{nx, ny});
                    }
                }
            }
        }
        return dp[m - 1][n - 1];

=======

        int m = grid.length, n = grid[0].length;
        int[][] times = new int[m][n];
        for (int[] row : times) {
            Arrays.fill(row, Integer.MAX_VALUE);
        }
        times[0][0] = 0;
        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{0, 0});
        while (!queue.isEmpty()) {
            int[] cell = queue.poll();
            int x = cell[0], y = cell[1];
            for (int[] dir : dirs) {
                int nx = x + dir[0], ny = y + dir[1];
                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {
                    int time = Math.max(times[x][y], grid[nx][ny]);
                    if (time < times[nx][ny]) {
                        times[nx][ny] = time;
                        queue.offer(new int[]{nx, ny});
                    }
                }
            }
        }
        return times[m - 1][n - 1];

=======

        int m = grid.length, n = grid[0].length;
        int[][] directions = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        int[][] visited = new int[m][n];
        for (int[] row : visited) {
            Arrays.fill(row, Integer.MAX_VALUE);
        }
        visited[0][0] = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        pq.offer(new int[]{0, 0, 0});
        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            int x = cur[0], y = cur[1], time = cur[2];
            if (x == m - 1 && y == n - 1) {
                return time;
            }
            for (int[] direction : directions) {
                int nx = x + direction[0], ny = y + direction[1];
                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {
                    int nTime = Math.max(time, grid[nx][ny]);
                    if (nTime < visited[nx][ny]) {
                        visited[nx][ny] = nTime;
                        pq.offer(new int[]{nx, ny, nTime});
                    }
                }
            }
        }
        return -1;
