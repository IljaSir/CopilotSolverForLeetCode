Synthesizing 10/10 solutions

=======

        int[][] result = new int[rows * cols][2];
        int index = 0;
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                result[index++] = new int[]{i, j};
            }
        }
        Arrays.sort(result, (a, b) -> {
            int d1 = Math.abs(a[0] - rCenter) + Math.abs(a[1] - cCenter);
            int d2 = Math.abs(b[0] - rCenter) + Math.abs(b[1] - cCenter);
            return d1 - d2;
        });
        return result;

=======

        int[][] result = new int[rows * cols][2];
        int index = 0;
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                result[index][0] = i;
                result[index][1] = j;
                index++;
            }
        }
        Arrays.sort(result, new Comparator<int[]>() {
            @Override
            public int compare(int[] a, int[] b) {
                return Math.abs(a[0] - rCenter) + Math.abs(a[1] - cCenter) - Math.abs(b[0] - rCenter) - Math.abs(b[1] - cCenter);
            }
        });
        return result;

=======

        int[][] res = new int[rows * cols][2];
        int index = 0;
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                res[index][0] = i;
                res[index][1] = j;
                index++;
            }
        }
        Arrays.sort(res, (a, b) -> Math.abs(a[0] - rCenter) + Math.abs(a[1] - cCenter) - Math.abs(b[0] - rCenter) - Math.abs(b[1] - cCenter));
        return res;

=======

        int[][] res = new int[rows * cols][2];
        int index = 0;
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                res[index][0] = i;
                res[index][1] = j;
                index++;
            }
        }
        Arrays.sort(res, (a, b) -> (Math.abs(a[0] - rCenter) + Math.abs(a[1] - cCenter)) - (Math.abs(b[0] - rCenter) + Math.abs(b[1] - cCenter)));
        return res;

=======

        int[][] res = new int[rows * cols][2];
        int idx = 0;
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                res[idx][0] = i;
                res[idx][1] = j;
                idx++;
            }
        }
        Arrays.sort(res, (a, b) -> {
            int distA = Math.abs(a[0] - rCenter) + Math.abs(a[1] - cCenter);
            int distB = Math.abs(b[0] - rCenter) + Math.abs(b[1] - cCenter);
            return distA - distB;
        });
        return res;

=======

        int[][] res = new int[rows * cols][2];
        int idx = 0;
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                res[idx][0] = i;
                res[idx][1] = j;
                idx++;
            }
        }
        Arrays.sort(res, (a, b) -> Math.abs(a[0] - rCenter) + Math.abs(a[1] - cCenter) - Math.abs(b[0] - rCenter) - Math.abs(b[1] - cCenter));
        return res;

=======

        int[][] result = new int[rows * cols][2];
        int count = 0;
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                result[count++] = new int[]{i, j};
            }
        }
        Arrays.sort(result, new Comparator<int[]>() {
            public int compare(int[] a, int[] b) {
                return Math.abs(a[0] - rCenter) + Math.abs(a[1] - cCenter) - Math.abs(b[0] - rCenter) - Math.abs(b[1] - cCenter);
            }
        });
        return result;

=======

        int[][] ans = new int[rows*cols][2];
        int idx = 0;
        for(int i=0; i<rows; i++) {
            for(int j=0; j<cols; j++) {
                ans[idx][0] = i;
                ans[idx][1] = j;
                idx++;
            }
        }
        Arrays.sort(ans, (a, b) -> {
            int d1 = Math.abs(a[0] - rCenter) + Math.abs(a[1] - cCenter);
            int d2 = Math.abs(b[0] - rCenter) + Math.abs(b[1] - cCenter);
            return d1 - d2;
        });
        return ans;

=======

        int[][] res = new int[rows * cols][2];
        int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        boolean[][] visited = new boolean[rows][cols];
        Queue<int[]> q = new LinkedList<>();
        q.offer(new int[]{rCenter, cCenter});
        visited[rCenter][cCenter] = true;
        int idx = 0;
        while (!q.isEmpty()) {
            int[] cur = q.poll();
            res[idx++] = cur;
            for (int[] dir : dirs) {
                int nr = cur[0] + dir[0];
                int nc = cur[1] + dir[1];
                if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && !visited[nr][nc]) {
                    visited[nr][nc] = true;
                    q.offer(new int[]{nr, nc});
                }
            }
        }
        return res;

=======

        int[][] cells = new int[rows * cols][2];
        int[][] visited = new int[rows][cols];
        int i = 0;
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[] {rCenter, cCenter});
        while (!queue.isEmpty()) {
            int[] cur = queue.poll();
            int r = cur[0];
            int c = cur[1];
            if (r < 0 || r >= rows || c < 0 || c >= cols || visited[r][c] == 1) {
                continue;
            }
            cells[i++] = cur;
            visited[r][c] = 1;
            queue.offer(new int[] {r - 1, c});
            queue.offer(new int[] {r + 1, c});
            queue.offer(new int[] {r, c - 1});
            queue.offer(new int[] {r, c + 1});
        }
        return cells;
