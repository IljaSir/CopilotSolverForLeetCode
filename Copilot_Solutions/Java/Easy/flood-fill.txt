Synthesizing 10/10 solutions

=======

        int oldColor = image[sr][sc];
        if (oldColor != color) {
            dfs(image, sr, sc, oldColor, color);
        }
        return image;
    }
    private void dfs(int[][] image, int r, int c, int oldColor, int color) {
        if (image[r][c] == oldColor) {
            image[r][c] = color;
            if (r >= 1) {
                dfs(image, r - 1, c, oldColor, color);
            }
            if (c >= 1) {
                dfs(image, r, c - 1, oldColor, color);
            }
            if (r + 1 < image.length) {
                dfs(image, r + 1, c, oldColor, color);
            }
            if (c + 1 < image[0].length) {
                dfs(image, r, c + 1, oldColor, color);
            }
        }

=======

        int oldColor = image[sr][sc];
        if (oldColor != color) {
            dfs(image, sr, sc, color, oldColor);
        }
        return image;
    }
    
    private void dfs(int[][] image, int sr, int sc, int color, int oldColor) {
        if (sr < 0 || sr >= image.length || sc < 0 || sc >= image[0].length || image[sr][sc] != oldColor) {
            return;
        }
        image[sr][sc] = color;
        dfs(image, sr - 1, sc, color, oldColor);
        dfs(image, sr + 1, sc, color, oldColor);
        dfs(image, sr, sc - 1, color, oldColor);
        dfs(image, sr, sc + 1, color, oldColor);

=======

        int oldColor = image[sr][sc];
        if (oldColor != color) {
            fill(image, sr, sc, color, oldColor);
        }
        return image;
    }
    
    public void fill(int[][] image, int sr, int sc, int color, int oldColor) {
        if (sr < 0 || sr >= image.length || sc < 0 || sc >= image[0].length) {
            return;
        }
        if (image[sr][sc] == oldColor) {
            image[sr][sc] = color;
            fill(image, sr - 1, sc, color, oldColor);
            fill(image, sr + 1, sc, color, oldColor);
            fill(image, sr, sc - 1, color, oldColor);
            fill(image, sr, sc + 1, color, oldColor);
        }

=======

        if (image[sr][sc] != color) {
            dfs(image, sr, sc, image[sr][sc], color);
        }
        return image;
    }
    
    private void dfs(int[][] image, int x, int y, int oldColor, int newColor) {
        if (x < 0 || x >= image.length || y < 0 || y >= image[0].length || image[x][y] != oldColor) {
            return;
        }
        image[x][y] = newColor;
        dfs(image, x + 1, y, oldColor, newColor);
        dfs(image, x - 1, y, oldColor, newColor);
        dfs(image, x, y + 1, oldColor, newColor);
        dfs(image, x, y - 1, oldColor, newColor);

=======

        if (image[sr][sc] == color) {
            return image;
        }
        int oldColor = image[sr][sc];
        dfs(image, sr, sc, color, oldColor);
        return image;
    }

    private void dfs(int[][] image, int sr, int sc, int color, int oldColor) {
        if (sr < 0 || sr >= image.length || sc < 0 || sc >= image[0].length || image[sr][sc] != oldColor) {
            return;
        }
        image[sr][sc] = color;
        dfs(image, sr + 1, sc, color, oldColor);
        dfs(image, sr - 1, sc, color, oldColor);
        dfs(image, sr, sc + 1, color, oldColor);
        dfs(image, sr, sc - 1, color, oldColor);

=======

        int oldColor = image[sr][sc];
        if (oldColor == color) {
            return image;
        }
        fill(image, sr, sc, color, oldColor);
        return image;
    }

    public void fill(int[][] image, int sr, int sc, int color, int oldColor) {
        if (sr < 0 || sr >= image.length || sc < 0 || sc >= image[0].length || image[sr][sc] != oldColor) {
            return;
        }
        image[sr][sc] = color;
        fill(image, sr + 1, sc, color, oldColor);
        fill(image, sr - 1, sc, color, oldColor);
        fill(image, sr, sc + 1, color, oldColor);
        fill(image, sr, sc - 1, color, oldColor);

=======

        if (image[sr][sc] == color) return image;
        int oldColor = image[sr][sc];
        dfs(image, sr, sc, oldColor, color);
        return image;

=======

        int oldColor = image[sr][sc];
        if (oldColor != color)
            dfs(image, sr, sc, oldColor, color);
        return image;

=======

        int m = image.length;
        int n = image[0].length;
        boolean[][] visited = new boolean[m][n];
        int[][] directions = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};
        int startColor = image[sr][sc];
        Queue<int[]> queue = new LinkedList<int[]>();
        queue.offer(new int[]{sr,sc});
        visited[sr][sc] = true;
        while(!queue.isEmpty()){
            int[] point = queue.poll();
            for(int[] direction : directions){
                int x = point[0]+direction[0];
                int y = point[1]+direction[1];
                if(x>=0 && x<m && y>=0 && y<n && !visited[x][y] && image[x][y]==startColor){
                    queue.offer(new int[]{x,y});
                    visited[x][y] = true;
                }
            }
            image[point[0]][point[1]] = color;
        }
        return image;

=======

        // base case
        if (image[sr][sc] == color) {
            return image;
        }
        int originColor = image[sr][sc];
        dfs(image, sr, sc, originColor, color);
        return image;
    }
    
    private void dfs(int[][] image, int sr, int sc, int originColor, int color) {
        if (sr < 0 || sr >= image.length || sc < 0 || sc >= image[0].length || image[sr][sc] != originColor) {
            return;
        }
        image[sr][sc] = color;
        dfs(image, sr + 1, sc, originColor, color);
        dfs(image, sr - 1, sc, originColor, color);
        dfs(image, sr, sc + 1, originColor, color);
        dfs(image, sr, sc - 1, originColor, color);
