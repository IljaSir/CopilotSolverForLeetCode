Synthesizing 10/10 solutions (Duplicates hidden)

=======

        int[] in = new int[n + 1];
        int[] out = new int[n + 1];
        for (int[] t : trust) {
            out[t[0]]++;
            in[t[1]]++;
        }
        for (int i = 1; i <= n; i++) {
            if (out[i] == 0 && in[i] == n - 1) {
                return i;
            }
        }
        return -1;

=======

        int[] trustCount = new int[n + 1];
        for (int[] t : trust) {
            trustCount[t[0]]--;
            trustCount[t[1]]++;
        }
        for (int i = 1; i <= n; i++) {
            if (trustCount[i] == n - 1) {
                return i;
            }
        }
        return -1;

=======

        int[] inDegree = new int[n + 1];
        int[] outDegree = new int[n + 1];
        for (int[] t : trust) {
            outDegree[t[0]]++;
            inDegree[t[1]]++;
        }
        for (int i = 1; i <= n; i++) {
            if (inDegree[i] == n - 1 && outDegree[i] == 0) {
                return i;
            }
        }
        return -1;

=======

        int[] trustCount = new int[n];
        for (int[] t : trust) {
            trustCount[t[0] - 1]--;
            trustCount[t[1] - 1]++;
        }
        for (int i = 0; i < n; i++) {
            if (trustCount[i] == n - 1) {
                return i + 1;
            }
        }
        return -1;

=======

        int[] trusts = new int[n + 1];
        for (int[] t : trust) {
            trusts[t[0]]--;
            trusts[t[1]]++;
        }
        for (int i = 1; i <= n; i++) {
            if (trusts[i] == n - 1) {
                return i;
            }
        }
        return -1;

=======

        int[] inDegree = new int[n+1];
        int[] outDegree = new int[n+1];
        for(int i=0;i<trust.length;i++) {
            inDegree[trust[i][1]]++;
            outDegree[trust[i][0]]++;
        }
        for(int i=1;i<=n;i++) {
            if(inDegree[i] == n-1 && outDegree[i] == 0) {
                return i;
            }
        }
        return -1;

=======

        if (trust.length == 0) return 1;
        int[] in = new int[n + 1];
        int[] out = new int[n + 1];
        for (int[] t : trust) {
            out[t[0]]++;
            in[t[1]]++;
        }
        for (int i = 1; i <= n; i++) {
            if (out[i] == 0 && in[i] == n - 1) return i;
        }
        return -1;

=======

        int[] trustedBy = new int[n+1];
        int[] trustOthers = new int[n+1];
        
        for (int i = 0; i < trust.length; i++) {
            int a = trust[i][0];
            int b = trust[i][1];
            trustedBy[b]++;
            trustOthers[a]++;
        }
        
        for (int i = 1; i <= n; i++) {
            if (trustedBy[i] == n-1 && trustOthers[i] == 0) {
                return i;
            }
        }
        return -1;
